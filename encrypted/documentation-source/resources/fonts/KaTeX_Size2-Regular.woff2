<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a66f8777b83eb9f2f014ce59075519233de956bf9c2920cad60060a9f8554c2e0f8193f565a8395d3b615cc27dd21137c0118fc20943b9f05ba721d87e87a58c5d058d26da75c0915e819748726257176596ad8c192b81046c56ecd49036a352ebc4e5c3b9ef8518eba5bac7531c6560b5604b7a90c8100e09df7eee841cd3a9a863a33e790adeed984119fee1724e51690fa8e4938cdc04b86c0cab2d036a02997090a8974eea777271f3e49f27822136e4b7595e23fce05f467dd14f2f9f99aec5d96222d13eea979090ba6cb4471b1b55ce108045a306a6415db47576c4e25f49a816ff2f120aa95268d6b5bb6b78ddbd3839e4a4784b5ad1c8cf434d627089b6fb2e0196f204da2dd9faac6475d376c2f3733ac81973866089f79b9bcfbd59f4039734685b8574c0f4bc48b4a9c4fb63d5c543e5fb1c0bbc02ba24e0c13693e6a8373d0e2047bca93b8a0934b57289978f2dd45e9cf0d148fc6c0b1f6d175b4550d881f6e14e7b08b57781788bbba3deecb09119be057e605216e3b0e8dc1951fad74f01f2e791f8845b2188b1f026fc09290f5efff61a0748fb2ce548241fefefbe017df6c9696b4205ee7ff33034c661b462b0b703d6625af6a59e5963b1d203653d118b76e004c38f657e04f051ce3a4d933f29007a4102252ce905a8639e20a54f0ac0b60d63e3116b9ea3b4208ab835737e8235e472a08a7a81644c07feeb834dabbece6e342d96b20e59415bc0d689a27c1c22c2b8661b15324a9c58a9a223ff0622c325a52014a2c951d40ef3ce8c2146867301e63667f22a98b1617a8166d3e44f54ae2abe1a7d67ae875579c6e5569a5e4d56583d7906ac2230d998adf9cc6a428a7250f0a1bdb2b7363f720c97aa1b7e5ddc4e86bc6dd001956b3a97793058b0fb7e9c9ed8d5aecfb605f2e1d13d66445b138abc82fedca9b2d6cbf482921745927a7f69359d9479552e05962e06ebab184d9a96f7edafb149d2345e802a6503651d8a0af4c650b2271e525d83eb7e007acdc2c67b3c6319e52498ccdf83f732f293d77a275292c7626e45456dab4e003c070850d639788889cef193a12771836ff60164ed0e79261250d2477636ad4bd998aa626cb13256955d1436507f41db0e6781a5d322e2f79c363c8c289728304747543d0ce9ec88eb1668defcb7d5a242cf966696eb31dc3e956c9417fe74ca0143d17d3d508f7c8e90f300f05272591ea27fd72a19375136af6d1550cdabea0b7f0d2f2e414ef4d499f0e33dc6e179abd7077ee0e4542eaf2a4a84bb538f0c7daca62476670631e8c27056d34e007c62ee320d2f85e1966741af92b67732ceb86734c8a82e7edff0536fd5023cef8dba4176a4ab83108dca25e469f15bf3c330f88cc687370908926b5f68f7dfe9c44956e331180170ca1fa22cf68375021a17d383ce7ad0770567acddf73a9133512e1ddbc7f2cae82ea9c5a1c8dd6528f12781b014b7956c5f5473f135ed1ce0f182cf91d513effc11c513dd59dba3b7b7cf7d15e8eaadae3121301f1e1dcb5154ad85b30f16c7d0c016960d36baf9be0bbd2cc3f4c3df5e3948c8c9330b7b85e0d4fb85b9f5973a35195d4459f652f6b142c96fee5a9f5da4e3a119b348b16c68fde08879916cbf15f8f5c1bffc6b9fed2356bf13ede8ac4da0471b5d56f9d7057ab2a1bf5ea3e67ae8ac4d61554ae95e126a9ec1e4baa72fd7edcf655bd2e02f36bd0ae92a260fd901c140dd61d2e6b3644bc1ab8bbd87d4eb42de0dbe960e578d11ba9ea34cdf311d58085a6910c1a8852a27a315b75fa8552b312bc7bcadb540850241a2e4ee3574e5ed1631e331eb67137781e00252f5b56acb62005b118d3eade0ff0c64b7bf962277d95587a2e9effeaf359785c4c0d795e1c9d29f4e4c26198819f45f5c1bb41ace74410e2a1a2a459ec71a731340fe4d8ab0f31a00f213583254835e8f16b10fa6201eb3c2a2b6aa22d0144e5f34366eef9b15c6670f2223c640a13c11df64bd6d7fa29ea70138ad355eef8044b80c9d22cab5dd440f248c44c549078a0e434f94acbb85e5f6a48cd107b6ca75e323e133814cabb65801bf2d736883d99e603360211bcc19dbdc0e549c9efecaeef0c13b00a5a7a77ff4f141247db5a1ebd4c144822c7cba151e5133e6fb7b8d53fa76d64ec73ea1b300cfa42e4dae2634e03ec51db0a3220bfa624739fd7117e0f661eb349dc8d765a5f60a0b675fad8b004cdbd522af11aab729f7ae69dc85812167a6d9bfb69e78aace9549f72bcea4667515dae90136ced9dadff161a2b67e0155de5dc923fdbba548b610d4f291637852e79543dc7422c882bce220c2ebf964f3152c2025d2d2ea0633e171d8ff9e51d08fd4a7c6b07476bfd02585e3a71cc16789af25e635c5a712b263380ccb078cf89c201eb8a794093ea20a5189e82b9ab032c676938c3e0347f8fe50e0a1297c8e3f6582ee6fda75a6215be5a905c346f1c5320963ae02f8ace7b907b5e13b13bb6548c63ae90a867490aa35c00b147f31eb37d4c1ea6a79c3f8b7a1f4390074f306888623696bc9547e7e6e5a57c370096113dcc8787c2d7b7036962fba3175ae6a88115e34c904a94f6adc246af610c65cd7e16fff21d4e30c99a47b3c2499baced1e20a36c6bb20c074f899d23250eaa7129e267745a35c48736885c21867619f5b458b6174dab139100aa0c5fe355e90c3c219bfafb085cf5cfea0db43a5631a0bc73d83dc9eb8bb8521c82dd30e297976720db6d9ba606662b9907b9972a7e46c4f34479e2e9a6d09bff26579982d12f0247ca9586d0432e3b397ad76c8f9e70e9248f8db466213c43c72d874f732ec470d8283535416b5660a625d8207e4cf47c92296d3cf3ba594bd4386604c840e5ed484d6e3f714b736b2e35fe43976c3893e96055d28ba03b27c264c59d343b0949cd6c5d8c99033bf67c2c1e317847d96a216b5bb9e4548466d76e14957753cec95836495b46a6e9631b17413f513cbf55ce1970148bab388cff9beef4f819cdfcc10a4d3b6a7598f17b70c3c8c83605a6124068b43bd3e041203919985256694c0ec622476458658c453f0ce1e3f290a5ef3e75dc94b09af5afe81f55375e8c91628cf0d66cc05513c7fe8c1eb7d91e7af04c4315c076a4e2c997e3d3587dc94a147758dca97fa56d3ae349b4e87fb31249ea8ba28d2f276d02a31dae3f80d7b3379c08be4572d76de92c8c19e4df930fede053f4fff5d08f5ba5ff0f842ffbf3a2d9b1385ca0398d0916e7516466b283dec20fb2e26332a647d6f36739ede393e4acf641ce4074258b142571a750fc32883e2a8f79fe4f1a5a497d3f9d539ab7d943e2268bbf5c05f6e1e55794f7e4bc370cdad98cabc222ba0d0d6c38dd06947714d50ea8a59c4bfa47113e66429ff2585e5cde7fdced29c94b0030a5870c8ca8469538234950b1929bacf8df09211d7b0e586a187e593619f74c1143cc5a4823fb9a592c1190476aae86a980afa0c7588886b25f359e1fd0b7417393a5ab25028ae4c941fd01713c5d70d528c85c08067056e9935285a4301dbe8c8bf681c3e91082f1f87e753b575858aed9ae2e927233de9b42df6a865a2132b2e3f079fab4831b2c3c9ab1eb10bd08a2a973fe854410f4bd3a2eeac59d70c050a7ce690346b90ec1f9f50ba404826dc09688900b8fd89cb141e4143684f1c078779e7fc00a20f0eb335c7f74532ec3f840ff64efde20015399699c7f46ab16c5b5efab5d466109b5c1904d94c93d762744a05399349aaa8764d0133e7dc2dd24c0041cc59e35231368e26ce0deee7ae46147ac111d7c74fbdf9bc21cfc7a91ef52ffcd40d3da630c12b034cf21a3e62cb788c3008905eeb66a342221498e0929735c11d2f96d3700252c0a6650a3dbc3ecf786fdc7adbf6fe247e26143556187d21c31b131c5fced96427aa62e6bbfd649677b614266e748979c7c493dd49d57cb695d5a13f762fc7f53bbcada3f6bb9e503d45a31b3be4559aae1de70cefbba2be152d4fc03bb44192a638f8f8bb8e34fefc202de2e228b2c4c103f0429167fa2f346ed9e810b791c4c22c9d562d9221164db337aacf33ef09e6423e2540d8544c290ec4cce5a8681358d65ce5bca21435acfcac28a1ce3835b435bef4fd3e2e26b40214d2923174b1a0361f97dba3e449cbffb84751b7699f17717eafec8735023dba30136ff62612e7eff9dfd030bb26a811607a4e595278360d6dc95a48dce890fd8036dca41944f67f1a0721f3443265464014e525c49c0eab9e3229db6f10cd69659ca599e1b46349cede3e2eb0c0bf71e699e870dc32c3c28e2eb446b85219abbb9b9f829c2212b1529c0c064dc69e068ab7c8b65ed87f34052ef3abf6079709e0d663db4cd387f2a7efd69392de93f165c5c34143392ced1dec110eba385511cf1e1062e30b9232adc852b32e15c4a666c4e38884265c7b799aa723d11c71b87cbc96bfb5fa591ead0c03ccc14526ddd52aa8a0ae9b46a8484009136e5d9de0f2afed74f7419c693ffd6351c2ab50a9e96a0f9aeb47c17f0af349a694936e8e712f994053833a4896f5c6d9d6f1f95b8d5170dee9fa9a6fee768fbed3fbfd5b8d003a8d9768170557bcb295c9e76274bd43d0376ad3d1d2bfbc3c2f037c7e59805a6fd34fdbed85f61425637408d0906f19de3cd9e23e72d76e4678d4bf822e18544e0119f37ddd5e653ffe8dcbef7a0366554d1b1e4c3cc82e6f0bb597f94ca37ec4f0c73309f32eb8266ff8ea7ae1e960adb4084d68153f004ea223d650b20a48a96839c9bf50da270f97af01888cd3730ff684780df14b3b7912ed873495ab081ff7632de29ee63b8b0cfabbf384d4d51692a635c750a80fc73f2950af6be3495b4f5cdc31e43ae2ff200749b8406886c6458afc2dd78a08cd30cac2e08bb3bf7d057e7c3b54be612c5a9d0875a4b94bf9e0fa5cde3503b16346103896c032bf1854937cd896098ae293146deca29b19241d7201994947b7c70fac3001408491f2a3ae37e2d28199d016f486ae25c4fde29c1558b2c112350c895aab0e81e45145e180c370e000f259aa33429fd7b2d779d6742784808f6aa8a5e8612324b4595a65f44afc151a73c23b302201ec8ea44e29d52e2bb27e353a3d9a13677a6b56e5134613326ecb74af5653049012faaa91f247ef7da57aa1d11aa4aea8ae87b48987ac3a5afbd620a704d64b4eef3e81a460c5a6bd76fc4e09eae7077a3ba3ea482f4eb2a8bb96fc2dc4c795e95c479455100a343a7b35bfd802f84e38fe60615dd535f7b62f0fff5c006147dc1195aeb54d4bfd3d91e576abc2fe48bc95b0319c222809e9cc672b6245711cf433052f56f34e99a01d40e24ec47b3026d27d923a66c4cf78ab5103885b9ee3cc5ac1cb9d6a91b44793e7ed8e296981f8f921c8496acdbf468b5b091330f772d4e89422597bc3069ea60df76e8038781bff7b51430fe04f8f44dc7b295437a4d3e91b80a0b9c2e986eb9f98f0e56de2f4ac057662010e386a75314191f97b1721aba0866d80e6bbf898add7b4a730cd3904208b348097f506a0f36aa11d91d3ccc38a73ff5f2a3d3ba98652511058ba6b84449c85a6ba66e702a05e6f55d2476ecaae97214a94f7c6438b2576258334468b695e79d8b6f310a9a8b39650764607486d773ba75e47bf54e3a0ed81a339c046cd5769fd068c65ca27636d7cb2733e09f2acf1e73824ddcd59a80917d6af327f02eadd98c017bbb631c807f722966332f85e7844f2f438d6cf7b45b5a8f2160097017c1044794c719817928843a83e58e24d5f2b4740b922abeccb8c177abc3b7964e97ab2bb69824f924b3be490409418aaad032fa81426f8d7989b4fc47652586938ba0b512fb84a242787efaa44ceb8e7d3ff44abae5353fcaaeeb3a4457a8c6ab9d7b53d385beb11091295246c79cdf216a91c159bae3d9ccf274000ab4fc042c35603d459a24f2e7740e62a977d4908ed2cc42ddbc6df14db46134217984c652d1b4ead8bb04867b9ed7676f6dfa2cba88a606250a4d82a3f6887d779b0178f8f6880422270b89f4eff170e22730b98c48e77af104a172bdf2cc1a70baaf1b6271fd687c49e4e3e0c321797e3547d4f6cf8ece6032e7317466729ffe965376a7d86ea11be4ce72d795ce7fbd4dc316bf31dca470d2b58defbf6e8e19cad5a1e773a6c4ee54a841d055dba4e566532cff52d6c21d961786aed30a694fc9f468ba373bb700ea31c3f6e713bdeb5c50b697b2f3540e0711ab603194037f0e6589941c7e4b7c713981decb37c320fa49864614f9e97ca97a1a64fdca16ca76d4796147105a315b2ff1f0e42eb59d3250a5bb1eea5b7ab5781b91f541cbb9eb6d3c13008d27bd7ed044b59aa22052c111b35474ae196dd7257195c55e96ce3630a960f94959124d8f1f5cbe9165ea37fd3a1f52f2a8202602f92d1492aff3acf245e7536093494e1fe1a563af96bb4e06cfc861c6565df6c9ebb3eb7e4e043719a8b399ba9836fb85c70b6c32da7b5cf3bf8788fad20b38709a8c0b4f30b1e8434ba41b6a77b64bd8b85e21d1246be122a97d12ec925d77e997f32f508fa26c47e204098909bad1a9ca476197c4269dc17d816753ae306bbecf7c5f9a43a238955b28fbb0bfaa8b3d591947472db67fce117ee21370aaaad430dda540e220bc47ebe7e0b75b74502b566661805f3cbfe1fdaf50a2da7d93e83da206f58c3b4a08479416496715da9b451d2df071e709b4a6b80b610f96e0e948147ec356bc9f59fe4ac2423811ccab0e2fecd243109eb40537e11262cc3b6a9abc1ab3bed2751ad71db05196db37d444cb9893bb5f5c909c052d1286bc82a751ff946160d1e2557bf804c73e2929edb051c02731d570d11560695f75becab47f90c65c1f1fdb4cde9d9a4f4e7597d8b126a3fc18f0466f9bd9516559a83a413425880e58ab4dfdac2e79a0c593f83f04879ba7bba64bbee13d705dc8e2df635a4fa82711d402abf52d35c5966b1b983ea7660f6e644a25058c4273023e9779a7579f58d92b356955933bf4693507663e461c23deb2681a0bce40ddf37d92d03b72abfba588e57cf912c6ea5c44b28c23b69ba7f3d337d6045d7e0a54112259c10478778526c733735aa34e65ad46df4786fd3422ea207dc6de7152db3ef386aba77414189e9fe40bfc34acf8f0877caf5bf047b4788893e9c95c0bc266e548a4ebcf68612424aa1760baa5d9c911fb18c1f968f63d6294da9c17adf1265e599e0cc79f314fb1ae81a21c2f6a67e79681b0c3cc076db60719895bee84716fd7fa664cde4b9432270508f0843b9a7b1c29f091d19db4b8ac8b8afaba27058c8496bbd8e7c9942fa86807c61123fd4e25d6f865d27fee6d9c793b395d978c65ae70ede70289cfda30a9ad7fbd761edf2379a9017d43e7c7ed8483cdeed19557e4b31dc403bfa6f32a286ff308bb342c8cba3bdd3b042a24d106bd1fd97c4ea126183c89c24683f8fe21c06422401c480931b43d937130ae66bf979e7216ba951a4a4b96f28547fb1fae62fa8f0f05b11ab10b112dbd4399c2c74632febfc049eeaf9f015399b1ceebcf5a3ea451b90d577a91ac333dbc53735efe95fcf7597b33af50afabc3689fcb115a84be4530619753ce36b9fb7127afcb1f269371329c44b0cc84b5899697d8985c5076b0a8f6e50b5675fda68394304e71799bbf06eb963d688dae13c431f62968f86d97f42ac7d7f417b16f5b07ea4c11c5b8722c4572b1ab13a638e85add169aeaf9e490a7baa7afb1aa4723cc5d8542b40fe28f1635c062ad3589fc2ea139e7d40f2ebb1850e903c1c7de9a777f82cc22ea1f55c768ca3514f3c39850a96c751bc1c73b640abd06c4f75fd4d947722002b291831636c96d4f201017d96ee560f47a19674c7fa03104f73ec44193c0998a4784c86c187aa05e5a4e5e58cbb95c718fbda67edb0e9d7429e27953fe32613afcd01afc06a9673c126e33a7cd466879f47ce249ae3ba3995f3d9716fa792f6881c57603ac53378a2dfa429cc75ba944ac516409044e3e5e809e805ca1177bf03ffd21da4b68fa9d1542c77b4166e8d739887ae87710b78ffa89122d44cd43ff5bcc52d70ee4ba57f489917df889e177db79841aefde051ca71d4858addea8893f4b242681a424cc8b252b99891ad0d4f00130edf2c5571d12fd3cbbd220513b13ca651b446fdfe3f88adb9939b7cdb94009bc2e7180223771883457a6026faf4f65f557e4dc50312bf29a4ba2bcb19e3881008002db54c5c337849e1ffc87abad2c907ba483ad86082a17174f4b89b7b0d9e117c00324719fa862619bdc5e0e71f9b65a581ef0aeefa4b7e2f6380acef2f16948b0ed2ee835849f079d9b4ffa977d62f25db420f9050497cf665df394ff1b45364b210a1dc04d653fe8ce67a7513d878900479b3175eb28e04536a389997aa28cd772bf8bd7beb940a2609a2fde3e086594541d724eac375dea2508f626b389ab28ebdc0191b8106d043fa66a2925e07706b099364ed8192fee43ce4d55c9bd1830f4997af77f20bb046f35f48d07f947191945c9373fe938fd071936ba14a0b8dd6673c1e4f846d74d7830dd0f79fd68f88b549eab8e97bdf93a5673086a3a31356f50d246f2cf4a93ce546b745a3a0cf512ddde90af6683b6c3f2ed2ee6dad6ee919a2099ea6dade4d012c7fdd9b1cf7482f6b45484ddc67615ddff0f562e9c80f65b9e5d6e47d35beba79e54117738aa12694a8b2faf4b06c4825430e260a0ebd54bf47a48919741d9ae0e59ce6d418fb2e290a0b94f2a3a4cbb5ecc1bb2ecad6f8ff7ad5844b4f12a6e42f33f898c11e2c529aa2dae8a15dfba934f8c18d690650cfa914ee624abb39127226120d9add6261582467fa5a046575612e0b4484911cb00884b61d1226025ff3e4025faf8fcca4e103940ac888fcdb20c97bbfe5f1d7ddbddadd8019cdd610896e8d034ac273ad1d35a16309b832b3e1fcb38e5613d4fdddf40b8170bdb293db97528ede88c781db8483fa2c9c587e3bf1569901ddcbd5d938b0156badd4294b648165d1a1103453b9653bc8d7de9aeba90d45fbe4ecc70c263a90d0eb32d12dc391f29492ce004b8ba6290d2ab2cbfa7f8d269b0f42341060aaeac0f2e76a53ee4bcad113c92581e0258a1a769cccb4df712284a365890ec6e6f5ab98f35ab70a9cb96d6374fec585c249f0505828e4327481ddb6cced51e40b76359baa81eb78a9170afb90659a9e62cb404b310b670301e7784a10097a8e219b67a92ff81d1a3341c3ebfd92a2d8120c53a687c2ef8645b386f910a6ab2eb85e82079824225ad3f7416c0452239788914c4696ad3f892a6465f17d43a7e77218b376abbc6795dc4cd6fd2a814903b6fb329a9e232a644189881af594e15e63bff05997312798a5828896503841f1786fb99c1fd0d5e4982d080c97faa6f8e0dd40e580299856dfdb3ccce9d3522e97949b7b7de98d8705223cf3944d112aaae4b4fc2b091a0d7afdd96220a5209f4a3867011ecbd4438cf050d3d0e63b81f6a65f18effe46c78e213e1aa225b8636dee4fcb4fb467a8e32911630554be101cec67f2cb97818788e776ee35883673aed6eef93c4eaef9df441c4046745ef59da200d86570d75b579741bb8cb592409c600f0c7133e49207fce19d78e43d30538883beb87c17b3fdf927a2d74f996b764caf24ac2fac2d2ae1115c67e859296eb68870ddc6e179bfeeb21ed842f63c5fe5bb0dd2d8782bfe8942c5c98d50d297c75e202f433a1e5824300d48cd27db1d6a61de98956cfc7d8201098fce7b86a4f52c6480d8b6013bae73b7433cedbdd5e3fcb973f69bed6e0f96545c540175bcb210b633984b61c2131823624a6c60ddad64fc8a18db51a694be8e2bd403095b7a23f92885fc99f8ddb3fba95142a945cfbb94b9c03ee635df10e6ba4846492734d2d3f7170f82b9210184cef085d244397dec3623c82198a40e5585c6ca2be30170e523b4b11c1c9087bfc9583f99ae551219dcb6b256df1a31d593564b21d914c5f5652b59c6731751d46277e654ad1ab265410403064d06e89e61fb6a4916faf82774576c37d6f1db4bf42b6b6a356e6c97d168709a27e5346f0960e238ea4f39eec582062e61904ec100357f441d6e2c815db1f33951bbf5e307aa95e3ada3c43c13e918654e775e3568e34c0317950a0c74e2247c2365e3d198be8267abb73edff1339d6d76ffe4df08cd0e525da787f370918e85919f4ff99f05b1987dfa2c40fcce77b420069ba384a7d02a307ff794d63b4b26756205c50f2d625156dfcd5e0249de9e94ed9621a2d5cd07d2395a2e5c639bc74450af0f2729aa58c989afa3abee53db3ddb0037c7b311e40166b96df13c2e16bcb088e110ac8fcf0beb4f655747a03863b7eb866f1fbacab6f4b7358605bc17d14281d36aac4a90706547b93194b125cbdc28e894615b38cd7d3ecf4cab736b426016222176d93eb93a34f3dcdef2f77eecf54c2a32ae87883f4fa7e61bbcb2966a14b12c1d125848cf0a2286dc180a866a5290db564bb88f202852bc5a8149f2080914181741bee201a7b66e03563f636eae471d60bb5340a0ad56f180ffa6216edf90834190db2e817b2ecd8fb35f5b2f8bf1cdfbadc438627467a32755e8cfeafd678b1385e9f701713f24d362e32dde50723f010a267ecbc082f17ce85a8c2566734fb2159fd6a09e58077a9aaacb61402db0da021dbb9389d972eebd5a74d67864743586b77b6f28d8092d94c38f778b8f4c2a885defc0e44b09c43d78f79e0d286ddeb36ac8fe5deee8876c29716dfdf55dcc3ba281056fabd46a950440e0e1ce312601afff47ce25d224107fd3e6cb8375dd8146b12e04bda2ba6c023e625bf2ee4cf43f5249e85d2bc74958ab7c9b5297e4488ba8e675dc797e41d46ee425f6b29c1430f4ed14ffdda9b38dad93d869f3c81fe30b9d90a759dc30116e46fad031d1a884128baf8eef8bbd1ec9ed05d9156be827d6873262117e6f007f4f7262f6b16286f5c4bd508da2447e02ea017bcd6a086f726611c6f58e263ef69e38cb1d2646145b0d5326b82bebc5b86a86e55536a4c4306192cd734f8cf31194181e6d3c532b07dff914d9b8d65d43c189c73a0cfb692357d9bd72f31810cd3dd0a937cc6f9844a1e1d764c0a6797cb6d21b7325d5514d1fab8fe47ebddbe810100fd3d09dcf0912459dc1aecd9759aef312c867ef9094a1461ecade41a63b2a056ef0e37cc232c530766cb99966aae73f18f7431ed825f53e636b6363475643815807583fe8b31a38d33338806a22b03fe1878271fd5051a5a0b81be50bbb36cf8b7c673814b733598afdd9505d43b8f8372fb6c28bb7249b2a87fcc5c26cea659f1eb46c4eae8baafec0ff1f89a32fe99f8814b4fcd3f5999d9af283ef0544fa3dc38dbf93c0cb6d279d3a7337a4ea6ded5819370903de30dd3e738c552c5ce4b7a962b9e729e1bcabe2d1bf89d422bf21b0955ff38c947d732fa97d2a6aa65c38eccb9ed09edcb6c4fab72edcd5ddeabad6664980b6db74d89f469cfdd060d8231edfafb89fe1a598a3864789a2aba80830abca62d189fc202d544b124ec8a4907551b2ed08eee4bc2a9afb18b991386cce74505f90ebae98b332512b2e036faea9eeb161672dcd545420e159ddcc99b577d3ef3e04ceb21881145964441322d9a6a57094557362e2b4124a81eba7f89f299cd34e909354c5c946a51d5adf59dbaa735e5a01c7989121c53e3dfa3db42a65625e861408a213bf1d6d2599b5bb96784a87b29becf9597fae870d4db999aa73a9efd904352f4b6e9019e7acaf2d6444f08bf858e6027a65a9167c1bb08d3c9d25630e685c821861e1b1cd894b9f57106c5be9803875690c063c11eb2a52ef90b050fb0e0194327c7080d50a836d19e83efe9c13f4886727a209991a3f4f1eece5f44b3b17faa498b739b7f562a280b9f5907a76fd3f438a21d1bc58ade6886dfb804743c70c84e08dc16ef3f836733c1d61fd81759e465e336945672bdb76ae1a227abf19cfbf8df3c6be41dfe0955906a2eb0bf4c9eed50195ac543ca1b9a9b61ee7db8fe85ad1e295ec072d91fca41e4922e24bb1a003e4aad08f6586fb62e0d15a1ffba696238fd86d384253ecae254f3089cb98f1120444f4849c4bff0e909469882d9fd27125d5679bff15f4b8a0818eb83a8522b01890e6dfab92fb0a79de4ab73e76c0d3249cc660bec8cd03554e43390ac2f0409d8c26a22f1b43e15abac1dc85c174b6bbcbaa4a6e68caa358871a5152bdf9fc90a7e77b3273391d99f585dc8a51489f155e0d857c9e72fcb6350b0ce677a0dc41bc292acf5e8080cfe872bdd0cf0a1e3feded45d14ac3e38edc39ab2fb8adbf488e3659daeb857ad105b6c5a00fc19d1dd30386deb54166baec0fcd6823baa2fdfae83ba7468d523f2602b642c41a8b3774ca006ae8b91ee82824654b97ed49da2feefe678759c41a1264d6e3e034eb45fd92d272cc69880a739dbff168dedb05f4a885216258493fa113c2938e675b541161710a0729ffd6ecec788b4234802f0b016b156996d6f7be3a0045e42ebe3cb8db642ffd807f1ed64f4a20bd003fcdd548ce3ae20c0433e9b763c26abc03bb893dc1e517c82913f0210ccd3d3b96dc204a4968cf06226158832564e087492417a2e139384625f9d42cd254ac0638b2abb2da34a5fcb178de17b056ec3632d84b86e8f70080914b3abb8b9c7996c3d44bed5c01389b5f0197d4e992a49717b4fcd54cc76e615ffa3a939d45236d1e04d77a00a05384bbfbd1cae73ef491c06690883ae60eeadea99b5147a852dacb2bfc5f8252b965650b280dd8f3f8bad5c56c6c3030184f3f4e3a62e53b85ee1c0ef82315dfe4046050a8d812f5ac693b6567980feaba3af9fe1ab6265f5e379c0d488f9bddb5f1067ce0e607aca717e37cfb68109095c15d2ab9260c5820b30f5a4e26bd4cf5c98298dbf052e84dcc9786e8695ccbbf2136e26483624dba45bb9e032169e41ce8b82bcad2ca2b8c70280276d4ed9bd3fb03fc8745bdf9867bcdad5e6abec2e72561ffd4d4407eb65b6d628a4bc834b22bdc0137e28382fc313691b7e22298d3a339a3a0e134d78e162228a97daab87f164fc90e1811e81635c21129a3c947daf5f6e9db24ace7d86bab15f11548881382815338106859edf0c5208a0a091fc383a9121256eff8778b6eb42427d9cbf7d7db916154e1ed50671bfe1edc0e6d2ec2aa46aed3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
