<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c151f705e6eb22424fd9f29c4b3b0e074a24e4588d7cf21d7709c3fa3372004dd6a16672431aa99260e364910707a2eca1b2b017695ae66a5a4a717c95c5a4ae4c5f607970a89eb1ed82c707c092a067af2f871a7b277f306d45f1a897db14fa1e25c943394b3f96768132d67837491724b558d4db6f766624eef441799f2a220aa1a3f647aff8cb6c31ee958b7a4c74d401b3c898925c42b34655bd4b2773948a67c5d8f8b2b22f5c7e93ef87a75c9cc21dd14d1f4ff66642cccca57ccc5d5b7c762a179a2b26a90ec8f0c5ea0963ee3d571d64d0362c7d6618df39cceae84cc320d6834ff43129267f6ed3243ab8b4270121add34e24578cb6ac83faf2e0b4065e379bb7fbaafef5514a2e6e3cb8170f1674c45cd0c1e683b537f7d3ea4c2db43fc63727a029afb9453e37d09fd17ec4ca86840f91b7660b0cf82e4c2f7762252ac94932d27b6c9e7f399bc605c0391b4307e444bcb5ed3a96a9b97c8c021cb3777d2b0c31b80350f2f55805894ae097ca287918c642ccc1aaf15f9e82389856b8f9dc1389ce6f5db4f2b19c0fd6218710201d8589ad218bb0e768f886a61844c8569221efb7621cd249721eebc9850ea2341f11e4df4bee5f012ea60e265afd6f559665b3b10b552f51ee261ff13c9a974371b07e6abaa188b57b6b5197afd2ef85e6a31f27011455f9150432a2ba2e848f9da8ddfd02df6239947df7cae2cc6ddfab469e9077ee687044b6064594a5e10626e2e11b4c4521629155e7aadb22359e73f2723cd11551aa9573037ec3e9622e1c020b6461e2d4f016f5532c4829025084e998ae549f524c9dd03abcebe7325fc47437690a7561418bb5bde06678a3092ec8381d463d883f6a864c9899ec624eec089c745aee91a143235ecdb84f9b2d717184d6f89b46a6e220fb8df492343070e1d9b4a3482d77c84909c12da56e3be69e7f832f01327041375e8488f9f3e3716eec1997b102df37b524928e1d8a579e39d7183ce5a881abc5b1e604071d382ff0dd641360a858266ae8256af358890f049990b0c90681b848c5ebdabae22cb3e6f9a94ee3fa0763763b2995068f85242a7b13e200827e28ab192bc6c48591c26f7743d662290fc33a25498a6fed01622be02deab5aa973f6cf7bfcc1ca4bf53e686ea4d62bd4a751448480587d1fce52e19e648a1e9d912e6ce97bacbbe58a0244baa5f41d5b8eed14450a22f9b1d29a862410f46531b66d205913c12e8852ee91ab6333d5d615af028487ecc63593476980893916c51d8f8cf2114ab2e3e0dcae8d72997197c26ab4f92cc17451c5dd15de3ce9ad345f254602a958531ae08e2c542702606a76f39bc0932a243d907329c46b7b9a84876d7fd2fe0dbbdef7844700b3e6fb18d1c8a2bb2f47646a4cd6accfde26a821244a1f8d34458bf01324912946bda9dcf2265f675baa0dc68280c6b2b647bdfd9074ba197dcc176659e476674279dcb86dd73a5e420b665a5aa104e610d54d0c431ecc65ab15962acf711cd3447637b211b1bcc791f60dfacdb91027681861ae7f6e1d3e9a5e39f3e8352ee90ec6487d8a5ec52f795ebded0b96294f8231c955430330606bcffb45e047d53b59f850c9071e0ac13da96acab2e6175745f3c54d211318387d616a0b4c8e9ebced82d8deba0c5a5ca50eb235eb20dc11915bcf616c547815fb153ac21640cd682e83c1700ac61df4ed900c19e37ace1244a5d7e64c5ed55a57b58e58775ffca60d884b6f3b6ce82c50e4d7fbe4764de491124ebaeab12d5c4b8cf6fe747b56b8f90eee3001b0ff45151789c8e348503aaf858dd525a28536d081e153299a054f5aa01f5ea3ab4689152a853450e66c5f243dbe6deb4bb2bc8fa521b984ab9396d6c0a7e8bdc4289fd0210451884fe6f7353ee3499cfb701330a91bd3de581047b63cfaa8d16d2258fc9abec8c1d157e02c1588f5bd294b6ad2eacf62864739533ae110e5195a5f51baeb5a8f879b65423d2234fe4637e2eb03216f594972c4ddaccbb9b20956eaeb49d4580de4e761206bcad42b77f3574cf9c9ca5c5de7b8df9003c585dc2e0caafcc1ae8c9b4dc2e7b93810b47fdbf92daa95b31ee3f7323705c99cb7e2dac6379deb73e4504725fb0ac01b5a180dc261b64129e6555613fabcfce0e93f0bedcceefc9f60eaec53c29c127bafb0cb49d19347d920f80c6a57737fa4c4e1909d3b1e9cb7f94e33b476612d1c418e2c7fc72c1c68391c87af361b786f221dd70f18f0526ad2cdb6e6ce3001d91c656ef38f68df250b0ded09e5ff0b5c3410af1cb9d79c21b3d1dedfc7eb010bbe6782582a01ce6499356221caf82b7616d0e348c5bd04d29cbdf6b917df08802381a557f0d8312d2db13002efa3c2f06d03d1f7b763b5c8f9759d8d0df145a7f96d7fda31a5bfa4895a6c92c9b848b09cce85b938df50a7fcb073ee7637e555081b4d94121e63e2014da8d791affa3be4cc008036dc3808c178a95ece6e82941652628e95dcf2585a3ce25f998a83083b4305dfe6a51000170d69dd33abf4cd06cbee1df60ecdfd187d5a0bec62fe2c20740b66514f6106cc0e7e62f856875638e54f7f09d739c00528a8d436830f9b89566204680870b169769012cc246fa2a7d10a1441958ca321262030f124b7700bcc942ba160cfe2725cd9843a5d038c3d9233d9f106358ac2ecb8ec888251299a061386f01bdf0865d817c4db177ed489f22d18240112d4bd4615460d154c4fee7b39194524e3ce20f7b7535c9324b23236dbb5b4805ee250ef1e5ea2c5cb87f3cb3ef19e877d8594ac5b2802c95ea2dfbf0da1e775e0fa4d26ccd9cafe8661e85d412bfbd7545211030dc698f26af1a18966196f737d6b1decaa61f21251814d35d63ff520319b362666a35ff5384d80a8a1e567e86cf283598bc7fc52d826d2a0ab72c4ac6d82a6581e560d57bcf05bb266e4a2c9d44b60a93cbbb8342c1df7d5c21bab49ac369535bc467ab446b6521fe01365075ae7cc88e6c3ce6c3d26b0a1aad2d6a9a63ff196b046147e012da00507830478f146d4beea0cce54b562e379136a21244021667bf76ea56cedf4d6b340ea00ec99f8738718a1cd702326e59ce0bd636f62e12d3298c59d50aadb3fc2e5c7546d16a91e51d5f3c287114790b1640bbc9b711a3c2433a3eb7004f51d0e03d42cc87d1248fd69c7c7ca241367aece69ed589c6050cd934b22e91d3866663af82735154e5bb9fd8ffe58fb776bbbeabd5cacd60bffe755ffbe4458ff2fdbcee7922013b00a34c9f4541f356261bbc808378d0e218bc3cdda1196458b797282e1dd695d35faf9cd984213a124ede1761dbe9ed813c1784d088fcb1ed5fafe3bd6a0b19359b001d79a2791681277c954940d731df1eb1dbc994dbc944c4c0a1c7336db959ae636a60ffa3c02d397cb67683bfab87874166563e1bc3a3920130ff48467dad005da2500710d778e337646714ebfcc5309d778a587c49feb2da258a7d0e1d0ffa8e8f95bc35c6f8eebf038de076a72ac5119a5f5c87acd96fc713901166c496ca21ef32772c63e33b3ec39c3f4b18848ef9102aed2d91ce8f74dcab29704343fc671887f0ae489cb7c1acc7a2daff802317be451e478b901df3446d599f7704869675c2d9e4a1790214b74c712a06bccb2a2afb7cf9f835bd6d05fa2bad3c59d5d02a9e96a368ad02e30dfe865ee2e339ae00e0b1477b6309b347cac5b2621f5f89ec95ccb74da6a3ad900976551b236e6845ce9080b68394e90ee4683d62f0e19a375766fc54ee1408601e6a97469980606d4923103fc1b749f30ef9f12746b45d197b1f4ce6c3e59cfc4173ea31000cb1bc993c8b7b679b5f26f0cee32d0bb1c4e177ff23301286d9dce707f5686006f9b61a46a8770ee3bbe8ec4351f1c6c90811c79b1161ca48f6a40765393333a693fd0595f1126dd3067782ebcc7d5747177589006ede78d673e99eaf5accff8f92a9f6802795bb324ecc9394a017206e4c288cd769f2763669ce0bc1a0d162d01857a01828d1f7c64526de0f325ea272a103a9cf64df53e8b53821fec89395dcbe5ef3c31af8bfc40fe38413d676ee2b380a6e3750ec7c01e600f671864d83c97c98750990317db1323e28b75099b51fcb7f42d999eea0367de4e0ef71f3c31e377ba1da26aa0c0f26b99ba823d97bad06ad2f38299bc432742fa228f35cee7cfa440c998608b2ac14cd2d94b95e3864329264544a330c2eb5ac9a2a49d58c0b8c4ea4d063ab94317c1827217bc77f85b8f93579ec19c2f23c5553fca8c0fa152637f0019d55162324c5ef3ab950fb4555db20653ba77984f9d1eff2effcc9018ed8d6d44dff7f1d512a4fc6468882d5041d2f54dc45433ff8c797006d9fd155305bcd4e3866c99dee130c92cc58d0bfd6585b43f6ee9ac3d39ad2f22b6ded521d48ab85fcc56c774ea42828987b81965a10382071bb3b10d345ec77c72c8d787ddaabc6b481daf21c5915f76936a548bffa082d3ffe648d843c0efbbfc8a9d0b3e145970553350d855d6f619d0864352f60ca8c8fbb19d1359c3582b1d461af3199304447eaaf0f55a2f279ce4c996cc833f85fc7d673d9a65dee25eebb9dd6229d03f4dc5d321fbfc04bbd1a8ae58cbc0f60e9ec5ebbfe56a4b7537280b26cdccff9589c3000894fcfa30baeaf419d877fcbb82a99caa4b51ed33f5eef5cdcf888934c5408200a59919ec4f1d4e04d76c2b18eaeda4a541c58265e5dbb78fbabbf4f6d6e029631906015d33d2572ed2f8f6bd8c3b04ab13ae857719dda437e7c6005b10cc80171ef8ea4bb1f5ec4ebd9bd103be861f240a959964b1da195f1883721b9b0fc98ee78921573051d4967075b5315304c1209c48dc47c3634b18f3d50fb2d0740f310f9c9f21943cf086fe00ca739383a4afe64522268ab4f35b7088c7d6455d2833bce5bd92a9ed9e996cccc243ac3235d6ef3b18140b5b4bc4a8decdc37dcf0fbda9d4660a94a753ee1f89c72db60259786e94adb19034d20695844c95cb1483ff257930f06a1c80c538c74cc97db68880765ec8851236cfb19491fdfb385f31f235f44a4f26639254ba9bd739cf06866e3926d796c82b5d87d4b0d33786ad02d449c02a6b3fd5d2b5283a0d9947ae8ad40e5aa6a3f97bb45da11f933105e704d6f0048349a3cd62301dff5b6f88ff07659c8a9ee59aa938c064b82a2ea87f4b3f82fb666b55e167f1c19a3d980d9e170abfcfe2f34206226b78960bba32878953e989dd5f1940cbbae55372dcf614d9f9a6fffad3cc9dabacf8acc7db9f207e0b73e4c354a80fa044aad6ed1b274342488afac2e1eed4c679cf0312ea55fdff3e49e5ae15b138c7ec56c8ec7e8fd2221ed7d525f44bbd522ef91b92d32c7f956978f3d18f65e56fccb736ef69db2947cac6dcaa89537164c5edf700711a9db47754ad79b522419c76f0052ef237aa20b8e84c8b1522368d6de70b3bac25f4f8102bedeb11a3a251876c6ebd0d44808f02a15eb2596eb7ce1601b439c219cf63dca005ba52eaf56d4e8600bc630ff0af6fc3ec514183cea0363dae9acbe4c2e905fbae537d9e1e4fd7f7a7f66e9e80a52041a985d029d0255c0b304f15288ae56004478647847b2cf18b974e177528aaccfce5f1a664a3ab3cf920fa17654cb64494d361a298788981a26e9dc327b1334f73de1fbf55e59dce1a44dca0fbc1b5cb38cc25f93205645864ce639522e7aa4968740b57f6eb9b5910a01e66f02edc00da2e2efd71ce5747dd0c82e2c078ebd58c73fb68966dff2f194b48fb73d893904b6eed513a96929d457bfa39c7e4f12aa4b891ddf11283397370ac49f059e866949967e2ad99424ba8a55ce6800faef7b34ab11274e9959d985b5af3a02fc1cd7c4dd3f3323516ae220431df0e2302bc6c48181925bf71e56a0557ef377790ad1d24a3e3e61f4e738ae0250e4af0a5d57acc1c8dac377420ef2978dc3f52f167961dddcfe31572786b8f831b2466e45808461e58a78214a77c9ff465a45fc6482038fe3ce6164c3494d9971480ba60c4a8ea93003fda2e3243dd7fe513422b0f0a657612eb3672c361c0a049dbe6229f169a4e094f366097b8f7d403c5b8a7645e1d8ca28d5c2526113a6be55f9c86cfcdb203250e8a04ee4788b674033ee2a27cebeb460cec14b15b0f93ee3ea4c2472b29540915a876010e99d216f43c1a8dc603c5d8ff52e834ea84fe3ac3d1c629940f152a2470c13110552b1210c4e856236ab5814121bf9c3ca3d124720395764c1c7391e8b48e0b70bb4e5be3e4643946d638014f1e08168ba2eae16804cc1df10decfae35f52b8d308365bcca403f23aed0861a21b208303507c21eea13b837cadfcb386a67abe2d22fce79cf2982469c6fdd2d472818f1c1108f1763030f3db6a4f274a5784a7c33211db4a1e2af0682f33a0f3e113314de8b42a4b316450023604213b302561ad9b7fb242128223559e196c2b56481557c663a65aa67b8775fdfed3cadabf918791b02b4b40a6ef0c43742297d54d2cc0398655a1bb2f150d7b0e73b924408e1c721eab512d4e51823d4f1a247e080825e1329ec35bc7d74432d5025deda999852cb9505b27f5eb28527aec26638252a83ac40b6092b75fd778d7fe4888733d6072392df9826502b3c6d691afc9232d8e8237ebecc153a1eebbbdb89565f9260ae3aa19ac209674f4f2f9aab6fea8fc5995676d8605260cbcfde59b59e7de9d342efa8e76813952c0a71fcef96834b5f1646c852c5ed941c44d00e2a8dd1a9b6ac4eff57a4e0f0e004ec93da396dbbe2b1995e082d3b96e742c193b789baceed1fb4e812d1da6e4fdaa8d3915e218b4f1a46d1db8b20637911932b5c085bd9b5596d561342ee364e2b3d3f7b1a604d18a1366f052859ff8fcaf3bc7aef5c86ac6d630162b7853d0e6f6f341262cb5dcaa3e5e4ed8b935eb5a8338a3f3dfb8cd0cb57e2d84798644fa4ce5ebf168616716ed9fb1044b0ddcd5468c6733b43a13b74f08fe86d112e0ad3b0091843963020388b8affb9b14163735e73f82216a9ab40bebce38c435c991d2b105075644a683b3be6457db9554c0c9a413179fa8ba151e794d73d767f9d7ff87ed505e5cc9e18559ea7cbb552216ae9736d09df61919f092ad1dd323e98e96758fae7b965090efae4b70ab4085d1778a5397ceee57ac8192a3c19d19894ec7a02c964a8c94a83c943f4cd9664a6c0b9c4d821397768178da14b40da13eae5a13e75b699855baff5baa513462132cb9f2689731a2936d341347b5fd78c9f41ac90b9cd3ce26eed226bd5de8455da58ef017cd40eed2d144184de6dce4f82a04a96d07addf9fece2da945920cf43f4a042f5a0bda36be4c8a5ba6dc2965e3cdce58b6e2abd60d470f5853bfd89962506297f0d48864fc14e570913af8666babfcade70d53e16a5c30d45fecbee41c2925a0b2d54764a5b3cbf66b37cdf379286c3e3c542f91fcbe978e565047bf670dfa63262381aa0dd9b30512fb284b3b60ec9bc847b1817bad910816f3ae1c9313a743640b57afe215de2860105ae1d4359dcd8b517bdf78d732500ad83ce3b9abe519e4095f1c7ab5c6f726484d8449d4b30c8d2817bc10c48bef8e2ad7f140403a7080151c33c6b7fe02e816ec2bd399a10a9411f7a3486a6758f5f4bfe62ec3b03c89277159014f3cc9c86f094ef6dfdd180e09cb1bc9e008a3f1581174844e0d4a9bee86e8433c4114872d29b68a451d7f2fa855bc56f14c7ed6a986e8b0a91743f516901872ef18d7715de6bd32b3d80b2500436160b12082e82d45a72ebb8b5b2e9c6589f50524c3c3b1155fe7987980834480aa84924bcdc93978b885e2dce7920a3d75237a7cba55fd426119f0a884b9954ff5d9603e3961cf0b3e1bcc07142ca602643557cd9e3433bb87a35a4fd7f1417c06986bff9033626009219e2798683ed0985b6646736909d749793ba0e1a4535e5b73f47e8dd8dd540a12404e6c9cd0af903c25e68e19b42c615db6fe96203634167b69e71df19f7dfa651d65f5092b5c0eea208d8671045304f184cb99cc8697df3fee6d41b945c2a321b01de8a4004df36b4bd91b733c4ac55431aaf476aa6cdf4d1303129ebca08706a46832af64908609b9d0105efac4f4571442ea0ba19edbe46082e0aefa8002ff94f8c4f4508ff2d65e80f888ad18f4d11befef9566d771f4e754739cc5202e884187b128a4bd808bc77b0c75f3f22a829a3c2ef1ae3b996b0a67ee32e579954022d3ce66fb96a07baa41802462a5a653c3a97a06c5df963dcc5f86e9521d963356d3f77c20920ee7296e7010d6f80a6b6af041db8a576e5cf9db72ddac67076f7570fdb6ac6178142462221e115fb1537a3e9180ae9db20481b1879039399b712e42248e026b1ac5934aa6f0328a95e52e7ab141e76eb8c0d495540b8f6086bc9f149ea40b71a1729db0412f53f16fc5cc1cdf7d84b4134b9c0dfd9dc07098317c8b12ff4e052493174553da93a0255bfdead7b8cbe69eb14403b3542ef33fbf9504cae0c2def6b3decb5a2c36487fec982a45542a887c4d289e0dc334f6033123489c3f3abf640c996dbfe4c5e750dd738726ca83b6dbc881b73745a3f038635f1227a47c2d1d8052c0326fe722a2e957bcc42067d25bb6f6d3adaadefcfb9bd0f517ade07b670e16304bef8e1a953e83219cf0336b058ebea055df1493c3653174214c05ac5e5f072e624e275879fb66c9b9e908f608aa6e5e7b41b4c4672dbe87d060df19ed81df41ff7758fb368fb398d1c8ede1af74867db71e4bb0438fdc7f3b94ea01738ab05435da14474b7d5c04ac52ae5951abac23f200d15e1cb186cdf75c96c38fe0c6265ec3da7e36b9653ad388a071bd316147eb31aab17b0c7ac94b3f5c9b03b884eccf1625a921715be41a0e65aec5dbdd59f68678ea457a7734ac8ca168eba88b7be7dbceae9f1b584ecd121ec9da68116b2e137e9c37a67f74b9214ef8458b4b8ed1926205d12686d664eb50581ef87aee619c981965c9378c84e010198cb31c4b54c0d34556cc496dc393543eaeb36b70c579320969f3045811dbd6e1bbdfd0d1651999ca78f5b39adf0c24f7b2ed10aa2c64f6661ab8de14d1f4307b92f833ea085f25c8d8d9699652f41650be4cf361a6cbc43e68aca314feef78c216c4cef9473ed878c9a423f590202f65e0af6b40d0d2fba36d9eec08fd7e17e26c90e843914f54b5cee69e9d2678fa42a45954d052959c94105e3d81f19574c8af226fae28e3993abc6d05d9075bac7dcf3e0b302778ce012a384a8681ce2f07bfcac6948b723be75ea4bb37b701821c59f5e9a165e30de749e5e08c8c1fe59a7be904863afd1bcb84d0a96ee9853442fb455e7f5749180cff81ea6bebb1a9fe562bf4f5d9732f97f5f4e7fe4bab79d17ad1973b2dfd33b90d9e77b5f7261640168cc60bc77838a9a1e18aa4b2df7483c1199d80b600516d67df269ef2ce2bec15f3d2aac49de30499ccec091215370b96a0559c4ed9fae471aa21627c3b68b3ff0fcbda19d6d32a49638892d04409786a355eafc1f8e202b0bf4a67c4ec4f7f11f201aee0e7981fdcd46f02051515a86b3fcfbef37025224dfc7db877880c68e2b8c7a8c0be93e73f585f8cf79366c370fe14a3d5f30e3774bc0f42bebddefcbce85c7b766dda48bc6646cfaff66f81a25be30f958ecd82ec1294e81490b05fc969141b2641a9b4acea2516f48b97e323fe1d4dae0e169026e6128144c4bbc42820a6b86b7b47192f509906f59add18945e35eea85a99f21584f52f47c90507bb71f4a5cae5ebc8ea4682846cb6090a9f8cb183c53040946e9afb6604eac2619e8206d08a1b1b95887c7222a111972fbf581b087cbfb4b4b072b877fd57cd9465b2ac04e4ea0af155887ba3cbfc905c2b1655e85df0a3ceda02eafa68d68e8c08f3592de59c2346a5943862b1d661d1786d43ff132759d6d130fb1124274e410bf8f4b9af11463e0b8eb1832e0ce87ec723f50f8311dca6836742478bfed94cff5f101baeeff0cd277847d3b1c9227a8a314e8e411b66c26ca81b7d9d1b01155941dec15fa83ed6573a1752dd8021abc43594aab95fa6bebda1d7622f9fad40bde28efdab4ff842bef27f58f483c322ed8838a8bb1f6abb64bda8ecdb7d5c573f29db9d5dc5c07648b91f7f44d83a05e6032e9cc2986a9cb1c0ded6867456766c5ab21809a206f02767d58cf2da0f5fc703e8a863869fe3731c8edac70b6172bd889d6aea80bc3dd11353d6d31cc3761f32a2ed26be1127688d832765a5f932ac460d5b59c8bef21b452f6eaa56f0e8313bbb5f4a018759596c3ac822c6e473582354d4f8c1bfef68c6adf7fbea43a3ff87899be7a38f18da4c6843446f4dcc8ae3f874682b5bc28c75ec3b75aca17c37a330c5d36827d842997f5982f5364bee33dff84d9f8112bec882089a979ce957059e356241c7e2e4ca665883e4f537dfe7c618fee237e9eb806f4c75e853299d407f88a22b6b27d6032bceccbf828619b528dc8ef16c86043bc1df1ecb1f2c9d8512790c395979ef9b603c42cf5d64e7ec9c8bd8e8230fc6cba889508a5e20d4a9e23d1c93c58d92162c71840a48650ceafa613f04d3580ce5c5a8f205b43512694cabaa163a00e2ca1c984b92b890121457aea64961d7ac8dc33b593d6e5e7123b8f75c29e4c9c22a3a6fd1bf78990e6f5202e82d4d1053710106007eae2d45efd2bb31eb79f5a2f351080011e84f02acb4bcdd7608304c2e49b49ad10ac2d0376f1503f95b57e475f5487da3fe3beb77cc7e11316050cc2be57cdaa2e3bdac80b771c5ed933ae112f1fd8954888ea28a5f320a9119c007b716dea634c96247c9e826fae5cce72de515f2ccda405523dd1ad5f23b35d1de489363a2db64098d645c2d6ed46a4ed416005f7e330c576c53f93222611f07cd3abbc78d2cce8fb21ad0fb8d23cc83cea1e39a9a69b0da8392c7a929eb4691308691efd0f629c26d7d2b665fce5661d318ae71ecae33e5bd5080480ee50e5d853de66213ce6ebd3a21a66679f94bb3d74cf41d03563f1347a91a5c5778a2f8b4d5631a3c7e2e8c0a57acfa772951c154eea7db61c0dd12d082d2668f6b36584aa6348f7d970e0a60caf99ba8e50ac0c810ed306b62a87ecd2b82bc776e18d1c8f48530e704d313ec21a740e67c07147b69c93f65d269d6a43b25fe1904cb16b54e5873bad9eba0f7dda30f1fe8b7cc285eb6c048e939e71f65365a57e86ceb528fefe2ef0bb093bd4be6e8683c56873525e902824655242a77db793c04b809b168ade4a958500beefa16ca425f5c80e54f7c1339d4eb4ac48575f52d8390b3b4ea736f65c672d0e57c165331dcd58b61a9ef9fed0009d3180299492adf6c9ab35329ae446b3e43698765686681639b92cbdccc920c07f36cf9e8e7b9fcfe7fa8ea3d22d426c9e1d557403848f462b4249001ae68df2cc01bfbaa8c22928ae4f08e2cd6067789eae8be5a32eca3ead5dde2a95dc389839e1f7b322fb9917e00df2052ab0cb160250e07dd83b86ba4c87692d1ca350b230d631e3e60ef0565aea54c587f09702bc3d1dee01a275de1d369e15b41fadc9c3199d35ab9e57654e54ea31019aa18b9cafa3c322e5398bf6401cd81e44fb35c47fa1bbbc748096017c08c2af8a7334623aed18224a68ac5204e3ec0f1aeee39788ab4b24308bc1565e15e7e67b304dba3930d8fa10c4de76077d8903b77a6764b321e4014f447f1dc14a3a61681ab6c3dd89cabe9df0a1e4f14d9889490760ef655446ec661d54a4e711a86e4f19336dbc95f11df2205468ea8f9cb072c9c0810e54548f907ff88d04ff895e951f6b760118f2893f89c25a9e29cacf3c217019dd1ec0d5a7774cff6ece4ddb10e5229f0c9b855e87baa14e84e8fb83d15ec921f443a149f6b24a085820f2bcc1e516c758e2a86e4843e0f6eec99a8f6064e657dfbf0d0a43898d45e7874e36c17b8fdd5ddf0323f11f912adcf8c4495340724338f62b13d61ec000313c716d55fff905ea4a15afc72e94a1b2014659522bef28fdb94aa955855b7f2b42773ddc538886777d64705027608bdaab53cd82aa95e242a875151a7a715fe1fc1d6a3b7f854c7c89cdfc7f3ece3641bca0eafd7e5f764349fa15172ed9303e42eaec089d706ee95df8378ef454bd07bfd2da615d3ee76e8542cd553382ffdecd7e3d133cb7dd78d432975e07d4f91b112acc8ec5150ca00953323a53e309545f9a7ae312252d6461927b001e6a8012ed9aee0d4dd8bd7ccf6b8612d68f389e885bd06923541431d32f18be19e60b8b5c967c64fb537187c8a6d3745ef846dd9ac263bcc5c643eb863840c6ef3f4a328066e5b66ff76a6895e7957b84e11d5bf2d9dfc02a053cbeabb6c77dbb00f99b73c1e9aee60ef61e61eb00a5e2b4d8416032c7ac4ab456d2e8b130d449d84215896a9dadfeab7949c1a6899e342967171b5e03578b66e855c43b29fe23eea175513b059969f3c81810f50954c173b183f74afce14b3d3310a4028dce2f2227a3e7b99f8278ff5458ad3dea8d41a1d5a64040a9ba6a6b2e71b7c6c6c7d0b57746e2af1e02a8a0fa1bcae752de70afd882b2a196ee1ce7c6f41ad46846fbf4d4cb02e1ee3ec8053f9652bffcce674de6e1869f30a37b4e3e60e33b733c64a15e516c5d6117ad4a221904c380606c59714674481fb354caa0375f90069aac3000dbaede8f5990d00e72d70e6523e53256ed3d5b24fd9b5def84605fd5e5187d8533aba148f1868d376cf6d3db4dd9176f18f9702ee48b9fffe1b0bc037ac75e4db11060f358a3fc9781bb5bc8c4fd033a15083ab528b42b149fa01ac10e623dbdde926b6c366fcbd4c36e5c8cc6d10be6092aff9834120c0b6529f169b629a3c27b37bb193976749cff8032a14ad744145c34219eab027c0c52ad9e922e82e0fb0073651cd1a3a5d4d2752596ceecadc40fffa0364c2a52b5c87205626b406da63e4e1f94a32fb9ab8f8329fe564fe61815936781a6d7fce30e5a05f92c2c2b42e7e625f657ca5489678ad3cc552da4f0f6ac49729a42f509f9b966199d00a2c4c775854aefb34e55b8a9261612a96ba5ff0ce26fb5d7757eb852a9d96c7de89cfbce27d9f6ecbd787abb50f60f00719ae01e2140d21bde65764a197d9f4415e3dde634ff7b1ce30c4b76b5c68c0ac1d0a316c9f0932c42d8989e54f7f7e93b068ac09c8649cb358ebb7e527cd8cdd98e5a6c8c1b8fa093b7ac75b9abdf807ef7b8a9ba7716c74ff4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
