<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"701b659ed681718e050afebff12f10c12494fc4f50c46452b5e6f06952e692614706513e1d4bb26b450dbc0523b3d7514e7b2187f2405f183b728b402b35b1fe161d08ccd4f24ecb3e8881c4f0743d2637c07d8ddf7848b0b4be9ec706c8f23c4e5fb1e808834c2888a5247b73f47399e3f038a6b6204c492f6d5dc7f3de5725a78670f4ebdad1fc7d447c0c6cab4fefc0e3e328056da295195908346421f71c006875465151d13693a945cc70825fbea444ccdc30cea6f7df88df3f6a3cee9ee1957761081331a43efa394917178a057421889bc084353ba84a08b0eb824ad8ef51e2b40f8dc8b6e6e53584646264fae23795934d19b74e3d890c15e43d6e26e1b94743ef3172b08a9adac5836dffebbe8a6b27fae4a9f47aef9fc1118eea89331e46497f89b49e8d798116259ccc22ff030b1cd01310a81e930d82c0b06b3b8cee69bdca765a59001b641dea909523b7fc6f5a8d0429c0d27d593050db907fd4e08e4138a9b9e315f779227e012129790020bd13a22ff1ee524a1f210d4338e0380c4141cc3582d4a5716ba0c082b62b76452a52b354ebbe7ab7b3f849e658a5472bb847bb935b8d1b10aa70da31ac09e5003924793c3d71d13b58d63019f2c6882c9bf2838da63323cc3930d3f79c8d999a1790e76219f639dc2d47ab80b02c45fde6f3aff072085d525180bc3fb604e6e946d035fa334d7eb7935bf0e64a976158c7e764ca43a03895c6634cd1cf8deba9e23442c65cebd21c2b5753a366fe756eff01e6a31e86778695d30e540cfdd0ffeabdd4102ea5cdaaa47c7dc870e8dc49d10b1a2d757cbcffa51c11bf2e9beb17f52986b4551df13fecb6aad1cf242ce66122d8e96170d05ed99766d5561f1639333784421b879820816f49eb2b3810d001dc16bf8d3dd4ecdf920e072e002af4646c88ffd008087e04e06c716f3b26b5452356b749dbcca091603ece8a2544977b1fb022c79ab662191a566573ed8be80d51fe2910511878c0c496d432567f108eca6a8bb150eb97e7208440ea945168a74f3563c4a8e226e77a3e16258fb0ccc9ae6596fe8e4b31361500c8393655f8200d7f238eb5199ded1b398cd25980169210958e11494a8fd1e6d645fd1631f11b72873028602a717f2d3d6232415450389ca66602d95f40a531014a439baa93b7ec1f6907f881603b96aa10a49e3e6da9d19483582d8b9dc5f3493e3e254a5f27c0f6b1e5b1a3c637b1d7ed69cbcd07d8a673aeb4e937ae6fed10562a12ee89fbf17572a2ab998acab221b8cbdfb39ac71b66a37ccbf9eaf92dd804f21523e0bd7ddd147031c62c2346acfd425e29dc67e5968093b1819809135c43d31ef17289245b063e7346de0c3b2e2f5bd55f5b0b9c87a8c5830cc6929043bcf3ce2011dec157b9c6c6723c8001a96c7f301b346262d7ab0a8ace06eb551fad350cfa80c81aae32636809230008c32607b8b3a31479367a6af5f14c7a795df19a43878f0bd7721b8c71d76f852e9867de0c219cc2267cc7a11375f2ea038488b48a7ae4d601d315d57959c45dd93c9b5f0c273c6a1d66c7129e8fdffbb94b34480f1f59ab3edd6f6854909b5fbea0d9ebb21ec7423a329a88cf5b36e0cc97527b6565a404fe8f52677851a632ddc0074787cf76f6b438328e749a52a47b77d4ee1f9e03a20f6f874e7afb22a67df16f5cd0878e9986cbae912cc24cb26be52bc092e29f47e995cbac04a937b7349178ab0a49308d93db046ea0b44e049d4a9471581846acde7ed7f46a6affe848d3c70c2fdf2d5cc2041df8cc13316dd4266535d877f0891991261ab872106d1bdff6c3d72902aee88d9224eeffc67ae9857f5ffabf6e6b8f03600133f16460a7e8ee3fff7815e2bb5250b72d07d5715dc874cc8b889292ecad84eb202ab9d368e41bfb8433d98a806728106ca66025179e4326681be00f80cda582dbdb339d2bb6fe22121fcfdff48f67da6f224fe99bed358aa850cade6be16952d9a76da6801e03cc6f9ff15c238d5cc7e235b0b04d475b3c8c5d228cf1ecee238986b6147158a62a43a7b88a7516b22e2fc79f27cc04d15348fc3aa3d893da0b416ca5ebaa06e345ca73ac1cebdda2cc92cd80a82c08e37619e9ca9dbf3b79e071c92e1554bb6ef47c7e0e7d6e98f891c81a883538dc61fce749921a752d95b9818c774c3d6bb322e254911a109a28603e6a2debc96c0b7a5b754ff6f09ac82da6598d53fec14823ddbf1275acf857a16f3ef62913e87f76ca8f11124fb8456ad172056f65dae96122531ffa1f3cb1888371150963f48d15d28b4912a4b5d72921fdb2929a35557d0e92f34fca5d59a7fd81cf18628f2ad7949b4166ccdb7bb56029bc53540eef279db8fe248b702bcf95cbf656b654bdd4908a567593227ac1b1782497076d907b9377986100db06395c557d6f652c70c9f5d6c5340f42f78dcb79deffa1cb5ca5aff3ed676225ed2d45a0252ed7c2f18c85a4f8c14f187231780ac1e99993bc2aa846e03a34bd37eb45b9e94c46f54be7b245f35fb089e3ddf14c189d64cb37201bfc65894996cf51c89e52785e5950cb9702651740447164a46888962d4aa5572f6b88db5ed4ea053e94b0153712caef0f9e9ed6c1992011349b215fd29bd874425f3a2ca1d7c184a275fe5513b9cf2a4b54fb8d070b58a8cdf925a49939ea86f72ea536716ccf7308e7e7a798b90949706cee95af5c9c33b530ba85cde5319a49e11a23b84e93a53efc37a5cc3581caee7312ac8a27a13509ce2049fc2ebdd15069d3dedd36bb1ef3eaaf687a36551ca3faa154b6c9081e9c50585c5c22d82fa41f30d9e3456ed630738db7d841130b7e0837c4d84689da5c248af31cd4f0e10aa016141f88a5a196f745e6fcc404673a044cea193acc46c0ed574687ad952aca0aa3c13d17c2b087a0d7e89a27b72484d289c4ea81eed197dff487a4ea16c7e6814b1d03047c7f8fcc0e73a0bf228795486921ec8c5684a9361c885d73685b02b10b6db76d8e4fefd4f8e0000179e9338649d670913a4a6ac38348fe95b57fb4d90246e8c0d1ac6b33c055a033ee86564b69a0d5a0d5eab49d70b4ff37192688373f1a69c6ca1565a338397eed12fc196b8c1c0ebc9f80bcc51260288a5968f77a8fdae0d05a491ab692cc3b1dcb943a1bd8e93b1eed84b24b37918b0d16e298ffc5732c96eb08da598cd3493333a4e8e6b4a6e5d44a80be99e7fe0e394e964af250ff0afe43f30e624c2b1c0a7c9071730ee1f7eb9eed67f0864307f5778b27547151a3e8eb60d88ce5eaa76f0810c39576aab2a46f6be52a359a94317d1fea6cf3f460545fce9bb496578644dee096bde1615ea702db05e57a891c47b2f964a7ec50caf8056e92148d02007ad8bba68a9dd4c81c647c6957ef530dd987e1931197d59b22844dff33a97b9ad998f83ef6f6d111189b434e55acd25ec573809e121e8ef408888b3639aca76fdf382fa362173384ed4cf817ffef36cb0fa880feaca2600d683a05fedf33cab3cd5841f508d87f761438bd8d8ac936345d875fa102d8f696d7a668b17df57cd8c524f2ab1e02fb994657a41e9d5ab9825ad6fa05de7b93bc9eb4716e07676af4857426e85f0850fa1503ea593c048fb6dc11441ff2abe4b1e8408208daac8d5ab892fa7a067c06e0a4a26da5e4b45e2ab7884dfb1ef8565ef1ee28a31aada62075eb05cc53f33a8889bbc19b57b96e01257b0909a4ef781396efd15375eed9710faef9bb2faacc10a35bd6b53a49ffc7fd7c3167100d6d7569839085db91e201eb55da1bb39f803c73828e339b2890b2632cecc8e8f66077f07dd5f5dcc663833a02310a122b85b39e19b89fa88d97976fd4d7017b8f38b8faf431ae57cf42d7e75edbf23889c0c80f155e57c84efbac0be548f9801b9efa866d81f4b9cb3d5cb03657d6bc9fdf32d6b9ea9063ce2d7b75da0421a507575ddce3e551e84e7a6e13f56f54a4ef4e339e3f3643e6d8e68422135f11900592d779c3ab8dac461d4360f5fe4459be43bf17567194a475213b3fcba075edc15da9a50acaa7e7c03fc02506b9e3eff326583fc783a18aec387336d0501cf98e43e1074b0149054d3a076815d365e80bac723120122b0380f0c6a968c1dcae8ea90bf48af80c64f78ce36428e7f3b8a7bc6609a6febeddca605f0743a0666bc681b48da5f6c9778ad2701171ad5a6bb756bcf500882287bb70d2a018fed7cf4cfc2f4a2401465c4d064692f710c32db2f73afa55be2c6eb65a35d291fcd0e09e602eb16c017729f526014188b7b18563234fc064505d40b8623d7822434982e73f68abea7ebdc1e8ed3098c9adf75f6e47bc3c7e997e2e845d56ebaabc62024fce3e471ad65313edfdf214e310cc149d4e44daceba92dc22121a8806dc9a64e978da5c8796997ae05f1e5c1593b30fa5f9370f9b09caace5f548c6c5c43ebb6a1b37ff58c4247d662e638895dce09c85b00cabb2816daa9c685dcbe4acde90645ca40b609cf2ff6f13a68e78a85d66ba5a4ea2a2f465ef7909433de278247fc724d482f843a347e1e9024a6efcc3ab7842d76557e24de057ed9ef5604325aaa75d78ef475a5279311e005f4420ad076283e561dcf173d720d1d8388180bc80b1cb16203f3aa78abf15a3ea528f02f90a3528fd2ae6a5f082c7fe8b08f97a11f5011f97e32d4856e69834a67b1edad646b965d7aae585a4d183126bfb2b2b659703cb60ba718edb19b1d2a57f15a343647d87829eb42f41fab59c87e094f5a1c4f1976e33a2de832cf2dbaf69c454fe31979c7f07e30c753c2435fe7943c71c5b28766785e75a39c447d61750a2dbabdefbd3787d78973f536d6ef98f8e6f7b3aa67fb731f5cf6186d82ed7e1228792790249986dc87507f10867e7e1df2c4d98bb4346c950f09b95cf13daa6c2625a685243787f12d8345fa639dcdbf0fc001a58d04bc1be5cc7829c79166f383bfb516afd89458e672c86eef5506dcd776a8abd1dbf4b30762a2f2206b1150460a8dcf78363d4b20433c87d790d43ad6e04cf057526d4ac15303393dc2c50449519656e772db466c5e1789146601e3b41ae68aecf0082675546f3b28f6199e4eb49b87bacf5856209d51ab7843ae04ec77170952c85f13b69af1234211c7f39c655e4bd988f996e6613f53687fd675764d3a6fdc72d161f4f8a72760ea68749100bef0cb1db5171e5a8381c679f99f7758ff2382abf4ec65d732299373f024c384d63b7031bfc77b4fb3b7cea424caf62852ebe0dddaf0fa2fe892ef5acad28735564558ddf4e2d0c2e6bc416f89ef6de997dd454ccf82b068eccae9a44b47235efa3299c0a53221b60713c1a031b5b8f600000fd50be623ff675d1445c7b91aa388871b6a18d062797144f89bc3df7bb0edf9938e1dce4ba6cab0f40d941228cb3ad1650b2b1a369389b830e40bee22a33ae71fe82455537229011e5569ea43b9254f21c3e4097cb4efc357489c72f2e4002c8738764f809236eb8240550a395034beaf430910ff1e29fdc56e1c7e184ccf4a9cfbc552a3b4772a0e0f33a1d17bf6e60a2320bcd42de22104d2205b90eb2ee0fdaf136686b1f57b04ceeda730fd834e54ef974ce042a733323fc217cdef911b10391a33f4a2d06ba58128563378f3311054e26b77ef4299629f7facee4cbf4e680c9346cd3f9e9844120de9f5356331add9d9520a5eaac520a8e8b9b807824524c09adf58f587d1a4c474d477bde54e7d9c51b85aab98a0a5cdbdb1a4a910976ee403a3901339cde499afbfc9c2a20c3e4fad7af7227c3a50eef90dd14f66adf83a6399b989f1125aa44d2dc84afdb29808c70da34bf22e96149f8f4a7510d51797ba8b91de03bf98b29e4d8f082744f07a6653630146a9b9100dfe0285521fd6f647875ba9c7d6e9ce28a83b4989179f116720ad7049bdd9e4131beeda833f73531eec176a81f72d57cd3b0ef997772dcee7d43f2cc4ad3aa91f6cc6bf7bc95e048d6a7d8089dd33b93ab8fc1bad38110f775acbef14e4f5ff349268c88dd905e84b902a13a6cdab85ce0ccc4325c4f3d4bdda2aae62a3bed0825d6775c6db4f1504f3274edc4cd3e103f31ae3a4b813ac2634d6b6b2270ef5f83e9cdae2c9c5b99e84f3d6a551d4762acb6d98b00a8a62ccf63d11cd824dafaecb2d281f4654b1c8e4d306f91421c7a960fd7e3e2f0b94d9140ece3431114c26591e01322bf5408c77357364edb25e9a1f22b7bc1c64dfbf004a6e0a79a31f7de302a4968bf3be915ef43ee4382f7ea32ed9d3cc9676e5bc6bbc08679a9197116a9fc94bd97bcd078dc6c1d4db74f5165411a18a3d4ea198787dd233e1076bd82a83fa22f27e4fefbd8321185142502bc623623c93fb93807f228c2f07aedd85378a318b00fbf6f4c3fe1637c7ff53c3a0ec97bf74f165361fae9b44e1310f3d8a95cb97ab2deaed6db936c1f7e580eaa8c31c502c0e529ad2ed886bd996eac85d76a09bd5a4d5b47a027df51451084ca1cf83ab37604c6fc0bdc6ae173f73a2a8580e3eb87591239035ae3cebcadfd28af73fb4be46b956ef00cfbd2760528703190cea0607a80934c49562618e5e2799b38bb680b7df9833d2fdf5a16a471149e770d5d4856e706d7817406f6bd49f265a9470158381456349f79b428a6dec40efe21b8e9845f74e9c59d84e4b75a59fcdda5dd1aea48dca4559422055ecb051ef32adf34ba9fad8bf92d120605d31e924e7b9eef4fcc610b4ed438c11b75028f6388b84bff9e164408870700c76e1d2480fe4040074f1869e43cfb206f0823f0f268c3c83183a602439edd827693df727ec9a4fd7d257d8af3ef816c72320d751aa1f49156b1764d14799a6ba9584497467ece58e9e75e2fc2ab8486e6416b1e3d80999072d0ec8411def3301019ffd29c33597014648cf191c4721118c9af82fd6b1073d82529ba33278fb1431addb67c27d9935caa00e0305418dd2fa5531dec7d845a22a26d99252507cd9da1fabaff3e7a350d93faf8828881ed37889ea29105f035b4d20cfb41acef9ee3621a32084d08b89650926c1d2e1722f91db1c024769dbe82131c3bc88181be11a790c7c51ff219e112e019a2e036a21a402ffdea1c3141545ba4f32c0091f7714eb88c0bfc5d2496e11d19eb1fa6f4bbac048840b20f4ceedc79fff1f75b81a51685acb5ba7ccd165e9965f70be0fd106b27af56b2686a7a5f3bf81d2fc19d8d63495a75c4104eff502af1f63114cc92feeb2dd9aefc55831ec0411ba82843d1681a09411b0ec3208259bfd64bf94e04ebc739ba4cf667deb58f365a7fc14506bfb988bf285082a20e5e370ee5e0b19599ce5ab1f3fe8cee998eab465ff7182469760d340be0b7cd4b8c654694b6a02b2c96d74cbb4a4bac1a26b8169893f3cc7c324adb63079addfee447eb322a0ccacc1bfc6f321fb61e23909c05aa291e4f531a6a0136a31b0ebab33e81af3d0de2b18dd80898fd5f71e7bf39b269341b8d28bcf872c27aff29b66db15c2f5a8be76a44725627ac76b8b8475bc7b14c97348076a25335d5bfd02c046fcb886d5ac2febedd41c5a8e016f52b083261b072195e17feaf7d7577a90a87e130b3d197de4363e81864c96a787d30d2fdd33774187085dc698f3d51ac52a2a9293771add2713ed831b5cfbe78605282918c82a87ffdba72d10bf4c9e39bbce966945e2b8712fbe75b2ec2641528bcb76db88863467b85fb88f19ba5e849425cc044436c0a490fe45300169489d9813e352e9f9cfa9aa6154360090460e3e0f3c8a5c5a0d3c0bfb5ab8f6ddd1fda705195d143e0eb419f9f641b20ce339cf5bbab96def27010cb1e4847a91d397d0f02a145819679a80931b8c85ce2e7bd287ff7b215d42991a1050959c61cb459cfb7eb52df94c20690353f862f10f0f7763de551cc7ed13daf75f355d18926098abba7a5f927cc78b73200412209a0363d37d3f5cde6cbfdce0aee4b5ba1e0b63fa8ffef4e847f8fd46c70fe08c3c227aa3782c338178970e9a3a729ed0d28dc1351f65ca309e7779213f6a145aedf3bc7b8409332133b485fdcc5199334b61edc3dd1a776f13f400bda16d93e652bcc4aa6d0b54362c9e62cb46cf1bc327de8414d7981c79ef168e87effad05c391bbf20024c17bffb4e15885864ed10db6cff0d70c8b6de372a8b63737b02ff58d6d347394302b2eefeb7367b79cd27522033ca35e8d5e6ec6adbb2aef7e11bdc4e4b2d7b47dceb38b17f9f2a0177e106c5bdb3f7eab149aaacc4380759b1d0584e93b53e9db2e5faba4672c83da870914202b67d1d43c136eab0f40df414fa0a3a5d7fb98859a9261219498768621df8752640627f27bd75eb229cbcb7d664edc5f592be181aa38084e90454d382a3e584220df25c11ce1430657fcf4cc3ede8e700decf4e5ad0c84a0e1ce54af822108db2e57f3581c10554b51e879de668473bc9fcd44a8a55c2538f76fd2256face665fe789978c70e7c186eefda5116803023e080ff6bd3cea1abbe1c15f21e81ebb5a7d88fd3c34707254e29eaec90ef008494cfcd60165703b626999bbee81ee759a2f1400f97593a0d62b3d782ddace810039993bbac5cc8764585eb410e74b8407e706b00bc8f3f5125cfaeb289246dbe84f0bd249019a9a522cfe55c3847f38b515c4310765ec0d33170d4ff24f68ce2badf540fff7896ddc09b0dff669d8802bc59fc722ae7eb72001aa0c6dbc42c76999d5a1140d16d972fa84244165b939bd102b67cae0a9ab8f1eb0416a27bee561033d29633201cdb5af765397e821f38bfb6a8c66d0f5c7b73ecca683f9408e32756add436a63252064afdf355b18cf5b3e4c223dcaf677f2ec5775039e2b33b82bd8a776168a606788d1da7fe4ac18e0b75f6886d8bd5d0600cf4989e207270548e17bed6b8c6e80a30c7c9b8c685e1313c75ffbb08117c104c797fef4650355d283af43231571d0e7df20091227e90b93f71fae44eaf6d988c1835d151c168e4b4f2e48b3d159c7810f5b9ace16f96207052e8212904a7e7b0d97aec5d32a1662e41f8df3275231d6a8c6cd089e43646a4eaa01215e80e68f8e0cdc8905c94f0b336572934c278b1773fa404ce458f084ab1566cbd2a53af3b3b3f788cd2721ce79725d576e5fc57911e8bec5668342f28df8425f9394f6039f85432932c6710e7cc38e2fdbc7227658617b4a7cc6a9f5d4ec41534c5800bc2e56a5d8aedf6716b23591d11d48743849d7af48efe2c3ea7e70dcd9ce8912861079e9a79db28890f76b9a989bc1fa80f38aadf6e09d5ffa839d42e46ed3bfb9511ad3541a9d4d4cda97cf393dad30547ed4efd4709999ce0fece16626e16f7218ceb52082eb77e1d47020c6745fc0702d6736dec0c439e17a856637a2646fce3e472eabe6a0a811a788f1b57f9116209e117e3dfcac9fc7902fb0efb336e6c70cdcc121a5dbd1f65d0254c928b4004e93d8d976802b71eb2f8412cf2c7aadfe74d80f51765c257d35b45c2e3784d53bc33a79f762b156b51ff81db655740bc1392e24e592efe3b3675aa69a2350b11a28c0d1c466edc27130598d9cb0b0b517c694884750eb7223fe66ccbfb45faedb12518714c908f99ac0edcd3db7ec198f3f74cc7c8683808a66e11080015a8e5ef07f36db40ef3bd2ee3995488ae4d08c751dcd4e2754d465e7fc65ea79d226e8dd0e3c6cdfda242a384fed2e0eddacba7eb5b1864c59c7c9745870138edc96bb872702c8cd5bd444f7215b009f696921de656cfe8d96e0b2653e9513b69999111a873765eecc546e1186f8b9d13a811faf99264c7bc198cee072a6749d45d8305be32789791320591934fac10486b53275846377afc526eb8cd13941d6729f9c731ced9deed60051afa8d8c088aefc5f9ec1fc5464a52621467e3af14934add1ef56768d23d980c09dfdd4d199653804f5e998d0c9a75c04ae0dfc18f40bd8b0270d221ae8ec194f636c370a6e9827160b7dc76cc3d0dc58cb83c5cd4a087f957aa29011f73fd118d109f54fb80382ee35b75a4e72413312f151632dd5507f53a7a38d389e340cb717f8cbba92f1ce734e497f49ee29b4b66499569a542001aa8ee4ec49ff1b576e2c5d85e21b078cf2ca60754a4ae680f9de0f25834c3e15f944f2b49559332f413f7535cdbdbcf6637a710e584284ae1597897c8d1fdc3d2f8253603d966b945bbd3802a0fb25c763e0d3ed51062f073cea76c61962364dfc31022d3ac812574fcff5f8b87ea3fa3d03456482013178fafce48cdf2499c393a9c23bcd3e0dac0ac62ccc57cf5ea134e429662754bf779e0577c1fdbc92e3bc82c625dc33a46b332b408e8b9370615f18948622e7dbd8f0661bee76ff275076270940cf9847de604ff573538096ec9da8861de01d81996ef6f5a89f6ea03cd9158a3fcda6c76320da6182711a28ddf1e1847a41d7f660c4e852f69f30086e4d0f3e9b012d08f13327fedc09e3190172cb3b8826dc058f4c0fdc4fc2d7d0065673a13132acff1b7d386d4b7571de3e81e63c5ec53fc61a729a749f6c1e29746d7e7a1055753cd8165e3c8737e8b054a3218e36fcc5e6f08277f140d704b34cefc40024ed4ce7b5778939073b09ad4320fc65977001efd22962ae54953ecfac5a1e0e9faeb758694dbac4f9a23dc9054a2a813d9cc9e10b75387814db998c9a75044c1316980cf255cbd9a79c697bd7a78e9a5eb315057aea51c6788bc1753fac10f8a6cab9de7a1f819183127c72378a57c89d2ff6d958cc4be707a0ba9c856b8552a0723beb9a5d7e21eddb4168d0c189dea1674fc704f4811919fb731851ef2eedde673bac25c1e5306f7be136ea6ca64163e5f829568b55e6210e9ba4b47ea1a232cde96c1a27f43a6b4ab67e743051c7f37b2af236c23daa195ee2801df39be6ffe63249b2c9552d3e5575cce68b07cc54112471fa805f89efc5a773db7948821e3f907bca3888270e32c00200cd608c7b736878c88153565b83375871d6955bc1db270525d43ad5b10781c37f3342ec0e41af287a5fc98d1f0e959ec0f4c2584ad9248403d517c69bb5e36fc05d6add2b0573bd3edb589f244a09287f8f2ac5fc5708f8028828f447f1149507169dbb9a61c719bb700ecf4af195a315903b63d3e38707dc1a78e9374224eb9ee52d08c5b71e5139f640df7b2fbee3d2ac57fe67ea285e85c4b8eeadae0295fe8c3ea3c38a4a098f566d62c2ea6196d1e1fcc906850b97efc62d1e43ffaa6ccd2d62970078bf774cc86c3d36e2cdb1d4bf866fe1b2993642fa63fa3f77a3e5e7c0dded3315baa7407fb563303dcb7f63a58293d04362d27b029a5c038af39e92d617b3176b8ea58f4b41f1e9f30ce821bf3646674271eb0897e2870485b55b8775ec8c045176bb8a23f0b70e75642270113842a285339d83cd64487ddff9955d70720de3d0b5a4d184028be6a9f7d330fe3cfeb6e683f6a49914b3f499f708fcd785b8194aa0845a51fc5c2cb7bcf9efb3eec04481b4e3967fa62699abdf85125606250eb09eaf4d1f09e54fd09491312989cb92e9dabfc310140e836f4bd75316a02a5724fdbae2026d673c41ad6bcec020990fb3250d71ba3f2ee95a266a4e85ab0b8f8f8dfae480db7201003425e5dfb203756738eecafb91f9ab0463cc7f21029b0ab996feb2571034ed1886a690d5e4330ed4b536e7d022418e2dc626a575e371d2cd1cbc88f4243275de9f686451ac10d83869ebaca378e3eab5c4290075925794b7b2c4661b162585b015ff6f33075912fb2c5d962ff9b5a7bfc84f170cd9b94ec61279f49bfb90dd3a6a94824b2ed037d05d28213e150258e33dbbe5298b21a29f8d87736b97ea8fde01c0b9b3efbf8d4427925e82b584e5142ff3a5e41ed0e22370f2abaeaaacac7c76bf563b81841e57afd21caa21d3035e7aafad0c55aba7c06063a435f88206449dc5a89157f41e43e3100c6ae3095a2ff4f5aa4bd24944729e4bc44c07a9cf14e982ba39a3d6baf8af193658c0de15bea6bb92864a8a3353936f317858f5f0a1b6443b22994854276b91e4d2669a33598a58323cf94aa78f0b0d415ce106138683e768e5ccc220234edf56c8a0259850d43f41f5fcbcdd87ae12309e2031559abd1862c9b91fb6d83c51a41e2894cad9422e8c936ad10a75b898713988a15cca61c1fd5bfa2f7557af9cef8d6a3f214554eebfa724aa5e58432abd9e708619a26c04edf0cca2eaf5f2eb3c9185d0480f27d2acc4060c966802d80d2037c40e1b4daf31c643e7f55f40ffca27ed1f272ae2a66e14ddf2da65c04df2ab0907adc220b1b8d4902077f2432530e789d18f1f83a71a55788e246553956c7038d29f1fac770b80201886a7360fe01ae7fa5ff9144df94c926a3ded9f7afba1b1734ba3bf9a2a9fc980d65939878cffde96101d12047e4a5e563827b6acfc6a8cf8e6ffe36201f2a7d8f359982ebb97c8977df9b77ef28281cc314b941c5369b87ff3e36f4acfc374fb387b85eaf9c2f81bfffefeca7fd07e26be363cedaf0febc4f3eec292344fdee61c069c39fa0fe60e29719c703ac032b7b66294aecf1bac73a97bf6bc09e1873f64d532f66f9012bdc115d3b8b634f29eb66398b67ce16b76846bd282200b93dad6bd65a005f95de6c55c0d8e450a59057e282133a1175001ca63402d4e31b5787179917c005536bff77da83ec0415eb0d4a6f9e320a7731488942160f162745de1daa0d21861319150de71f1f4e79ca399a626ec0537e8456d594c318463c12cde112176c21f404c36af98d65da5c362e643a01b2d07c94f583d8f2630f55ba180fcf62734fd2d19568c5507a12ac9d338af5eb88dea080d09ff490cd88f9a874e25e3ff800fa9b0138a3d53c5984a992d42de1b783882ea2f922acea32622abd90b078b3fdd058737bd6119a1fdc202a736f7281659b475ebbcff32aa2a6b0bf835d5a20a0e94e612b16b876e909adba1b108c6c1b842939540d9abc96bd5a236f4a10435cc49475b85a57cdc8d474826a75655241d5821ff791f8935d961043fb046717df050eca3117cf75a59aad971facf07ccc1b4e1713b25adca6eaea1972e50a2202e1b77591b8cf228b838e0ae63c809130373c61e2921ee0e53dd1cba4992c0a48a0ffca7274cd3b93a0a9e26409560d040213afe90d5fb070e5b8cefdcbe672385bef7ba22d4ee416302e105b4a84c3039e68db37b2619f78ce77a39cfab3f32dfcb16aec8a372670a19298faf339e05488cbfcb90ac1c4a7b0e4f41dcf1576189d7e044edace3582b8aa1abaab4bad21d8698bfbaaa56a093b0a0968c0b5de0a7299204b38bc67c276648efc5eaf2e93ded0f3e018087829abc3edd3998368ba1adfc8af3ac079c46015879c70ae68a62b01937d85e411b5af03724906918b777931c9e6b31d5fb646640fe9245ea6941d04db1f3c4b3fc603028fd43e1921c88f68224a92f0dd5e64a09b19ed6bd6544b9ebae657b6dcc511bbe1c03c6e277f0d20304f371a0eb0d5c264b7f409665ff36f8db07a7ba9705c70c3ec5bb050b306e8ab6b465804f4221ca0a17f1b96c2d3917ac0a4bd018a5a70663593cf5cd3ffb16c05fc9e493b264a1174b139158c91c93941b26369827fbd277338ef712500d91db769ebbe1b920b1b7e7eec6d441f483cd0d5019e855a5795a77f475d2330a2bd7f265649e13c0cbe90262eb5cec6b9d20bf9b431105d8242a493faad4b1d085cb2b753c31fa6c949cab928b2d339388b0cbe03bf3a984faf149aed4e4b4a484740ac3174eefe68b768034534a815fc12b9f6bd0ffae4171be8e5ce1992cc0c20f8cd7dec707e2deb6e2b6c7cb53bd6aad90e2140b2f51e6fe3f4750f0f3dd6dc2ddfc8bb6865e53c801893a72731366379d6a0b5cafdf511586480ae410042083b576d260e30964e421ec6002f9115ee6e6bd9a8658b97166dabe3bc1927ec821a4e8ed2adf07d71d69010b0fac222ed5b7118b6313b89789d53344e4fe90f24e43073285ab2b6858350df26247fa85317a0f5f1659cec7ff5d9a65ef24144437f9dd8d8047c7a90361f3482ffef21be0619f31279e37d900604d2ba2f9b1432f1d3c80b6348","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
