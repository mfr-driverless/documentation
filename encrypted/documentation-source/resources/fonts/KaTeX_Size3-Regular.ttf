<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72accf8c499893d8bf788244dedb383a77c715bcee132408a2e18c6dad55e36b034850bc784d17eba0ee5aea3732f977bb5f12afa1a86eb8246724853aa1d07b2981ff042769443ea8217659c54a1c40aa46b217fd62acc2d1ab10315cf7494dd216af14128edffcbeb9c2a5e19c5e9af0eb03f2e985fe3f13a3889c76ff0796a203eeba87378d616cb6ba511e91324677a700b3dacb8290cbbf3bf5b11aaffa4ea7e9cd9c556a6e126b40004bc1832322c1fe73f5b930754efafa8c22c7798f3173424c83a2c0fa6342920bd268f5bf4f00d34574cfebcd9ebeb39d3defc60f2dc506d0a1321556629007e13dcb6aaccb09e390a1d5eb973bf420817c902a76b62f5d66f63ecdecf2ab42099b1b4edbe26979c31d68f1d3bccf1190899d83d3171447dd360be6bca8cf952cde882c8435d56668ddd6a01fbe730b4246c465273fc4225466c9983067e812fb35bbce3cded3951af9ac5fb31278b504a2fd3dbe90f44a85530d72b24ab4d018b6685609c9307cf56e0a00b1a5f2efd83c9246944ddfc1b8978a27c0e34519b1eb89d58f593dbe54aaebbec09e33acd215eb97564dafc43850fbd1b677165d57a644aa3646f7ac9c3b7788fe45facbb5712179360cf73d988f8159da9c792a3d611648e3441c11b094a61367aaa03dc9ad60147a948a4ce7addc432367928fc55704cd76213a20748ccae9377d046a0a28966c49666d8503da9ef234c88156274e1afc2a7e619fe4df9437791c74377fd86d025bb904e565d55b6776f861a2ec6e02389791a6b4f8581d3711770e43410d889a160db1af216e187e0e6c0f43b9d34fc52b0c09b3adc76927f5f6842ffb24bbf78a717e09c2089c936a58628bf0b849b79213d76b0d31d3f426f59debe212ac6a2cb22c7e181c493f1d369e5ed77c87fd08e72dce8816924d67ac55c6534a01422716ebbe1ca74aa6375fb210c5159fe4c993aa1721251baac89a97e61547d119bc987f6f5abd5b9f22c4e7a5e5f161157824b906a35f3f37bc3dae724a53b8dcd4aeabc93d5107de51f93e7762dcb5866151b267b6beb812640d1725707c8a7fffbeb44491c675725046f94b3de136969da08b80cdca7663238080edb525817821876671a856699360797b24ab96806a5f20a76f8ef20c3ee80882ba3b6670fd6898dc4b4cede42fad17977026ffb990c39091bc2d7f6afb93ceb5276de9d99bb9d2a1e0ae8f2c48e5b4bbd9c809ad721b4339d6b58678ede99e96feb8c4448402940fa5f3210657cf15b13cb0108956961b35e7f740bacd925d7dc141f0865a17f1a3030c20ed01ad4a32208069d4f0ced23c08863cc73acae202b49703c910d21b11d2f60700668d26c95f93ce54cd43d5b455e1194eae51bf4a1b4f87107d66edd9e6ccf04d20651313e435363f203b48310064697b5427d037c612a35d949caf91791dc727465d9e51df148e25b0ad46494dcc60b90d702248e8adc34625b819a90e98e8481c351f4a103b1e120e8a9620f260bbdf76196e9baad937684d3640a2889e8ef21684350e3a07d32bba79d5d53f38623ddfde8203096546510011ff1a1fc73d96086f65f63ff51637ccada802aec12d1579ba718ee91e5bf882b24d56fbb4d5d388342b542a0699faf14464f61fa467a00a772a21d6425a32600e852c5df15a4ad179deb5d68dd5567ee6f08ba3e809ceb120e9931bae054d8b3ab7b84e678b69e296e220cd8be78abff93b110be8a2fc0cfd856d5dfe90d152df8447a29bb3a92ec30f6c8af675cde0160818178a582f3ce6a570e0c3124809e2b27fb44a579c35f00be656c9af96d4ca9ce8c54cb0c0846b3888131f7087e64ab8aaddab38ebb97f0c1359ff79c391be036d01a91a8bedf29913f089d9415701cf7ed4030d6152de241fc586ec80b17d0c7d7ffb04bc76eb9077427a356faa31db3c83eb8dad1a2266a3acfb19f427f87eaef90066a828fc46aedbeaf172d83f6cb7166dfa1a9cfea6ab48ee45b976fd320ad3806463b1dae630d9300aa1975178529b9f6cd30d0cb81366d97a3f587ff15421937ed2c6513d2fec64b059609fba9efd58e3246b1041aa41cda971d1d7a06d296714247bf3faa5216b3ad825eb58f4c50c351d798b3bb6f0988aebf17b162b762d45da290b6bfbf1e0e6d7a4260686381c5517ccc06e6a42552c3a81c32f94c50ff8d26f2c9ca2a569ce87c71d17e2076f2f287ed8ca8c6f5fc57113ff869aa17278bfa629f271ebb622b65c206f5410abde84b675f1237130863350554904bc89b70047fa5f4a386beb9ef911327bb747c1fe335655f5de01bd75d7b0c961577bf0b167731e518790c5862a67cffb1e0492a10a08700dd76ab52b1a4b83bc4c5b9d513f9cde3554996cf02212a9324ef5dc439b004aac28e182987959b6558376584c318fb3c32901507aff570137dbe271150155201193a6b197ca484f10abdf990ba23c65a120a4a0b14ca8a7bae3bb0fe32ce8256569adacd5c635bc871e5c4a88b7d14c87f317c6ae1d380da36c76399363e1d1c120ff2f175ed199e14516e8b059a059c3c376db6b2b342eeb4dbe8fe3223f998a92eb245de3ab43aafc60a6424e997ed09d3823e5ecfe68899f5ba7df4898e8b64210592328d5aea9447bb61d3bfe4f74022e7ef0cba193e6e7cf3446874331808247ebb87fc31abfcb5142d678ea0a8ab723776e23ddd76c0ab29b72549d40130213007f86c6b52cf0082a4cca3269b94d5f17be591ca41a23b5656d7141284e05b2985f4dd243419f939709d9ee796157c187629fb80cb43096a6c565b65fffbe030521a46f576b21a2066faa788781c3f41c292b4c7a1d4e8487a38f4f211b4734a4e7aa78b7ebc337e87b6ddafb0ba21fe5528738bff2a8cb02adbaf1d85628a555857b49ee90a8dc726c70e2eef0c8ca0300b49e0ebb169b1f1a378919f6f1976ac66864b471ea6446b0beddd45853670be96e42fc98e95a0c67d48b2451f5da530364543c922000198163d390f51fa8f03a0d03bb82a23ccdf78d8b2a4f73b0728315aa31b26ee18ba16343d33400d9bce8ad0c46482f2fdc84ff209f33a7797f4d66d6f9ff5ffb61affac55d00fba1f8690a542d9a5e6a655bbb18fe1a8d8ab8a42450a1fafc97173cba17f28effc83663e77ddf5b329ce3392173c3dadcd033e6982004e84b35ff15f4c7b413d99817880cc052150f3a47463dcdb277e2cba028e9366fd5b78f80d9dd0a393b64a25e05ed27b253f4fa66fbbe011af01af2fac9212d4a55f06732decd3b29fb51dd3d27cc75efe2d5fb1ad7a23c7ba699ac518f0e84505945d6c415ef590777aee224bd6da0bb08c2fec7787af0cbf3d3972f2e74de0daf31c275e5287bf8080f67fb46ef28162b9075cb450eb0cea07d9aa1d605ad7801228eed863a3842f7fa1058c414657be007aa899227e17b19150b98a8d798e3874a198b07491aae62c46a8553396ff80325b89a5dcb8985cff00afaa70290b9f66db68886a73917239a8fa614b9048d56e97085a6d7741eb71e7115936ad7cc1c4feba24f19bfc98f913174d224628b47816b748199719bd51047ea86d759a6fc3707c7530569b8fb888fc20d07dde7b7f32096edc653c20d18d44aecad638493c563f8aa1e6496a2a7d17890a849a8a40f3b11c017521e90611aa49e877b156058cbd78089828eda37c36959b477df96bbb674c5bae9d9b049e42973ede3ad5394abf476e5cd1f156d8719f7f7ba9e5903f8f52ea3788112f2c8b7ca152a6c3835ea9ae5fbc8775f39fe7fe728bb41f7abd0a97720efa5dd28cda686e80609ae37dfe48471dae08f0d14d226e9a9fa38a5fcb0e2703e0d54ce398658c8f5d830b0592a6bfcd5c4cf5d565d41c813982de4576f4f57022ca125f3c458f4de8c2cbc18bebad2b7148ed6d267370c52b3b5eac88ec10942890ccf232acd263849f60b5256d53db014d67e71e1d8e7de9af2f73fe0a377f95d87cf1121aabf8e84a7062b7a999980534f2707ce86be640a883934050c2af9e4a08574848bd79a27551edc581fd5f168822a2a6630b587dcff64a26f2ba2e323275618a2eead590102a25665cbda15c8facf12036c5f678b9f7e57c8cd148cc84066d06e41a66dbbc93a77d29c6596c4cdb88372d5f208021bb54f9343189e450006dd68f9937b254a5b68145f85bbd80a9063b666e27eca9ffb916a377715977ff610d15d1cc98dba935f692b6f3c816ae58d8cfb7307ef7352ea2433c34ca34589a416cb79a2a785aefc574552509c812cab7f4e6676d5d4073486ee4f5efc3eaef1dae61894b8ee1489df36aaa944e1a28456b8e6e6be2c4bd30051f570d0885469874292676facc126ab776860b654fe3383eb738619fae4c0db99586676644005c6a86a347188c769ddaf6e4db172f7e8990df9ce34572d25e88621da3b578cb042f5fa79c0911744d19e99f016bca70f3d76940d69e62cbce1242f9eca68886b1a917cf75b00993bcc7f8094827c333ab380e954249af4a12046f2dbef533ad7c509f3b8822bf5918692bfd669ba5a8e3104cbf20c050cbce97b4df82f232a8d7860e468bfccba033dc08ca6bde8e7e01a9129c0e30906fb4587c892cdd5ef5af1f249503ccdce498562617172fca247319efd3a831b54c44762f039df2f707ddca21473a5d971e71bebf56a9017a5e5447e9db4176a14c31912dee9cb27a51595e312d43ecc4b28ecb2c221cbc18e15f1b09f03b001e50aadd173a46cc65457f109a9793ac65328757a0fd91222a3c8f6f553ceb5cf19cc9f6605789321d306e7c6210c3c1e0888a20a9884fde7076ea506494275b98cac72174a2423e99e9999c2137d616cf64520a55ee662426774c874b79e4bf57add6bb36f75e40b82a92589f48e2e6d91f3ae32721635bf8c9b1239d987aa45dd6225231a7285425c9bad53995761020e0bcf0b36a504bc5e2d80b91fbb58f3f25d666e49443fd0328d8fd70a5377e7074b469c05f2f799baa0d9cd751c76886ef87e4924d60b8f40bb464b1ce06c828434de06d7cfd823cb2f9ae0d694f7407d8d88efe9bbcb9571ca857d14a83c16ab810a4b542d09bdaeac6267523206482aad80d20ccca81341ae74c5bcec5d7a9d11ba3a2bc7a60d466c0b9d38442e2544b412aecc0586cf7da3857111be7c490faccd214d6114c5038900c1aa0b8fea999ae5f86b02000272ba99edd3ed4ba9df59a5f8474c082796811e78877b900cb039d77f3c09bf13869c196c103340cbed21bd390a253aa9ec0bdca15a1d7d750012d82ec4e50459b61b05047bb965a648d1285ca194676430a86fb4f024f4e3d1b5d01126973b6440b64245b75d468b1ed094d72e561892bf5cbb3b162ac2b98cdbee86386ea8a93fa0816cf97d5ed07289d9d95dffe67d1b27b079074a9e3a46f974d39b41c3cb81c12940d1461503a0e05dfcf2fcb240962b354b27d1b6812650a91a5178b2bc58658552ca6a6edb6d6695cca08d8c5875dcaf939b9542d09a938e245b12a3ddb23129fb04d6e2ceb7f9586717c9d9f2952066dc67fe4b67921590605d49b5f38290a5dc42a146b4c089a25fa9867db2f8dfc8df4e4fb3da32c0a740dfe115aa44b2e5c640a519a17fb947d60a612e14ddbaa831078815b25c3e1f287bd8086505b8ca77868dc7edbaa31a801cc693f8d5203a2a8b9605b12b333b0e3b07ef58be07e6edefea12b498509f9cf2cc853cd1e56d8f11841654ea5a88d500fa3e036c19e6c1e2f741e2884ebd92cf947efa77bccfcde47d2a7c478d531c48696cd0d14713473f647211e263affd8e1bf5e45d6a0336e5572b9074f5909daf3687a656c5fcc215a5df7dd79befd004dd22b399b76a1e108e59f33cf84cffbb116c8f18c8caca4f42bba49d3a59835e6334c15dce4b85d7b09d6782c3b887ba17b9ea67ca6272efaa897142ed87e140bedb69bf2319951cc5947ed92fb6a7e525d24a57d3c0ae80110e67411bd9bb30e160a72ef9348c45d2574c90689474237bb545530276dd59da0a848c3c10352a9c8bb50d989c785b5d8896f86e45bc50d57428582ab1408286408985ac231a72a0eaf7b04e5ca6a84e73c3a9a8094b4bde1da5812c05d484f91e409047d51f87e2dedd9e4f5e734085d0d5bf54b41959f600d118a73c124687866ad10b36ff19bcd652e386075ca539717b2a556bbd5c3bee1322f9079cd6c981487eeaf2160469f1329e88f217a6dfb414515791b4f866e0873d062f89b6c6b5d5c3a59c08f04cfdf30d6b77513280bb6c4d586bf9f14ec7da88063f5b0ad9599bcfa553c91aef31ad92ef0949069e91ff6fbb85ae7e2bcb98788fa83c7889242336a5878cef0cfeb0d6e09c0e76e3aeb2c79ef92e6c8bc7bc5140459bfc7419135e3cb9f8e47d6c3adf31dc6586c63469bdf37a300d08e530846ca6fa6a764f48ef26e08a579237e0471bc55106b48b023386712969c1df24374db4e765e6eae9245a121431a5a719971b46d89ef3d0ea3be8f121f4334e27061518cff57aca77ef35d05e74f748ce6d6a6102a6d462b369cfa01d0652bcecb44a4ccf226eac2fec5e2ed1b76839bc9dc44658c8963a019095c2b846011b5b2e9109c7009f55d25911ca850bd95b9db4e13c6ccab89353b4809a8e150f673faeb4d5fcd3f99181f14203e967f2772a7d4a86d5896468a3ea5f2474cf8fd31fe9957eca58cf67438bf6c717375ee3e447152651fd5c285c05ddb1c3f8bce0b1682c3293e4cc030794d7e01f744ed0b21b94db8904d634ceadeb71534990b9a7b1afdc5171bcf9f656f7bd58a37140288b02cb57b0a12c6659a9f497c4bf0c5ae4de6200dbcc3db4f962dc16af5fcb57f12c43ac64d7c5aaad1a0a36cc4e0468b9c118c47bdccb82281129c23371dfd05bcaa588cca08f32a78be920df0bf10fb9e319c42cad4e611824700af1efb0f25baa8cf7ae13d70bc500cf1bb527087a1091bc100759994339e42636bdca7b2a00ac22ef809509695af0778bdee78e015c0498823879b3eb87fc9be52878dd3dbd5e8e5153c96da9b65463f819aa6d60b6d88a5baf12649c2262358e435f9be96f80ce67155de6ab301fc9db999b8fefddd7669d6eb034bf3071a4fdcf93513c33a2b760356fd9dd5986e5a9af6604bb45ed865aca75f9d062d8ef6fc7b48284768b72ef5ede2e796eab3334abdb3702851cd1a3c3acaf522130a5f3d2b67f453104f156c563130877127e6fa7d6082c5783db83d75e9d752f1d08d53438bdaad79a2107ef512efe9ee8acab4dd65e969bb5263e5add0a441def856736e76decb1c345fc6e0fcc4e5e0f4a9eea15f8b2462b6f400b42e7336d5b6df523bdd320280ea19053a9df63f9c0b18fb4170efce0ad52f2dd54fdfcc144aad3ffe88a39759e75c634f5298e56a990cd6cec89709211ffeb4534270e73ad91aed1778865ef134ba95e90aaa0e084e219de9da1d4bff86b08076c8b86fad765244cf80660c7bf3f20f0c50f2ae43290ba26f10d91c2920103a0cbcf60218a98f3980de48d1ebfb7fc666acc079619ad2ae72a1a001e2a2da4217544a08d9749d698cb04b2059aa13835892e3598e72de5e5d1117f3b6b8dc29e654b1a1cdd45bfd3ec6e69d883448f0cdfd2d2c3ca6cd8d252510a362aaa1b1b7992d5ac22f2de2f29e62197a230269069de00cdca6f6b7228b78edefe8fbc8f8cb3b9526101efe1265fdfec08729dacd26a035f4a288e8aaf6e18f0b1cf61e47859dbcb6213d0957a5c575f3bc1280a69a2588260b63937b8f338c9bfd86404acceb35e0f292b2c0c6663e1a41e5933207f835511f37b2d573c2bdf814a49a5956a6248200cc9289f5c66cbf0c68739a15d88907a1211407e1b8d2931cae3eb411798931ffcbe69277ccd0a4dead168027786baf4c6970fdc0d246b6e663059c8958bd6ec51f8dff6969ef217e8fd1db49feefff72827082470ed3fc28b53ecc1307af64931af4902a51f7fa83b59d3efbf78d88bd7008ce48d54b6578ef34a1a5b248d6cb34dcd811b9225c9a909d76cdc6532c6a6c3b4b7643da140388d53280fd3ea8e8fd000e9c345d60b57556300914ab34d34c61a7e16caabbb8ddca6950e6640dc01c4b6e70f12a79d22058ca5fc492d49e3dab1fbf64d10577245437a82e80ec662b7ca4bbae80d9e16039cc337a02556875274585b6fbbf18adecb36fbc1e0fecfed3f068ababc3a8a03de1465fa7ceb31657bb732180d6dadff42b84c6d8bfc3316719afc2da78e7d5b5a5b88c8861212af196ad3e0b6aac3b9905385dbfdc49962359ba80c561938b8849d5c7452a49a826e0c240a9feda13f5ef4b87c8647c2ae1b347d6881a9bbf0bab59b0af3e378f0e688f099555eff0015944fffe0afbab5bdbdff1d3cf56b766a0f20fe2c6ad5b5069ab36d7feab2427b8e46bef8e5d893ee0bfbc6b868b69a5f8eba5bdd051e3e3b3493fcccb9524f8fd204f084263e006537223217a8da34605b91fd4bdeab29e24f5d61a50d3111afcd541fdb0c7b54d51bf62da3f2e2ff68f4bbc07de439a5d9d09ae247f8e7cdb4f73b1920d97b97fd22b7ac64a247c1d3e4f76c6ceb1bbdda40081e8f3fa5ec89937d229542077d173ac602d3274c02c9a869b1401e9f61d901b79f27ad2dea2264756e0ca72595ce4c6b7bbd7a09a0559896dc6d16fa6dcbd76f8c6417f59cedc7bc244952163fa335693e23424715763649ac0d75b596f431f66ed35f1dab6a5c9f0d13631939907d39f5a8bbe4d473a44a92e17e3cf3c9de5298777854f21610e9db59014dadf38618bd16d645f81d97fadcd5a1820bf806c04aac11f9ca6fae607552db2f2710d7fa0bcb938acf6f0afdb903f9ffe7bba828b4b01276c9785879e501551837e8e0ca6cc37fc27211522e70ba86932054d02c9471332e3c1d0f130673562aaf18807774f58c7f589e39ddbe2f00713f5bdcb467d5a33acb51dc80b385f6b0c41f8443931e7ee9c2cb2fff8264a8a4625cff5cfe92f8233ad2c3c552faf81d4218377856110a1c1d302c65a09cf3cce51288c44691441343777de5b30375c26b467b9114c9931bd31fef7c18ef73aabee60516fb66bde69348f4549277d3c928b52ce80cf0a0415538af9be2206640297300724bab9aefa6377df59da1fac63ca26039d97a42aa8b138698153270ac80e074728d40df57e6f9b13998a5fa3e782a90b10a13e78751b6986f06f9f167bbf66ffe8dd9ab9c442af08051bceeec3352c3ef77d3bd4f6f2b99f2161f3b6b566c029c10986898673e103ad87859ae6979e5862a30445cb97ab3f5bc15a9a7d2ac3c639a865823bcbdc6ffe7676d555ddd230de1dc0479e9fed97383589913f21b098d305ad8c558f197ed133cd1ec83c9cae45dd6e424ae255a6ba8bdeb0c6adf957b8f754b2dbd6365c2629b8cb1974965e0ec3c994d551c791d0ad3105210a0983212415dea69d72315926eabc10e279a8bdcdecb4ab3a6c11d919910826f66fa2c32466ad37987455f00c415525995a324eefe4e9c1a4684c991420cc899b98b74740afa16c07489345bb7787320767a5d6f8d58444e54536b8e52a5b2e8256d7c93cae3723fb1d6193f71ceaa7c83fd9fe0a6a4f12691defb5b7a8507b35ab704d3cabe639197ebaf8a2dcdadfa760546d39e1ff21fe5a63a3e1a2d5b41b5926f0a10c5bf2f42aadbf2edaeb180bc432cff225d0d531f388555921462ca2c21ee50779317f2c6b3917339ac2f774aa1743bb4abb4d5a383e00d016001b0fbbe85ff840d1e1d46cff1da8b10eac251a69fb6f7d373192975919bb9b8bbb345533b4b0df6338f2bca0daf1554860365882d37090cd1496580dbc11b42dfebdd6ebc87c2238c01811f85abe52ff2e408f7a62dcb5460cafce936117aec025414cb08ff3f57c3631de269e174bca35af82896223ec6ebe26b342bdf709fe964c0c221dcb7f40ce1ab29210b8bbc7d5b4ea41087acbdf93e71d4b9ae8042775bc685f7ee85c8f49d629bb0da8cb2391a5b7d044e50290cf9785e3a611f0b3e4f777cd02590b9d197a9c96276a49ca54a0e01acff81b223c1c79f4f2bf28b9e19f01125780fbd54bc7083cade13ca4bd108c7181d137a03a58f4d258a388beab58622e23ca54f1becd5d2a78e16be81ad6a384247b45f640d240d5ed276149175ef1eab570d53a96b30e9d7bfba84e21d9001419c74f2f45a883676da8a81e0d2ec036ec16c9982c83144544e7d09c6768cbf70b33160a782b1d58a052cf59fe8faccdf9ff69cfdabf5576c1f85ceb0298a637c94ce939b5035ba97ecf345e0f955b6b9291d3980e7c18ca31d8ac6fb0fc6b531716fbd8be4e14a1789d70e60845e31adc394b6c5ec4acde56c6ee5bf8584c0888d7c30959209cd397959cfd1c5a93fe593c865424e9d4fb808cc65e034dd8e2f9c40e046eff37ad60d77445d66d1ed2afa7ab07dbbc25dc8ee8db7190d423380af548e13ed3428d1995c1efc049b27892605af9b43ad71c28eb1d6f71f2c42fd867ed6264f98b1aac14a7d8e015bf609ee1d5b0d4f0cd930343daf3768240e2635684de6f892f0413d49d1b0cf2f238a5c374921a4a46b60de90d5554213a0a64e4bf1e2235bce272100e8a780d3ba76b0ea495a6e49fbbca4cea77b3eb248c3498a763942fe75a61a20b42060e0fb71394840bf7605ea4fe17b0a1bbef9241f2c1a60f603e5c90511a35a1309120ab330e10aea88b39135adf6ec5d3e6494be92b70eb61b97bf7b176041713520bfd5b8c3596cfa15c279f114ce83687724b60f410115a7c03718c6b38248265b3d16d6d71897da0dedfc66a2ff2cd7d784e5206e3b7aa36ea0441e615edffd355abe472346e21e899dc29940a92eed3bfb45334eed32ee44981ad438af953d8b9fd05b82146a55bfe174917bac124b7d5dfc0c29f2eabc694eaf6df3c19541e8c359a0109beb045ce96a909c53b4b5da28ddc1b5d08f13467d4b1894bc2f4e5497792672d38a89a1c5ac228b5ede407595e980070330034d96c99c9177a8fd7a8903fbbf163a7fa1a55a8b3e3e1f584ae14e3dd6e58b0e7df5c5055b87437d3f61e6fc59602ae488e29a535696316a2dbb77e5401f6a2969ec32fd6d74583721b64a79fb2549eb1aa0d4dc96e447fa6ee3552859fd9ac510d037604f2f91ae74b20b73b00e76dbeb87e223e7f51f1a938b0fac77d8c012e6f3d33978640bb7e698411506c1b8966fdda771a553fd02f87e870882cb262255d32a6ef1a591e90ba34519a5f88b9a9b62397a88a06304862a43f57183afbcd84a53d3e0fbeb03266a6519ff50db71c34d030cc6595ed1ab9d2c290aa67d8af6a877cb1771ac411c689b56a70b51ffbea8d8455379e78bb39dea1fb4028b4119391c684908e7cee219007b17171a11a63f00668d771e5ddbcb05b5f6e17f0edab33289a762bbf29db5c7e314039a1d1a60d21a1dbd3d99465f2174826bbfa32b18d8314b862fa7deb8d2c5fe11e1317dcbb66c38a7a5224bbe462be6402324ecb53a473385f195af555dcc73102ce94746a8dd5cb1ea8f5eb506aff44b5ff72f211111e82f10507c745c4925c6253fc6dcaa89f9fd759c5cb0de6f0099c477fd7837374091f5ba2894c1cbaf9a9068c772b75692de82a3efe32f097b5025e48a96a813a99578fe0b24199a0ab8716ad7cd6a4bbf914f2443925b2adbf014f6effdb6bf4bbdf45febd82d934ef16b2a8e492449ee48422d4f7bee071d533f4e9dfef1ac745add53dc121cae6a06931acd43158cdaaa5b3dfbb21daa9238693ec649fbe1476f854e6c7116aeabde500a124fc3837ec2b92ad895b39230a3ab325868ee499f8d804aaeb307dbaf1c446eb7b68f892fd7968d75107e334aacfbb36c194e88c17787fd127bb382106e4d7864566b29005bb2abd2a588f59b632403129512f466d09a3412d5126625bb8c90d1dea73925346c788c424aea08a21052ea9f2e41912f052f474ced950fda61821d63876e161d4fe79610651a6c60f7d25fad230869f76ab87306d036290e4875c5238cf2eb925d131ee130badd0f50a999bfe2583f3b138706c29ec577a091565c55e41cb2ddafdbbdcb88918f3c2cb15ace2c698b9497ce690aab7cc8e62cfcc25f96bd3a4851445990a06ea51188da85ef26b0ec4e552f495c3b7291b1d6dc7d692b39dbb69e082ccf5a2fceba18b4e970f58a8294f27a88b19342c8457efe5f12142754c07126ea0f7951485052c37999584fe12cd8cd1f59ea680582c1a1323cbd2a7cd9211536032d78e0d5b0b70366a34471961da461b3f752b3c1d12698bc465622a62d4363d06f18b948fe2b25cc92904bdb8b0b4fe1ad16cfbcb2b734e86d68cdf98009195ecd71863d208ace67c88fc90d003c1245953a8b9c2b645b00b602052928d64b7dc2025980f69fc7bd4a0eda49b69e83a70d819dfe63c749831bb934f45e878ee084d597a4d96642ef2df459e84b762853c4a34df0acda848c51a9aa4c329ca3faf5a068c3c7dea4974564ba1dbd59e95f9d0aa099aab5d8e5dafeaf5269e80fad0c60bc00e66c78044454e0298d2dc6f0e67c7eaf36ffc679a4333d1265f6b071946132bca03c57e26ffda96bfc4ed9a84ab761cc11cf155686e5eb1aeb508c6ddfc2d116e6d79434e5db3a2fecf5e4c7c5def3f247aed4b8988ce3b8cad83ca47762f9d7480b889d22d9dfdb22a1dcb261f967dafc65b66ff2c2b334059be9d7cf5068583cc2ac1bc6045a66752347c316531dd21640769a0d88c94b8efc2a6dc398624862fbc725f9607daa975aeada9c9bdf8325ee2dfc3af90cfd04db2008e66012d2ded34c60842d1275deabd87291e3e3ed81fa5cd97d85fb2621e024c1c607174231c6bf2c9b68c4fc3518191b38ec2ed75f06eee55acfe4dab85d5a870bcaff6d229734ceb159ba3bac0f7bdc06b8a7582101fbbc7097379f6f257696ccacb8a4e6b0c7290866b2ec5781fa6bbc3915610911b6d6570c033be9704ea7671e238760c48338e26807bbfc6ef763a5b9d274a62f14275b4b827817d4a713736c9188326b9151b6f7f0e5fe21ca04b783f47abc353344fa7caded75e60882853921f01aa7f97b864bb52130b1c6227c0e3d87be5b413c072d7f9d8a2eeccb3d803205953d08082dd1a895f609cd5ecc9ed40461e280ca0a61d47d03ee4c393636a6ca6dcb6049cda8e791f5a6f4d09e20b8d3d3dd1c23cb4eefb361af1fdc931bfb058122ec2679edea12dfa5328cbc70c3dd62c732568c304e4284438254d1bf37f9c9179a3ab537f9a2debf4a055aa227faf56b7f13a8247d7a78215a01694b17b437ccf9c3674f515f429774254963eccad9f3a7ae567e9760d56bb3bf554b9796de3f78bafbdc4bf85485873f0139695fc57d63f1d45d25b585467da2424726cd8a63d857274f115073d9371d8b7688f39b8d7e17ec9544550f66fcc8c31a29e4840611860aeca423fc9c5f411f06e3553d944d32b499dd50d693749b0394461524e74b13eabcb9937cca10ab1082989c613ac1fca1e1c50c76e7a2e5d0857c8a3605817661b33c5823dc9cc959bffe289d016f9569d800d59e2b499e9a8a3afb6e55cea3e08029c58bd059f2ee7d23c2778a5905c2115c7e3dc07d28b0a1d76720e9604418125ba804e856a09e128bcbf46f68aedf0970bfc039db8c8deb05a685bc01b7c28a7f6ed778b2a0ce1ee13ff8b8b706af88f5d5c9eabc726083d90be3183df2eaa7753a5c56a5b4244a9e930780355dcde97eca0a6a0484346ff45d1502dd5d982e8c49eb2d9a24a2213cb35b3cfc4a1b2ab7f36dff6649150008d1195ffac84bcede01f47cf7dc0f282801c78cfcfc5ff022e843693979f30bbae55e76f17f812221852c7c0f903e234159eaba318bcea571f41b98c8acd45dc48ff8d3c7419dfd91256f1ec7b07cdbee9feea5355bef4b0c393a0f049de9b49a116c14a8b9cb78139d90affc0599543ae2de9f738fbdc880c804d10bf7b9cf502e68906bed3f81804f827301db9472f901cec65a76d65f7be0fdc0ec311be15c0dc3d1f707f8255fc0317cbb50ba8ee6b0db0a1ec1f0f28283320d42754a9f1c6bd5ae9159","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
