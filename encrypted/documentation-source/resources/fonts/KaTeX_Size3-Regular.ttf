<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e0bb6912f204340364cbabe2398bdf537b9a9e4cecddb72794df25377fa10c5c630ff3f74301b1f3bbce3ef21d363fe319db1b1801670bd706e06f66ce24d8e8530d25320657796c7cc645ee326fefc0505f10d943af04a70e698affd9185b16bcd409f58199506bb52641dbaaf210c3f34d2c614f63f80fe49f08dbb26fde8dba0d92ada7808c81cc592f4b04a5d8b3b2fdd2439a9f5f179c7bffa1e6d371c7e09dfda73af2f64929cfb907be3af780b88af037288894330108a94895bec44d3e810fe73938193adf6f7da67020c23490752a621deb6df8b2cdf47629f99f63211f6c76b74b685047ba7531c48e3e4e919a8a7fe5714043511af285b4570cbd86ecf10743b721a94e0ba973598f18bb231003e14d508c2381c1fd095338fab068f2f1465e083794ef15bf7b35c7b4a59e46891df5b79434d9303972d2ac50111d8850fc7b47622713f57ccf3b1079ab157ec2e8d5658bf91204b14167ee81e1ad92379b56785c4d37fc01f21d21d0921653cf7648e55a0659e1ebb0b40424f41b43b4b03133b47966c5983706da3d206cb85089383f972fed1762f145e33d00dbe2ac1b18275accfbac69737ae37ef8bd2abf40386117dbca757cfad617f32a77f6bbd689469e777d92b3bb1460d796125a6ffa8ba1df24ea69421c56a068a95e4c5dae77e52961ba16f864964595cde89eb260b50a23e370328c36dce720dc79e9f839686841d96c8e24283f2425dce03f792fc6c688559ba98a5b63dcdbb531c15cb8a0e8b5eeaf7890b7047d425beb0e6386e4c21e52b6d3ae7b161e4c8e10b69101a3e1262522fe2f2654adce59e341edb05e9732abf653f73f2c2e918e723bbee008b4a2d5da90b7280394909bab3b680262282991c3376722946b1821af04e7b7a9c49da41b6a18fe40594f9703a2c7dfe7ea673e20ccee4d69e9206f36a34f969a82f7549b5e9a366991db87f07822479ee7e18095b25385026798e54fa10626e518290f2b5b776e73f802b536982b065503dae2f15f417c10e029c920efcb40440164d8efb01926c1d867b76fd5899a5fa6886ed2578d19bf68f74e25ad2fcf7def8631b969a75d8659defb172757990337da253f7bd3d66e19b6a6398efb0ad1745bed5d40e729b465d731744a85d99db6fac3e8fe3a3d86c414288b58f2f4ae117fcf067be47b058d3f90b29a90ada43babc27df214a472c35c9aea89c04d22783db76b42672acd7821bd98fb001019fd19a6b7bc646e119815aefb24beaa74aaf3d6a38b0b326ce9fa0731bb7791bbda74a44de360f73f1e5eb02602c9eb17146d86500cd89f90cad5b07d3dbc3601076de6ec547f3f8fd281a4a996f0ddef3987873149861984024053071193d39f55fa5f4f210304a9e13b865a80274b9b6662549884764c5f5e44f44c08785d6b2af9f3d2233cb3c2a8479dd7f117909f3e25c2d038722798a32ae0a587b47365f66f92e781f0ed27e18e4e3987150aefcf61f26588bce6c3197c83f76a6aa8b7bf43224e9f7a0f8107a676baf4bf539e8324b5285821883a06e2e726a2303bc7c16db68632bfa78f6da92ccc52b6cc818475d3873ba93d10d7183264c7804f077b231e81abd9e515e727cdaaa7483f88f64dc768c35a51a6a06c4dad1d24a87a9df31441fc8581f29fffa920ca8cbb85d73ea1879958938b3d6909392cc9ae4beb5ba4fb27c7f9ce271b7fadc35d3a2120bda27ce81b2ef17e8a3532083b392f4d4f93c85db7927f04a17d9263d0c8bf47d3deb81171fc36770d46d000c3930248e2eb6c5df198147de7110af3475172a8a656992010e9da161ae339466c7a2b228f5e25357e30fa231329965c3bfee0f67550f3fdf4bd2aa7cd233f8a24fb46393da58e2c9642d1895cbc86c01cf778a88195539a73730c91bd61b18512c00341aa79f7f217a7434317952ca54bd3e21376c2a49ee0ae7b0476ab0502af81e6707732284e7e85f1da9806828c6beed94c95b3e03aa08c8a84b68392337c6d8f7c920f6d9f3261578667b39572b7032b46b16bb72cf6466df0e6f3ec36a00269694b23ada50a66a34b9d7356c3fcd8229aa479cb9674826d177da01fae4d1e4cc8b7ce342baffab02caea8408cbdfe5f62005e76a92e03fc74c3c22de3b10af36b9585195a39a65583819cca6a4cd7f1645386cbf0fb8d3f915ab5e6c2f169eac811d9affed113fa2fe4d5807598f1e721786df26bd0b45abddeadf487a86d64cd3d0dbd9dd259168d2b0f554301bbcb732fdf631f5b89884b5cba234848214fa4b421cf8723c3b39a5231b1cb527cdd826e91f6571cc60a0d1a5498bb500797558a3a6694faaee44a23c9ae5fdf97a3c0f7cd2dcb72850e9f12070802f8c3e2c5af46f2e3aa229bd3fc4ca751f8629e87b604756066ffcdb128452e6283bf86079d5bcdb30767a123459453e0d1f0fc987de947377a69ac51981bc0abf4469d3f5fc8ddead36afabe95307bc3b04b7ac6b8220e1358a1788e0d08e349bd5670e2d1e9c90d241b16f95480ab63a4803afe10fe810e11a564427c321d437e8a1844decfa4edb3781ac1e84bf882b6711da3dbf72b335323804aad70df87bb24f7dcb333c4b180aaa9bd0107203c9a66e8314ece9714c13ac84baaa795053f26b06791a636e67dbdeefcb3576d77130a65592d60ad8b18986ad5370b487b2e307341ae215b5d51cfe7265740ef2ec37f6ceda29629e60a8bb026cf668fb9d528f051fb4021bb23791d6d76ea6c4351e6d30837970aa34933b436a187bb31261c2dd765551ff575e892e493f5ee435f2279bc34860051634ef7d86431f6769b030f20cf62232edfab939a215cdf47c88b4ca12bcd1038b6a042b7fe0e3ccee0c14f665ae3f901bd3ea343e6d6fca45994225cb96cfb855a81c35d0c57522bbf3ae542a2fd53b0b13a208b07d72dbf5bbdfa787f36861d0906313050606890f8fbe6a0d79c52f910588876e57f3874a7aad0581e0f93c08788eb2499ba6f4f086251f7d00b186f1bfbe4eddb6e735dc424a7aecce7e5caa765a48f954eea6da69c935f022bdfb7c6330e1bde4087c8508d3edd78e4f2bcb8c9654a6247ff376a8e3622dfcfd5e520158ee4e1cc63427efac9a3e41148ce80eafea90b43aaabdf188d5a3ed857344a8b4a1fe1e012fac2156cffb0193c9234b4ddf768e174183f3d5e25e67cf538b766603289841de29ed49d93d2fb68ed48fbadeabd71a75adb95a5bf2c17b23cca912336ccf558b7bf3551dbc85691ff36c3947cc3275cdc39aafae076ce3a93724302d07e038c9ae871072a3eccfdb7177b948c07063e7d94035dfe20de782a740f34731d50b4b6dcf1f3714638c874a114d3ce456b034b6b02706c0775becbac215e7d7b31b89b140d3dc1f064a0fb43f432bfa9e281ce64d7447b71e86bb3df82a18b6e5070f48621defe29362abfa796fc43660c986dc290882708b5ebea083b3f43434dfd5b288a1a3fa5923e323fa494056cdc4ac27b1c1dfb715d01048ea03cb23ac22f4b5e93d5f2bd1700421b6d263273e5ce3895787d46c9b78fe7fe0818d59e4481ebae3459aff39f3dab53d9e8746ccec640efe2878993d470259e13a5e38cffcb52d8db09280d76c8b6341372c531bdd24885da84dfb66c3f83b926061c6a398a915b2a5d9a11c4cbf98cfce7e26b7ae752ee93c90468d2569ae97cc9c509eb2f32f5f7c3e48150966b6aeea2f52cef54f9d6f088a362b8a9fb5518d38e5342a851571bcf4e73a1fafb5b1145c6f3c4841fff43b2d875a411cb6ccf39f8efb040eac643be3b0cb7419feb752734a408fbe1509c994e246b7dce4ccd20bccf375d2bde65ba7a44de863a4d7360d9357f72608b0c9fb6db2fe2b1692c7ad70eba08b5c473e72c42fd1844bd282d0dd41e723d6548cce2963cd9bcdab677379af67120a8c4406b108de3d6940668dcccb0d2a2dc6cb50f627543a8cbeb7d9740cce6d7de5b3620d0b62ded40394c99497df2acfa2339427def3762a2c0ee48652dc8305488d87fac5ef093073eba6cd88cf495db3dcd0df105c4d441b24ea12d0c0a3fcdcbe03d9ce300399751bdf61ad36afa1df0bb57423f5b34b91ce0aa86edf25913edd1fd16eb823e50acb8ef1c263af75524c346a91fd1098d09981e16debd87b8be8e77914fcb27c4e5c2750fb6a7fa63bef8e40c0fb3cf9af0192c65293f3fb26569ebcafe45004edfa1e7091f574832f6557e08cb0b6a0184bb197683dc672b971c3875ba158d3a1f1437031f6085d36ba4c283330f80d0229db57938f7e905425ae4889bf6d77a05df39e3a1f10ca316ee8e3a7e9ce15d07f91d7bed4e0f99bd722379c2459dd971f53a7f91eed2beebcee269a2f19565f7282c3cd9a949f3240f626f71e475ea08b5ed269a25cbdb58fa9f998fc7b999ac459edda6c8fd9ecc12a833642d4b4b73f7ef9ea94650db3a48f01c9e7e3d39df19d74a8d2e478079eb079913a7e46e01ab01655981c8a8e2202a8fb53c927cb7b28ce4a40a3fe92b537461bacc6156e8cb206564b6bd81ffa6562d0b60b81506d35e38ac9ec929a4215d404832854fb99466b70b5d9b7cb63c8f8f179aca2b2e34df5c90d63e0ab09e83a7d552d72319e96cf82edc69e5eeef09764b46d027f4773983c9a4e1635afb7dc056f179f22a4d28e3e846736eccd311324470e0ac2bf9de31fb752eba8a6f75a35201102f4316daa8af76926fd96bc5c4bd48d0febd0e9e96257fd130d5bd1f81c4f57863ada3dbf683fc6f42fe68d749afe2c93782d40b375c3b320a8d62cb29290c5791e6cc5e54eba5f8ecc0ebd804c703d09dac657a96145667194d73efc144587da09645c12d9aa3dd4c96937924bd90a05d0af0d7d4ae0c27705f8d1fc440a25c47d3cfb03092b6f2fda6a4c649bb8df73838d06952600bfbaf9fa643873ba4c0f7293b97af3087fd296975dfe60d452458d9db06658b69c4a7e4f6f3a6c125e3dab387afc0e782dbe7ce333227785b03dda60081da2ddf24837186012fd1ec3c6e6898d5b1bfd55b5463adb81fcad3c585a84b0b2c5c9ff6dc6c17bbd1eaad7d56438c1f134ec65a2ccde464f09763c44f0e2c270998a815b4252f470ee3687f12075936420a30690f69c9dce1bf3d513e85dfd8ecc08d498661bf773cf1e69ca2142b875404bce9f51de7676ba73be1d58e3ef1a047558729d5f8114b4ac17b1da7bfb4d16501f0dfe993fbbbba0a80016e4e4d4a0b83b93f08ff61aa2f001a74a550eab096ff7d32df19d8dbeeeda3212dfce255c71b41e1c9dc25743dc33b85327fd2c24a6fe4844da0ce3273e5cfa31a50c8bf26c31ff6bb08cbac109bc890cb4bb596eacfa220037bf214e0c9b3964ced2f591630c455218f512517db72150c93d883d6eb8837526af0e2181af4f342a1d00e643aa6b1cfb2ce43085708df4723ad6d39ba3e6083d07bbb5631fedb986a25bcf6bba61202cc077a21996f4fec99e4066b8e16b3165c91ee34b316aa753e268274dda713b14ed537a1fa4e79cfb971922d8a3be45c1bca7d4bc2eccc5d1e6accbf234ac6f4663a7d267119521a88ca4da2e859b637f5ff24ddea27c6e31ec43779e921aeac9abbd9e7f1cba7621ebf994f1045ced25a831a2e93aa448789207209e5f3665fddc7b372a66d2275d475bdb89120a6dd10bcaa35230fd2a931d8b85f9eb5897daa420e2eb55b979951b4963bbb8b02cc46bd33b2ea80a907833ef171b394f7e2573935ea10104061e338193abe834c76097002304a91b6451559eece965f47f1a605013d1fccd7d47caa23ae901f9131abf327053aac89d216b8aeba685f5e5d579d5d51a3b8f5ba470c2a188cfb39e0dc8cd13a096b1e710b989e2bc0a87426ab151fba49cac050029272e14269abab9c2b1157d9bedb185adc5fe3815186b57909a890b14b5b3272a33871e3b49e98cd57a1ff232d0c56ef2603cc020728e41810c77852d43c93888f8749b5232aeef61a5dbd165c83856871ef712ffa4bc70a29b1332aab690dddafab89471836b16567743c755b751984160f5fdc8bdafb7051e1603fc88b5988b0eaf50da3ea65d2163145934e66c259e7f56692053bcfc54b44580e732cdc57863b5c30e4f727957a47ba93c96f04d235139444129688d26494edd821bf0f9e47f6b18d92f7ca77beb4f0ff1a50397c471f50fac86d67997ee0cb662d7eab912ce28a1c70a3a48ea611fda729075f899eb97b0106e521ac0bf1f23e5b5d901b7e7fbbc6edd4e7eaeec3b9af07e74a37ff1082b7178c6d01e99bb81e74c5d15cbd083565b8a0f52c0121f8102d80640a04f924a6aec54948be73f2b00f73e7e32ec536bf523aafdfdf7f891172990f547e6ca48e87794c4580d5c55a55457f10770067be8ced724257e22185a1923243eb2aa88b4d577d3834c7902c36dab24c3db465e1aa0a8966630612a38d5e270d9f48dbb2b713e19de36dc80e28ed810cf603b0a877858173dbd175d39b1c526576559c317f55838601946658635f81c02f7f727ae852c51758d981c29443dd8cacc7d996570de10fa4453bc34c375f9d79a37ee0e8705d0ba112dc868e6eb08198d61ddf5a55303060b67b28d6b2425327577760e4a44d662a95fc5f52c84db3b1843f85122a6a433dc55dfa5bf586de82bf6e8345792f28fdc2dfc40ecbd6d858b916281a62ee5921bf88ae9462ca63abd6b6061e32a6a2b6d47d66b4900c5a8deed8a0730299f20e6ef0d07957cf0d0b736d0cd92de21157972ad327a995c121e80fd728cc06a68f8925aab7f9875a8e8c736c2964bf5149d8ef36950f86e7b50b9d6fa49cd2d1237bba4b7cb06b736d776aef8aaca0332fedff7adab585c7b3ecd015881eed489c67d5323880225dbd14688de0dbaa156a6a9bf14ce72fb7865f6ee22a5e8739b1554d3b7fbc7251984caee940b1d9cb56b85474b60e7c89553e26c4a026f45e46cb3882efd50a6f4462cca569af4430eea6c700f412e2ebb096daae4eabf5f603539d19139d242964130d32ca61d505efb4e3486cf5b02fd29b7dab9d4c1e1bac97f6cfdefc6583aff008d81b8e10e21c16de4bb064884a2da07ef0e5eb07f510ceb059af1a3128a1f7d17bc9302bf959e2dff4bc56a69eb319cec6b963303350ce567870d95f67cc6a5a294747ebac3b050716082506d5c32eb84ddcfad99aea19752cb24aaf29de3c1b0e19e6de3834e47922120df47f2c55eae0a89f96931ff924cde831410de6a83eba5fbbd4a8921b9d9d901ed3dc19230709c0aefa166c599b6d13e908f5105140f1c1150f7b8c1fa243ac7f8f38ecb2d16783b372597af7d19e1b44e4e4d2e2fdc927b178eaa5941c78c66022995936f2345ca6b3cf4cead51b8958b52e0e6b321f5f974c01791bf862f3c4789c2341060c1edb62d346bf8fe4a8d0308036116e62d76483df98f100998dc9b613a5b2677b720a35e9b8ab621b529035bf698a2b25cb8feed7895d0931f2b05f097b85d57807d61a2694c12cd2c802e7e37595317c8b9910992fe6cebb7ae09681f4bd37cd93afca16170256ee78b77546ccc52467e61b65cbd7579395c9d492052289d1fa1b72217cff39024b8a798cbdcb21df8ae64540b720ada10f741c5691d0a839dfa1bcb9559b2020138938cf71c0f651a5a6cbebf128b0ade3c8b209978775b05df715c4c77ef509dddca5f53c766e4729cd1434bcf109d270804d49c6faebb92680c8c3a0b4b0a3a3ddc00939f331651c00526fa78954e4a8303e3360743d941e98aca895986c7f1900c5454d8cd81dcaffc6470f90b543a1910055ba3fa3177e54bdb0beb66f77105e354b25549059ffb98d86815072926598216bc52623ecfc22daabf966b5ce7e9a7d6c48ae3f4fc058222194f2ee3a82e759e1dee1bc6e9506589d889bc2eefd9c468431c1c93c372010fd7befb0701c1def302dc7619ed35900b0ca43e18a800bb6bdf3614727afc2be2984a228390e75d9a96ec0a0d85d20fc7b89aae5aeee7cd92a09203609e4d0602ead790b174279eb1013cb0fb1a6ec29419ef021ba0f26df180b0c743428b5c4904222f6fb19817852b14914e4dc123fecf8eee46a7fbf3fdd19f0dba3261b44d22c7f65604678278e6b99ab515aeb0e85d6550ec8757a6f3c00e8f8a42e6e16233cf6cad051bc0f3b3ae79d14aac9ee2edebb2fb827bc0949b661af48e446375f110366ca2e26fea918734d00d4a98f32f70a6b2c8fe1f462b58f546ff78b39dc2ea9060ee0c0e9a2bcebb56a2ff912319160fc9fe23f0886ca5676609d01c19c84a0012e5bde83a1463224bf89e97491b956bf66120a07a4fb4f42cfd3e3a402fc6ebb769dba70a145474c0b3f93398f906419d775cc423df5585022a3cf0172fe759be19f09ff190b980148b3ccfdfe0a092a03f98b9ba6935c04b081f7efec917df6b77b346218eb0ced198aa5fdd5fd12cf32621a1df24a77cb64ffbf11a746f24ccfba3d8ef37e8663ed667a2dc0c77bb27f316b6914dae9c6dc2694533378e6db9db25ec4415dd6be49eae8ddcf0f96bd75f44f41034d8f34ac5c76fd6aba14f57079e399da60e6d84343b53b8b273235dc8b026db3bd9aeffbd245ea25c529f5e1268c7749cf376028b705445ea656eb26eb67003d2e475950b7fc5dd5f4e2b06cb7ff51f1b92ba4a627f0bcd41771df2a344f0e715ea3ae694d08fcea963d58211b325d6ea4d2adae76c0b46442812c4b29201fa9e4ec2e70a7a4e8a6c975d8253c16e7c601fabcc8676bc16235f6f4a279125389297756bdb34c3254675d45a142b4d596b6a98032b86c6f23453163e4432f2d9fe34c4ccd7d15640bf277172de4fce10250234d793b4b3acfa5ca091b55fa000030e9fd8395217d8d7c9bc956777f2e1a22976bbbdc4a24aa17e0d605abd68ddb473fc7a3bb87d74ec91fc848db0ad4192055d29aa6d23db590ffc858d8726c0bab1a7976f2b45a5925e41797fb15b2c21d3cc051708b2c971fe0af38c92b51f1d4c7fb4cb934ab29b95c87eec04b45fe26c3898b2a031c94392097830141d353f2379222fbee14fe7fd734b12b2a66f75313b7646f1cf61e6f3c50d7df66d03f69eff34608b6e85cf5ba5ce7c0c7eb28ca6264a1a06ec0ec70604bcedc95b09eb5b188d089df5106864f9cb48c60107055e0ba2ad55ed59e0270868e0c85ba10f7bd1e6954983fd7b4835c98907b740798d1421a01e7e66fc3a7449c526238bb3d0b5751ef08b7532c53e815d65f082f855b28d02cd420723b5cb10472b7cfb5543040c52b4fd882591206475f88f3449feba2589372a470db38478b8ba11d449bd662ca7c90b8c7243ca45ca6ae7a7c5b4e17f0cdd56b068b52980fd6d894bd2c641ad46ed8d90f0d509024cbbe82e65bca467fcb6df93e3208c84ded92f6bf9c31410e808e9ff561a05f2bd0354bf396ea2a0a298861a2a518d252c1a88ba92d36f13135455e7b501250b76dc59db7234fb708a39c3688b6d9cc6a85dd3dc0a1c89a89cdfe48fd13610f99dbdba919973d6f03fa6e044975d1668f110e955930e1638ed4f52d82024c162d7a9dacfc784cfa48af2b41328186fca21b3e2a5043a3c444c601be9002c29395661b32ddfb63304410aca87e2bab7e5f5f3f180a95674b9fa8a88c2ff6176d3414559a3c7b2d64cc94d146e3106119b90ce3ad1cd7472e3706109b3e37d028df7972b98b57f5a3e112206b2d0309434f9352c47c734e2591db08a077bcea5ae64f576feebe3cdfe670749f310d621567857339a2c4f0269f5f35e64e16100b094736b3481bc17b9a7a3f130643a26da88f367f1f87d9db790167523d09956da89294752ed3e33ab1a377a58476bac5b80d4c095d30dbf98297aef563ec23cca9a79dda553f658413d19d2f7f286383c24583f55258af827431952ea92c131f29ab4fd5a1b422ea57a4a1281310269087a45dee1c5eecf631158a6fc46d5e6d3b5ca2e42ef601f199d290c15c8ec49268c2ae590aad73125c1de4d0eba87fa78adc979c9575f5ffa3f18c6ff5d75b23f0c3c487e27934f2aee32bd4b76bb70e1d91b352b90549492d3508d1824915f841a49b708cffb253af8b635628a33c1057839dea03de547988cc40e413ceeb45e07ceab0c4bc3f260cedddafc3bb35f684db0d89b6dd1b3e77c45eb455f466315fb977408c22bb34ae5c7e2144039c2359099a6ed2430b1bfcab55ef99dfd84f66aae1dabda5b0b2b7515d8f0810d1024ff554f6705ed53a3e7942ff11b68f7b497f2b10a926e6e6f616986ecd8eb805f47d22bd20604b81315be81cfbd8e42bdf993df2d77035b364b7bafc701afea236297c6afd3945ac6d308400942c0bcf6a9f6b62b7b775876babf17abe2ae6895510517cf361bbee6f202f0c7eaabbf0d2e532453088baa305f70f577d34c7e998c1be03ef55eb08b8c65fa19ce03f668a3f9349f5e14a6c51ae878769e33bd0e6c59ee847d8f22dbf2edb4678e92561e4cac5d39ee70eb04aca0da54810177854a173b96bd898e600b88e8a1a02d68db31ff9552027d871e7e8707574f2ddd9d5725ce8338c7216dacdc673538d3150f3b2ca23239bc75e8623b8ee91be2149d0d88f3caceb76f706407a336d6fa38720fca03c310585b74e2c3b65cb81033e1088b26e8909beb8ea61bd6759080fdd1cf4761ba1af6280394b715672ec014f169774fff5c001b1e486e8a37675a22399f9b4d46fa2c4e0f6b66e1bc8d8873ae0f10328db64fc9829a73607855b9ae680a62bbd8a658dc8591c4599a9a6fa4e7ccd69f4ed2a165ccd1d76500726e46b6a9489a5124f2611adba08d137178466868429d303d6fcb8916cc05411d02a1a9586a7a15e0c27319b5a35233bab9de85baa260259ff9334f76cf61434e0ad5cf7ab62d5f7005474b995a1ddb0899a5bea57bd944396276e9e12f0e2c2450e2008941f3acbec8a396d46a872e5842e5346e88249bd9d654c11083d97c6fd67c8892a2855c618f94f0338adfe2992f203d3e02329992c99b76c6799679f69bd1d1512ac6596973dea72c37164e3ba18d207953dcda855fc942b1a92743cd62a6dd35d81e4737a25aad43c873842316b1ca747aec9542fb9742886245f02fa8a20f031b38915e4f210088562c9706253c93d2511e3e32f7d37c1790228fad4c779a769bba2c2bfe84a5f881cec2eea89abd54e7e3e330806b384dca43cf494ae9dd32e66d09b74624bc21f8bd46fa5817e10ba33fe8517391127382379d2a13080b2055e862a0c20043badb92828114642559bfff46d73679247823f14412c473aa2eea4316ef0f4191a5c3c2879682f559b9074d1f5f00cb18d7d29d7a56bd52a7434eeb83994712085880bece0de7ee03720f1636c7e50ba41cded3dc639c19cae6b83569e2be97517205f90b951d30192319fd4162aa001f7b4cb4c515e1e46c77a646dd930fbfb4c29c86025ecae7d91fc36030fea1e4173d2344272071c5e6281d78c24b329eb3c4891bc511dbaf6a61ba15e19bd07981b7b046b7de8fb3792d30aac72c22379617eac915b77f6d5c9fbd33aa551354b2d4dbffae1e6c9214da56d059795e4dc1e7968f9e7d6ac98d1786b01382e92c999c234aba9a762a2088b9bc905069c2b8250424b6d5c2fe062da090cea1848926bcc0ea180be91975cb737cef580ef634f1644a1e7098d09ad9bd041b4339f9e11602fbb621612358884b02f78cfc82ad355a0ffb4144623337c436c1164100d26915b82e1412d4d57293634fade9833c133f4ef343d38d0e5ae384c533ebf165cbcf6fb7eec7bc015d4f8bf3010741dea720118abd0ab9ae3e28bc88a0569803e8fc8cb4a1ed7c3b32619bed862c47d641a02e9afa9a2ddaca8818562a1622f1d3e436f22087c44da4361635db36820725a0a7f44a6153f1f129630d2414a637545f9ba905eb361a9fcf1931ad23521910e41368d25b66dac1147f04fad692788f4b2e8990c29f28f478a4a27b7bc626584444bd461cf5afda69f09dc84e1be7efe926a03b6a84be182bc18651b6c98477fd88928948b776fce76cfabfd5a21c659e68ec3a7a0e5147dbef466ab3e09713050238a55ffcbfb3f91334b40a0e9dcc18ad236c5161960efb9ec77a27e3d7c0917a617da0e77a91085b31a053937a94f30c3c89169057f954a6197f8fec457dc4ce4e889d5f57bb579c5ffde196a31d801015065fe7b194c178a72a3d345f9f6fc9bb29b7b4ce2c9ea1e1a548238c50fc061aa8375df8edfcb8d09ae5a80b3e895c0d5a7b66be5b5d73e360c11679d507441a44483f77e1e363b8cb47dc1de91cb53441758c988e2749ea8758c4fb00142d88c5936b8e0ce524fcfc4a9dfbdb1ef63cd262f89d4e284b7d4eaa752500df724d754ac2c42fb308dfa17cbf7ca15f63a968de3a2080a9a3fbb00e0ad0c028789843168abdb1acf5e867843437cbd461c128048a027bf545c4ff3444651db275abae035188770d130b65554f4b9db36663a28f79f2dc2228b9df6b23cf03f658c5387a137d661cbb0eeabe4c08e9594e76a0aea5c581ac4997fa215fd12f4bfc353b71217ac03057b0f623cb97e1a10c3c73c9795ffe66640d3e5d3497d15fe38cf2d138aaf9685c2e39e9f36489f6ab944f54523eeb40ce6f89b7749021b8e4232bb6f3f2749fa37b59f949ff14ee999edf5385cb3e2a6c9b7ca2e3aea3fad4733cb60467ae0d849cdd22dd0579d6f7fe95cfec5ae46736b04930f626af4c00e196971bc4f241f393df6f6b793eeeb590512574d3fede67f037892ea5c0bd0af81854655993c51427281114c99a5c1bdf6038b14957edcd87b9f5d753116ce529fe22c36c0b0af79469685198ae9033ef5532656bde320d78faa8675edbfeb42d9076e0e3590db04cbbe939893293101ee28c3f62d078d5daed4b621bd24d75f234e4db55227a33f42129084f8558bb54cc51b4b805f475d57f578f940fb2a23a556c9b1755da68283d6b8d514085b729c60418eae065696683de13f93519f398624fb9f9617c6dd902914d668c85874772de13a8e550db9b224239e5006fd25243430b28709fcc0f9f5621222fc6208bf28f1cb4172cf2566f3a984081dc63e29e9a5b5102bc03f9f5eea457b0740e232087ad3b6c49a11cbd4d38982e00da60dcf1fb841761849d86024ed60ecf4940050ba9472c29295e3833118f796d19edac446e56588d4eff7cdfffe552309bd67aac15504dbb31a31a1327c12f4eb401048a00346994bc0901b77c2209642e3d4e58a869306343657e2a1dcabf259a0cf31f19f9abf0602e0d514d09c2d0aebb431b92e892c88c4fe918c2fd0350e9417684d8fefdfd4550a9b68e233aaf0285d9db6ff93f3947186b6c30a3723bb6d2326253191651c9fb06b4265a1482ed07d6c7e6bd5a3c99c5717569b6e594f8278d24ea2012946c38fc69c6f435c92d78e8f43082fa7bed8bde387956bdb773edc589965aeeee045687f5cc43d26495f32fb48c573849379be302700b2f836fbc2cf64b7250d028543fddd4f12d9a4e1cfb08a9d5897a394373e8d451fb12f27b6407e3acd45fe62089018e110268c1b756938777a92042627d6dee46b90ecaa862a44bcf8db8e785e4560bca2c62bfa0b8f0485ee651bf4f406f7c1284dc6dfe790e49e25840b9ca3384670e3e7dc651ed0d2195220e0ea90e4fee2ae2d488fe1269a57560779c3cd314803946a2b6e383a09dabb08281b40073d77ba8de83fe1d49bab9043834e5aa3ee0e74c093f688763021a074cd9eae67aa17cd35f1b9446f04fa2625f058051599f90e88237f5797f3030637d728407bdb7d2649ddbb9a58916b3004489bd38c1c95191f3dd5451c44b8c7f7da35130ad8900429c9feaa9913f948c5bdb7b62151a2d8daeb7aa58f6d0d670a4d46cfc160bd833944781921c025e8988e00bf4fc37f330ab80795829a9aa7ff55c97976880b8fee2256ca22bb2256f7a69a89bdcfa744e23f37818a3da000c377ec1766ffeec2b407653e1db2f30a612b29573fcffd314b41d97cbdd146ffd0447eb9f6e7d63814aa9c249a03af15a8d7684af8a877e3b914a5cb74decad25ef64c0c1619b6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
