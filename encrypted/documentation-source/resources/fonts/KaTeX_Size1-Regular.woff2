<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ad9a8427aee33d8ddcbb798af0129dd32b9d86266816d4b5c2c930a53c0eb0b0bfb846ac087118e5c8856b9263a8df7d20342e35405c655bcdb7e8410d5faa8f75114f196755327a79e5283219ef825746c89519bfe2518ce88ecd37d778f6c3185004caed4ef4e6829a685286aadf344874930620d265770feaffa6d8651b4e9ef61e2e65c1cf358e5d35c058fa9b2d6c3c06b2979d2f12a7c6dfdeab66edc6beeaf3592d9bd44170d005b3b833af1ce70545278345b6044ecff58a49db5e1eeca5e558a020e20ba2996a2f5525ee304a3e7384811601f4ad33ed1c1c189631d3692a13e541db99c090d91d20c384b4f3a0910f73745520edb92ac3cd48264dcb0808aa75a7ec195daf48ff9170366494d11f0c6517056fb511e48857ed44e2fed9cdf2442c489eae3eb0af556e9cbf984b43dd25bddd11dedef68aa2e7efb7d7d603821ff2c1dca052f3d2cb33060da73931cdcfa067617effbd0f9c99e05859e426a3521a1ae679f721dfbb791047b6d02d8f7282a72579983de493b3cd6a2cef6278e7fe00987c99e5a3347db39505170d850faa552fe58215b430831700f6a1abe2e093b28b46f80dea999fd95b470a8dbb9faed3c6c7084b2099d340ca8ab25371058dc06ef53e5c8fd9121a095a8ca63a334c67d23decb799ab8db9922e84500abe82b9314700ef56796a40420c6ad49dcc73e3c690e2ed9c221c9eaffbf46644125ffee00b69d9893a5f88a53646077c4236186964bb9d4eda4b159814fb43180fc900b14eeb0e6b4dac9bac443ccaf8be59f6c6a774e2254366eec191467321bcf51cfb0f7054d19fd9fdf72a41930990b6c5dad9dd5f2a9c9210f4ed4dd20a4da43c3fc2c6141e5b5e4ab5374ddcba83cf92ae2ac76d2e45aca417424626804dff4338c39f06f2669edecab77c6a29297a48e0d7f9ef2ac742bff98ff12b5ce73963629cc9534e11a7c688015580c1c4c2a39334ab27a7fe5b030fa7528a7aaa87df21dacedbc64fceaf78dab5f35e1203c386fbb305bc3570e36788f8f2af149694979383d928a98caaaeddf6285be59ff89dd2b490e9b30e8df8afbf1ed1e2c1612c0d84afdc3c3bcb4a8edbd81964465c6f8f999cc2e810e6f9f7d33c7b90fe06431a5f3fc5a7fc5e77271df18ac7fe971140f21311209a3d6c178c295bd985e03666efa966173fa4692b249b3920e7c31890a56377098f5c7542b3b470c387b95541a8ab6d2252cfb1b0a5b157bca305266c660c50778a796efb5c987f3335bf500a4e3aab82529c977e78199ac988e9b8793ced823c3562a580e1d68ef045123e12c4c5ac88059cbea030898a565299a2db6820d13274c16dc788aec8adb0c4f00a50e4baba922bab4821d6e6984528a72187785ea64dbb710e2721ce905002ff206a825910b67bbaa4d723bd9709ad0656c3c0573d0611a7cc8b7f5d19d75e524011cbfa63b93f213bed94320672c9331705d4b4e1521e1706cbbe30700828afd7420ae24f4970b874bd6db742fe2a868ee11f8e469e69e67d8cc9f51ab2cfd9d3687d1e0edc38079e8ce2aea3df563a722c68103e8688a5e6169d2d8263c00c1589dbac322a3e6b2a8acf81726c89f582a0ef67a17e16a436b874c7298e92b5e2182658ccaf39fb42f4cf0faeb3a151620238ced131a078dd0a386954413c01fcdbd958c75da8a8c2fe22077b9276c32fed6167dde1f11596d40d79e33a6ff6f6b8324c0be9af50bbdf5d93b71e72c320b627b09e6a8efaf49aa4e8ddb41e29d0c73a2121505a9420b3ac4e37023a8cd7eaa88ca30b43a25af723be2a10f12de606e1176b2c4160db9276feb04305dbb7da0a69ea886eed6ca649acf2764a32d1f93d7d494f367d1ce33951e23654753b6ed6a4225ae2ad1bbbfdc26156cd2185222454b9d114c9b39444c26a022ddb56bd3e5b05c131bff82766958a05067debcd96f1c997dd6a593673e2ae693ff1f8a3e91d6b31648a787546b3b1028bccf9418691f46a2c49639def81ddbc37da3a62af859869865995982e6b1b2a8e8e302f0f55d1307bf5f315c173d57ac4c096718be693df05d90abe0443ae054faa24df1c59a31b056bc52b633d6c5dd88fb63f1509162c3be91b5564dcbd2d7d5f83e3420bc906e2e25752eb218df691dcd37770d1c6a7b19378f5ae1a0a4ec001b31f3632dea30c7a258c630bdb27699c842771dc6bd61ef9c094075311bb9b4db4521bdb86454fbb507f6ad231a9cd2ac6805bb2dfb3115fe35c2f90c2acb0a68d75f5d6b29af2e2fc6585cd01905444a9b1c5e5896522916641cc9335a0a1658455854c626a60be3102c85fb8a30980ba3a813c5affa70262cb8d3ed30133686e0c2344ce14c118f2ceefc8cb4dae3290c67150a77175a8d079baab214fcb1b591faef0b4b1b91c8436a1d30886159095d21cbb4e8faf0f76c4cdbd7d66b90f0fb77a91828a2601b1c3c758e8f0849b0095369af555cf555e0d9f3502d83c347a3e13dbe9d9fc70819654bccaf32babdced15878dbb913e430c4f77548f50cbf850cdc94031f0d7870dff33ddaaa3e947973f5ab8703ed4239c38b6348f0789fcd6b00d436f5f12edd2abb12c84492f63c86825857c975231c2a6caa8a27b49b70cde0ee42e85698f317c790380336c07cac1e496580784f5a5936c347ea5163d59279c8fefd9e4c0b1d89a69f64091c97af169591fd2feb7e11175ffe264d86ca9142f5ef3c234cc9d1621060adcebf0402528bdce1411d0b0bf9b32cd6a9de4a76f3ea0018ef113a80934cbd377bef670d455bdf3f6812c86a0c4b04b465adc821223a8081363123180dfba0d31ae47d7588de3bf6a2910a20e31de27318ad15a0c1096f86b0f75055229d876838627d9db7f11d81459df51f46f848690ed9f2bb69a35029b8ecc3e1504204bdd6d7d6c1cb79f2dfb940a92e3433f80636d6f16c4ffd823ee78f860133ace3c9942e6a74ded7bc9acd82ae8755716e994a6a182f6a29c719c0bc899b924d610bd314f445e1836ce55341ebab8276c3be7269e4c998ea0252e55943c2b8b9b81d470d201aa71faeecb620d09c7ac87e10b94dca77047379cf90050d4d31b74b39257a307b607e88c74ec19e7fccb00ef7cd11e97b3c6de8cb5b466eccc3f12570c315b1775376c6f194e7ee078e3916a378cc14dc0a4677c46681372e4aa808226431ce8194d0a7b10b76ba3e1c69073ef77a1d6a497bd09e4fe17949b897e3757ca2aff7e10255dad4eaf81bb3894bdbe4291a1562e27a24451209a19825712a17cb7bc211c24ffb513beb6cb3302905090622d77321d1ecf14568acf2ca3c03027bc4afce7b834fc8f6b8894f2a73c65458403f8ab9c94942c961011e247f2b38aa3692e9f24dd9c7379a9a36bd2ada7b89d947b393f9970714d999202a2cafd8c8bd002fa9a3a113dbbf57997917bd7f0a25d30e9d0e544b7639f03eefa4289db0e7cb92bf87c1c46dc2bc671612aea83d93964b39741d9e0d5f419b5992224ccd4fcf8466dac2a3079287661f7ed92aa673183328e6055b7a5641078b28c732d0f2d2cfe6cc037af4aeeb5891f8fccdb66733cd4202a3accc13f5eac6dab09da744cf3d5098d87186e0e5e1331cd8e05bb6f7aac8b756fac3fd26757424235b42bca704a2429b96e9bf6f358b9ef628bd43affcbfdc55b1e6dfcc7c4cd93ad41df1d15886ae52c90bd605924b4a9e47c575df206f0f53db2b92ffd9279e8db87c8daee74db5a1623e5166907373dde3e51cea267ba0aa6d5f2544254625c460f7ee82ab7cde7b9ac4042317708c946b57d12a2e6813204c2500e9e64fa55a13a7a2f3f72fa5bf46f770bcf8f1f294ae67837219140a7007224fa1cd3bd2e16d096460f538f4150aed2e869e68340a8af7b7cb994148dfc88e1ae5c677ab030405b38908c25a5e77cba744ef1121f6760b722f64292c951f7fe8546051c4cfd72a57ecaa39787bbad2ab81032aa5891e92aeaefc3f1371d16d1286982228132bbf89ec53a9875c51cc3ac644315e240daa66badc9fcaeaae11cbe5fb21cc69712327b04c3916e8a0fe0f02716bcf6a38aabec9e0e72a1fc7afb0e64759899b5a524ae09a5d0caaff70af8ea4c32a7358faab041e14fc96f84cbb1b70362faa2fb1d50184116188ad179e4bcdc66c135ed9e4aa7452cca0d88fd323236e0a891f81cfe69bea5d0103d869db719c3158db6dc7cd572fdfc4319dc4dfcba7aead3b437d4d55acef53e16c04d05bd12f67372598c452e0dae15fcb2acf0b9b959e524b584cdb6c8d49cb235148b7b18f636e9226d01c2c4addc6b873d642663f917d3cb99f3f8871d4b9c3805967b93d4af52d1799422659e15a32fbefae7dff97bfafe1f3859bad1902d65eba6ca3d05c87d6c33331f30f23c0b5db4d31aca8becfb079ad3999802d160134b7db82b136a80576bc11f9d03824f7c2b814f1af82eee74a81902e0b681937185e415479457084baa595b38c9408809aca78060938664f699be539c73694c2a54d03e8fda5cca56d6770c772a8cc495d9d708b84038ac9fcf5e93ce95242ee41d1012f486e404d609fc5d69d12e6c882c408e829360b53062363f0f3a48bc84b305efbd8e24631a7552e0db58d6ddaed211b97f635a5a498251503377f931c4dcbc8f833d70a7dbd265d3a02e37d62ca880da6051595396c45dc1f7aa5a12c19f58224b9bcf0c42ed8d9e54a3527edf275395eaefb3b6b187abbdcdbe1dfed6e843b80c2bc114d83d25e047b0b3f0e395fd46bc1d3c4b95038a4cfe415c2c0bbf364e6f0a41e1d6dbaf36fe68123b4779b2debc7d47af65b4f596a24c831fbab216052265f30d7afcd1255a5c1d6dd23ff9b60b54bb14f98184f4e91a39afe03e0caa0a7985699694f455dde4d9635b3a829671dee2370e2a00ac5ed0432001fd54c0b557e8c91d93a4a8aea7381d2367616d38251b340f1365b9a95922cdd1d12760c6da2c5dc3ec04289e0db1a1e4ab9e907cf83de08838af2eb6870271916d27d2c15e3a79c123038dea6371b39087a55a5d7e8b00cc5748ff7738dfde9c1552017151d5fdf931ce484e8e0b7046185f5d23dc59a497031af36f162e3ccd65b3607a6ae2be13a2bc7caf441feb015072778db004ceb36ee996c1c14bdb0f21ab1ce71c1d432716b710a7abd30d6899bc20277950ff4a5b572258d352bee1009baab721a94cbe5b2c3351c82d2f03dc6a6ef2b90dc715d747e490f709448e284fb5c34172244eb0f0b3145ca186e18bcd4937108ccba484479aab861aa80c0d5598ec23ccfd68033bf77ce17a472cf09cfacbc420791d241eef7ab5768dbdc993a882a2fda7324a73b38b3748117bd32dc23ffe4aa66336a26f083ffc698c842b5579e52080b06f175d14432a71ff85ba42cdd60eb9bf1c3edbe322376b233a6aa66a585eb098929ee29d245c731925dc0edfc0e8bf8e5602c923cdb73e63aa5a159427709340961c8f85e23cac1c7c5aae2ddaba1fff495dc337b03108aecb2c9b8845000b58782e1fe797a9127f3fd8067614c893eac6543076cb51f5463d6211eccc0dcdff75682094c6df99c153b90057033775cdfa7ca6450b3caaae810c0b7db6cfdbccaeec5ac8b4c6c3f4e20bd8c65da50336ff266d2f4d5889d53b87ea2217e5a96e106307139283282fc33f4d5ba14462cdec89e08095dd11d7622f4e69415dc6deacd744b38a2148ea171753bb1ccaec364665e67fe28af437542aedde771be830ebf3eb26094c029cbcedd0c02db1ccb0608ce443557d2db6b433baf72f206852193b1c9bf93626e4c05036c50d4422443a09b1779615a9b132d7a0775974ce79a954efeeb2f588b73e4c8ffb5f2947212285753f54f31ba929965fa94eb4ff9012319c0e5f8c6cfe86c2c7bfe58108a985631314e90d13723b81c27ae404e8c2e7669028d807aefdef908d6a09de93ddb33b9b62cb92d95ea912b523f1d7d2d8e200a10d9dd686e4d93068ea2a7331f7fb60d7dbe41005424b21834406141c44ddf3971cfae11a9c3b7aed70435c03c7a87a3de7772214ec9cdc14270209ea4c6c85d8852569f983f45a602619d578f6ff4a4f3a9b89579179b84d6cd8a7867612c3219d1a55680ca221d74b98a1d06f83d0babc99fc3c6860b351ff8d74c190d5eb18d0d415624ef6c70f4e63645a05ac073fd7558506dfd807f05b55b443e6e79219d492c35f8106384f94f78ffca20d0cbe133482f83e627dad07682cc52d0a2bfef6be31f8b0ab6effc11b7cbaf3bac3a54000240669a5d548acaeaa355168f97bffbb1f5c6e67aa3aa1fad1466fa20113a3693e3e0fc194d1cd56912a8946a8400c7f98bea6175024824763a10d41776b6067b786aa5372c34f006950f2a80f9eb9d201e31c95da452995468773042927d9660dbcd1d0574700ca764fded340ceb6c38e20e79693f37f4300bb04ef696aaa30e6d8ecd593926cf98dfe601b6e9e6656bbfbd80eeb54d5a9cd7d9d5c5d57bd50ee92ee2d3c92bf6c481dd13a0ac57403f8da0d1b2bf56e380abb221c76ba5a20eaa96bed812b74648f268dc6fa6614059d620a12016c8e7dd97a7028b91a096159550de4375829232123eff9901e85d0dc23e2e9f3b62437b0a67ce5fee16f59ebfbaa0b05fc7c7709d328bf36623ce83af84142187886d406be55ee84e1f9bc9aaf717cb53e0472b5defe3df87046ced84200a01eb9c9a9425eedcada6da8d93455e4625cd870485627f7e476577a2e7a18b5f460bf855bc872b207e09dd1e6b69e09d17e47117e7781a65a5eeff87c720df44b98e25e45601557a8bdda45c9cb75be80de46cef057952255af844d49b372f3e7379ce01398a0beabef047aa5f9035199492c14e4c2acf9a677496d46b2cceba01b2db3b672ee09660e921680207b03a20dc9458af29c3db671b14c2b94d84299120df22201c0f0a6b6f27794f846c02d642a32326c41af366ad3d5936502af0e44a91c396caaba242906fd4427fc9cde0dbab7b7deb3d351770451a6ce1c71f5541b1181cc5309df59e350a56c8ba1087ba6bb40ba453fec79cc0f553aeb9cf66ad5766b0cd3b027779d1452ef3bf6e16b61ad731b87e1d4323ea37633a4d79453f6897f22ab6efffce5d01c6e48d29c5dcc63dae1c3b9e7151ed4aea9aabd51f263d52eff8e22d4b27bd626597189b11e36ed6514282fc0bef570c95eef0cb61612b5b1aea92ef9ac715711a9a039dcb7381eadb1c5859ea93b372874a19ec76cd6615f27d7a848a2652f9fee583f1113a8a121d093f7d92390b84ffc1bf71d3bd1a6878539b1b17d14aaa84b72083716123649b10e7788b0331c77a86686d7e7bceeecdc79765b415b96b8d125f134812d607e9e699a6574a76f1c9cff5d2ad04c2a646820c8daf3606759dbffc5c2660a0a516e9b03c1d28cd94cb35cde9e6729c88bea4484a8eaf0bb3b858053211b5d71efac57267d9846086e8d4e527c0ccd29329de2702fbd366b5d312435f27f54edc56da582526489096dc33be00c2715f515c755ca3a9f85f55e4fba4a232d1f0178666167362dd9f55b13c327f6f89fa06211f5584ed86402d1e439955a3ce5ef1cda589e3eb88739c1436ac42ca8af23209dd1bee41bebb4182580d0b14ff609ff08449996f188cc3b347a4a824ab896a2c20cd0b9e8a45eb89aa3c4c1e68fe6afc67b30ff9dc60758cd5d4daada75fe0f1620fa9229693d57d215de8dc1b777502f9c265cd32eeb68fb57a41c0bf0ca4fb9c7ecb1c73213343f6538a40ffea76d06b526318e2a34827fdc642b4090a129dbea3396511c817c9195e6fada21eefb2a2d3038f330eb241ee71f8c7125013a2022a211b3b0daee61a94cf7769af74b68907865706d0e772fc2b1404e249e8f39b976c021e0d9752ad8612bddf02884678244f84caf6efdfa1390f9ef25e96ffe3519a912d23c09e084ac152e634a21dd477ceaf5d815a47330e9f70f73d9fbbf969f405879f16b751999dfa2b6958e85a57849ff9a1f1b90c3d8b9779d6f4b400596638fa6dc12515a209376fabd9980da77972e5f184130473929c41aa6bb100c0f86a335dfd671e0838842e3725bb578d9b47aa57c2a890abd62bc33449ce2b323f436e8a02ade2b178f07c70ed7880a0af885daea8bec8a428342b8aeaf4238d92f71a0305f10822a9a444ea2bb5d33d5b262b6dbdfb3a55414daef50f7d03fec1d2cad7581f72f31180e0406f7d88a08c74b5019b856a3485aad6eb8c654ba498cdf0fa44b952f18cf4100994c31faea62c3084a1c013911c88c99639b8c688b31b8907fab8e6401b9c32b41194f0607aa7b01cea12f5a0bdc875e2781dfdc7b735c2203395001df482f012965b7e34211675934aa027f9526c961a6fad5bddd0992d0f881f43ad1d0871a3efb0f704d782ffb441b7904ecc43f7c9b40140ed88885d95675cc8bb1860ef995d10339256deaec9b158acb118a0a8145c2f22b1c9594dba99524ef4a7d47d865f6ce3596563f508f86f7616ccf228a204afd970d4dac45d4b3957c2a98eb5c49aa3e4fdc4e85dfe2cc57676e3228c8e1e4404829eb717ecd5543c5b847e86bf4296da39ec759b9f1a74af828c79008d4bd97d2acda121c06319d2cbcc50f8a1fe32d3eb229cae64fbd009add16c2d4cc9b0d2d8077c2d2cb84740ddfb96a055b470ad7124bc9c4d81d951adead4d45820cb67e42a57892b61ebdb2cc8f478f3814c5c9397194a9aefe00a21c1ea7ec789d8d03d4cf45f343c3e3dccba0cf9470b6764f0fae5e31f1960f7ad5503c611f0ab2b8d90cffbdd97249ae4352f3813084fd346276a00c223e145c3eb3f245697d6a910e3a29c5b6882e9ca387fecc1b80dc66984a3e4c1e89f2895443fec84bf66fc9055cf92041aea0ec9b19b458e09b86db7de307130fc885c98e11112f654088f371c5adc4d5299e8ac7d90055586281191bfc0d2687b97314e40d9269608ccbe02319bdc1f20e0f1366a783935b6dbb978ca36060912707ddc4e2327350ac9c20d4c7387778850efdc794038304bbd6c1027e8f7652b2c6cfa67d75eef9910b00deed38ac9ce04ac24ee2fe554348b720674d36cc49e99d48a13d17fe787273ff8c0e907c26e2aad5fd540d3ad92aff9935d02cf3fa52f37d5272f6c15e8d51cdde7ba2c0c626c8ebb5be8372825c20b5038108904f2a05eb0d6d693f2ee6780545da359b4b4bc2f7a5c333d390b92663b2a3ac13e97cccd98cc8052a295a7c5e62376bf4b55b41041e8b191a957bb4b3dcdb76f917ee468ff1b439e9cd5b4ea64472ef6a44ee991adf27866d5fd868697874348a75a373b6106b86b2677345a33775c5580b1033289ca337a4be32d3da9f21100d00391173d62aaf32ef931348eec8cf437c46f45f60f2a5bbd28cc22295531665d07696302b95857ce01f5f5b6a72efd0ac08a9d3ae7fce5469bbcd668839d9ab32842a2c0590bbc9db2b906d94ca73d9916805a58eeb7efe68f22d887e4e5d7e1409a085fc8b26a14400107a8df49a03254cf34e5a807959bc0ded4c75df7efda59f2eae1d5f8b27dfceb8e31d849376661c2ea5313d2c89825c5b2bcfc93d461db05116ff253aa1b489980142bf490d226482a2953ee5aea317728a8318f588414cb28ba578798dc0ab6ac591f57bd78c22feb7db6748ccf687f935e5e06289973ae07c32e1ed4ab9aafaa6fcffd87331be7038fab0198e1fef3a59688b8f5757f33d3d4bba2a36a2b51b16dfc29442c9c4bdd7e7241db654868e529fd5c18cde4bad482cc057058cf22aca5c71c3a2189ba14dec56649b8f8382fbde56d8595d0939d18f0a4241a326b56e8335ef4a49e3a5038f563e2aa9b71a6d7b74d390f6a475a9de3a2cf57b260710780b7f510143144d95cb86d79e609535773c66f9ff6fed3d16a1c67de8ab24736b4da10ff6dea41e0a55e955a43d61385d83cf3d724e7ef42d3ab6bfb502eba9deacacc93c15cd5a3b9a5d60a3a27fcae4e4032e5d02a6cef3eaad44cc9f34fd5f1c33bc55cf1b210105c498273cec6f9453bbc868650ceb4de6858d86a0b1a231dd8072612e5a80da9c07a59141d9d3fe292263a28c6c083641b7204637fff0833bf9f8a564c285559d003b3b3c5888b7e12449430b9a4da25ded59223c24c493a4cc175d6a84c7d595046024f7d93b294ec398fc3ea0affa8b83b1b2e05fe29614eec1512da6faf3451696a72c0e17386ae9899f416656848db77ee4f4e1caf1b89554b62df58074d6ad54d35b4de86b2ab1d37f5249e8c26deb89e1352e22f02f4a748d273d9d6cd6b0b51e496805dc0d9d93a2a149d6d46d36510352af371b75761220b9aca48e180a78b3aa4fd406242b0478a5dbb7bf312bf08f62895e272dde7745774c5d7956e4b2058e410ea00de32ab2dafee3faba7f6f608e5ad21d521c07d35c8a5fa04ac07c57a30ba422d54632cb3ef6f0f93690cdbba32d38d8656b753ffc439ec6e01fb147e2132e1312f77249c1c88167c54fd269a7b30d26716ccbc2dfebe7cd6986ff8cb9a0e819baf36f15edbf5804ff4895355e4f53eccada3377f3dee8f1c3bd5b2b33d7d2dfd8e1bd012260fd1a5490628c3a87ec30e784e127766122402a7ae40905104c902ca66c94d8bae864527dd4234dfdec01b9b1ae9d47dac1836dc9a900308cd0f740e0a296251d59208d8937e39125751a8afc53c8d6eb5584584d1fa3fced5a3ed65be9eac30d7f830b4129ff281088f7936b7839e22420aee02c7aec547fb1a4abd9f4d868de9a5658035ad5ab2d7049fb2f8e11d7cd545e451ee7c287b2db1b1933ec927248b34d0affe49f5157a387bef0e70280df0bab4f14478075883c7c17c0f378210d40cb8a9ebd0afc14059b814f20cd70c8d58e42419e1986d076ee1aae3c792828e17be9de98bb4f94b458b5ec28cbc1cae17ac3d19076bc6c34fbf06ee227e42b87552622b9a04ecbf64a70b3d4c3e02d7f1dff21dd271bb21e10e79634a3708860092f8268b7f5ce189347f7239b247e531b6363c6ef275042f4fde9bc2f290fbb3aacf6f55f17a9a1239cd8285b3ca53dd090833ce60069ebffbe15275db6710b843b29a4f5570f2271ddcbacd04ef013213dc79bcb680f68b6b1da5477bd5646827fa075fd38e94c75279c26fee23f365f1f2eafa0acd9d4130048f8d90a84db0f874e7329bcaf633766863018670e4af6ce16f87b83c70d803ab23b211f4916060ce4c5417efc457f8f24fea1f6747d3091c4415148afb31a43f755185cf7a5d27aa5d12679149889f64dccafad9e00f88b6c48d129442784f7f5defc4d8b8a966d3ea3a390fd3f208d3d5a9255a0eee86132558a4ba7267ce80d060e084eed70104d6cc896502830784e7447410ce3060899897d836b5b7c03d3b6108905151a94933cda57e5d4fedad1abbc5e2d8fbfa476531208fba22be4b6d32a8469414e351d3b077b3847a8c560ec76f6b8f462096aaba40a16ef6284e5f970824bb3916088fecdbfdfe98f69564155592128fb6fa4303982ac1eb67b56053985728fd6bae1c87d51eb621b0a19b85f8d2ac1e8d4f036759cb22ccb4060da2755e6e68872f681030a734352235cb2d2c03a591b1b9e1e25f4b3ae2d7888d63c26fefe66eebe8fec92d06380c1eac1b84f470165459332c8a9a242ca8e1534ec46b1a7364a33a08af10da07741ccbe31e3209e8704575e171b41529a900471dbec443e02930721004547898ec242eac97fa4610477bca76fed87d614bc5837da6477d85af5b6e1ed3c1f1e2608f71979ade533f17b66a00ef681d8dcd35a4be11bbc10dfb611e8e8ca3726f822f8de8baa45eb5c5ea1e89556f3ebbdcd74a1083f929741d21db747a6d0e2272ec760ff19819168e4d7f804792fcd2dc4de4685ea1eb31c8415ae4b934058b40a21fe68403aa1a6925604eb29cbe5e7e4e934e4aeb427cbed683206add4196e9094f24761376aa2c2d72067cadbf5e316a133773e0c57c46e2f4a4f207399fe7c7d4b69801a7133b03b6f5ffb4b019ded6b25b1e6bbeb2eb3efcf78fa92a893c8ad0791f26f1e50ff4dca54521dcdef7645c1a2495aa12a4035a8d1337cda8dcb88f0686becf229462c194719ee9a28cdae7cc443721157cde4dbee7ef8ac3aa581512504fae3d4a9512d46cf5189743100b025141785fc940c13ec11817671420efe323c97d4e95a0f4fc80bc504e50cb40cbd6fbce29f7f5bfaae8c28391cff6bcc32a06ad02a31037bc980813b20e9a7e5586b149d98126ef0a6779250a27fbdddd91c6306ca8608b8efe8e6646f4c4d6f8ca54d3a21016c0365aa8d23a3322d4a18780c8ad6bcb4fe86775a2dcd581c0c322cc6b6438a7c4c35faf394d8ffa2fee1f3ffa6ca9fa6273be93f3fdc1d91a5632af53f79e9a27b3df17e08b8046d7312070c4f9c665ce8f46fe855292fb5dcf74e0b49ede104255a2c18a447bd3651525eba6f41db4647e70167fc3a22c15df0af4aeb1378f192521f31f894b9f55455255f5c859e86686e83f818758a3e6d51771094bec31aedf677816dc5a64835fda803fb476e2c98f8314c0df1ff178a4c8c691e46989622da688ed3cc1131a084bdae462a09b5669d80a70fecd2705b1edd3c000958bd88dc1aa50e4a70b23ab356c9983dcb9c07399187d017cba8a7a0935e15ac3796e82ab94c713cd8c4132608732e2fb5a209fc706ccf85344391fd04f97e797f0e33c1d5982ea81920ca923744ed19d7fd6d5ec34f136a37246d3188eb5d3e6e873da9787105dfde47104faf7f22ad992b6327f6e526154f246c3eebc214e1d1cc9602512134114c901cf9b29e693f923f72842048aef688d1bbc280078263b1c2a178831b850c95a81ab56d161090ee2bae3b39e795029d79a0a2d24a546cb96bb86676c3240c73fb3719565304fca9f2ce59cef97e76e882c29c2dbe750b68c11d7c6dba7a1fb4abb8da3379facc5f10694c0a6cc643f2e43d88f6f1fd1afd8fcab1647df807767e376e5f7c8cfc0b76f8811987339644bc5d546f370f10786eef91373642ad00aacf0c282916840643fd709bf52252d9716af457bb1a0361d40870ef9b9f9674f1dcbc6a6e34491be4de6df714ca0ef2d61f4db8b8e8d9caae3cb3945f61f6089045e1910816013c7c5567415a23de80af36e6b013dcf1620c00e3b879d8ba1fbe14a555899d2d4af7088b4e1103c507ea1e7a5ac3703e15176ee3e09a42ce4d1ff7496162fbbac09a071ff62e429ef545ddba494dbc3062d8cefdfc1a37ed770b31023e88acb97140c24f7b72f058c437e9c811e43698ae7b51ef203ddda3747f26f3447d5c527c946164820897ac231a53d08d569460ed55368effaf2b16cff04bae198cd171ecbee33ab282d8fc0f1a244c0e68056a8a9024179e3ba3bdf44844a05ef7f591ef3bad46ab5b02ef7f977865f0aa0f86809d92c298e4a8337c92510619c91f2384b344483e6d2d4714a8f39d9f5b0aacd617e27c4a0dac80c32c9ce0352ca6a12f54b9043b0b1c42f528563b4eddbd2a14cb958a49614be8108328f1eb3df9b45b1a294ee09d024ba227a88eb051543e2599d14cc3cb7fd3055e51722381a98b158a3eb4360daea824a7390eef6f96463100417fd8b67514f7522d836e1fc658ed2406adbd550593a69a498f54958901e68f4cbfc2126c16b4c5015bb35996cf5f4db82b6668d43716c2d0ed04ad3472f62e43921a8d8f23865e1ee3a13b404263d87d76e6037d0a447446bdfca096f09d6bf75723c95c98534324a1b7681700b5316df36ba2111c21cb234b182cb501043dbb0eec7e17ae499b888cd38451204bdda9549402c03c7a0fffe58f6810144ce57231514b72f656f690501aaab50353224d9a8ac37b87db75c26866009d18de005af3caf8925f48efc6eff9d16861f8e3d919a5ba7a977b9ea13ec1a10599ca3ea9f630ef5d0b7a958dfc8ac06736411f5f1d274a0a586a548e7cbbf9ffc7680516fd735b82d62ae1336bd873494c529fac23fb85801c356a661a960df801d244a0fedd20d4226b70fdfffb9ac5557f3c41de34a1ae69e20ad43f70b0cd159f35c8984b3e4e3a413d268b5baab064106287ef47c525e91fd2298367fbe2055601aa05f7d8c0b305241fc107d08c89925f368f15f3fb8d25844aa8ada24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
