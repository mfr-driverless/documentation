<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1664d727b187ca1404ba65d00b0d5e13350b5f5ddffcec95a18df5566809365fb44347407aea965392185beece66b2b8d815415526dcc359ffb8aff96390a9459084ac1f2642e5343870ba9952872236bd2819f4cf7d8d63309cd314def121a2b34e85c6384b8c9917e4b0de5514d234cab775918ceb5cbe87262cc2b2558a8c807db72f139bf4f362beb4e299f4e5e9d2984a985c6e1d9cd85363f73c79f5d87f4e9d23621ff068363413dad6afe56ca114e76caa39680f6f0eafca107df8af3acd5759fa32c7d18a129554f86b43f4bba8d4e12b2263642b00c4263653e3830656287537e2f6b3852115c9ba8993c9186780cc2dc210adb6b5ff74f0d1da54e9157a515fb8e0a53a3dbcdc65a518cd0b64b1db44e2659754d71b903e0334fea3ae9da9b20963d05a79d393cbb82b38e0d5270d2ed0953dbacf4661c00ef9401c8d2da03054b9f634841978145346e5503efe82a977f28746d2af8034aa1414b782861d2e2fc2606c1d299155857b7225a3f7cf89cf7dcf9bb0854bbadd3eeabbf32e6d9d78abdf91ee69b2771f9f819702a482a4e86de9389b15bab003733badba10dc79e5f60e24448535c69f6d864b3039608c98bedc42e323915c5d5c431732c14cd223ada8575fe83072d29218f8b3d75170ebfde7b91b1d0db5a8d08cf39d98de1e1a8d0faf1b6b323c9811633737a365f43cffc0750778817da2cc5985097fdbeb02f0b0ff44109b22772188c7802205d1b10e2a72e5946a6d6fc611c37b25fc68baf173250224145896c1fa8a796ca53ff210c54f5ad38e23eb2312291173523876fb0b9d993da467a8e379b5a0f3f056b47990534a7534c530a9b0df945bc6f82f8858e67a4dab1caae37839a1c9cb4f92376b790a585aadc80825ffb2975e45cc68c8b882246710a86ccf5b9e70efb0897fb90b954376ee17a975a105e05afdf53a09567182b80e386917abba01b9a49f6f308a5a4c2a6ca5bc140c74ac3ee291db947b2b5dcdfb2336c4258e694d3fd03bb50761c1843184087950b825ab7fdb491286862f4e5cf5cad3ce99c710b46b08856c97288d91b2093b660d1ec16c5d8be84415fab3b9857f1c9c17f6dbde2b07c9ecfb16f08c0c7b4340dd6dc3141038b0b71f0759f5c51243951bce5c04d4efe8f3c82a803656a80a9d3723bdfa6de3590d6d2d66eee4c5c471c232f07109c6bc4c284ce33d807cc2e2d9f8681617893ae57062083d107dfe1571130f980a273e969501a785c8605daa41c2702d3e17da4d114fd02a44d3b0a5b4067c52ad2cc30a401b905eb2fa08a728de1a71946714f4b216b6721a66c2a94c2188e19c349f73508effc80a1ea8542b815e7d59871890729042262891b7ce1358677256aafea217f42b3111f9c8dd921499874667083752501f6fcbd4dbc455840e3034e910b099a5e0437c52b0652f22744e20ca6abb9b7e73a6baca9eccd8ff3df1f07d5390826bb0263c291914210d0ac0b50190d0f8207260c7560e8b3c55b25c6c240cfa468d9f86af41f11975f5b9d5e20fc904aed978740b40037c2b2e4af4aa1307bfdeed1697dccaa1607263d575d2ce50a3493f9fccdccd621600c2cc197a4634baa227dd63aee2cfa67b4300f048cd18879fec705a5a4cb6bc14cac0fa00bdeedd5365e5545e989a15024638293a5de92d65370f3a124dd80bfacdb04dfe2d2b8e3dc5324f053ce1309178e656fdc21ec2cb61e3073616b6a0388a9d08f95efd2af220f28086beb05ce7fbb9c0b9e324aee7cf862ee9f523e1f1833243d86b00fd134ba143e7400679f1ff2d8f2bf2b166f4bc9df37cd2f20aff016866668379f3ba0b8aae5716c2d42f9afc1d448a829100745b9c50dbd4efc2102fdacb84bd0157ba545abc599bc71c75ac9271748680062f4f52b44da6dc809b720db4fa74a19de2387e4b922cc70869d80f35c89ac3460fb506a99570688eb372748a702fcda418d9314e73b76410392e85ea427ccaadb5e98c457406d405ac61e7f2a9b6724edcd3d375847b4b9d071d4004236a13b9c399c6d1f4c95715d6dcde3fbbac969673d1ea08acfe08909c639dd1e0ace78286c283f09bde0ba5599ecc7247d82a9a15e3507785b2b8a82df2bfde656f1e4dcabde46974d7a0a0de217119e84c50378b313345b476eccf4a8ad514f6fd49fcbfb24c736e5912659cba4f18f91bd2c0ee9eb02f211026cbd44858fe7fa67742ebb544980863c4cbc183cd940dd7d8a816169e98eb4d77c51a28f84dcd4c97e2ba674f04ba7d060a0e405dfaee5f7bd1d34ec6ae994f9a4c6e957d4b760e22aa828998976d985d3b116954c0f1e095e99f9f6d7e246785ed0d7cc84aa62c99666f1327cf149dccbb7cba4ec8d7d6ca0c56fd950d242998652714522279575f0982159d7c9fde5858778f68dfcde3036db23bf7c38f380167af433d15ef687e35dbd2e5be78c2d137d622e41084a1b46682051f0ef490e1631b0a0dcf1a894bcf208ae9cb308ab8ab896b797d5f428f11248032616640ab3e2ac412d79fb0584cf4185383cac77b76069ffcc3d5478df3894ff93b48f41d018e383c94db6fb3ee7db4a078f9ad979d9d6f0932b27ccbcb75bdf1328c44c86a6b049fc945b6ec59a921da9b7f0274e6188fea049c93a497387839483716493d5e7275fd6dc6ba7c2854695a4f383264da02d67b64c7f550d74a387d46094e310529a5f02d8fa46bca301b39fd8acb92ae233e04a435e1e2459ec182a1906008c4bdaf8d77605d97f32691580635dc2e32ad6dc4975be1838cbc1829c99cf810686d3f3f877b019b73a8ae21f4af014acd70353a5f2a1436371d4d8499d60e68e1df38c3ad25abf041942325f7fd9fcdb2facebd12f3108dccd9b8461ee500f0df561a0d4408336b604f0cad94d043f04a4b8292fa76e8d314bad903d127024276462d12a2ec8d5d59a677c7440fd4ff30e980b3394589063c7f28e78fb976f13919f86e5bfdc406059c0e8a6c28b3f84ace43490e72da049a1476ba38dd1a0f774242a63f97fb86794ee55d29c69f67bf820185c3a2470c674624685b69e09e93a4dbdabd68bc599e197000a5093c270d71dcaea751a18c3d0b0ab701c13e799fcbb81094f379e545239ca710e9c290db9a04fd63e19786c4faf4874826a85c14bd24f87d6728304d618e27e7c902ee28da0c43ebf9c088b1a3d21491a07ca7c04e236ddbe31220015bc1d60783f75eafa46e2a6409d12f114eeaa8e89bbdc11c979c986db8c912fdfd378155b82f9eef14bfac529f14f9a98e63a5f2104d5d5988733607d10c76a03aaf616a6479d828b632eeb057bc1f1b868811c1ee8f0d6589c7da4f71c592152d56ffba6d7de5e135a03db6a700bd0b6f45fa02bfa917bb28c5cbf84bd208e6a5590c6d6d0f4f671f7b0887d876241b9ae09778c9b6cf519aa258e35fae0966d4e954e3827bfec8076794344b37310d28ce48aa5fa33524050f30c47569b9ee379ecbecb9d47beb4eba7cee4a76c54444cfdfb2b965a98330868e52d2f0295d2fb95b9b396214dfdcf0f0dc37024669a85401bfd74b09d55ca557f4c389aec671ed25b9101ef6709f6c3b3a5d5123bd9cc3f31dcb4dc740b9d5bbc48b15f287190608b06f5ddbb9d5ee999b7f247c0ddfbb91c4b5bd49743aad7d33c080bb2dc70c88ca8f03842ba404ef131eac86634a696122fac60bb794a5dca573cd0702c8ef23d6f2c4b037cb672061324378ab73e5c1a9ffbe4d6c8b976e819b0446483c28db368d378e16632cf7f71779e5be67c47d82d428378b4d5636c404518cc68ab0a7ba62307f9fc1c1324c220d461e37699ca729725ec8555c09db7e2355d934206f7f8395c5757f91560f848724277384129f9b53bb9b7dd2864a65764a9d11de51649ae100e43048092a52cc64d94b2694fb00bcb0a207ac296dee510dfe36d7edcef73f3094cb7bdeaed3d7592e6cf70d80752db890fafcd43f9883c77caa2970968564e8c7b87a5e278a94528091b9e2dcb13ecb6ee36a4d1b7f2256cb6b1132f7bffe604d910604ae3884c1acdcc0e3143ef2847894a9dd7c3ece25107ed4d72d0578f95ce20d37ffb8f58cfc9ee7b1ac401fb182e746248bc9b3d7628baddadac52c07c102f7897f73e9a2387b7bbf726e89c039962f61ab25642f3dbbe59673200c5b3ba2cfbe0ee9c17e34a106906684228e1fe3ec96855b940afd446a745197726b42550699e44e2e3be15eaa758ac5926fa07af306245b6832020475dd478706d5f64f45a0d190af8434a2daf0ff59e934ed3971aa8deb9955db7afb3e1249ea961b6208ea874812eda914f0912abc80bc3043f6938a5a9eea814f2c387e271645d41d50b699bc25e584c0d8aff0b218f67177fef5be8037c21ff44483c2db887fc9180155e7fd4526bf81a7ee7da5eea35e4ad9266660d2188969973b7c3845fd0da47978b989472eeb235990d0c3b673d8860df29d888b1a32c9e5d5136b92087e5f028c190bbc9c2573efed0830987a924b7ddc20cce6334fc966aba58974308e4ec710b81707ad0cfc50531184ab3a5be4d51e87f319d56221194c176d5e13761fabf6e4e674c79aced31e5ef4b66b03dbe898519ff4594cd37593558d3d24199cb19a12676aaf530fab42af82fd325a699deb8692198d10356a84ed4683fc9959b3876225973e17d8cd65c05178e48ac246076f0c5a844aa3bf559f13b54c4c9ba0558bec93757f6cd13bceed4fc9537681bc13cb4c153d15a3c9c31caefae2c66f43011871470c37142713a7f49d8dbafeed57b30d73080e38544c5467ebdc17bd447ffee04456543c6a65d07f0ecc53f47a58b47c0b8ef1c9220985ec4de8248f728ea8612368d75b5e3fd9660ad2f71859995dbd656924a07cbf144c4fdcf9cb8cc1c976a50a70ca350ac164a308360eb851418ade906d7dc1a81d7282db35e2ffe80a0ec246c481608f87361e1a282c93bfc199cde69260a29c3383f32bad8ed3dd659363ef766d05fb10ce732d9eb4dfa419e60ad47ba0234ba4684de1929992b5f8b22e14fd8e66bf38ac2e7d72b33c1250ba14434de42e6e060254846fcb23c1e4311a20793bd7ce08aa6be80dbaa81b88ad1455d53d01e07feff3be19efe678769b121f66f78c3fe992bad38bab742fe929e9dc804ec1b0f714593fd2d69ed1cb83ad5bc9202f5bd101f37dd917d5c731c4fa34c4280711f4ae84c200d52c9b5fa445c0898225285a864f4dec618ae1cd9084b033e48955da89e91bc4c13c3d6c9ecf4568e867be3759f1f7a4142148aa22a476de319bf588e59f8eda923050dd08834c16b13bbe58cf9b248c0e6c8bb6e9ea3758d18bc9eb7b2866c18b07774e9cadcb1bfff3a18da8e941b63e2c62f1c2c008bb87b884345c35b8c1abce36910e5127233662314f3bd0651831d9491f39ff127e6ce84ad0a7c5654e89a6d7d6b67003a8b84a76e0ab31c87c0f5da365f13b56e1adae0cc5ea169fc86b5bd1a5a53a27d0c99c0a1f32d55e7c93caa4c455356347c6a55194f6cf27d2788f9cd8ebacc05c461ee2188f2d17085c84c776aa8576be0f8ac1a27b3035849f0d7faa4749524c339ec2cb8ef8e0f35c9c066f03f13ac4ad80703e41203095eb3a9082e0ba32f10c0b67bbeb6ccf2217fdfad8b4553098fd858a96c60757e34fce5101f8d5efcb3fcbcd39edd1f4a6919c9fdab65c77bfcc5dafbd41ad59c5a5e90465aef1a8c481bbe5b49b1e79fa44d3def58add632e93cfaf4b3c48fb465fe35fb74c3c16c5ecf7454e50af50acbe81cfb2d8af45f173fe9aac30cbb7b383f2d9f91588c0f793ee3f5f2b3cc32d615f584420c5bedbb822c1bcf9cae400dd14558b57f357d2df7c66d40fe148e364fdfb90f8ac77587e94dc18004395da864fe7b88a23a1bd71141fa4f8e3883e8a786220d6179be77049cb9fd6b2e5d0d4df030456c63fd4a7bd7bce375199580a2c75a6aa291c7c02e51cc33d893516c07e31a485e794e960a05380b74106407c21e922ff17e389176cbcb3e44dd95a755bc10385a539fafec24c619492d88254af93e779cca9df70c72d40d5564998b551af2240d7b94bed6058473e7e7db8395939d8359493505a75de2277f187b9da9c7d847222e09e5681355e75e336359bd781f99909cb54eab8ad6e430b128ca314161b3abe6ff7eaa5659403a35771d05ff103b430d6ced6bea25a6f01959b0e7ea86173581e5a0cb0c685d0337566d61ac5808ddda5743a53864e8cc72e3314abe970a62bb7f39f00aaaeb26b464ba3381462a262bb869ab700474c196581b64c8c9bfb454b4ffdf281e7a7d3128fdcd6fea53b42e56dc551f1ad7f0b8ad0660eeaff53a9475d7f6e2977811d370f7de1eb65d2a53232e9c9d3fd7269c022ce5e5ff959898e7c8ca9a026bb9c852cf2374cb71acfa209dc03851d9bceb719f06230d9522f36340fc3dde68d91a5f90fc16d7eae8b33a915abef2b72efdbf7e7c2b2ef3b35f7f33d4707c309f4b748d4d0ff5411a2eb6d0e3af66f9bc20831229784e0705dd54f9dcf3ee95e311d6788c8f15a4bfe16bb83df6d928726c297fb66594b5b628aa8f1f800c34a2b4dac8863f90d9eabf88fa0dcd5d5d0c2fde7db627e9950e6ef7f161ee5f53f4bb92076408f19b06ad5b7ca25b94102cac4b11b727052622be396fff214ff0557912c99145fa67ba77e0dbaf6897db26d629727ce1bfedefed9874241d3d25585f5dcd26daffb61738676392eebe707b1c3f333ed859334ee60070b6980350b78cf07a4cd8ee11714151b58dc060d10206e3f28c6aa65f6cfb13b8520c7d41b40a90d6bddd7b35815cadd53e8ebf6dc918375c088585f56da0342d1ef7a757fb35ca74b6cdad13c5ee699cefb4b4a298e628c1b454599837a30d030bc4e72f52fe952cbe5409a067582bc5e3df9d57b12c0459a873e402e3c8760f53768fef37d47e53a55a5a5c4a2082afb3bb588aeb21f9898ba76ec6deba7fe5eb51054e5daeff6ed897ad929fd4496bc0ce5f91ae5555313fd58b3c4467b86d42a82188cf1d83fc7048c1e99dde51611e33ada9c1ccccf2cd94e2dc94547716c5550e170d2741d7b51889a9fc8a6aefb545040e10935f5693fd92dd0446904c3c6043bc123aaf6da7da6a48776ee42ac9fec91e1104c901d4be68ddf5a5466ccf4d56a252e33d23f4c75a7bb5ac2cebd3f1efef48ddd40de926a12c04341017a56a149e0c093d880563674892bf51fb9ab395308fd200a42c6bbfa4a99690b89bb1922100fcbb7bc515a85dfe20a5133abdec9caf041a4564aae96bcb1a5e8a2b4f8ccc236f855a6701e19cdd8916de6770320f5de97a5006d14d99b2575f62391e818f71f1a6d4b5ae7824f69c0d8773c9a12fef862d551bf66c5bdda70b336ff997b61fbf46e4cc187c5c5ec969c0ed94a1b950426f86296c515e0e4e35ee2607c03daeabdb6b398a976c28c3f0f03fb4458d7c3f494a8f2852eda3d3f27d58f672f51d604e9860cfa9e25ef2d898ce678d77f44da07b24cb65220db131131314eb6ae2948c0f570958615f8019bf307de3c825095849274b75a26139a8a21bef335c00dfb59698713dfc0337572aa95eb9aa76f2dbb696bc132e7750d94ae558fc725d8aa88e5909cebc1c8d304b3b283f5376e244273522fc7a7dc41d393063c7c9742c04ce42fe417049fe4fedb9004bca1b083060ad6b4b6976da197e5fa72effa4076bc455e5e232b052a78a517e9d5226085275fae544a7ab08149a20b0ecbfbab5eada231a67942bf00f0a5c294d9068a0697af3ba54c2f5f663d5a6b38989768eff5a38f228c4105b081df514d00f4be52d98fcb764014e152da72960b21c4b26e04168718b632a7f81cbbd39aeff63b892d42d511f2888b55f50f8fec3c29ed9c77c21a736e4fad3e6183faf8f4b1f16c1dec4c800f012774b638cfe2852f88d014079b2086f4fbf08e3a9f8cdd4b64a8cebbd1f437538fbe9c9e6eb6ca734d74d6bcc4790e34fe8360dfb6ef2373270207a147ec5e584c0d1b99bf399cc2690f67b23356245f73209d7d29282ae1c9d781edf7b54ac4f94a02615044336b1ef6fcb39554d8944338ac295c295c79fd59069abb1985f13d92ffc3afb0cba10a348d357dc0aeae6d28f619e7d3292f0a002774fc634b42ea3172a14e155e9b1f86b08ccf67f77e4ab6cc63f61f557bdcc181aff844586fe10b666d6b7d2eb9619eaeaffd9f98f270a0ec551dcd958fee5296db8a95de02ec00493e71bd70cdf1dd5641a85dde99a611a41a4877e8ab811e8ad5bbc4821518d28850228db634b704ccdacc34cf8937102e1981932cc8d11a691001961828bae106af7338d21bec18fc49a134376fd312cc4b09ba82cc7160fd35643c017655c5a05940acc1ecdfc84a4b28111af1c2a95e633ae2800a3198076a6f72cdf9935c2832fcb9b1ae2739c65a9263e529fc19a3c2a13dd02c586f6b4590c3a00c9137165a40a240220eae1feaeecdbe7a9e6f894b2fc6d9341d524473affb226f3a6fd0d04aa8d0dca1429659451c8071684364c2d72828ce687c5bdfbb5556d91a76676bbe4cf41f1f09d0f526e255a4b7b5947f2ccd46b0912100fe27415aa2b820137297d413eab67cdcb9adf5ee5f9110e425ded5d917f4c733850bd24982aaf6bbc96305ada73b82935f0a258b78121aa2b65a90fe374da53e8f3d893da708917ec8a3bdd0cd944262ab7bd8613d02e73ccf39833b82e0b91d7d68161e75f2ba733e1a595b7ceb7a6fa9a1d8b5ea9ab6cc0723280c6202aa86eb34fa1779555ddfd2d0595991b4994e9e77ea21c5b68d077c2157689a7a90e59a28b86595eefb3ce9526c9d519b9c327f3d5904b0d8b5af24ef9b57ac19863303a3a7cc0313624fde56d49565c804f1a88948a3d3b95c835e09a07a58ab4273b1e99bc2f5ffcee0a380badfccea43daad1d6e021dd8dc1d7bb7c5d17505fc0bb187179616cf4ddc98fd40071a58f1971c2a89ecc0f0e44cddbb55c07e0a81953796c34e727ceb1853325e5eede2ac0fcad49b7a854bf9663270b2a0d09f4f2e2180e6b93ce68ffb4ded6838ceeb602dcffeffb4c5a3e182f9346106b3f0e2014299ef601b39b9485c558afc955349a82fe29202dbfe0e281e8983318d8c08a10a26fd197fba9713ae1f99abf27a22c2c1f98814d1e5e56cef4898c93a0d9598a4422bb8edf35e60bf1c48a91e04a2a4e862a6e40c527c5a4ef6dfa8a714179405bea80d7b8cad2f3a775834cff25b674fa40b0b1ae1a7ca53f0942e6a2e70a56ac661b4bfa8e7980ea94fec7ad7013676aa4157a71880cfcc1d61e5e2649f83fc5919f185f7d5814ccb2c54ff7cb30aa6d62d6921874b23d2bf7b8ce7f1493f3806eaeed6e1d9651427e5f5228767cb92a493bc5344fee0fd40b58ceadfd442ce98a623d96ad773669c0658a91deaa12fe58dc451598ba1c76578aa4af1bb579efca011b4ebd1ec214ebb7ffcd9cbe686e1ee81c964de108adca4da7f56abcbe93fb9be84582dc7659a56db0b6ff68da5121158f87ce93b94c6dac556dea60224e2ce6910d2e804be5e029d8f61d84ea5678b3243c942fc868483143b3122bf096c0f4ef2d93eb18d14277511630725b4d01ee7c6db767d9bdbed0a7f1488f29ecd0200c76c066a8bac60137257dbd1883cf59f665342cfaac0c2e0230ca76987172eb928f16e160b575308d0e35f6a2526ae6e8460d3f65b69b28f85b92a5dbb9c089a9a28941b8d8871be9931124b242eb49408591e9d92ae071b5efe1240c13dd69ebc4827a87b3f5a3676ef257b2a039c91a8e43b21824e0feaae804565c639afc17a38da67b7eceaa07c40c30254ec5f623c184058a5541f0ddb215335a0da8d37de95bc5fa7202dd034ec8d68fec4181300b03f694dc4281c0f9b9c3426b04337c894315ee7dc5050837efbf1361e0c787f0e7c056b8a0d441c3149f64d16fb7be6312b527b71dde55ad29b16c28b64451cae2bea9ff16cd09ccf05e9e4fae687a7446121289dddbbfee1a75dba6541f2502a9fd8724a40fe9a513877a11d9d38a2dab6bdd5c4f9c3a767072a98744ba7f2e31d7769ee3527f1b961b5cb1f88f2abad75f14f464639811d170bfaa86befb114e722cf7bfd0430389d6dc95c6188a26597c9681e7fac77395e905fd2d975a2fc80eb91212e0c00f6e7c80641a8b0e23f29538acf213fc3998122ca1917ad1962b6a87defe5d8583358414f5a49e6bbf55fc0ec927305afeec3072fb1e9d63687a383833904b7a43df2bf5b03291f0acecc7ec954389923cc446255482c3dd9f072fa247a7b41b48b2535126dbd82c09fe4bd16202a47774f017245fd1f8083d251c0a2a51458d6162eee77bab3cc80f28df95089008965037b2afee7abca7623ff88019b6577da058099a1111eda0462eedf22225a639566e79f3929d295da1073b6194408fa7478fc0cfc8e83310ff67da982ddf75da0c57ece9887b5bafbf985bd6b92231d4b6d965cbad7c1ec00c5f178b66b744804214b46b833272915cf96b9daa1db8d64d1f09bca97f43b51196cd2f01c45ec7b5395477a924ff60f5982f97a30c16cf039fe448fc72846d639417c31732e4abc9bb031d1187378352b4024d9614610ca268d46b9ca98939888e92413769daa9e12909f455972e06459732f1b721716c038203f84d0c643a967c081e983ffd773d98edf3232dfb5ff375277b8fbbd79e3c20f49b996b14753fea2faea3f095dda0297f0e35444a8637575c84d691f2ae923d4f42f801a82ed1bb74daa1bc6208cbbd4c34fbd69c65d9894237bb59677d74a7bdba9bb0d0d762fb221b60a53e772d7164eee54627da5c49352d36c3da9560e39a407e5f9c38e09061fc2c8cb033d11b13c20f189d2ba46dd5343f210576b3ab68c3dfc2b6de8393377fca722adbc00276aa6573aef6d80fce849a493c964dcea12008b735713c96024271bcd2e97fc5632d7c50e1b984d339a6f57ed9495ff8bddaa84150d596c3bd18c32f8dd8e87e216ec3faf442aceb3345ed9021114c875075269dfff3217d9bfdb6fe7c44ac344a5f73edda2342f04798ff833426bfb00caea8937fff360263d628387c302b0507bcd0ef39799d0c205350796ec72b8bd350a3573ece6852ce994cfbbf552bdad78f960d585f6a8a55932c6360f4668d59d3ea50fba19e57466163cc76770ed85f20ddd713b88e2509fd7b483aea6a65b29963803d375fd38f8fb711a4a0edf964abd7795b86611a6d2142e965a64639de8f35329a2b2f71c95b8c4652f60524c88c097cec77c814eed8fed3d441cff3ec9735a19a979baf36eeba0f853524ad3bf33622c7eb4d6780eb631e22c2ba4168b191dee661c0c4185dda94fd0550fb4f4a44717979f9c88b6907df4cfb4be4c47a6fa2c7bfc8e4261a9cff88bd7850a2866407fe833137285c673151f91ab8246df6434f9933e2506fff01c4e6e2694d36276d17f647a51d1f97b0794ba5caf23020f313701c781177b42e8073a5939e7bf761ccc25367e5570fd79cd62c53863da43c0eee5b11d127cfde07e58c501844e8e2c9030ccaa43614132b69153c479aafbae97773bea1b994a0cee3d60a96b54e825d9e94d8d68c0d2682c0c6b7c0a5cbbf7660a4a147f9fb57d5a2d42fb6b27f618b10e944988d3281f004745d15a1a401de2949f73ec7df2d67c49e77374f5bb9edcc882a5ed15f959b9a8ebc53065afdf5ab1dcbff6aba05b72a68b122cfc212946b03a2f2d9034d637513963553384c36848094fcb0048e738583c6dc0604fe7115203338f627c1692cdfa25e157659e225c8b658874ff3cbbcace4ee7a7ba4c52d33d9787c4e78d65cdc39686cdc0ed533a4797910b154e7d1cd79aef4c5d2832a95712924674a0c75dbae7d3d385485e28019567991a2b669878e1882534724dfd87eb48f37b08abe1e06bbe3b65ea4d6cc6b866898536c9725d5286c0ca161d018454d1ea43e60ddbd818dd11e49e72e33dae2f6d248b1f821bb63d03967bab30fe2546e78e6ed3999ac2f80c937e48f948cbfc8ddbee37c94cadd4bc8636f562af5649b9a42fd566c4517eaf8f1057662e41695cbc76d51c2db0c3c2f6dacc6fde3891ed5e47a555cc90fa785c3b002b45b3fee6fbe6e28de260ae1a218a29d25c0bfb69c1aac3a5be96b77f1770e2cda44d7b923d3cc14e451d66b793d2574e2d6045303673b4da7e907e8eaeffc8dacefe6a31ae59202d9b97f58554ed026250f460ebfdf921a09354c1c19ba3a4ee275393e51a49fd24a7f9234a61d6c63afb8b6d9cebd043a484347ea24599e24522cd427d1e8b6f9ca9aadc8d07d364f7b417ce24602ea3048ccc695ed2ba3bd50082552bdc151943ab70c3c838bfdb34af4e0dceea9b5814c4d21fd3d3c599f7eb3ded20159b256dc4a18a5ab70453bcfe135c46653272fab7aa2de26e763c40b6672100c55c4bb78081e8e83129d5125e400b9e3eea28dc3c4ac4d96a5911b58e56e8880a507dab762d5bf0a433da703328ca07d807a623af5880ddfc1ff52d7a9827edce27a099d88137ad42b623e050b7aa2528c87a563057f41680a23c790432d85961fd92177296e3e60affe24e5deda7e1a3d02bcbb71f66992c2e250ef9fbbb16d277b91bbc1846c710c6520d007ff7948510a19330d05854882c9716b0b40825307312e8694eadb73ead8b18e0df62103ad1839a6dd21fdfa9ce79ffba0d05ebc1d6a669591aa479c0a11f0a95213fb507ed7dffbd3cdbd2980add44e7e6b12ab06b3edbdd3dbb98e231988bafbc5f435c6e97c59ba9f50d8b723afb184ec8b1b8c04b7c0a8453b4dcf5078991fbe4ab063728583992ae9e28e02bf647220a5095a69c7e19b99c6855391d31dc3e97acbc58b5deed10cd57bc9555087e07296f790d438eb8dd6d669c0cc58c2ef60ad9e6f14e7616042c277c8123ffb44d4acd7800111bccb00dc547dc5b95d3bdeaf1b1d4dec03868e71e19cd75d72ed8a135dbafed4412cdf7399d086366bc3fad88a1fe5b5f589f32c1435e24b07aa0e49f8de0ed3b07a4164295a651cd518e7716a89f95ccc7b145c9d75f6d5e424aa8012a199fce7fb8f77738505e46a087a667b3b3b93b0066e8506b95e7bd0490a645613b404ba9122d90233e6887a40f160789c7b12ec88770027bc17b39c2e560dc11671fb93a081e24b2e788dac25ba6dd1e776129a7c78af8921d3ba213182c0343655215ffa57ee22610f0dc5d477024ef51d76336c58ecdb8069038e0c2a66f663f551038a8bab929138715269ccac192d6f13eb7f1eb02660ad7e1b644df697ec64cecfe84d0d33becaf355c41e46eaf412884421567f788ab5f53320b4c40cdb4ee81492e111c33e50f6db3d8b21dc100db412c6c5488dacf1dbc4b881efaa69be6a58f2a01131ed89633c625bd516101c41981bacb3bec7290591c32c25b7ba80770c3ac8d961c9938dbae1394fb287c254306ebcf3ba51eaf4d310dba28e38d387723fcd4479221222521f03f305a0990419b7d364511e7b6a95fdebd02e1e43e09e7100614519b23ed389c179e1b5ff8128e1868b8ff9b370208f2c3f7b276cf023f4b99d8ba382f0118420cc68b8042ee2b43198345f8600feb5c7ec2ebfe3ef0e47d1f87531d3848e0717d09174d8c5ebd47a61ba8ad1cf3779686aa2fd1ad883e7e0f321656ab7045ad1ac9301e8040ae71c407b789c278246ee4ec85598c2bc8c1c8baad0abb87cba28cb79eb007a26c272301f70dfff0cc1cd5b95e77497168b51d7e98e272454a628875a9a25e94a82a8a1eed08a4f565436356496a931e4aced3028a86ffc2dbc4a691b76198e9cf3607c0579e7668d464028733ee7f32715c201751393eb1fd26f68bf5f1b69cc63714daa78f0f98dc1de2131c65f0e86e69bdc977cc7694ce134e8ded0e05e54b131e03ff7927be2b65ce7fee460284a6690da075d5d289cd554a7b6ac12375cd9b114138262ff06429e3f321e6ee6423d5e6bb4a78ba298121da559c0c801324690a7cdc6ca2a552cd67c15340ac43a455ffcc5f6303dbe2e70c48df8d5cc6d84138400b2ba54c270ae655a8da29f8d333c3e00f0c8244c1529256c8555a283b64285b0734a6b79e23b40ad3cca04ffbef7721c59467e18beb01a751ff5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
