<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7076c1fe5a8376d4f0f12ecf18bf6eb23358e023ee2d226c90e6f32592166fba80f8f83473f639c61255a260b2c8350d3689901e4e70b12859835b4f9993311acb28bd3d2cca447498c994ece6270ba18cb0396e407658f617f1ad6f5f55cfce319fedc1a2ed67ae9288f2fa3ee831644386c2fa49d7a12970790c799bc0a314e07a29b86f67f45f7c986d203abe76f907e2f5e377bb0a1084035f47f66434d7c553d07af6e10e3aa32fb54ecb1dfe834d302ce00bc99653f87518095d1555f40479a9b755d5af71312ecf6539021b3aad2f82978333c996425a45c53220f392d94b4016a05c9accd8c79fb5380550e6cf147496e8ab59a5c2df64718809e6dbb67ed1e5adb57d9f36051443796fe87dfba3ab336b0f35cc96d70e308232d54cec1ad0dec5eb887cec365eb325ceab662e79efed7ac76e660ed61bcc407d5a7c8e0efe0da99fcabbf7fcc0533bd9c1db4520ecb97159107162e5083d7a85eff854d1db5e1cc75117a264bb01273fbab44584ffe531f1dfbd03a5adcc7489c72dea3d4b62cb16aeb0949deb47c3a2881b89efc86a249091db37a97026061a2bfa31936a3a0ed13c6ca95ae97e4a20c19e1d9d513f78e44b5607f2fc818b780399377ea28251ee4668ae55ef05391412cf41f33dfda87de7d1e28b56e290d9878edecc7fba7a89a31c43d375244301e7184e81202d245172445739400e7a96d99e03f904ca94a0374f76204e6a22a26e0a832fb82bd0888d8226bc471da3903f45509a2f1f17ccab405bc6d838c34d474a830091053f3c393739da571116395974e34fec2e30aea66da503361a09e34458ddf54bc29ad54f0758d3c8f087e0cae5864ad6440174d626db127777d862d1afd4e6b1544dd6abd231e887a705b607a18a706e63551d9da3bbda9e26b00a87c88b3597c81b19bc8a4919535f33d7a1179e25660a8733a7437c1383bff580016f3c53a5304393e06a9484e8a35c143a23d27df720049b8536a49be8b29560f8fc9393260c91bb058b3b96cdb4e9abee52d5c75192ca3c9578ce9b5361d5d021c7836361c0e20df26661bafd4f230535dced05e81c2a6778e939455dd758094ff4978745ea65f31bbc8fa9370c2f71f121caeb7ba8c4ec504f5ad42bc85c74b2a5a5a8d632d99562060a4a2fa486b2bf8a41b4ac9f10d43aa400cca9e5e5f0a6b4254e9b66ca97906651b5221a8b9079c0629c0abebde0ce54b5fdc2e4c450833b6656d4a6adbb89b653e8dd557257c9272b9f5e8c8f33e36eb980e4cbb2a8454dad0450ec5b805fcc7f854f853e3052544e6dd7d534540f4ecb815e72a6e7ea0d610110d70b8db93706fbe74b81781b13db0c2eb4464039b2c325dab489f3f3d16648ab560d7dd173a1dbc3175258a95f57049cc993f18b511d7184480c7b865b6c6e48d180fec62849d197a2e8b28b4bb98cb710b008bbfb6dcba43e71f757ed14c5f74cfc8b208addcb7bbb60ee3ed855430dfe36b4fabb613fcef0021b453e437e7cfcc4999fa31575c3ba5cb51b7f1bad671daf485557609826d60900077220e0a1fb4af50379782ae183405edc3eb53a0a1a8007df3d7febe0f6e0d59236d5e19329afa9e9a91ccb26dbe36624d7c1c99f7cbca1b420fa21b1e403c42b4e4a1fe75de271439ec6d8d9498d6db05e8fd6527c0842f0c2a0363822b8f21c153b40c9d99e9526d24ae2b73553db6e6b20e9176685b6aa92a1db3ccdf22593b5aaa6c7d55f370b3fea2817548b486870e59b5573fdf4400fd986d7a615cbf6b66e89430751053e6595a50899e0a8ca8c61fbed6802515e27bd55d2184dfb2dbdb9cc9026e101753bc3d56ff0c9113d4046a249ab8766759ce6989e58c41a278d239f7d8f26d87b7c3a6b4d776c37ca47bc3bf4485cb247693f6ca16e905b56a331c01ac67b73e941b9a3f0e594a296f03d13a1e040fdb13d72788873b25fc6f4e6cd9262b48f263c665d3b4e7dff6b88ae09bd56b563ae0b034804a37c85ca98749abd37f52a9cde5175d0cc44886c6a6dfb245d232e7afb661663675ed79d27eb0f49ac525e218ff04a51d3cec570a5d4f7f76c95b61cf2d31099d823805670cab35c298554872323e8049400842708d869b98cb82094a7b6b52b3602b1c70765f14dac34222e5e3256fe99f545b375d04726c37b56abe2786da845fd72178ca2cc407f1518c6c5bebb6b85f078af61512afbb19944264d2ab1d8a3bd204b0662adff6a29a801c666fe1aa0a5a0ba2a5a9a5d8671ed9505e3e2ffe2bbc22228bb773021e0f6704b8e4d6e88ac4f9204ad986e668fdcee1b2a44e5c6e175b58c3e0fb7086e53d057b0e6e0a1b907b92ff40c96e41131676483371be1e85c7a2f87e4bd046c6d1bd268575020d8f916d65ee73728e178497e6859367b63917ce9753d7336d21638dd1986ecfddf096672c99fec94cf841e56dee6b3f5032a75b128d7821992e0fbd1793af86d7375bc7054161dc8f8c1f106804332e5917be04e61f830e3adf25518765c479560abc19c6221f047f9552ea9e37c41e3d6ce91f628f83fab802aecf3a0fae2264eb0a31b17bb807be287f3ce3aad6e7d826bc64c571d6ce41cce46db8fba130060528490a18db4ea13d26e37baea7dbd9514fa3e8e8c562d61b2f16ae74e1564143560b3eedec55895b20d604968540e11b059f237ecdf994f2230c2a27f9ee596ee9eab54ddc85d34a1e10ebe2678c837c2a464216b570d30c71f8477b2c839d36a511e36481b04e813840393e5dda539c65a9975df3e3d4d7b4af19f75ca52ff3a53a31f7798814b580d9319762a2c29674ffc0ad10b790a8153c9a181b50f2a8adf0149170e51e39c4371f1a05a3f13509599065ad80f93cd1dd78b06eaf0e4eecd1cd48d17aa6e1dd1db9d14e109163df79c88c246a67267d89de3d483441e1510704ca5ad6ebcc9a08dfe37f95e6597e0499181f665c890fa7ccf4e66e4040ca206ddf12e93cca0a9947efd39ef6e843dc6207238bb8f456777d94e4839080943532476c1656c3abef02bd3603862d076743a322ee3a5d3ded9399f90d4f0b6d56b4b9ff6745b7bfc1a3d52ae3dd3447eb038f424474446ce446c229eaa6081aaa866502e2a196c1aa741e4c5d3b6b66fcb32edb9d7dd92006ffb6e667d7df02ab5aadee76c49c6d7c60c7448d8c484893661d0cc1c0d2ad8729a7dfae7261d109658d78166000ec50d37367a5c4270f5c4aa11eecbe67bebee747c6616d2e84f2b8f710f41fbf5461fc2733fd766415a9b002e6797fdd7b5152575b8d5b91800a0e902a8d87ad0e2bd1bb5d7bef1e539b0fbe6ab2220257913c44b35f4b149371072f6a91e4d29f0be5db73931973a5a5fb38373e029f1c9cdc8ead9101b8bfdddafa3837a983c11d8077ee220fb3cdd2aad65e0cae9254bd1b298820e7a145fbb73d340c940d4402feaf4ae4a1c72162821a19385bd98ecdb9634adf4b7c07b5287c7159220152a541ab24cafe03906158fffa0a082a25922ca82c1c4cbf02b42c1b95b6812558417fa94c115d9bc7280a5b2d76142d8863db780034342ecadf46cf8c1b45a3f85fa22a813b2105a5c486bd61ff69fc547733219f0b21410bd61262690720dd7f31c744b33dd785197821fb22a700d8c674bd5df9f16f922801cee2a33f541c98cc58e23b1522b2b727fefcb82adea00220c4383dae267efff011641f78ae3b1b4202f5e5f8a894bbdc138412168fbc54e9dda600c8668187927936bb150bf18e221933f69e5fcb7e3ad4b2b48d29f7c6223a6d6a3bed93ba2978b6a463e58867cc8f9780a1d9a273be760aa7ec1b8bfebfb6b7c31ef97cc8cc33f7500c46a9bb191c7998bad3ddc7f9369a346f005282922078bf218b22520d1c24a361769e687c4cb4e6fc80b0edae01964fb949648572a52d359ab8b92052f84c657e0f077a1efab0ca54ad7b8235945820eaf16c18098b8fc7b6c300b3873e4de12db9130dafb41cd1cf76df3e5fa4c0903c23bce40ffc3c116835aeec946a619f314bbe8098097bfa86c66c347db745edab5581c88510e9fc6a895fa9e04af2282b4973609c070ca7e0dfe132d8e9221ab793e790e88820d9d09fe057f46cfa73f02edc2956607af9d441bdd79a1cda01fd87d1d249b820ae1a8f2c1f9cc8734776243e5c8e2593a25ef27432eac87b2871fbe071a77fffe3ab9ddee219db2279ba2ca4a9e475d9333402d26204d638c15456782256dc89ea1c9d2fe4288dab04ab2461a91a22a5f2294d2042f62d29b0359784add07f7430b074b0bc39c9174d1210978c2bbb23ff55a8897d821b2aa409c66493787274806ee3224189325cc00614314823fe473e28ed96707639a1082f011adc8d4ccae02ba1491d8fccac8774f43387a3d23d841394a8737e88b1e0c8027f89ec8e40e5b9821bc456edaf99007f131116dafd651885544823e6c65c479c9a14022d632333fa3a603f0c6ec9eff538aa048819ac8be87aec608c200dd350f5bcc8671bf374c7475912f0ce0185610352d32a663ca8cfb34f61581d31d54ecb20c7c4f984e99f921446cb71d855216c9b53e9e88a77b643438d17267e4a624d1aa7cdc055a8e10eb1b7385b2c00872a4f5dcc2aa5b7063611450807dc4027c2cf55683ec77ea06b9248c72a151c8ea2c172d504ac6cc11ba93047afcb4aa357e51ad6cbade5fcaecb12811177cfbdba839b65c615392c92eb3da506b5c2d25adb320accc3ba3a3bca50b4aa29cef13997bcea85575774159ad975f62584530ae542972c13ac924ae4acef580f79a4d96bac80b815d4e38e1a5d7179b884a4a2a8390a786bf78ee7379d87476f81f992f69bf0cd6e996ac2c7b43966d5f089d1001da4b95ad238b7b2183852f4c9464f92dba5d828a2604e3133b2a016951fd7113e2bc34d6cb0607e5ea78dd4f7a8f032aeb0ea6ada365122cd5b2fbf5191fa01b306fe866669eba8f04413cc104fb6ff6468cf74525199d8fdb6cce00bc75f26d069513efed0b577f18f9e11434a97fbe541b16184eb8b10f09f9f6c42d7973af1dedb94b6583b42bcb46bc1d9d2b86aa7924239462b0fb8fbdae6a6e00d09e304ce83a576fe6243d1249f5fbc5f22740453922b5d8d27048986d5d51696af69ad1ba86e8067626a7660348132ac08102b30c2a8c1b2500d775486aecd21a2228d584043726596f2b8fcb5811d787e54ba1661e10b9e8f449575dc79f954a744f1eafec3ce9dc94d45e67a46d4a849cee6936910d673cadd26a919fd0bfb5c74d22896a77a54ba7f28d328d59201929896cd02763efaf73817b50b53985931131e1e2aa5dd0e940d3ae630e620ebea234aa3b808c5626d49a195d0a6fcc232e496c48dd3f9c214cd7829c964af24a5e562119f1cddedbafd31f759f8040ff275b034a272a42fce3e94dfff8f7dc10d2d7b7533b416bfa4d0a64535886d3d97b74e9d5209498b86d1f171b6310f2e227d60fa342c30330175365b95f6e51c887586ecc35a71ac60a65a887c73d1eb7bfa1db7b19609adc94e2774723fbc5e332cb5bd22822d6b4eeea33f8a8fb8054f7da5f6f9deabf6f210183fed9c581334bf51ee74ecc613f91a84f808a26dce8eb90d711f549b618c1416342699aab00c67ff3e51487cfe0ab82c12b4abc14aa07435683804a2cca7725653c56a2c55ee7308650db214e59e4cd94e06e8bf4d6a8d93a6abea3cd7fafa41e032aeb6ff4bec8a88fd5c9117a2848c1847838efd33c1ee51254e10a1edf9eae47c6047050c5f7469217e608087d83892a998767dc08be585a6bfe33bb702ea4e7534d455d44ef452090e0382d9dd195e36c49040c9cbdfa71f2d42e02ea38e43a5385d871b218fa7764a4e1b7c6ee188b0bb017aa50059a811a856980d3e8def46756c5aadd654ce3f4bd29815e0f2c7693d945df6dfd4d8450d65514915982b4992f39d09305f3ae93d4a302b2c688ac4321c72671ab1f50575fb906b1c35960ff9635d34934fdb20b4c71114fe738a50aeb4b97287d8953dfec4bc63957b76b65cf43b53691515c7108cbeef000baf3b78e1a5441299a343ba82c20d59f49c4a8bdabb250f26aff3a1a0ab8ce9e6af0288f764e420ffcabf835db250fcd77fd145c7a7c7f4e88ffd093e32a7a510bc71647ebb9c4dcd9833d849d64caf749afd39852ea48d229bcdb694fc08492cfae49c8a23c1f301046656d8e236a7b485f98b596157a0e0a57aaae6a8d7d2bbd59b635cfd55829078c3c3f61fda4f0bcd5706fc8729813bd94cf1e1108c3e312b58f34026fec22a528137ea90c041e2fe4e30c07db9312bd3cc046ed9603f139642db4f6a52b9c9e1248080ac2e8d16d3a0f35469153b95ce8b3764645ba5558017157422d43c0817b85a0afed5c72c060bbe6c9904e142fa75e0bee3b72d4e56fa709e554fa4927c440575d95a50c1f59c9f760bbbde094838bdb7e190e055c51c7d85dc49adbafe005ff8f2092be62378c97754148c39ff682b9af9b287d891c8ea55be661fc965002ce2cbc4cdbedaf1c5bcd3dd63985ca9ef7214e6028cb01d532d929412efbc5d41972af1aa63e31f59221945f48229c9c16697789db03ffafb3742faa6484d5aafd78b96d908c02bf90a1b16da77ddf3364f753fc43ddd7082c47d3a0981ade826f55d7d884b7396908d14e8d468a14cb894631d5b5c89f266d9852f41bb5a6d2640141b27caed5c66667904d1a9d180fff48f8b9b7443a934ae694b0e8cb44802569d63e6ea39ad294d7a7e7b19c83854103072deaa43772ad80ecf90a764d1e39a70cababefdaa372c4d45c5449440d3393b9fabece222cf404f6990514c2de1a97224ef4555efdda3fc96fd9715a6f119b978c7a56fabc88aaf1d201d00dde7bb53b27a6bea4b90c30cfda26259a6a2674763e0742e20532c559518d673c0be7969977913702ddadc835dbc45a9b44e8f951ae378b1bee5e0de7373f8f86e5f49f906d6a67ccc3bc8c6d782622bb645cbebde004e8914ec970f60997495e4527b70fe120f4d23ac5b87e2b56cc741998ae444db19bc75d042cc063f3d666cbf066d20f08332adcb6b16a8f78ffb69ed73be43362bdf65df5784fd61bf2d3f8607889d4c95ac4364fce48f8e552ae343d00b9dfe865df4a75b5f3e08b2fe09263befd5089af796e0decaba03e272c280940537402c30e1387c0a76330183238e2365ae1d6d1a1ee04ed5c3e6e5eef561ff79cd668a1bcd7e86c9fd229324188518e91309a4e84469f8e64dd777649c8873d07912131ba8ad6ba0b6b9eb6cfdce4b7646d6ff4e47513abbd8bc4b58e1799df1a7dda3e435c7804c0f067c6497a8a6a4b1f72c0bbf36f91111b44ccdb849aaef00cfb5c70b86c1f6cfe0278b809670766878e60f32d09161aa4e6b12d07f123b06c13eaf0bf14ac5cbc4784d1f8f90d3a83cba804012779db2ca7ce1bb6fe5cd60d7df03ee93a667c4986aa20e5513887919ed356c7ac4fa007f8e39d921aabb2a22b593a1ca2a0ec94b01fd223e6c4e860cb3fafb93bfce376cb9a0719df32b53a38ded9778b1aa81558a83dc3d28313f24aa7db40a0b7111ebe8bf63303c3effadfb9aae6e059a21ed6e4124f601b920f5e418a4146610b4ab153458482bb0c46afedb37a002bd9f4220811ee2aab8daa02653cc22322f82e5f04d8610d216a9531db2a2c024e92382bc2ba0253572d394273f4d4b16cbb05da68b03fc73967c5496e5e2d640b6b20a0e64e710e4ab3e9eefb2d452f94c8fc9f1c017d2decbefc5344c2f00b47b3f735f2ad174e7f5c829f66288f945079b7f0de149243e688fb0e8b8560cb727b39b105a2c6ce35186d4ca01386337ef68cac9b6960f399af333f954ebfaf33e5083fe2fd70bf126a7a0a2b4a7dc967c4af88b1ec372b2901de53d9d5675405a22581fbd601481e2126f74fc9d7d9a55bcffb1f814d32ba535ff9a76ad6dab2f343a12ca9cf339362fc5c8427025fa1d0127eed2224d16a79c72ed3d025fa8c05f0b7d324caa2d389983302e408177fde6e6102353984f741dc1c477402cd090c3d5ca7b698744565128a84fc1668ec20461ec7dadfdcfb1cd569ba530af1f945ed1012c0015327242b36dc965101cb971f0cfc47c6664084c231494fe446a3424138a265101d90595556104027954870159980d2f1ac629fa05f7b0f5cf2efb087e8b7a4e8514c36906353368377c08df421520b3d063c5d67389ba7d9ce2f8ef0a04fbc8218d6062af2a2f222e95bb49735829386673d3258229a34717dd05b0a36f9f71b2f5d84c08b752606da51631c6587f944a1bc16add0a6b9df5809b5d348645a9bd7399f0fec9c29f3227c5185a8bbbc58de7c6273bbdd56eb40a25f8a5e0da943d6da31c9697fbba244920774848be8e7ff67463e01c44454934a97940ff8a1d5448c00cdd858c6e0599cd36b8b33ad2c9bf30f87d131ce6917adc7478a43598108416225a8bb140d9153e0aac613d3eece5f397a94eaedb20d1ea9630f2b96d82c1fb13176f97f08504715e1036a03520b8bb9a48f6587e7e3b6220b7393efd6652c9a024f1cc2c85f857b7f86de36fee91e02d6af965f17c06f18331d332682562ad30b126d0415468adf2afdee4532295e33d4760d5413b6074d2d085120591400fb4cf48ed2da4f649f61db02fea0133ef539885cc880222c3986830f4a65204c63bcd8cc95f48326ecc812c0a056078e938a9805224d46a5e2feaa70f381798d1c25ba1ade2da3f41cdc80ee036d4ef9e309b7e470d740e4e60e688bc171ce2b3d57dce809c126fa53df630005b5cbe2ad2976f7a27c35982fffcb8211965957e6dc8a5ad34cca669d8b5178bbbc149c17cc7ae44bb513a58689e089e9818dc534a98316cded099e90655749eae277f8d63e885ba007d15607cc67868e83d49d722b511c4be54903a8e0cc9cbfbee4033cf5cc4ead4b6bedaab3827feb538abcc496098b135e0912c72a015939317741e6763afdd3b69491df99a11519f392f43caacc5a423e6ee59a3c25746e5c25d8abe635bb035310c5f84b367e7dbd4a41cbb922a0eb4d91506ee736376687868b6a2e6d71224e3ab2cc34328d4020f979e2a4897775e1840bc26739befff4a0cc8c9cdc9ca7853b45cff6c77b669838e926da166d1ba957d0bf0040e0ab35e439cec0484ffad253dad9e4568374a9454e2acc97fce1436008b4de0b483c7b7990da2528afa8fa1e99001ce4362c48ddc3a0c62072b311ea890bd64c659450c98ca8ec863f7b128cc93f149c38c16d42bcac5c9f1a9f7c89c7d28ec8d4f2c95a020102be87056464453dcb940543421660c11faf2b605564653035c098a29cf9beade689fac5025e4c000e9a1fcc71fdfbb4f9d97684c3f928680fe07492fa03eee2e9209d78d444b6d9d445fa78021f9188ff535539c88cb0f2f2705258179d45c89b1a39501d14025fc2d7acd7a0fae2ddc3a9bba84b2e733d56a3ad1c3f7450ef5f16d0e787718bdb326cd4cd6c969adf421de186f3d9533229980fd0838ba9af66a78b2c8bd8314eee538e0164a4e821f8d77bb4b8b725751f0731f9ce7060bd792ca9823ebc33df0b32d023e9d6f182c224f7f43e80ee69d02cae9d68ec143576faf98ee6470fa466f8291d1a7480147884d1f9c3354da470068d5083cf86cf5f37a041b95b6c6ca420a0d511b3a53627d72fecf3122366d7602edad9bd947e428cfa158ba4ad74f3402f56977a22ca50524d92db9edbb7ce9022eee5d7290e051add6a1110f74d7f4dd74dfabcfc8bc61f3bbc3d738f8c753eae63ebc4bbdaf4a24c0b11f3b748367ae0696b412d0ec2f941005fe6d279d15155e8e579ca7f17b6974a317af658104e341764cfe04024d61ce2613d50f662ecd2670dfd2b3e5647d28a42837acb388272220bbb0d29883afaf257559e18b2633ca678d33f0b024b1790afa8f17016e9097ac27487c66da4a50c49c0f540ae3532e4cfa6862cffe036011c51bed920926067f2680d60a65db1ce91912af9c992a6069c47da87635e659c7df2d4bb72373aba75e269d267230d36ce8f74eb0ed64d578113bfe4b45e3df5e6180b269a424e58b5614371984b2e36e755e21b8b1569e82731c0d02b1eec6ce39b7ef9e40a639d3646c9777078f469562e95bb3b3c38768cb0fdb2041f5b6f601b2fda3f8e8636649da39c2e670329c3e8799bb2a9505cbb47c4a7b513118471d496f47e9707ca3ccd07ba58e78fcc525adbcbf210726b9c6b090cb87c26a0c438e0a5ee29a1f1a37855c3ba2eb9f5efff8a649f0e6a88a2d898ae74646242aeee1dbd8200ea62fbcc14236303134e46b49bf63f5d4899a14eec171998469d01c8c157eb903653b571c5bf65aed8bda3b8dd868436770ba9353b59f483b3eb841c8ed837e07a83d1ec9707d4443adb76d1cfb89b86ca48e200067ae3460b62066a7bf3787124af47549afc89cfcf3defe06d70ec2e635f8919cd83b3740c1aa305f58fe396ac650a37a09f95c9dc1107fbbf81916ab793476661bb5e755f6da6b73fcc37ffafa6e18c26da910599c7be470408ee6b40e1864b1a4484c316950d84ad9342df3eed578f70041d893f1422ed395ad3dd4ae01e81d18ab98de7a97b291d603862d3b28e2036d28ab4e771685e5e5bd3eb94cb88d4aeea2d49e3e04e778da9d08a9351d4de5c86cd930658163ac2a9a262c1431ad901c93a33c82a630eb607d70c757bb1fc6a2d692eb8f5e8bd4c5e564220fd6c9b2104310425d7396834868e97c12ad32b35e914977d7584c5ea9379349e13a3cdd5fc138e20231e6533facd2ba52dd1a6fadcb2ec57ee2a80a2d4bee6c1a7101fc8e7b08c48b77efdfc9b4f76dc8867f37e98bfc53d585b7f3a5ff5adf1dd4152077d255de6d852f287ae994eab5a5b1802995998c8bb926b21b16e8622f2f26af7ede7e67a733421019467fbc1d8c6d49b1a5461290d16d9fd3ecd1a13c40c48cfddf084da6ff9a7f664aecaf8d876c7e00d2c9772ef8bcb7b707baecc7d5b716b697804a2802d565637bb6746e96238432a9ee596a0785edfc257aadecab1e57b3b285dac2acb91c28fcf3661a2b46c2aca8a6c670ed57b050c34e93d6e2051f7a5859cddc6d946e19cf373ecb990262fb8e31689b51a555400f2dd5186ae4ae109fbce19b45943aac8d331e8b28da1e83ff1b2e2c9596e314a99ac498eaaf0bd1348a0a39dde8b065668d58a5c800e4ceff727c46ea495109b55d61e57dd8424da4e4a43f0afed7706a0a82e1f54909f135ea4221c3e2b9c3fa68cb7fc9b84fa092953ea34aab1a544bc7fc85a655360d009b260576a2211891e21953f9f0fd01fe5e6718f351b1e1f64743b40e9c9138b937845c4c428ccf42cd65a387d1dcac103999f333277c1ab018dc09e7c68303f1ba4fdf9b360c07e6ca3d438bcd91fba49d86a605340ee536c1a348a3d2e18479c3b9a4caec24c6d1bc40ccb2e097d199f92ef1954b8221d2469b6dac7c71b1abe9a4a278653ae88be2a18cd9fb333b9f89eeb5bf3cc432a2a579c1c7eb2862ac7e1c252f101a23272a8c0b94c73c77cf1dc653dec3aeca7b0de2d8623f0b0f3667f790ab05d9a69e3b4dafa44f82b8e52e24c5b7662ec219e6878dc40a11b5e6475b1dcb3af068efe3376131c9dddf872f0c74bccb4e9e18dfec4cb1f631f2e49b9871b5fa6119a124a27c04d475aba9d9838a4ffbb921fa1f48525156a250479f01d3321148d5b20b6de1879f7060e0761c635789ee408ee2d0b11e0f1e33c585c80dac0f264ee5758a22631350e9a4a72b15d919578429a833954fbe88f7f6fca0f24667b0037f05611140fe4d9ed605a2b2d10d0a018f606bd453e41a72c50ac6bba4003b5a07aba0fcf85a65bc18657888b59242142b23968b344bd5dfcb72bcabb80a81b899c0c1dcccbd3d1ecd5487addab7feca0c45ecc9a129815b82c1ff6e45e28d9e0fcc22b8d87d29d31612397d7fc5d7aeb3cb476eb69f6e94f71ec2a8fe3f0b70d0f7b10f36d83cc07cc9ea276867c7f1e8d23bc863f2b44f1b5daa714f3c515f0f34db12f845b240fa5bb9803532cd77e10fdbf6bbb7d0f07f844f8619afb1c4e049c65d12e352da3ddefc79de91adc6f5487ac784ee20da305948d1f07f11fc1c935fa40a7df41e5385decc96c0e2133ffeedd6e6c90e74b0710ee3a18d52322792d345fd34879d2f5ba3b2d00dcc1a6ef06353ada3b960d3741deb54106f0485fa358efb30498a4be9ded1e15ba0e487a7c5062df4bedc19955f4d008736d1f0ef9b791cfaec932397ed6469649d1b89c3935b00235bc00b5924b15d6ef40a4451f5c3ed43d87e9534b84c2cba76c062b39c2af8d057b77ba9e7e4443cac5929247b1333c2dc24beea1257b3dac3bd570a1fa5ff8ece7e4f5ce4d03932a4747e11702c337891e292597bfb486d24bf16e0be1b402a5ac3f6b60bc962abec6c215ed95c10174da8977b75cdd8f773296cd274673fb4f6d4f46df17060ba3cfccc0186b2cac50011d7a10c925be9396962607bdc322ca3533cc0a9207a187aa361ad6c55d944384dbd955cc735daa38df62cfe6fc9779aee40b53623205303c3252374ceb8ddbf0181db9957a8f512211adc87ad1cf667458207cdc2b4f214fbe74ee14a6f3873dc8e4968e2884a3c455111a35cc238c33e0c0e9c52d4379a9affb2f9bfb2000199d206366c863e9d141dfa6366059599f572099b51c4640b8ab5a6bf16d0363d6eeb4204fe83442389131530babffd91fcbfc6d5d104747860433d0f056191ab2d4343a401b69a6bbd8413e94d294c5ab4443a910462550af90773977373e01c625777e76ea7741c128514fafa4e9c835db89440812d6f91975e002b9104aa7547e0c5319cada8758efb1a8b29e87243cb17519c71589f311194f78b287afd74d38c1aa295a234d9268bb0a4e5aa2de6388d92232dea239c0a73ad9387a5c804fc14f4b511ec1254774021fc171f14667d85041dfaf9c762b9037c1afd8ba4b925227752e0c8265a2781eb895c1c7445059a7b4d48c97001ac7d44bb6167398b32aa262c506fc70447acd79d336fcd1255c1e3563b219b9e01972196874639d8327740c990c921c764b3ec46d2c547fa6126b66ab98294647bbe68e4c3eb0b3d226837ae4b3eb519b2c93eec7e12053355994766701fc459300dc71ef39764df3ed2bdd6868a6065bdca982307a40140fec9631686cee195ed2bc73442c4d81cb0170f140f116b273679fd1170d3272a824e94b54fb4f0d23db7a984f0d857b82f021765ecebaf1528f12439f4be909eef80f593383c2b5e2729ce5453eba1d98cdd264d1f1cedcc4b59864818c6f047f30f4e6b494b96646c9edce021f445a23e2f626497c5b5a4b97dbdd0ff52556cdd74779dc257ca12e88a2b8e2bf73fbc7d663700c31107c2e580f023d4759965c04eaeb8bb153137f5252713c8d18bb76ffb63948a90dc786e4ccd2dc8fda666dd634b89d0efcc1ca8d8149b5fd1afe41b96a2cf9df5e03d7cbf7884e49e594f5d4e4ea681ab0dc11142e2a6a1fb0a4721abd788cea7a552751c12c6963d588262a4b90223fa640f1dd9c243e6c96432e785c046241f4947fc2ceaed93ce5cba43faf4c3e0c2efb72cd213424ef06f8a239e60fa0b4384f025ab410ce21bd9e0681bde43c00c43a97279e35c15342a5029f2cd38df60e256f34068597d40a59999a8d38e71bc9a215e211d606192a0700855eec93e6dbe6d7fa47af58de2f91316e52031939aba1dd9e5ec5590f9f33587955fd737edb757cdf021628fb3659c3aa9e139d0a189b527d2612ef35d6ab00593264601cbcd5e3f6ae983d2c8c4859aade79c3c164bc3d616dd9e1a36f790899fde047f9f2049c3dc53e6cc5aeea9b4874f9c56a378ac23f4f7391a8a357fd132a2db5230eae8608bbaa99255fbbe338c95b0ba2305222a41581b874341746c2924e32046889535b2ae26057e53e9f955ef5c028e9082cc6b93c53fc45c1d8dd091621b771cd81d2449b6dad25f61ae1ded5945c421e0b013ec0727fcb2d354a45d79720ea50210c46aa986286087ba185caa992fc20947b3b375feff258a6e515a41122cf502ab5adba2e9097fe08762273947a415671f135e23d4c29bb71efd1ce27264ca56a8a5c04bb12ffa6374d57e179b57d6e9a03023b695c61c2e3a147165c87a7bd33c21f304e5eace2f5b7c8dd17402a82f108ab445d5d76cf80c828fa16c9172c5602ccf52ac0e5f873a24eb233491338a00caa0236255ceb00b4fc7cfb24a3ddd11dbd60704e0b954bccd2b21c74c0a1a65787626c3b6d4669f67a4074b5f53cbb9022f2f5302083085e8ee87a13bd47a3e43e0482b82accb1a837046198768a3afa485185447e9d9a012f17edf2c0ca49a5443b4ab047a0a470f593155454838fb32bd4c6559b64f67170efdd415d1a95269ac491bf9eb5b9631f42440630707d377b22174ef246a23ba0fb1c3065fe4bf42a62076844787403557d26824f1a1d5ed19b95a7ee0507555d4cb57a789d8feacfc6cd9d93f6349f6fb55a3ea028db7195df5965a6bc71fcb986deabbecfb65473cf651d3ce7850825898a178654f80dd0bdf044ce8a6623a7f981207fde78c5d7de050b715770267994454d18a5e8ca0e77bc09e6c1785b5b8e3b35930ccc4d71582c18943c0f2689c1d0a9fe933cebab1977c986aaf944f527791fdd744478ab5e2656bb500687d0b87fd639067617d1e129fdd91d82239534daf74b231607c92463142f99cfb4097cd18b4d50ce44b4f33c739412b4f5be7325be6ef288cb81aed8b7786d9f5ff3413c9cdf2d978982060e3bc44acb5ba50028ed68729ebff1ff4f83d8a88ccfb1f28a89b3c11e9859aabde4ea2c27ade4f2270c6d6b619fbae8fe86dcc31426e8439a91ed7927305b8c01ff643712e0ea303fa2120bed42dbed6f5cc2caae8d19182c2de65b470517ef855d58128b486703a056b1bbac35123dbbf46fe101c384d51474ec66fdd28d29ce0476a4e438456709b0100ea3a17b39cff5943b56a54044ce6cd74638cfdd5d6eb877de62e3e768f284a47537dd961ce1e4a251b56c7072d2d433f220491397ac5939a75e552ab0e807264af49229db6bf52b3875c9c46b564d81cf6a42dc1b9c85b4ba2ada435716a6651bae525176109a4c207e4be13dd24f3fdaf3df13cca973c27ea8fcb1ece45bab4788a5d146e9aa721de950d569bc3834424b5c53b4237ad63b6ec6556c64aa16220c87edacdd5918837d7f42f145f28fbda5a95f8115695135d80f84c78da2555782e0066a0e665fc45b796f28f8f7689cc5fc74f671811d53e0ef415da1dc121d75182cec79cc361e8e3977ab912c7b81dca71be37e78a09b9d69b21bd33ef478f0ab934d29b3a550899e8212b6f815bbcd914f59ce83b66d3758468ac6f50b639b44ce5b20eb41ee1f640f1bfd8893762be3b7fb2732f6ec3b567365348f68cb8a3f49bbaef0778414e892bf648058fb874837d896d6545aea629c53b098b4b752c89f1df05f52b1e609b666cbf47f0917fe5c26f36e07af60857861ae75f43afed8044662635619d5426c3e87f06a0970952304cacd3f508bed76cd2cc259c3cb5c748d678afbe820900e4d1cc209fcdd1e0caa3e6757022a1c454e685f2076a1c57f8558928405cc25eafdb6f2364a220149ebfd1d936b0bbd255b0ebc25635f42b1409c15d2f18439b08b973542b7744b648dfb7d2a67a2e036a8e0261a1fdcc91786271fe0c8a401535d9ae507fb79ede8e4408cd4313cd0357469d2532c87d7939eeaf2b5e308c8c53f8fc8164478e91faea5e0a5ed57a917465fe43549a5c160f704f41ddef41e8ab5a6eb9a623fba49f18e41d9de5a86eae117e0f3ba42d3952a865d992d4f997630f7a2d73aebc2c69df93e8c283fd02b62bba24087c40c6d97e5f338996d5b11e8c6bf10b5a0a2140228e9d12adcb54b64b215dea50bb41183c29125beb5845b88436ee3f6047720f8e06aa6177f9d8d7a9011b8118c8c0354381de0c401c507297c9be575074aab711f9f1678aace5a7ee7ed860b9863b1913ebfcdebdf10e2d254828a9df733a6d717403d70fb5be6f3918586dc8ab8cd3ec5ccd33d3445fce89a72b8da1ea91b50912efac497929ed3d02d4703bcb03b73246a039c3023159a6475d73ef95e3e608b0f973348effb1ca0412a1893dc22c5e023424716de25c80afc364449f78a7c25749e76815578fe777d4522ff57836bd4901141db3231277cd0cc5ee02feb98a5c1b746a59aae150ce68e9f76b6d5c1263266fb9716f117b15dc17065094a9268532d5376a8ead60516d36cc30e3bb8c026bd355175978c18bd4cb1722f1261f035b7682448b32d0601c8e3c38ea3a93064797d98dcfefbb8a92762bc69aad6c8c4d639a9fd78cb71c1b733e713485964a1582632f6654b32a37e20fb2c9c7d1a4b44557f23aa0fa553babeedd4cfb47f6aa2d0a83655a78c3b5e476df6d91cd3b7538ada5732df8bdb7fca8e74841a799c93c3c9b40438b24d69a58b86227f7a2f0a9fc5ae01cafe20473f0c97036a179b77f48153025fc7e215791073ed1e8ed062d4a16f2b827d8e93d9eadd4a3221c96177e5da539cf78c21d303622a2ebfd13d23972f67e5b61c4e13c3fd0f1c70d5d75e1c5da35b0b25960b5fbdace6459d96d16b971e271250bf947b5892c3f240b39a5fc09537412a66583521b723cda40b78d65434acbfadd44c63c03f44caee54c64eaf9823ebb32d5d478af550e08f08f3ca56463c126702e50089a575ba47e09cab6f2ba18a1b30a66fba1cd1c0c7c4ae8c9caca58223d770192e7f3adfae8db95335359752450df974ab4e817e9fd6032e6a9dba4373eb8b387c137180d73a6a984e45ee7b2b88c4eabac3acdbe711017d5b932cd42040863faff2a3311d33f105d87d5b8697cd0482eede443f3abc0199ddc42fb2843ab6c596552c4fc2a4454a6a9c3f3aa498638d231166151cf310c5f0f5ace275c0ca638037ad9c1edd199b72869ec652ff0fed70282cf6be91797eda8fff38f2a49d305efb99b441bf25341b8177576b9355a466b019f2134475f73cc34d94079d442ef275e43efc7b2a9858e5f1f8572b4fdc6900fa15391b220ca233f1948bd5510bbc6bde48154b1af82c7f0ca666a7bfadaf2c2d7a40c075f78e67025c1d0aa974168c66b1219c2d9eef23e8af409291f85edf8c967ea13faada9ab8f0244a815286d9a8da55e3126c681a2669bb03f96fd657b0d568027852e7d385e3775bad7c746edb0a4c5481a38dcaeac7ebb52cdd884d777920f9fa12fa1d26e42583a47ca1eb77cff44a75c9c60ba271fb44d06ab745563a7529e1ae8805068015add3e5c529d9521468eb83e013de530a1f61ced0cc96b47f65f64bde80ea09f0f08e920d6a871c56071c1262f9431c6f1bc1d89c57fdf36130cd5e16115e0bb778523523804843fc91b97d849bdc1cdb3349780b5cf280e2fe713fd8d9db967ccea599c9d245403773afca9ba1fb02f90134dc08bd86db3d72d68051fca9c72be9d9cbb892aed352e9fdd9420a3aba44bc97ff89b44e6b60dc7bb869cc6aff8047532d4c0d744c5238520de8bba688f6e94cb5ca8e85d05e912c2272a01108232f321b49c72dc02367917f4be2f93b3f498ed49c613010d94f8f9ef8a4c64e103de58054ae75b1ece174b78eba01facc562c1c3d3ec9127f11949353d366d054c35c054f43ad4611d0264c73da0183973712c762a5252d1aefeb35d43eec85804e34f365f6a2d71793aa0f7d787ea14e2a81c091a2dbb59b8f3fdb2690850008aba3190f59b21b187bd0f1f7ae44bcdf819e1485eb5a8daa9773563ae8f8e4a792b38076ff9b177e1dbb5224534a2d5b47af32598d2a5d2772708debef2bef56fa1b82cc80ae480e12d5764ef5cb2943b89416b704de5b0a703018a55888e1182ddcca946ecefcfc7d19cec420ce4f92203138cfce43fffb30c33fb312268ab5abacf03777cdd8b679b39e34c504fed2c9acf3eec36e8a20d0d0b3365d1b38727cd8d340f48126956dc62ce81b27d9e0527ba185cd52d195a1a90990443ff0b389ace5ec7263f6d3252d51f5ffb6d4aae3ed313d3ed505d92635323eb0a1517e6ac8d956f346ef96ba6ec0b1d4e171684ce5675863807ec1fff11fe56db0aa0fb051350e3efc6a81eaad6d6b45d9c8043069c079ffd00cd690a7333d9e823772440b38f5f14447dcbefb1ec3ea7accfdc402ef5977520ba953e2fd80dfa435497793e9b01d8cd3827bf2bcfc281fe31858c8b653baf85e906b8b3dcc1519f194c6597edfa416a6e18ce01b4efbadab294477309f07eaf358734da10273fa061466c4659523ed269698b681616567acc4f2d120fd7422d24cc868f44ebc4e26a883b2ddacc9be31b96de04532bec0630ef7d7e875f1ec741744bc5907a9bcae071e2afcc845e8bd6d1cb9df3ba5195efdde6525ce27d7fed71f9b42098593a3860f0cca5d36ee84fdadb5ab4da21c51b52d4519e1b202c925753fc9707816f17d26ca44fa4f89563651e7cf4eca73726e68cf93a5ed3c556f0f65beaf86ec7f1f581e68537164c0f348b69b88d74c147c6bb0cf826e836e7935a5f550428fa7b4988bb32d4c5d7106443ff33600c126892840c8ee4a1fe748b7d8c01fab330fc40695c922de29ae571ca1c701e6419d2f8fb6b95e4c3a6cdea3c8497b70ea05320de0f043ae050c0759cd08f2cb4f32ba4528f84848a6dc79c81a2209b9fcf2dd2448f07c3f1c2b78186a4e36010cc3abbe9a6f46edd1d8017b7f93db25376d4b0edd3bb2499b88bc254b5b379fb8b49efe557646263909e238711b49477b7cc730dc716ce3efaa786307e832c9888f053c48bf4e2ec90c3190da4d350a167c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
