<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84394cbd65db37020dd73530bfa74c498f92e5764c5008c2a5956f7037c9e69796f57640cd92e1bc21864d32f5f6ce5d8233a1f3c6e20f31c682c8b98b668408a3add417643c0edc8cd1cbbc40e656d5f397b1a3d41c0d10a8c2110818488bc772d6d14ea2407dbf8725e92a00b547fefe34c6d3862bf154b774375085afa42c8ff1b4d00dbfa2911cefc02859d938dffe86e88df2bbee12aeac7abf738b200992958c296530d667cd12d89022d49533d5bbdbd7fad62fff2547152d502cff843efbbdab1a95118f8e53262549055bb11875b46c85a8295a7f59b9f6d1abdbc882900cba52992bed51d324182789c6da8c42d5b4b79a38d33cf2f2445a8b9885afaf7155d1de245ed732f0da1e71ffe4d12f7387e1b4dadebe57520137369e95f20870719753cf3bfa6b9d90c9184ce29606af624e6f646652a09625677f6c3a5e50898ec12dcd0c7d4bea55b6576136dc2c6f9c84fd60ceb34d94fae2cb03880d7281de1a291f4d60825169c50aaff7c54ddb580e19bece0f5b1d2c94be43bd51bb77edccc79aeea5f3135ec744e3bba3c4dafbd330d9224ba9aaea6f0eb989b4e703b93d98e96f9911d77c44838e34fb71849f935082201de142412b1cfaf58f5f3a44d29db98079154b317e5d41bffafb0471a9b29397d051ef95a89b438144f33653f66ceb4f819e1ddeb3cd2b09f0dbe6ab15d38a6cdebca2c106f3e7d7baf1a73a8cb943876549883932892685e35d0fdb60cbb13bbe5c2fdd6fce138fff067ef9f2f90c610a92344a164aa19f77b241b1ed764878be8587160e17d4cb9f7677413e093389728368e82f3461f0d1ae6f871e41df22edda44b123e39042fc6e2a607e4016d4b85df32692dd2b10c948168d4dd1295a769e7644f13d46baa2a2ed73eae985355e0151664ec377711550bbed85fd21960d77a7d6fd72ec39da4d72aa1b8c7380343afe898b32ea6ebfb8b9c801d0d2db90e38dd9693362f4f3a51cd4b0b4d5ccd6e2f82043325d36b9bed4ddc20b62293ea282fa04e6fde5c4c96ee9bfb7643dc1e40a7d61c153cf78dd4132a2ef22af9f6b65fc81d056fe19a0fde5ddc34072c210ce75e6d2b0d436cd0355c7c425ce8cb421b6fef96657e681cc78d8a4e25f279b2b03ca5cafeb866182cd9c10cfe16f95cea185d1b6a40eb8e7092dc38e1a0d6a392aaa311d6e894af2bdf4dac1b6169a9808893cd09e698e76c12c5b10be65a63e345f9de60f0578c1e88dcaa64d08f7d872a7ba8a381e026d9432c2508ff4e39c0a3c2dc52e1806a5ee73f518d7c449fce25bb164891d3d4a00fc6e5c278ff14efa56dd47284e0f8440802ae83cd1e1f51788ee0d43fff2c8d53a86de14c4e61dac2a8d54fd1b2813f490334506dedec9c18b621d3e51e8a4454276217715771f67155976a26edb6f8d403a15344d9a76feff0f2e8a92398801f6d77d58b111b11408c3f1a90a8ca04e1bfaf79fec33e94a7d035101f21c2af766cf78e00e41f11161553c3ef5409a6888ddac4ce931e117cd548e89aacbd7a05a19c2dc1c05c981e92287a59a98ef5aa69e57d3bcedf51f54efe568744ccd7ace2444c7f04806126d16d531baf458a2da43ceeebf77f1b4b3735fbae391c890395da7c5eb83f242ac3194de69fd342ef47d807084732b4b93c6e08a68007feb9bcf5627da3d729a25e0e65b839fb0d89662ea531b9fa6313d7e6064bd12ec0926d4b4cf65417a70971192da9e36db8708f947e591ece753f9605168d5234724b089245888af8c60b55e49c4f50b3fd26a26cc4cbc4467c887491c11ac59874103c07a8d9458ec59da9b148b8225e56ae5781261d51a96de3c48e2c63842a9db504e582c3f412d6ee31347b6f95e1baa89687d47359fb36307e4d708237121db1a82636e8094010f517f11cee706b53e65890812a2fe4d51b9e891d746da3a7f4580020312c04c55842681ac311eee47a5381f2f071cc8f6dcc25a411f65ecdbf49485b05330288f8352ef9237632644286db14625cf2bb61bab48a38044811b967154baf8698f4fb12df4dfaaad7159afe9ab940e0a256132e08eb292e3501ad7239af282e2b0da1d6592d1fd983d24d3bd30a8f354dbe740863241abe9e7e8d53e3b0d282fc607f3301f5d0ab7bd8240974419c96230d580cdc55b60e2ebbff16d5f8720172f13042da296a614c4f04b16138290cf479f9689971c937822d4dc3508205820b2fb9f53d15e4675066459b5a29b1275ad0c334c113978529fbdc9a2ab17c8b6db41f9cc1190a9fbd68ff7a07307c1c9ca575ed04c3c57b12117e363628f616445a4b4d5400da37de948111dc0eeef17ee3f68dc89ed33e1f4cf282c6e79feea8599a7d25fe0fac6c4f707560d95753f21d950d562fb650995db84dd297bb27a0fac5d147baf8db57e72922abbb92db6b130db8073f6f03e8bc282f4033cf031809ce461e02f1fa329098ad5d2df91b1e6fe933fe582c9ae29ce34cf9a7c77e3ecfc571d2e50143ac7e2853c1c4ff59fb6d24023e58d3cfa8ad1efc87bbed3a0b0daee1d6a622660f77556057e18113be045638154c1442a1734f6ad7fdb67ace89c94c3c612b89b27a66d2dbbd15dc2b6f7234f8cc22a7141baf84e0d30257da5c59a5f1e6ad0bba8456f64f3f448e31fe1296a638f67cb562f447bdc9ce876eb7363bece682e0a9334f33db59d4bdc9a44dd9c6a635972077e71689f4cff8acaef007dea90037285a6630ac6b8fe5a9b8c744480c9583ee019e066e82ce54abd8336ec83815e1bf0ac7f603f87977bb8c841487d5da74330f9f533602a9b4ece85c8557434e2d97f3d768408be9554165b521eb6decff7b5da53b25387c24902241a7a5582e7d126c0533c96749d56d03d1d40fbca1ec1d9b748ff2074640255f9d19613526191e650007a2128918506fe440cd0e0b2e1452746cda1f4a11eabd6043793c8af5b00dec026324c50e32766f1be73484b61ab5af034e09d7ac90254caed73a14e61f9fd48083261451a690c117310e55f2435d44a4607b3a98ecf606cb6a777603e8dcdd505179b08f6207b7b674a3ff421e1163c87f1700818b60b302b3b960270c943fc3ea14e18111930b50169769931ec34792c9210c4761eaf62fd30f8591a50da33e155e9d397b7c6da87c4513f7a99338bffea1d1f6ce224237ee3d2a960f0b29bffce833e85855cc3a8cb30f1496e783be41e0270fba3ae70f2a9d17219df6e64cb132d128c907a702717ab84d0cbc41a5945850cc3834b4388715bfe5e0e68f93ddc7a7c9aed037c3da456043c8742ca96c279c97afed4210dc2d06f0ab86d686f79f01a4294694cbcef86ad14f42da5c289baa547d7270c530838fa131a3f587802e42b1763cfec893476df7f0816aa588f62046201ac74544556aab51208091f3a2364dc498a29be32f76ba1a1caf92401cd401162474fcd40a809228acdb6914227a536f204a29d0a57c1537989be655b7800a3c5dda3d3e65125fca2131e691fbb250a24cc2046f6827fce8ad99fc654a720964833d0ed1a78737dd7cdb20b6e1244f0d661b13276582dfc247697e94f25eff1fe68165ec49b8dd214f42b0a9d573aaaa6beb1430285cb8b570057a9113ebf340b2eac29af3e6f1da4149ccf277cf105bb3b31b866a692a8fc4c140575931cdf8a9398d3336afcb7858c1f8fb51f05b6b8e22810b1bafa528f9d6df81ad72338667c73b2bc1d08832cab77b74b81f1f116301ff82592dec7afc749fc50988a68df65838f10244a6285f53b1d120e6837ce528167e841057dce340b0662585eb39a52d38daaf58058596be2393a5e1b46f010f8516b7b34e8c60907e9ecd801f212fff99f16e768efabf90164679397fe72cd4a659b856e685ec82d5102e4171b344c4706485e6e14793a24a785ec8c90c960903514591099a6af8e6667721900941f2f6d4471375dcb100ec4713912a31297029dfb97c7b793c36bb99312b484b8cfb64e57f09bd54818792a6db70d45481ed1738cee369439eab16e7866aec9cd695ca68ea881dd9b0670a422531b9f8a85c82b2a6b714414c8c3cc84bc2ec057a5c6689857820684bbc94af71b7999308fafff612f970c914da1eff4b6c16a29228c3fd8cba45bbc704a78240135474bbd664dea5a83ce2405a1b0075f8dff68f620f35fbcb00c9b061a65c4be6e82215bd572015128f11ef49f88d308d5c6bfe551ca426cd7c5d52f9d3054f4526048bdfd958745cb9b42e25d1597b6e13eeeea7f0effcb6e32d21f5673cb3bde9e9104ea2fb3ebf728b762a880083ccf97647e0ecbe08d921612d5c94c69ad08d8e1125060ad26824045dfd7dd82dcba21b10f837f1c74759454ea362f34d717bfb293468e68de38e6afa17f5f134ab700af2ea42e9dab3a1e315c737f55c92bf1fba9ffb91c5767e21fc32749b2f76026ba2c7c90316afd3a99e79f2cc257dd95078ae51d84b39caca860f8fc08f00de22e97eb0e01788a0de465e151bf7e96943834313e9e9bd3a407b8846b80aa557354f9e79323b90da3ceaba37725de6808c7378cec63f57d3db039e170a45cf4beed5ded8712f54557ef518ca5db2ddd273e4f9e4f92ad8b3425659ed8146db2a5133124bae914b5ed536eafc9685e7bd0d0ed16873fe3cf00dd8e954fc90671248dd047b5a22110309be22e571b1409e9d2b621191b2758bb4d5c9ce47151bd7ddb4f7266a14eb0102412e59efe2e1085543e2f22e4dd7e40f0d8b89cea25b46ab669a8cfc7964041ec3f46b8773f6660d6e9dfa9d56028a33136a49718cc6b7a284b42dc321c03534aa26d9640d2ecc0ab997a50b5ce6d8f5186dacc5324e48fd8a85433d645a1f8c5393ffa8f9ceab363db33e49b90ac6ea5cb70cc95f7f3e071d6c14593852ece580e8f02c4f713a8aea30e9a8e7d9865d00f571c3a8670c1ce119605fdeb70155e8178101a553f19203d3fd95d16da5076fa924248a2b0de1c0770c4e428dd56edb2a85d12cfeeb378152a1710bf0b860cc2069a8ab6bee4ebec1d45b6107474a30cdc55462b85ea91c3ad999b175f50b8236142b4764c7c095aa4d164cba5644188ce3ab4e516efe1538fb48836826bdc139b3b8ec39b7402712cd74598058edb4bc93e8900e96b56eb45596111c4642a1673c0711b6c67c65b2feb6bbb5a34163b99db5253be2ced8f87144259d7765b1c50635d4a2cc99af73058dcd319b43a1b806cd8b4ce93ae06b97795dcde3923eebfd81b7b698b8661a6db35b71c04613b52b0103b750f183fd22c2db85129645b6d81334bbd359ae80cd88951e6d0d43448b9304a28b0a137c06e5f3d51552b92c1299559124f4ea2f0cc19907534ba9e39f5f4d454df821e88e73e86aa30e74dd89a285be82dfcd50979400d624077c373c0f8d3e62db2766b4f78eb55a56c7173887b9d5821e9f29f2e46631f68b7f009651a286efbdab121f8fbf58a94d2a3f1e110a739e84a77cad60c1882867858e813b6932604d5e82868531f489db1ca34938b989651829d5e6384903a7823fd72048a5c6d158c833b763859f21e82cfae5497c028e01d5d5a4ca354153bf89c01bdd3a3ad22382605798151976751a6d8b9f335abfefbb461e99974200dd79894d55ab9808cb17a70515bc929ce8698dc18aa91ab17b8d9c5138d2f1fa6f0537b705180bc30ef8eefd6d930ab9d2635badcde1798cd8c19073de24a3174dd5fe55806f010fdbd8df40abefb7c54dc8ea73c316459644f1ab8f1bd03a293f4dbb71c1ce8a18caf07dc3657a3efaa9a8f553c183edddf67f6fb9133c1d7c702ae8b58c8560d9e076ce66cd3b92ef957804974e8d1432b053a59d8cf423949760a49cc5f8fb22cdd51cc701526439f4da819ced494f2405ec7f8f36b1b169ea8f43a8d548b6b7a7bcfd8ca6a0d31ae4fa474c2cacd95941238b48da936ed122613000d062b194f195835d98b67f1b1e096418f43630d807eb266754b1e64d2a419ef26435019572026232140a9b874728eb569ca64adad7d5508cac8cb77a95c30b30f01e53389c96ac13d7b042de90ef1ac9c909a9469de95d9372f533f9da0b8850a53c1cc13cfae2cc0cd0c3b0c6e1ef74c3cb44749a019f9b53396affc4bcece9723bffdc66bafaa6e201561ef0616d06b2dd3b16486927dfee9ead40aa067d8d1d165228b0f131a0b7af6091cf8befd5a72ba6db0f6e69937bab4d005a8804ad11b5fc084706cb1e76d453e83414740bf36c620659646735a3cbd3822e4a9fa728f4a7e7f3f550446ee6c92b5689a7c5310c98c10b57d6453e46766dc7c642dc9a51f4deac17771fdecc0ae47e321dc33671b383b272e5f969abeeff57135e6a697ef19c13dc854f4f5994fabf23e67f062755cf0db89bb18a1eb6ae96ec77426d22d385d889ccd592f6961ea62604843d6f4cd2b65d351c5bfa0710d980e66bc720d6deaa75a342cf7df27fc6e9431e834dcb814e7ea9b84c167b4aa701365098d5abf8fcb8c6645122474d4cfc009107cf61f7219383578121d20670cb4b23e6320e1d9c1d73986cf1bbca65f0e04cef85e9f641f23628f73a79b1548513ab69596dd29b8c956c785af9ae082de0faecb3326620188e34ceb52b9d9d1863a43e7134e50a8a89edcd5d25907ec28ac3ef2dbfb9c69afec09f8d1424c9325969b57aed58d309d03a687c599da1ecb3deb5806eff782b3402714811c98dd5c201981df18d278888e72a54107b6e76982b11ab7270333e8c3ac1b629a552a1e630d4519e0495823ce74a805a05e4e07d82557ff8826b0e701788051d1a35aed2697713ab7d39933566766351cdcba1da3becc41271ccacd5337fa779b727426c4e1b589e876fe3e4b7d9aee948fdc41b794b10871957b9cb60a72a388bef283b72858e711afc8b20bb0236189692b2768210e031164adbb1dc3f579dd1af4066f85c85a61b2a7534f9f755e54630d2c335e7649715192c9c118fba6a4cb29e1ece13e9d657038c172c1c4576d6909976336ab15401d1304423f0ee5ca750e93b50d806acaa033658481c50fcd83753b64edc21032edfcd7b749d65e4bb4db9787b27f9c0c9612b7bd8f0fa585bcad81ded559eb3db532e1dda6b03c325f1d92ab70418f45d02bcb7b1fbfc3368e975f4bd501ce6bcf4d620622a5b078c7bffb30dcc0b002a6ce70e96d66c56aac2f2cb5a12ab0c1607ccac19e081f25ce8813797209f20dad8c4788ed1f2a539bbce9b3f0094ee38e6c29b56eb70ab3d239248e0a151976ab3690e8455b723e2c6c330757428f801777e38d3fac87a7487af2227edfe6eac7db0504cea2762c18bcd8df4f8076d5dc8da08a5480491606b7046de0ca3ce83fe5dad84c42d76887944298df56e7f14ff870b016e51108b3f5f7734d5e624e4ec2498c977b6fff0c96c8091131b11824fcc91868af62a219ab36eb8abb025001f384e4e3edefd7b91101db7ed3f43cf40bb11259fad6d274599e7f953bc9620ee49a060d59622af848f21614274af9ec663c2a545253bf3efd0e03422df84622d0c2f4283501bdc64f904d8c1ccfe0c459f6746fb5b7debd0235a80294331d2c643d218ba8aaf884e25fb9c337996c07867c246c942ea188a8f1d6401e326faebf3e46102b2fedd5650a96657ee525c082ed6905e1721b64acf76ff51dcead75dfc37fcdf330dfaa61819b092d95e46f5b2feaf7cc367f91f2563d6a33be2418905143a645bbc29f1e3aafdef2b8c833391b5221ee6b62a1de3eb510bfe13ab25fb8c057eb46917207c09240af82a62a925485f05565be8e17d31953a62b9c6a7c056e130a4c1e5fd731576a54805a2f182f9cbdb2ea1904ecca33695d2e584749f3ad2e45317e30b5b250a69460733e51717c38d594d46733048ff7c5ef24b5ca87a8685de2447d797c61a73ef2f289d3cfebf75c144e59a679a5d9c8fd9549eccf3f1fca4f35856a7b97978a1eef52975d62ddb2fc911e96f12f66c0ee3e44a99c3d831eb4022c2e99002ea5ad5df2f3351b7b22db66104cd568c2a69139f64304c5649587c8de0da2584a1d86653574836d09cbff43625c877c0e57b1ae9f9d9671165135141e8ebcde1fc8c17ad2d4045394ba0f6d70ee09db933cf2a672f30386c87dda76d578285239a0246d4399b43ea04416dd2aa00fdf8b4dfab9d6f76be456ab6a6313d34501873f3fdeb1da348b0f057867de39e6929ba2c067239e436ce9c3ccdc835e54d9791b27848365fb29ac7011a4d0225e54292a0be72ba50fc43858939542774297573efe6e4d41c4ce27c697640a745c4a3af527304a6f60ce6782d6ad9907acd3ca8b21757f444df8087473c310e941c3d5fe459569f2586b55b9ed04d5862351ce7abc64593f2bd99d051073b8c0b7408c5b33f75c59df1cac71ebdea2f8c3a3499abf1471a22720684e86a15decf5daee7189d0803f71c7a0e4002dacf4dadb34a950862a259dbeb5c9ef24b01b9248684d3c0381b0c59537ab8de7dfc6c8c64f2c88a2c0b795fd80d1ef6f9f2b2a333ae46922b092bdd697210a2ac4741a1a0bbe6831b59a727df9af090abdfc9721b7934072650d9f96cd2e20375808209cdcf36ca7b7e814ba2f9d8ae8a8b8898fa811f9863673bf29643f8ec7e98fe702995d80e07eb04a0e317791f7b4710741fa1eb2ea13259a40500aa88095260cc9815b2771780b1410b9006564a80355a8dd5849d136ba473a31f438c5c16b81f541d302faa22ee7e7ad14f6258c76c4f524ec4d07ea4b26ff870a2ef2a7fcb3e1c3557265873395a90fed89b32fba96b873fb00f68d9e0c92f995b380cb014bd487858af9736aefa387ac0b82e224835bca70e96fcafc11d14a98a127ad0b7228a95f67cf2c59b1fc4934d3e524ddb5a94b34a0c46bced6aaf65ea7b27254f1eb1205f69be433a3a222f9a9c973fe04ca70682797f8cd84486a2e9905e58775192c33bf6c1512e782465217f6633760c00adec8224bd51568e667d5a8fbae2abb61acfa06bf10bd39804bfecc74f78aad711725ecae92ab6f1055142b3d1678d2985559b4a6209f95b498102bcaf771ce0df494a67c4a4234d70554007cc30edc0a486e42f14af50632fec01fe2785293840d6baf635b2b91663b0bc91683a7464621f1d4b044b05de05f280cb72fa88f6daffb3e104b78b57087293862340a4a711b50c4fe1c87294e66039519a62f39e1710e5f2613f554c2e252ab9da851ce4be8a1be5fe6d0c86a12ee248968417ba561857d1554a1a1bb3cf373c17eb6423b063d3369c952b9046d8176c1a0d07b4941a5f3b33cc5836420e5abcaa843c49213a5ced24d84d98e0bb67d427c367bd9cdb76f0ed7705d299b7cfb550fde6eb24d1b23879fc3238881b1b293a9d3e49e0c2ba17d65d113ed9639cc59593e6c95fca16bc7214e5d2ef6b744459c41532219a421e1f3f4f61652cf590645900e1345cfecbd3b01d320bb74d26567afae8cc6371175cbd1c01d651da7a9ced559db0059994ee7bb951bc015dba9e22e4afc8f07911aae14bf415f40702603c08ac6f60381b428ac056b1185f6eb8f187d089356081f22d1618160f9309bdb9aaf83371ff91acebe9802e338e6dc03bab540fd93eab2309ccf430a74ea759df22b81c0174542fd1b9589cb4ff70467219855789be43e8ca7ff7c8049f76603536031f261f0b9168c8db3f42d802e42723d28108dfa772aae1d24e11be5c4c95c9af47737e6fab1d92b3c2e5f8c5964b928d3ad4d2505890f544c590bf132d8eecfe4281c665487b49f075f57813893404300377f5403b785579a7d2f72286ffd2b41b39c8625222f72852d4f5d85bdd32db431152b0cda5b034078b644ba4807e44abae859e065dbc4871fbfcee7b631173b6ee643ef07fdc206a20fe7a543e14e5ce2d90da6cf1415eb03732cf1e923efad394cbc2e7d9d54a9318edbb38ffaea5d469a5d3c0eefa0140e7c015aa47fa693f3823d42b1e825e39bad203af5336998f1f2ac63d57bdfa3ed28fdbaf1dc8bc79f2d0770de3ca519acd96da6803ed4076584ebf95bcb1171d3a5c1074da5630d17c013e6c71f039939abfa5736ab56c7c7f4cefe3be328dbd3503680eea24248948538934a627772d7f832b395a1366fb8466e1a2448d017e6788eca18734f2570c8cf80ec594a889bb305e1fb2c5b4ff6cbf9d13230ebc1fbfbd9a128e1e9204f78ccf2b86f59643c2067dbb92ab50523344d90cca6716c03a777bb7fffb667d5a03660cc456afedb5a8c715f9ec0857e9c9bbf6a0d59b567a3678168995af05a6a24d101c38ba4bca50ea204a904d2bbcc6634e47eb7e643f8a9b4937879de48ee77f62bb2cf245ad42545ab76126e07a261f6b026f10cb5f2720a2f95d1ca7f9f8c7a9538b7efaea19052eb72a9fd84739b450da98f5599e21af6ee55a7f84b67b6348a2febea5bd5c5773e15cafad71bf9f2fcfb72391bdb6c7185144bf9ba949938a3b7092fb0e373cd62de952da83f741c93de22fff2eee3e7e63f29cca79405654db0e33e75dcbe85e6cdad39c6f9761f98a1d84c9ee820c286763ebdf17f10c469e0bf9322a7ded8147d697ed7589cf01df1014aded50156cd0c48f714d27dacfe6f8aafd7ead15ab1cc77c5f1826f1587f977b0619a8865c3a390b8e8b033a199d4fae5012962cc01b88845540ab62abf249c9cc30eb3fcb6aaae40c859d2e42a2b3d20733834678581572aa65105e6a24e48e9d42949b3fc152ee9a04592568f34b7999bd30372764bf472ac86b6cb062c60e371ea51c03d9bf4f8173eeaeeaa3b4dc003395619e425112be52643d10c77ec2b12300158f9aff852fe8e6322e57bb7b075365651e5ba882ae283d88b7df463f9f5a757c1aa73afc6a65bb6d050210732df63d066caad859d629b35db7b577007986b5eed7d0c0d6140d46f116bc1faeac704249f310942ab16824e0a0dd62b92affe97affbfcda5020b95dad4d403c9cbc96d8304ed8877193f521654b8f20550dacf8c5250e3cf67209bc54b06fc3accb9203cc23bcbd855bd301545216552b4fcd481d65149f8096e2b9787fac9f384ee2f8975df9381af8dfcadcfc7abc73b9c419eaeeb38609452c9405c6d163d25bfd791b035400aca5378d8814724b9aad40b60dd9ad2279246e5a2fe7bd552ea87d50988f7248114d4fc1950dc2badb9e0a0df8f195c2f55e1d8cd31944530a858c654c18821f5cc94f664d5308c61412db842233806941c8121a29128ab65e1bcf9424e7a39a319f5662ba1c081668680a5f7f7eec72e1658b6303e7bbe0dfe1de2b2c96a47bd06d2bf7da51086e6eda88f55caa98d82046a0a3ec93b288d59129bccded5620c6ff2b35724ea6f17501274b86c9a7a5504fb4a1d0936a0fb03873d0e76ff4f0f01ec54e6748bd7c8c11f65af0d98bcae5e53a8605b570cafcafbaecd210f31c7d7fa5e2e0857c1e225d81af82d45e686a27f3dd81ddfaa4aa567e880565411982db4998207ab3003a4cca03550251929a1519093be19d729f86d0e065ee0b4a8ddc3a01f3915c0e86e89709c619b482acc642c5796de348871f25e08fc397fd6539772bb24b23d5240718dccc8b77e064bc20405e1cb6bcdd298a86ffbfae5149031dadb68d79ea25701914a7634d56469e995825f3e1e6fd3d431cfa15b159fc6ce601f142aa47c0ee3d0f2381652ddf002c45e9287a2d040bbc6cb3d1fc736847938ee5681ed5a8dbf775fedce1a2aea712a5901b0246906579ea5effd8967e085465bc043c404290cb90c09d7c2bfad021c6e8ed4268cb0c8c18e62627302b42c4007f5221e512781be5301cf190943881b1ca1ad42984ce6b494661732dd6abb8ddb70a0874479c7967324efac438de5c51bd3d0be25c2503f94a32c5b942a2dec8441e0276c99921b6977d5140614ce11119b5aca3df0a1a1f727799f9aff53f978c558e9e7721931387232780c815af74b753cd8e5e98f4ed980b7cf48f066859cba793087578e0f3d565620943723e7e202a64cdc6f382aba22baf0684f6d9a2ba3de59de733c14cc570662a60018a174d16b74f103cddca42fbaf3ccaf53c24f854d4c2025a10370095bf807fcbfa8b277c244519e0b5acdc5a8b6eab191748e240988b11f9316945fd1490ed28babb72a1ee338f1a4706f764732f5c3ab0c7abd5bcf2380eb30e11ee0d0b07f99cb3ea7f0a83f33635f4ca544c7e565f50aceb73014c21403166d2a284c51de50205821313c7251f325891725e5646baf42bf791a60f3a6011925932808df58ef13765508f79ff0464d8134a68eb3076f5335ec12a8fa58bc2ccea34ae498ede8d1d6af5fa1f1cdaccb12f52ec963b9e081f8ef698804501d74412a6cde9e3bec92cb7dd6f6a0444e3dd3c9eb8f99870d242d576dd3298036a1dc7be1ffa3fa415e00b21a32585033cd5795e191cfd9996d2bab190c8d18a49c532fac8b3053354bb6e8f4cdcc2380d4192b659e7a67ca4c4fdbc51ec4d344f53ad04020732dcde21c2b65a318531f2f842a7b1c0e1baa2e3af200f6837a970590f6b8b5c9e77b4563c2dc754f7f7d5328a07dff6d6ae8d9ad0aecbe9a5852eae5da3a6ddf5f97c541c20e86055fdb54e5fbbe434924367ae890d23e17d3e3a2420bfaaae5c265ee039acbfd9b5d75f42802be93216b667951c04eeb563f891395ec09e344ff36911465d6437fc618a9954cbdde94b38aa7c9019955024838fc234591e45b90c3b93ff251585704607d3687edca08172f5c2ccc981a0166c95e92532418cd0dcbd5633fe3cf6cd1a581098e0982e20bfed23e73149d766895c0d6c73b6342b006343593363e77e01e056024423cd8dd0008b744ddaa09b8085b2c2ac11f6dce2433b22a296b98e57017191cc09713b2b110b9be3d4d7b763f72c696e0c9adababe7dd54537661f2380db5be1e5bff686116ef1dd511d6f2156bd67943ffb1c68f302b79448ef5cd2d2bdd17d21da2c8ed79ad3c2d52be6cef7074bbfcaf2e70fceb52191e21d2097c8c6332f3a5512314b3dfa3a9c4da8f4234985e9f898fab1eb83555b025606c1002c86adb44efb7415ab3860ea4e17ebc305aabcf8db79529b86d70c8dbd60433c9ad15a4c30f1e07d524683ed6dba3c876fb8cd03205a68c45f19e6605b87dd832b1737014b4ab8d5e2fe48938513c6741fb9ccca21fa8e3ee3f3cee4c0d8684b5965451af364a3e226510202459c7a935328f0ded2fa7c3da81ecc82fea2c5309686df3493b7cf629266ef95c50415eec64f12aa5543b80c2e75786f3eb844029887314716f9dc075349a4233ec2a1fb17cdd6fc114dbdade3e0aea716a266975dfaed7e58bf67b1b2920d4dd90b098603d879398186eae8d54a0eb92a49c59bbc8e667a967afe72406673dbec943e475dbab34c546cb0485a4f031999cfa76f5bca0f44e1e12b5844b2e4a7a001147770a42b10d6b57091555803ccc11311f9dc43ee4c4a1885ee85c8e93f4d4270077bbe70eb15feb787ca327eb5032feb45791a0c750510f57a4bf4629690c232f3fa5f382b3070d1c5be8c4c862a10328aa49c920aba916ae240a9e923761aaf55a645b72a90334ea53db21ce296ec8b9aca22d7e516553d104895eb6755adf6d01184a37c74b64f97e95f50a2acb5f560f995e3dc9d1aec2a932a6e7388a8e952ca1ce2b08d7125f177841ef1f990072e76c08ac50083f4fd8576e6d7e2009b46592f897d90ab54c0006f2ccb8dc8f9a6c107a3a436dae4dca8acf1e62bc3962edf16c94b59ef2ab7077bbbbda93effd94f0638163e80cff183f8786906110ec88148ffb0d894b4c34361c13f1d603255da923ab92ccb566f2a702fd76b85b41b63abf8b511336fea91df6abf0c7921a27b6fc857f6012f43a19a339eb7e1b1c2ec0290eb70adeeeed873e602d4834a1af554844e354987e6cb4ee038088ccbb88d7ad27a9a4f3ec5a8b6febfdc75a682fbac3a4f47606be191c188e64fa28a05313d36862dacc733e22708707632e0a59ae4e80995bc123769e4fc0f6d2aaeafff109dc917b84da260dbb4602536cc047dc92d0033a205fb64a910562a4a929f690bc5356fbac4aa593e4759cd9f9705936133227b99db7c84355dc79f2423d8d75d7a107fa536d521b59e841c32e6a544a1d9811bc46a6ac50a25ca035970ee1683607ff46c0f776850a98d9b3016da4108254657de545bc8cb06e8519dc17da703e3303d045f9bc706c7364ea8eab50addae6139d04173f25903a2f8e1c76c51e995e67a4465656db2b6d2c3c39fefd2ab87f42a232e3212b0b4d2488932ed63ea11daa703ca8186c1ce869b634c376140473f9ec722980caf02659f575bbc003839dc85ef78424bd74f086a39f457978ed7d8dc242f2e0dd56b77059a42432cebcee2842c1b1ad94b257ab4440a23ce793773289c1f54eb9e9628f1a9827a20065471d2347eeee64c616278618d1ad6537a1a520cae6bf4990fd87ba769b1e845c7de9007071bdb47e8edf3aea3e19259503528df31993e87b64ca497838423c65bb6917254006f20d1e2c099e71ba9b8a400f7460cdd3cba2d8a371796f6478e8df76e6d41c591fbade19332c88dd90f940dd85ebeba819630defe7e0de294d9e706cdb24f1017a3722016518de1e611595fe917a4111d4f64acde853227b391f892e15e940fb6252f94c8d39a6e6ff2b208b174dc6794a5db8893295d8b760edb26c9f76469c78863799b203461b628b124340e335db8916185a0e3f632a5cedeb72bf04423396bc106f40f55216878e7c4d0297863518f3b65c4eaa8f6f64aae3ad5ef28c19fd5a04aecbb61abe813d11f6dba2072963b5c4faca01e76ac5acb1f02dd3edeb40abdfc4187278840ba03b88f06a78ee2d07357e01ed9fbb5c6f627f22de4b938338574ba79957de36e53512915b2e8056e184abd371bbef566d1f4c07a8b9e20ed526de2e05ba7c5ebdbe7ff46cadac5f04b87e8a2f6453f10f2e82e6f7f239e39b7af54343369680cc7162b7e944552d17a3bee0abde849bf3fa162e90b55644de9539f9fc8f371cc8deb0d529b4e30a244b707a43814f42e0a64d77bb51b9a141d9fb4df777b9ff4f8bb15479a4947cd4418c852f44b33caf013ffd3be1232fa11b639204082f76928633122e60a2d7b610f95d116bf944620d4613a57f13d26639b29587739ef7f83dbb476977dfc2b24d992e70a26975d21cc80f579f10883b90c61cb76b40dbf35e48a9de59ef73cf455727081ffd96aff0d857078266bcdd8fee7abb954016bf2ed3e97b8fcb6294a2afc32bc6bedc021cd878038484a2d2ced91830e6dc269ccd6465eaf3da0d727cfecfd4c0183e1dcfce7baa016bce6495d0b5992ed85c6b06e17248856dee27492e816d3e16a0b7e2708ae591ae21d4bea96167cb3f29c2cbf3fee1372e1b974ba2597de031906be89f9e62c2558c6eebf0e0b6595ec6d54e6d5e53d44d7c72167185bfa9316918b14a32b2a8bd943f9693692a5093be8b1358b3f98fc79bf4883ea2532d1711fc0afb6a725664924f36ab865837818af5003a94beb6cda567bf0ec887e6f55093a52f3c84a906b50022d353972a0a8d04e4f70f65a6d27f30ca83a034815f8f83f59854b83498291ecc2fc08154423c4a7cb3a28ef430baefb0ff96c9534b5e8f12c5ffed132677aefb71d83e755b05a093b302361b7150f9f392e2ffcb8f9a71c1ec7fb2a5e91446a1e9abc3d93fe0ad955007c80bc63c76d97d5dafeca71621875aa5c669d2288c491f5c67a6a8313455401cf933dc81b5c8a0c88e680d80c014e9c4869e26c57d36f51d1760c3a746d33cf7773cc4fc85eb01bf2c54d4a0001a9ed70859cb4108ad9119c7ba865b28a68e3b8f9881f2baff71daca50036530c14ddcf0044de36bcddf34eb9012a2031724689ea26f59d3caa9c79d9c10b398bcea929161b1bb25e16e4bafd0662c83ac4c00311fa0951e21d24403397baaff930a1192997cdade6eea5f82201ab7f3f6021c706b0125d3eea28d387454248ffbdb67cc01194a97cbd0c7347850578f081990c66460df6b9c6c7977eba5c9f9c57b790b3c216e1c8b9273616a172225ef0e7422ca188b2e341c3ed35dd32503e536d5a47bd2ce3b577b4e7c2589e22475d818e0b3f682ad360f0b2b50e06236bf11e16657018e1db97df1af05f016edee23f1267a8821accecd173d341334c6cc58350d40ba3eabff4e9203f23ae12eef7d4bc74d06cf5f035244406de2f13fb09c9d6a2830936635f1772c06610b1269771c0380016e50d3762e425b46c436babb2dcbf8c199181c17d7efac626d0c7f6ce1448598941ea692801ec3921ba99d05b6651a32fe38b478a8f81150af28b5ed17e41b63c214587bf46e3417a0f526599bebb1434d06444c99a59c3aa0cee8974000826b821af11243dd073bdcc76f1443035b019a23e159351be7021aa0dc86b917b99668c5f8c10ab3c30b2175a8a004971c136ee856ecabea7c2f8b697de3707114c8c8edb045f57b262bfcc837a3f346c99348d0f0fda6c5c6d4fe6b123bc4479e36c5e9cb1422171b0d7e486b53dbdfe84527d0fe4d33e2d91553a1b0df195cd5c376af5018256583a22f2fad8ba722898e3c9f4c8191c6604fe83e97ee93cbd2da379a36bf29f3f93691d8b71f911f13cc1b35b926f4e15013f784a474bb4cf8080b5f3ce0f102bea97f46ce0b96846a6d8a92df85de510ae4f3cc6d2e4315574b2f5e7fe22b93f54d805a90cfb4f79c2106b262a981a7e0453ecd51f820242e54fcd322f8410c75710a449214a80fbcc0523de3952433483d46031d4168fe503565cc8c30ea84795aa9a33a4029051d3d07169e1f9c0e5b5a1329fa29253626618bc73ea3d536741f511b5bbcff40a7b5128373b5f4f658a41b64006401f5e05da3a057be57ea0105b608ecddf54bc0ae736d901b43a85804d45be323f23495852ff682f758dd8f8cbfcbbf7fd3c9d48c46d8e1d66aede7ddb666f99f792d7e786bcf376b553be59a0e7a66459de4b488e035237216dcd00403b1be8f8e65e8a0b00f01ffbf4486ec0bfc65cd9603dd0841b44cef97da094b36d966d8917fe9db2e03b4c774774505e35412c569651bf7883195a6558a6d1956ed2dbfc97b3e77221500bc82c78c7724e38c03b3be97dd0dbf9de2e78cfac3d0f21a99fd25521f0cf118b8b27b6a4ed5a0afdb0465e2c83312b5c62173df6d9d9f47c99efde9b8288b93dd5f34f246d6034c06cdf8767017528e4c23b0e0fa3ec961cfa19e60f75134453deb863f9c0e69c569c2fa0075fcbf7bf961f0e1631ce55062386d29158fde0f22d3b2ac7e06687e7a54f35ebcd652b131d74ca831956ad3612738f3fb17b1593265edfb896bce0a8cf30439003708ed48257962e22414224b8f9ec3e984969bf28c350f1ac5c6ccc73b2bb6173b531d0d8ec1b93364be1adc82679f5338300d1ee507fa07eff5f4565aafe2365acc99f62dd8cd29cf6aa74d37a8a35282d87076cf688b49a326bb1916885e63ff1b8b4b2a7de2b4ba9a2a5e2d573071999e8fe39734c180b5872b364753cb7cd1503a7943ec95d271e03146f97d8bd717865a6a3dfada57b2faace469e26b8e7f0127fb5db29571231cd15f83b44df091b7f2d3d5e3a1bf1eb71e80cf14796733a757c7dcc7b696051eea4d329af51e7b04f58627652cdab067895e93033f0306613ca1ce1dc0609d35311c61804051e306d02c46b0adef5ff03c044721b8180af3d0276b0d789107cd1cf2317165100a10374e82b2ce0c1400cc8be3c8e44ac63ce4f6a4200a7d553ee02ca94218e8ee83b1d312fbfd78ecce731c8a73bea3c03a3d3435501e7273d7cb6cb4e63d8a9ac67b24eb326f26a7c5acc84ecdd1f64b8ef66d349f3712fb4d5c9659e53cb1a3a86fb0922bc4eed213e84bf1a41cf79d1c9f9f1585f30c5d2b6a8a2539678d756d7617dc24e4243f40624f7cdc6a462c717ae508b04a74bb0aca8173ed4183583222e391610fcfbb11285bd862a317e08ebd7e426cba412e6c23874ced1c13bb274523a053d7d58f5646112ed5b45a8209bf9c1aea1a2875f16f367225e4f5fd6ff3cd194760748ff96f55c15af17dbbd30e7f0cc39b99da2e2ade16dbb676100734d69f5693117b1d8d638db409f00d73be411d3ecda1df17ba90819f62720211fcd3e6954fcff70ec1a6afaa0573360090c9f86492c5dc67e2aa3c0560242b55e7bd71ede71ecd1e3b7a4a5ea52daaad1b51e89ecbc1985d93f6812ffceaad1004cb18e9a7f213c105393e65b11565758ea11b8f035e6fa400ca013015ae73ec742d43748bdc8ddea68537ae5479cd3884623bfffa63b84781bfba25da447e1701844d6a81dbc4c98b5c01caa0d44aaa8d15224cc7a921fb4ac87c9217665f958d57d1f13710195042c735824cc29a442dd75ce85059c4afff2213b81ff5abae132f61fbc0e8a62aa0a294950f1007815179b195dc0d1c0a88717917d2402a241cba95d74df6fdf527cdcf7cbeff1e72b9f1bf9c6f76131142d6232ddde0b241842c770220579b6614e635b4e5339befe1232b3a88fec85665657b357223a1fff87abeb5d3d1d384e549adab03a2896c6f00fa77346e024d0cc1fb7adcc1668081db59cd2103c44c2633f1d99a115c227bb28c42e067f760adb0f9b6730a1d546747031d0ca6c1f8eaa348360763c183521aaf2b20077a2703ffda9a426178fdf45bff286fb823abc03782bf5296b7ee5de496b744cad687403ea77d7c4b1692fd6969d560ce57a70ece3182cfcfadead8c5a63b505b3fa13e99e62f5611132a137b8ab0862163aab794616c924767f823bd61f28750962b13f54d9f20a9d6c082e2af0460c20c7cf374a88b1ea4ba67be5db341dd378f3321838977d0e71ccae1a244b00cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
