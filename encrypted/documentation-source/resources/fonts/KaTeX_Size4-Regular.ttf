<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06bdf25902be855ca47a2c91fb15d23f8af290dcaefb4a1f9f6f9a62d3058c797fb8d4786ef044ca1f9b059464254bdf97bdc952ac9ad66c8805af524ca87ae54dd7c3731b8a8ac8aaabdbe28a3c22fc5d899b5264ad87df3630ce55b7ddd461cefc2adf74168190dab31a794dacb2a86373910e8a1f1171310bbffc9ecf8caf4a5ec97ffa93800969938394a3a7daa5955a007ddcfcac25c20f07d9e9524ac0888fc6bf74a87e3c570c8b0a3d3089b9af7fe9e26d5a1ecbd5ebd594fcf5eac210ddebfd39881127d91da12448252c3da71a00006f3fdc91aa551912477a400f1a07976709b7b95ee5402c074f047b81c7a614cbfd751812e6a43bc190d5d3d6c631b2453f157e3db9fcf7890e7d369bd2966c1610d9db440e94eb83d30a04e69cc84a830b7dc69b3ce78d257b71fa127d9f3cfeecbc5dde7cb28314b6e23222b4c50532dd1c11a13a6603c01a343c3f9d5dcc1edcc0c43597365b4cf2652bf12a30c179fe8c1977cde5ec3aabc3cfea358eb7d08d8504c72c61434b78512c26abf1cb07e6b87adaa69419d27ce5f78c218844b194f996ae68836e64b2bacf1e0dd1bc6acb0c2b9815908a970c69c283e57f2aba694bb1cced9ae8a22ab28a10e76e407eca6769f4231e92e30f9fbf1d361ec6e164a3d795a7de84406d86b068716d15016ba289fc5ac0d484ebafe786d55848ede73fdbe28085b9746f9082c2cb9467f64274468b786df297cdab856b3a8ad7d38844a2109814bbe2df645d4c6b62cbf4805b5251cecd8e18e8b8e7b01231fc76048d895c2c283fdb6587ede7ace447c13e5aa484e3e50995f5fd82b9f20a07e290d86c87be27053a7bdab1cc2e4d9e67a05b2fd4aeb6267c837ca75d3f0b083eb478a3c9768a7bae59a2d59166080522b814476671e0901fb39c8c43bf4239d90446f6d28e62e0169fee5186490809ae6bc428ae03101263cbd29403d82ed4676d80f9a39b3832ec061a48908e4f4db8c2864878a3deeb05ee64e5ddffaacd971ed627cb455e3f200724a648a5dcbb8dfd68bd0873609505128512374c21e885860d4ffb5fa9a2e23a07a7124e448df5f809d4456a17b8680736d834143ec79484b0b6f862004f96abd03e96bda7567c5a0e43149622206b2b5103d991e34f034f6f4fe447f5d97f83c078b5117e48176783938913fef6c3e1b91e3908f2456d9e83c32903f797fc05fe19d501dd556d9d8cf2fdd09c6933019da8fed19e942d9f009afe5760d792f143d64be7bcc63d6500b0b311c36596d68b97843f26d087e8fb8e17884d020f8fa4a97d85d9b007730bebe5ca3e2f8115ef5867df11f6cf878b7c7758dfd1d8769b764b598f2260e4770e9ab7e1c8cd2ec169c47d1637e2a1ec80f4d0c8627ca1b3711b729bdb5052a9d448f94542fcab20f3f66a666a2d9236e6186c7faf736c12ec3cebb8a6a67b615c258272adf2294e5142a65f168c936e1c6a1cc4d435539e01aa2d8bac5ac25ae660ce05f23798787637063fa5acce1923701c74902721e189e4141fffa79ade4d04ed8b39bfa4ee16e004f48a5d19e4696d284bd215c04c4d560ae60c7f07916838a4401ed22433022f63d83df1f9677445c65e9d0bdb01a06619bf1a2a2fbe193923461083c3bafe68cd64fd44a418fb544d6ecc083521dbd103a2d439aa17948fc778000b6cb0a4ad25c141e99b4b62cb493abf909adf56586805013ac1d8b34430ce9ad313b711b7e4aecbbdd5113a024c90318ed95833fb0d49754f63633be594696a556bb231414b03f09a7cdd354f7c212f2a91d7b3ce5c86f20b1f3b2cbd25a51c0fce981e3f944fb23f3cee86b2231cc37413f2a259182e0c17e747db64fbe4c7e95270e7078eac0f1799621d6ec288ccf7475c8e19f508f80777f2fe1a193f20fb3a98ffc9f860189eba025425a0b26ef1dee4754e092c0740aa4be34ab71a0accf05c4759feafaa73d103afcec9fe964475059b7d74cdfb4892c49c129a5b9be508df4d0e6f63b03439dc45b484829cdd6bc37adaea78a9725a23921d6ba35fba6c2cf31c481c9b8fc972914adc21a5545c47e7bf2c731d281332b2de87065a5526cfdc20c86827985634abc83e2bd9f4bc420128b76ddf4ef8aaf788ec769f11d510b219a08ded0c7d6e6526aad3519a0e759fb15b4318bf6e5af7390a6808191dc0396a8d13f553ca29e21b7cc7ee271d6f37e7205eccca7739433795d7882353297d49b593f8951932e9ea0eb74a0ae5b23690161847574ffa02d0046949f1937a6455a49fa77f3470acb4b21809a2ceade8ed0b303f9eaa1b5adcd981fd449e77ee376e6a3c62fd7b35c660ff6e01e789c8390053170a5ada4728ca3a42f218a935d5114815be1c9c4a2a618af36ed2b059c68bf19d450e896733bd040a3b9c893c7acf8b565c33653fe8f7fa3c5e566d2b71edfe621fa7a1d302d3a4d241466bf025fb21da537236a5aac8553f54dfcc44a97e4ab7b2c91f51c9052c4ab9a3f1e751a9864ec1752c66a945634a822a2621bbf5cac2b7a4bd512d944bbea66f35e3f9988320df607535c78e4476569d3c89e6a12411382a55ad00f16403bc595707c8c947334cbc63449b865c482b44e9d4ff2fcf5b786d942ffb8c9b9ae074bc84f0a977dbf4ccc8e922c086f8885b73cee767b7e1e453f8da1335cfd74e951898711f92566b551af333774b06e79bd350cb6f699b4e05a6d168c76a338eea807cdbea4a5201d825e687870726932ddbd17ff8c7d504e3656790b3b824c2ddc24865d188eadeb17feaff9aad1d32aa6d59c17a96b06aa69c3a6f1e0cd0810bda0c300705763e01f90955ede436745805db36c415213d7f04eeabb83ff68ab1acf2436217ba3d18787c0827b0aadb799d6e66a3aadd242f146aeb584417a09685f3b113ded56402fffa9882103e898bdd0c4db06c8997603a57d25e7eeb80a559b306a360de6c16410d6a8ab78b38bce689c71fe3d92f7daa9e36e4cd446a31c450154c05278d3502c6417b58700707184e86cd6ac04eb253c3e1e3c9f3c1c94a22f4895a39869a3bb1225c612ba90ede004fb77a423ad1468bc9c6b49e3ded427c8d410aafa228af957616e802759eeec21fe1c4e18600fc4f13da8f1894dc5cdae98c1c8ad5b284935463b69fba20e1f74dd89a995ce20c52c521a844c8c119830c3fcdbb80e43904f0edebf5acfde837bc23e667572cb2dc4455fc55cc7bdce447aca9453b666af06afea58074b8be501de1c814220bf06c32abf028249b6d57218cc526efcdc0adca895bd27c945c9767e7c254cd4c096de6b6a9a98d238f1bc7fc782b5ec392793cd41874da970c188cc04d6b2b68448f958f10aca98fc6444ef96d7ee1f8884f3d2f63a8dff7cb710bb40743c0b991b2bdc1d82d77ef3f61d7decdfc870cdba68491c9e762f03f39a77e61321b1cd6f336cc881fb47933c27e3d8a552cab9a3045d3886b511885f8f30f71e4460c555ba3903b81acfc7cf9035abeb69571117e80c34189a5401e442587bc8fe9fc70eac70e9de52e106c996259989a66f77345b8160780dc225f56240173ff764d7667a663d9631c3dbaf0111f5ed54032f8029edf0ceadce270eb86e20e4baa09954538e4657c7c129b6f73c1d9a180d06702f18588504bb522f83961351e83992576ce6f215943285caff2dabe3a2d8792689cb68f3120fba1bb6572aa6a5b06c14363c69e70348668c31625b1ac7dd3c7b5335f8e808b26df95ed1ba904c5665c597c856168a8ab4ba6c5cd564a26496bf43597d78251af85af1246ddde87265f8c839d666412704e850c6fd868e63a1452dcc9dcc92bfc4872c875dfeb77d1284004bd21761347b9cd71656734c8e72a86ddbd8144147dd0e9db0e2aa179da529c6f2af60ce11996319081e2cc6d104d725ab5611e7b2f6edf5d6f4c51984f1e7726c8dae0f5f432b8a606890014ba1e939554e2e2762c0030500b092ea92ea9ade8b1c9dde0b79f9191753d77f18d460b864aea7007cad6357e36519032825a1d235595b4995a863875362fce1291f4bfb440f2a34f40042cd856a84231015d7f72dbc1e6b2aca8e7a85d0370eb1232384536a161c77d4a827730d18e689cef01aa88bdd290b132d15c275cad4481dc8db1f567d9220e256620ef98c423bd951e76c15c1a9c17ff2658a7f74f00889569891812544a4f5e3d0ed960a9b050f0e80bee2534e7cd8a81e3de95b0cdb2c0ef742c4fa8d44f34aa0fa6fe59b1227d8fe4d1f5dfeaaf2908ae3fe4a4acdedce6bc5813535a20256640320052d55dc7a6705b154c96f606905540bd0f756277ad1f3a32d7f95e4acb859bd7cc7fec9a3a19d7b5f3d2b1e5486aaa2961a7fb50404315001e8af260841653fbecf5838dddbe4d5ae22806a3649ac486b6bdc83060dbbb7df1237ba3f11e76aad8b2b4e94c8f0aa298705e236c1a54aabeb181715bea39aaac683a8ab9450299e58b4ef076510913bf7d61534f05e83c6c63769cc6de5cea46393389b6350cbf45b3195186c69d48c55e7ace8adf3402bea4f1e11622eb3965401e32bffaa15315826f55f5fd5e4871abead545f9b781ba9f31e6661dfa4a390b23e00582d1630990662dc81070cc41be2454b3fed1e3217dcf25d42b2ddfcf2424b5250e84830f910766ae3be08fdd0d30a341d25f32952e8ff83007384ca8f9acf95b9767a92ecb446a63a930e025adf618ecd72796dd599c5bdaf4ffcbd324c36693946833b0619c16296fff6b4ba9a2b2ef7c543147e65cfa552bf7f3aa572c5c3bcfbebbc8b288bdb662a59e1f9bc76c499a690522b516cf5271297bb5d772643757f77144ebbde47d1afaacc8dd7ba886ee0b57ef06788eafbb0df9ea819ba1bb8d49f574aed89a728f7cabe44df37202ed133aa52a64bcc4b7887b71dd38e535cdddf9d1e1dd93056e6363b8aaa637c80c4b4576fcfbda433893e266c36b5aa9b9445ca2021b0af4b036a8fea5cf4cc0b8fa9b8e7f36899373d8bdda9e192ac4312d5977bedfc0a9981da2a5d7ff0f7a2869b0cade3b6e6157f3143e5d0030a1e549b166b089d35ad4b2ae3484f8e8097acee2b784c5c3eae7ecb17a170dcf70afceb703f5d9879b94e00fe7413f78c58c75b0c60d69cc89bc32cb1ae73df75f1a2c24e59e7da201133f56148538ef1bf1afcd1ffa1615266e89bfad40ec192ae97e69870b9aa0fcbb9477ecb34932704fc63323b5f7c711a4cd5f8bbb050b6a70d1a9bc854649afceed90d5d9b7ef0dc14a53ff75401f599865a3ee2ac8c22f27e836746fc596ccf7682493c7775447bf51c77391cc8b4a5cab5b190fdcc0989ba36b23a65fa9ff7e979f0bff17813a5ea442766f56fdd7dd2b41ab2c49d3e4172f2db2c2a0c26bc8fd544ccf0cd272a01cc8cd59c6c261aa9253422b1622965fd7fbe1608bf7ce41fdce758991f9d92d24ba5a056fc4bb508c7bd235e87abf486ee4a68d86d37f9cc5bb37aa6fa40018ad95862f51a153a7e7b5cb040cf10c83fb8e0eff8de9280afa4eb38958cd1377a7e2f1b2478df6f2f539c43367c9bc71027e80c28d20bee3d24aa33e55728b844df37486c90db172c973b0418cb5fc55fbc1c0cd7cd869a1a4402f4464a95fbb632cd4fd234c8c41d31640b9606a7a4cb0a62b143ee1af1e42faff7f030068d8bee0791291afe254aa1aa4fd9cc02b665264bc4eebaa3981d29450a6139582a4e4db85cef14fe7a13cb197e0370457f4f9a677638f308c82c150cccb4cbef242e0e6e9d9d612f0b2249bee74ff98679cf39890f4676ecc64c78c50de54fcbefbebc5cc2706f000ed8dbfb0d8b945dc250a018255c8b7376e91505e28ef0bbacee4f4eff1b31c2ccd07ca933403cbc1f3c70215a93db16039ebffe7c479f16a9117a22ff8bb38e5bba66cf6d886351d07773ec203710cf0dd8c2b27658514d661200bb401dfc6b4a550d5f0918a412c2db243c2d62e10d4818ae002d15cb582839e4c6ebbff88823ece2c671109f5423bdf5e8c097616c2490eaa8a47d92f6e1feea6e9897032aa2377a3fe180ec505912fd4133892ebf7673b1b83fe7ecc36ba2e769003d8f360ec5e94d2ce88acb1d1ff661db606f7fa64c8f7c2876070a5d75c4466682f4d6ab91007e4faa4be21292130790118a8f6e59283dac6f95df70d65785c889898fb1e5af20cbaa22bd9eef1b87dc02f8fe3578f53d38ab140ca59b67ab7ca52f27465b47c0742c8cfbdc4b39964c0083bfb9429ea3013140fe3eac176d83813b82cd103332468c00f0aba85682ada2b48d45286b5c704aa2b25ff00212d794c102f3fc6ec71a173eb4d34bf813db86976bc15aca13a82c65b36df0f09c0c737f009364178529b069cec97350b4bb58254645815d06fa26953b6254141cc39a189e854bb1665628dcfc3f0a8a03961a4c875563885eb73c13fc273ae5867fcee1e42ba58c1cd0fb7dc26557e9e4c47c7c008fc3f3f7b6e5f14a7718d96f07bbd7a568d996977e0fd790c5e126a02bcab204ee25137f814cb39201e963cd6f73eafb04465f8bc80f464fd9780cbc545f20e059b97c14ce60e270fb880cce7c84a6eef7a64ed60298f0adb27fa7acb63756b7eb87dd5309b2e929d24fef691434701c125f2224ebab0a611b534db90f40c67e1cde6b33057db500eab40c2f6b32da454de867a902eaba2b3aff7be4bd1c774c7801707261d6e16b0bdc725ddd967a53fbc4ea03c26dfd930a8713b0cf67753f1fa4da426c41449d49c4c8f5332ea0e0c47133de8a3a6f447fd6b9e52751348c2888acdb411c8886ef9337ac23c6676e6ca6b55ef95d4c1407047f2dcfaa3edd46f8400555cdf3f4bfa12e6a45d1e78044d539bd881eaa29317f5a3fbaf88365adf99996c9bb375d000a12517dbb4e01324d9208884f7c283a8f24d5e76c29ce25232f994ab6f5cae2b4bccfd392b24a6c75c1136fb8ad1215bf0586adebf8c83653d1ee287431290a706f950d2eac133ee0f3997c71a870b90d8a1c5e6ec3ce035922b7d5efe19b307f56685e0065d215e65525c30166b572832da1376c7a7bb644c6a7686aa0d535290a5417c95b871eb1ab29f00d7b118f7ac64b2d470687923ce00095a8d6854d42b5f0609e4f1c312cc668bd7bb1bcfde4eec785310184bd4387c88d67559556e187fe46292e0722cb4494601d534ad454fbd9cc5b2262e1fb06a8c8c66f2bd9c0d7f471211b426cb646d1ea2060b05262dba22e6240adb08b9c3c5a84e913e148ab76ebc00ee5b20a1775db3530b244750b4c7787fbea69d8c26feda9b10cc22505d1f8a6909378538b29623d93f4e9fac88c121d4110fcefe174e584cc932ee344e60ab4c4245962d463f71a51c70d0bf55b3090669ee8cb0cd93b0149e2f402fbee6091c71d3002663aa3918719ffc9671be6efa960bf57e55bf0bcc22a46d96f1768bee57d2e5fb4f54a2772f8bd597a1dacdaed34a406d9fb1d054a02a62929f32175852dcea6512325e1ac169e611143d8d1fb2ad834772d9fa1daddfdc871de722872b47caca5df7561c901770321cd1634b82f2d7619fb58b5a7b1ed48a5451a192a29d2eb842185fa99d6a5bdc515688d3d4f6c1efbaabc99daf6dd4220ab4a7eb17d1fe038f3fa6d8a9efdfbe82b1e3d91daaa5d255abff98d0a795a68bfbd8716857854a8ba097ccd031a58104e40def783310d47d390c4c80e8528fc5fcd616f98b422caf4222b3ceaeaed58624cc9f784631a1d0db6ade51a52ea63bccfcbd09037e67333ae2bec1c872c4e11267d7792fe99bce4f84537c96c09ee8b9a312f646d63782d79bda559f1483eaca5b142fc9731f9c277cbbe94f239cab104416c316cab5739e3856e0ab1ec36b94b7acc612fd70800fae232cf47bd78a45fe2416a84b7883b61246fa8d983e3f7b9da1468f220ad122c4dcc7a6e485dc5581e5e26ef700b471ccaf9d711e67ed9c2898dfa361d56c02ac3187a7f8922ed6261b576b97c6947c6c120dd8095fc3aa64e63d5c3dbc3a67c768bc9ef57374983e50128003bff8c8617dc0fc40d10c0feec09b9de6a2986311d004e4cc5ffbe3738143f5ead2a12f3f413789e0fddf2c5ccf80d1609bc5a1e5ada9f8a909d85db7a9c04175e148e224507f192bbf33479c8798c84345ee255f502bc235db1a8ae531c7a238dc97d7a25e6a453a4d0e7c11557dc74046ef791f797e39face68db72dc7987850873cad05e4435abef6b87a8d4e0c355f6384f861bb6334f848085cd8bb6a1c6846ea8363351b80411151fbcec399677c17be161f218ad896ec3b799e007016f737b48bde8545bdeed6125097166db1a4fdedf6b17460aa95ffc0965fec962f971f68664fb1719117824b81349e83495664d23ac5130c84faa53db259fe55b3e77dfdab42cd04b96b1494f90bf0729fd3c0e169ef272877471001f0777cd75288086f61e7043010160ee8ae7761841786540d42810c3f0e91f2e0f4a75215b8a94cfd4ec34bcfebb46c9120e58b64676ea2282e6962ac248c8fce2d69ae28091cdd9f9417f94f040df3bcb4e1596c11147a9d1fff243b496b0d875b123c4f0638f1cf3beadae798c1ef4b8ae1f8d38debf5d2920e3e1665628cdc6d82e97060f49628cb9d3e8636e8fbee62c53ac581a6b2b18d139d0a95aaad75313eec151cf167b63179bfc7d475f3acd50c5de15eb36feffa517b8bf9a4a372bf24972cd00bb8910e2f4616f60da4d154515633e016ee16260428041a79b4dfca372c10c01139d2d356680924c6a4a02e44124cd76feaa9e0ab9dfc5b2ddcd8d409c2fbcfeca1d6cbd6bd66287d179c22a065dc0ee3e7298f51f3c0a277b3f36a48bc37541cf0f7ed80454a17e63ee24b929f7c42d92b37e93510ef0a4018c7e3fa19d99b9e1f279a8a558144cdea1bfad49892fb8c1bfe17d127038fc44beb9b0c1f12bb7f5d2950a25e9ce8423258afc8113cc6d61a24ea4fce1db1fbb620c2aeb4a326d83c23f90a2536c941f6e4b0ec437258e0f38edfea7057c4656a778344034f931daa3ffef44fb6bb97a3184c68eda1a9dac44b87e25aececc58a9a1bad10b190ad339a2c6f81e75869258c83084b82885a15d27d01d0a74d5ab180eb245a279f0381817675edb68a72fb3584575fb52a81876a640bb520d32d1d8f071824094ffe76f6ebf140ed98268a3ac24b045fe8162fff9597cabea382a4aa531ea13b325501a111ed5d586c1a11f7c8f1e563f8fd3792e98fcaca927216f256cc122d0ea9dcbbdac42a3d2e84c788938a60536d8fd0d9e408c8ab7841482ace39dd446ee855cebf1ead2cd834f4632bb0c50ca9e0bf91259a2d08eafa3e112038f97897a35eea1cdea9ca590b90952650d424845d7b849245287cc3525576db3ac5446e093ce9d831c39e6b29b4a36c1c3b059c240c7434c0fa013e0822e44159fd7b8939a68dccaf5594c8ae890c40126301eef58a4063f9ce0058c3c2ef7b71b25357d87850a119fb7a62169dabd6f42540e92f24e41417e426714427a81c178c843b1c6fbabbf8a0041b978d84309dacb23b313113adfbc2c6e37f0ce0238b121efb27b979f1b10267446b12a82e1015b7786345a47686948ffa43cd41fa359b98e41f3255a2d931a3a46799a68626073cac994c763a1205229f49a1dc2840cb042ffe41a253933efac883bc8bfdbe95d49436f906ff4ee7ef768670c0483c708f03affa11047be8f70423e8b5dbdaea107c24ebb53c4390d398b2186b9c895f87f8ea8e1f55e73fc2ecb96d3ed1ee7dfd9366ecf0470148432afb89d17338c37e4a66a6567689a4119da1a2a2f02af751bf1644a2c298bac4283c271d31743d142aa73180ca9397f1d0aa24f8908d7d6a34816913bf3fc49ff52d17d645a8c721b60118f3a5cb9374fc52043980ce9a622569ccd2c7c698304dea505d3038da00ce355e4779bb698bfd446581fbd268da7ea7606951718ed99a6580779d77782fe5edb4be0bb33fb20d0579f30284bffebabfc5572e14851ad5274bcc9abf3eb04317d8f9ca775465e87383fdbe05ddad58f4df36a4435da92177d966595441b67a9828c7731d6310fa6bb1f175ae3ff966923decebf6f7c921af2646b59a13792199d4e9fbc24bb2cc8c6a63dc8e467b8bc7710efe0ce943bc4011b06089885556fc6744c63f944ebfb03c93f62832aafd418c48d87224740847f3c229ff711f3d1a2dc81e0700a8b83934e0e557d3fb83b51466db8a080cf4abfd16650e850b311c01d4739f89c73feafcc7a1b69148ee73b1333ed3933faed1566b737fbf38abe890dde940eacde280803f236b1312e6345d7d8e861863255e08de55f0e4656e25836a0c4498b69e08d0630cd40a30ef2ca0411513c5bbebb5364a5a9a404f747971611972673171ba1a06cf9a6f5599ad2e1ec4ba895ffcd21f442b2bb432fc7c834cb16f0fe673e14105d0305fd95559504c7dcf79581ee842c9ca1a66e0001db4163ec90a44a4ade14a70ee8c8cd714c6bbafb9278fa61f4c66e68fb1e59eb8087e83359d955694a04e129ff78191050b8746a24aca4c3734dd57b5e7d772c771ff04e685418cb922f31af24a1ec1f2df647e8c1eec3887db6ec97dd60934fdb026662151aba583264c7e7a7c6d9456fae36e103b57a9e7cf5be4a0498db26cc4ed1ce07fe361b004b1157b11970be95cdc8b04d1af150ad9a5495a70b1a621cb9b0d0639882de9bb11ae8fb598b8242f1a52b9351d9e78da5b3e7ec359124a239659360a2e6effca07dd5eabb7bae4229091e22776aa9686f36c04257ef4dd918206f8eb50e83a5aae5db0636a9211d548ed719a832ef8c266953be7820195968d1b247da543f8c5dc79cb703d08b0070da074603b68b4fb060c13936d15a343d960e8aa5188ae4becfec84964f8c7c1938acb488d55e27256ef1757fe458a6c22bd600c9b9b602e14ef799090b1850ab2c412cadfa1413b01759ef3341b16738369e9ab31036db99bff3b0c9c14f460de18150b873dc7f1258723e007b6aa796f473204c58d516395f0a66a9961709e4df34f5c7bcbf20d63155eed9a5a48327bfadf8e02fab2e9eedd0b8b2cb18f403528434a16624e6f695d95b8e3b3218a4148e83c5f86e7b5a6cb88516ebdfd1291e7332a313e0a9244b15814f2eef5ccf9a75ab69c3e55abdc784a488ec3fe296c9ae25cd7257bb929f173385d42b63deabd3b00598b91249eb39671f1ae56b36ca71351870a0491775154aca8fc8812c9bf24fa4240b65bdbd92ac9ac971f57641e889b010f806c36bf6776d58ace7682bc9b581f6dbbf3116bcddd77be5c4740cb626942083381689ebae367c4096a4ca98bc6dc26462129234379218706acb3ca1b26c50114aedfea1bf7d383c99228b8e22c9e6540397b4cd799a961d92028362bd54a70f1114244cbe7a15065b0ab1a59dccf4b9e4c8527dd06cb0de86647f37cbf7b4189d95403bcb28202c69ed0db4f1f374aa5807e4145169cc84c79a10d7dcc04104fb519381714e7c5b70b588337b106c6ca9eff0018c0902a2b546ee9141c861db366175bc4459aa1070b1d26b471b1177508835129e1063674842b11f703e29b4afc17f622a005461253d6fac0ec0f4de2e9dff7b56525fb9a7c4a92b936b11772063c3fad7ed54de190a0681504f6848802012292b432d33035996f294c5d6f8fac3cec0a5a28c6a494a9817ee29c611a12511378aef78050fc3d035440ca05145c3c44a6fec50fd0d96e4c29c3daf596aef9ba3c95aa344149ca013f0cc45b7a4115b8de013a7cb8feab28f7d23cc4ff47a6bb8110309069f163a175eef39ccf3da7c45887891aa7ac275ff2ac611dbbfea8366328dd094941973194e330b064835ef3586201299d3905a0c272a110996c82b5019c6882a4b8835af0c8addf5929eb67aa89fbaec30f5d21533a2dc90fa6c8ba9d332c7175a32fd591299026983a5e3a4eed687e140f26a0de976e7240e77ea45f49ef7e1505204fbe0ad883c1d10f0c9926a1520ae0d75e16dcd3e34381551cbc8055d9306ea2204f794bbfea8f95b49482d545eea63ef2b63d0e622e5fda0b846781b46c78e3333eb40421db00f26bc55302d215401cc5193516380a33801fc04205e8f9edca92917fefbc52ca0b016286446ee9bb0b520e22cbd3b744a0ff48ff279e45efcb0d08136800ffe45f223a32b4e14956743e04c1436ad0382bb19dd22cfcaced4386b3a9129ae8ad61a83d6748ccf2606f94e3c023f6716fa9eac0c66b512c5c37477c526be7ae682c99a3b76317b948469e40202dda7d1f0ece30d2c7ec1f613c81d3e9bd5438e2afc1f1ac7d2a9108b4b11dda7ce684cd4c3abe6208b7333ac47c8b372098bdb6dc310e66c1718bb26e748de4bc21435a7c5e469ce992ead2320b4f4aad97ef7e9c97cfba5d16b718f9134f67e573bff329605bfdeba4739c3b59bdd7a238ecf362c598af41f19cb1d99f2bfac14925ed8ef914f22ceba8eeb1d22acf094bb972789eef54a82fdf3f5409b47bc58295b64ec88490df4f587fdf108256fd2eb425bee1598bf5de286e5f196d9a680b5436697dfe40365e560e3f4de3f3d51e5d0cb8e0454a0a3e7e550b864cd78e24dd9cc1ad27a57d4c29cea507d11c4fc62ee2b2eba73c37eb933d5adf71fdaa6e9002d117e3f33453809e1bbc99d9c922f8a9db0abe928e1095c4f51655f4b252010d3ab6aa53a15fd826c4071df85a1345d039ab200149d04766cc232c6b471b330312cd150dffc2a1cbb4efd385f5aa65f005fbab9a4449f9622fd8d5f141beb8aa3f6f3d1615c4f514277bb422f9d0586fa713a1e7a9af6ad02a4907464e257c7f23ee2167e8b4263ce420dcea0b56b4f51b525c946844bafb4e09e1d1c73469cf77db8012815941a7b05d716c6532933ddac30540db8fe9d45ce897c079bcb9b8ecf64a469a56d443853dcdf331c8f0b191f7d0b3825aeccd1ee7394a1029ea55c2a2bde1fafc05a3586dad025728ca4e70067d836e637c2e950e965cf9e5f4e278db8b07fecb24b2e2192548aebc03de9bf5f78601a68d28840b2041be377ed2c61cda08881864f018a4313a92e30c6cb12b82e0d6109dba38dd672b4bc94f27ba698e58c28564a9de23fa9de5daf7352dd865dea8df0ea2031d46f18e69e460288aa457cf5af04b2ba3738900d35f065b7eb8da8150d385fd9f3859a0034e10046a627c7ddb7c3ac34f82ca3ee9c34b519bc3208452956543ca7ea74fab932262544d70127d856e2888cd2bf65d3cf949d8693afa1c9f28f1217287294318d2ea678a51361cc612c51c28b3abb16aed07d572a94793653b17b9487a9383433ad8ab8aa80506f0d1ddd5bab51cf04e203510bf4ebd57a9b8ddff102b4fc70521c2e32b531115ee178cbbffd1138f19e76158769af0392faa0fa3d5ad286de90123ac964b7f1d9d3079386a1c4eda9f8d970737219e516d4e31144398cf17654ebfab82501a0f7ff73d6ede0de8a183396145092536f4556c8f9f83c4b5763dd267c714b1207877c5ce2fffc574a299770da2d5aea4daf6b14b9382b2afae1cc452bb12200f77eab99f6a5dc30ed0ff528dcc6e4c63c827c9d19aa6a4ffa0cc8fe8ae01d5bf0237dff1cabe85db9f7e562f23ce58b4aeb514345751576ad92423a84dee7bcaa4791f01cfe7731bbd12a2a492bb884b53bad81a25b0656c9f52a554274bc7ba9c105d6aeec9b4cbfd8c8aae2e70f003744758cb056c320989d8001f74a25f9ce75ef5bd36c2f38ea4e4a8f911f083a668f818970e00fce28b01fa766575562c11752ae1f2d4e70ad957b054b7605626e78183f572b41d1512d3057f68e579ed7beec3964edd83de5d6e4ef3cae52113a3e79a4852bf02ee0a1023c425a12daaa8d1c1596e77049e4e55c8036b202262d479b45de791d1da16f3d483b16a025ccd33a8fc8fb5f12d3dc09d587e7d5ced56b34b9be7dfe2eb710226da3a8a96ca8e9495c6e268ff42948d1b5b94da7f36c8fd431281ea3696d4e95f8f615e44004b2a1502cf18b83b80d68e2407b478f8f2c792af948ba3d75646376aa697443e22d17392f0298597e9e46903f39a31ae85d1fff828f18ad5b393ac99232734c97241d24bdd2f35a9cc6ee348ffc9c22d90f173d4aca4c9b4364791dbfbb59e1d71d53e52ef4003e37d189b0cb10116d590fd1aabc363e9e19c9169812841567878eace050f853e706e5fb4be28891bdb9d6ce901dfbfaaad6ec4e118d72cb62a2a3c5daa031449172df53c75a924b5099eb63ad4eec4e8fcff1902d67bc334db60b500ac62aa7a5a5bf536d7fedf962a7a4b8851486f48dc9f9887b635efb99517cef7ab0d9ba8fd795b11f731675375338cdc5c269aac328516aeea5d8a5d829cd5c5bfe004a6009ee3db412da7e2c01c364840aeab90864a4b72e245094df3ed12e72de8923e0bc00a72bb048e11eb569f189485520c63dd3c7b4feec10ac235dcce92c33ae3f10651715860cf7c58c15f82151b9c23ec0a4e69eaf62bdbaf79bcad8a3e8d9e52e3242e2b479d2b0479ba372994ce99d753ab42de77d3d9b647b5519f2b9c9bbf69fe5aa673ca6e25926ce2279e120cda8e30245bdf51bce00de03f36e1c97ce0517a870facdc9f80e88de6ad64f139b7e2362ef026ac9d8b9e5d5b60ac6b50871944817b17633fe171d28c2297f78b1ce7929aacd54ab6790174d36b94c24482951ebd4fb34892d62503465395990d340742f815d9026dcd735f878fd5737fb6813252cff79835827d886e770a6cd31c5e8ac3a6365e370716cb9494e2387f8604699e6e8bfe0b1b93d3495e1393b354b4ed0b6bf0619de173fbfb4f4f4d44c6bda2e9da6c39628d0b0228c7ee34ac07d8fcd462287969ee01e27795182a2f5a5272cddacf2825a14ba1311bd0a90a814831277ed3493fa393708b08bcd4addf9f14a33827aacf866a5640b77a050107e566c07bba5fdeddc7b7fa6190f5571e322cabfdc7f6dc3292ec3008a4416b2468ee2af08ee1e85b73a6d418fc407f6a0acbd36f12da51860f7a61d3a0b4920ced691c10cb2e5fd7ad06673637d4f5ff0da64b86b3682cdb140745538168e0ddaa10b772cc385749432d3939666194faffa4df7bd87a1bfa771ec164bbdddb9fd1985f9b9dd8115ec1247e253500e9c0d0b6d6c023889fe91882a7060cfb6c923084261d44a4b347b89bc75360ffea90affaadd971789b4b3daf3ff5eec89000c2df7f0a3162d53e8e5d382118ff81a687f725fe54e4f55398797ea81948b972dac580fd981baf2bcec967daa9ae9d0bd2095965eac0520bc83cbf6840b6bef0aa49bc76f3b9ba8464a4a3f05c5dfba433f7e7d0a28d66039d080f3deec2f6491fda54f1f8e70aaa898e32fe707999b7d1e7335673e73fc2ba968a9db9643cd9170e1eb2cdee52632164502b5a6704196754aa5abf2489f7a5c476f5e2722d2bda90318afb4dbf3f40b36834f60fd353bc98aa9e172db9bbab08b8fc5c931457ac1c7ed22b503393ff464a1f7c60d5a47d3b0119e640d45ee5c4fac0ef8f3cb1345d44ee24ba41835ea8e010aa030719174259e0753fdb9ca58ea47bf71cbd3e91523e03daf8b3acfeae57acd41f2f0b022e637dc9ae4bb055495d654a8b1662893ef9b37f8a6f28686480679a718a9a52bd08732a85b682cce6ebcb966b2d48373de0af31a70074bdb24bfa4814a46497be952b747771b1702ebb7b2e6bee19ed958fc5cd5cbe399829cd77428f363b279c18e45fb69f156381e17826ef02c18c07a4626c465b7e41bdd6603aaf30dff15566d7954e1572b00ff77fa09446837f11347c4c72be29f0edbd7ba77fbafafa1f4cc79d5718f6a4a86218322631ced999cd24effa9019f72131ebbba984807d7edfc6c58dec4e49aa7e9c995bab9ab266381f386a6ef6ed4bf72ac5731d7f0b9ba49c45bec2a8a8b550fdabd990fe828bd833fef5387fb218d9a8c6a7feb6ceb2a64627d870d48514a79360749be2c0848c04800a3a39c9b9a7fbd8a4ca2518e852f7553e3ee5beddb4f17f0c759cb06fd9f03430d24ebd2ba616ade7da894aa3d3df3dff195a29345e0df9bfbab70356357bc6b3b2b8418f82a9027197919b79ebc4062579d94f5af7bd828164df773358648ccf88c30e4e06695c190f6d72d399dbabe427f34090ee856fafee48b4a4cd186887be7ad851be3db2d24f598473e923829137e0b7befcedc31015c95aba1a055d246d5bf6710aedc9789f69b2bd06a07daa9857d06f27e804a8bf19be008f7cea9790b876576829f32aaf3ecc52f5acdc7e242602965723ced311246a812f40777651f8efd2ccd8f5490412b3d8dbb40d196c5fc120691df637bdace14eed9337457b72015e29ea6bd955531bb81561c788950337a039c4181786d6de1a9eb145f031766a141a9dd0c4f12ed4c1f6accba3f8f420d6675dd2b84ead3d17601095ec3e61cf346923363a65ee36de818eaa4712ba5b153f7a53299a81487eaae2db6702e40f24c8ee8e6e32ef9c54d1a9564fabaefef942fe34f7e1e53c03bfced4b01eb2030ee7370f944057aa663e88511410f0663b4d30726de44b68e6204807be7376e5bec2559af3b316c2d334ce99662fc8de7e2d92326a559efac8f135e7237d4e3a9d2f336014684049e00e941e545ee9c064ca7c4b93e5680b63c1fd5014c1eda994f0c9898899ff89d1b013e917128efa24f376a59a533203dbd38c6047b889262c7e275221ef346978759233574b7b194ee04562bdac3653d667c3a9b2b5c17350502af8e143fb55ee6a4ca8e5e5683c4f9063b96c54fd209ab36507e895b8ad2889d8f590eaeca42a812da99a6301cb94f9974ccb0c5209e3ab56b7053e9d47b06d0e17b32dd43b484593a36e9a07df78a7f1d0ab0016d30c0131c1bec6838b58adb7dd9ce722736f19b4d1e61b74ca1f08576cbfcbf2d9186db1cae4286ebec43704b259d883b28242d2e5e4ff00416470e5672f100f69fb18d72c452ca94d4c3a760baf8a52239b9e7fad5b9e897f528f882dd5a9a20726ccab76984258e12c2c32d2322f717fd99378b3fbbc1e42b2f97da8f760c74abb4c7f07214b3fd6e8b11f8b8ce91136ee4125b7f5e667639a0fd36e380ffcafd0f3b5c1efb85e388c13942856b67aa505756000beebc3cf3a1f8eb905250c7901f95218f42d4e9692b0c796f0bdb002202a88b0bf3dda98c01fcbe03d10193e1aa25b5caef6fed0c6b5b7fecec95dceb5436cd3b384d13041852cca35149b9da445c5712c1f2997a78e8aa0f0ed4baee1661967a55cd63f81c4e1a586a7b18078a39dee777394045e00c0663e591390ca005957382a01fa703afc30ffb094002712372e21c6d686da597aeb3c4275fae2a12f04b4ed748909668708231c242393a13a14779fbcc67d695959aae5da5cf0cf33a106982b0d65da40fdcf5fdca7f46efd1e8583e2700ce1e0e31384ddbae58e0f19501ae3a98fc1fb688d46f638d1be513bba20cf8c647f950a44501ab54ccb8096f3799cebd3fa4301b436eec140719f378b9fab081e2ad9af55afebc5bd8b66e58e1ca1e0293abd3e5d149221ae627285460d02fbde7b6755493d820ef4d07a9808538a5fff3aab64441f5a5ec4bb4e2e05623ff726523c6cb8fa44f69e32e827295bc47b1f1e5048eab608aca94409949dec4e3ef58d9e8e5944954999274cc93389013bd549b028eada280adf53f8ada17cda7bc2084ca4c5b354f38d884eb7a0ba08ffd8a98e01ba63ccc14c1e4574d687f3900800433bbb49bd943c9980a1af03db88db520107fd3b0bda694868f36919f47e91ca556120f25079d3a26094332a45963b8a063f58f046ea9019ca2347fa6a1f8bd58db80748960f8086527bebfdc27bb71d8e62aa74e1711203d1bba68bd6e7d4ac09be850555016b7eeeb14a11b55723162f47a49963a374c4a783e6e1c4c603e244ed39c8b5e63747145311db9f85c5199a65ac1560b973a5cd7253b1a68a01a1b544f0df73f35c09d68ea1ed22b745eb5b1bc35e460f6616288634dbd2f49798ffa42b881db6bebe5f4c781ffd584ff4936448e7270e579b803327baeda89a0b287d59d6d242780f1bfe210fcdf2b83578f17f5f8374843d25408ddc3069f5a2df7076b524afff0b7ee84439b7b230f565a9600d3da715fb87437593babc5f200854422d6ea00109ad440095f65e85889252f540949ad706d2f62138453e930d00c5bcb3f082fbb130e63dc7a959ba29bb1b3b04ad11e39caed27e3141d596c341b8e36530aaff1bf9527153f8c442bfe04361fd5f08ef52c4303d68c44d347b0461f46fe4ada86c9edcd7a8d82d404bb83b2f170c946510933ddd11dc9c219326432ed982734ac4558537b7221438e4964110d13787fac0156be0cf3ffdd5a8c7a903e5a37be5986845b69e1d28ca50c712268c90fa06825119570aba07ea77a695a71f4fdc291c9121e33a07e82f231ac3db53ce1c64843ae9817f1381f086f944bb7056f188188a02a75b59f5eb87cde4f15261b335b96c4440a14a2135678ba5ed798ba2609b64642520db2cefe403b3c03784e8d46000d057914ee8999fc3edab0dabad8b3b3df7e65706dbf441063580ea4e5dbe46fff1186f73089bbd09fd27ee810df873bac01563ad4de65cccaad1eeb29aea5e7c10340e056f653433c81e72cab506c4ac80ae95a080ddb59e536ed7e418e3b16afff71368a75f6260ccad13f0b73d03305fc8d1d575d1bc77a8b29af338a7515c6b1a045876a84503ae3022905438c096702b6c1a4741ee15fbf88320a1af311a240091cca342960e3f33df8824018d17234723c8f2ca407d5093fc2727ed0c5a590664346d60a5ae3064b283c8a89d1a5abe5bd3b4c770dc01e69e207486fa21513a38751666b8026af3d0ceead","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
