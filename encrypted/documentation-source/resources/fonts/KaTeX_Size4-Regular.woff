<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e4b7073484b4dfe7a9ff1681ffb00e2ced4949cbbea3318b57b4e71eb317ebb53944c8ae095e4d7264226f00309e6c7d96528280f68467441bc254d57d7d9df4e5a1c6d418a7c0206a49d4ae4a215b019824909691c738b83aabdfea125569f53d67198ffa9bda4570deab1aab3f49713962a93a6571d8bfc26d5daf19d2bb058f8cc51d82f481dbbd269a087ea1582b0693ce908605258788845e082c9b0ef86f07cd25ca95439426db14751ebe4a7036f4eafa94f7a95873553e8d8a7427558153bb88e68c43dc7134473c8b49728226304776f861a302e480a9ebb70f62675859d6069ed48f146f3b679d5defb026002ecf0f1f16318c8c2dd78fade7115565451a217c7d7d139bdb80637f20f95c6d063ea19b056cd41714952038b460fa53adf56ea4412a0e510fa14081478bdccbf58dafeee896ea449b63724ae13d00e900def083f295cd3e6ca4cd5caf35256742ca93e95f04de2e05e8c597dc42a02b72727bc93c9694e7965786e0d86981b78dc38ba04ded1d2f0d2fee6851ea7e8d1464d73ad28cc9ddc53bb0260e87d97b71a19e1e385d058b884a22d8f4d9aff78ade60b56827e75639c7560c2d9efd06e6e35d812645411c4daa50acb61cb5de0fea43fcdd49143455edd50e8f408efd11f851095ceaf314430229d312201573b2dfe80793d7f3a0cd7030b073d8b74f18fc25254a927522401c3f3e1054d4f440f1f956c5d6c9816317b5e78baac1e039e4db0550553057ca91801cb26410666e8bdefaf99e86e5f7468cb968c1c680cfd8ba16e5dd75568137b116eacc6345cd6bb0457a19f1f9fb16aeaff1d9527b65eab36b8e558a0146e002ea095a40438ae0d5c69cbedadaae924432b1eef6a2c3c42de8d2d7e8d594f5b9c943fd534d4dc5c7585e40a8ffdfa8851eeb611622c7b6c2f3d44f5567babc42d36b7680afb94897398d09432611ca7aee7df00e8a1e43aa18737e31988fb8c33fb288ade44d5563b4b8bf6911264e02e3ec148b2ae316df993339788234e3eabd58f6505bfc67d775b6d1f76f9f64af875ef754da2c4ad92aacc381fd34550514c739b499322f54468cb69c89825295f69e54877db25e255f4dc188330b1c82613f813a660f494b91b8d09b71dda221b4db4bfba1c76eefed378747cd587cd1960ef806220e0e8b47bb0cbbdab5dca792e875137ab47ca31fb1056fefcfebf946d10b4e12cb93f2001297bf0fbd5315d6fd3d492a7cfe86b5919c91ff9928147a6bc0d04a0f0309e6b1bff0751d85f94e98b68364080e1bd2089996d3bf17cca87023f77d251b09b25d4e79adaf392b9214ba9082114f63bb7bb089878fc42c7b133a0d223ffc49bb9d216644b8b417d595f309550bf339635831422c0fa7aa0fe1adb0165276e6da107e61a3ecdea1af00cbeb66ccf1ed2febaacea5b3406331cfc573f2c5e403136c17cf3ba117f5ed048aacfc9c6731b34c46a4cbaa2e837684a68afaa3977bb953c941fecd07c57dc4cd3c73f6c58b929bf647f9c8243a727b705fa69a826d3d41dd317054c94c0289d6e36b37a04fcdad63f6447807c3ba7a0d070cff69a196eb0b595add1fee17244bbc78040566f70acbdcf2b2945e36aa296614977c0f9a557e2dcfccbd582e41e983f3abb114d86498e5c88993e69b511c7e1a920117b8cf219d90f0855b93a382cd30ca68cf1892544828844dec38aa1fffb94791f493eee4b65918ad9084c0593fc80f67d5df4ac04179bde31296205d53cda4e59271926b5251887ad14f38bbb1ae368b257cffcdc98d48145e1f9c5cef03bfdd8fb5b58d1b8a3f1b14d9dcd8f00e6f92e83c88335fd572b3187b5ee4c4b3a10039ee3d57ba60354f1285efee39c43b85cdf39747795a8d9fc7885198b1e19f87a6f5d83ffe0ef9565803ab4f581c8a36ce2fe7d3e65b480539b53cc3f7f265837fe05cbe2662dd494ac6fae759c7f7c4b3e5f4f115a04d971457563e99e2628b695cdab2b67c8bb0e3a8a13e5fe27f3119f3dcd62cb46cb0b27593e8ed52b642a6336f81231ce64e8c611936ec87fe27b80e10ea598283e3e49e8bedb680a5116c52eb1ad8ee8e954673d7cd30e452f91dbc8a7355fac8a9aec05987fdb86c4dfbbea1b9f0f73f855776dfc853198feae93722e464ab1faa2cf361fe2910c46479d4d34ccd27285f9c037c1875a16683af50a75e441d8a92078081ca93d9324218a1d6dabf88f7c5971275a3530c0e9fdc0df2c74f5b65eeff53770f5d4ef0f617e0c5eee8e75bf37a2dc7e185594a9b6106bf01ddb16644c0c5e743131addc6f3efbc5fdef5b419dce3a084c0f24f737f5fd5f54d64ff075adf846c0e9554f42fc73e5123ba9dd1fbd8073afeeacee2c1e1846f7824829ae671f408e2dc9a13721aa2670c24a0fa3de3d603a904b63cd1a391c3f71795ec18a418e4efb982d1284e0998d6840d7ed78f7c9efdb6530e7a3490671aa8098860648b9cbf7b52e8d8d59c9df4f0380b658102ecffba717436dda40f88335ef0ec955aebbf920ecb9e1dcfe51adf8ac8087376407408ee4756ad5f78b415c038071b9d4891e42dc15f6b9d14b40a7d1741022619c17a1f49685361acc1776cea1ab740030dc375ea5cfa258837366b64ee7ede43bbbf479d3e104714851acc2444937031577cc7270df4ae5004bccbd8b2ca93ca57ddad71622fcbf9e446291b3d183facd13be63bb7c06df9839fe267a0ad03f6811b02bd8a21ad69936e33da82b59883475c99bec92fb337780e9cccd2fa99da8346d68dcc8ca3de80b6011c6946c39a76ba34b63e465db42076acef68a4102f9898a77742c9c797699cc6ee65b76eb138cc08713a6fbaa10d6aa9bdaaa3909e87153d588b6b198bd9c072bd9d01669f03886d52d7aa1e8184afe7c177657233fffcd6fd2327e56ae4eaca465ddbf2beb2cc77db181eb6f21ad45c60970258cc7cf92a7ab76290001027686ff189418962708bff3087e7a09c1a0f31c34eebb4d4e7b668cf4a24d758ea593f7ed1e59075d424b69b5ec8de2ffd757ece9a8cea42e7755b54ca6ca794584a4fea9f3480c13aa3e05ea03eba4087872692a302cc79fec6cded8b38d002adb4a66fb8a1f34fed6893207a4a04898a31340efecd721f73da040520d4d8e52b8275d6170e4df9fe20a08648317bbb7b0364254438dd7b8f2cb91697666dd0b124596e9110b81172ea53555797d985572c0bd81922beefdc7934d05904f9c37d33bd5c78f633d5ac097feddb2404948fd69e4310c70309ab7e1bd3bfc5e17908ad8c99246937ac33bdb288df478459ae0a8c253c72cf19b9ef16caa9d38e0e724c50a98a5cba663c678920a2a9e0e17580dfe48a8ad4158bfdf98a270060ae4e2b9cd0d5de75821c97ec5585c7d5e682e3475b252c6a7910daa539e72a1fe900ce4cae556c661561c7245a18f4b3de3abc9c2b8ce3eb6353890e2b186a2ec94ee8deb4e13cad2d5c51403c472d382bc4c52e80b9f2d2a3c52adf07a9715cecaa2297b58f9ba8059b2c54ef95178e58e59a82a41f4bdb24a89637187fe7fa236059ff8adfba2539ef687c4d68191d10ad28d6a65fd4c663b0f0118eadd7e631a1596272d92838b5a8c40d1ed605aba9c140dcab3ab75ca7227ade3d8414dd392c7405ebfba7756e51aa864aaa9ce1f3374214ebd7972ba1e7df57b182878dd3de71d3c95b34f9d70cc6904b4deea97b1ccc88fed7bd77b149a57fc465ea6f20a16ba1c865b851643431a76413cc925235bc8f7396afab0df0711463ed8a9020993dba339ae159a4613ac8f468ce191845fffe1f814b4c5ddf567c8f40d325c9e3184c4e41757ffa537c87b7c28df4383d07816fc758f48ae9034266ce9278b6dd705794c184c18a72decadbb89a1088c0d1612301e4ac9e292125cad1725d224c87ca0191bb9d4634789f2c066bf9e82dbccb44b2a7fa688f7b6416852fe28af070161b6eb709772dda11d990eccbecbd1baa67bdd83a2183e2586ebd869b309d305910097a103bb11fc782fd84b50b795dbc1c1bc4d9419a4cba690157e8e6ae402f75c2677b7fd01674565f2348fdd3284577f1afbd8352938b1d4474292fcf15f37f72d98b8f805637dff3a16d04302a252216e1c27ba27aee13a4c083e74bd99b4b6d50e84356cd4d57deb42f49af5507914670dc342117e6abf698ed31a455357dae865caceadea405aac1af1129960453937998ff859875406c6e22beb41581ac420532d3a97051b2b84b4d437d0aaf0569d87341488fa58a45fc0973e60d8f92e1fd7ea71d1053c3a99ed01059705583551e615820876415be6aee0d1edd4f7851afca2709b909daad47550bc80f7b27a08fb10d26e4b9b604b3a14194f08407ff88eea539298783dfc30d45f4c67e61c9c5800fb658375dc6d56017803a4a853793307a7c65498405ab67e441fe98e138101c6f9d891964c3578a847c2ed8fd60801916f1372a986d829245185848b1c626d3007d31d58b54bfc6a8352d3649bbdb9867b577dc5842cfab27fec9f88fbc377be18f6653518d3d17eafe541397df902f10fd2560923b9d7de0dcca1b6d72114a49d078666bb6f9786a96beb722c60ac1d54b3d15579bb1e3c3f24027ac6a5e858f40b08acf8abbf64b4f8f0d19b043a8aeb6a8b410fe3ee49db13da9bcbb4b6f8d950b713ed384ea6222795d720eaf01a14f563f8e350397b00518ff04a40cc007898d8c38d530977ed4d2f5f48b3fa0e4d94d02d5facf65a95db798e4cdf9c895d06880cb5844a88268d9bd209e7230385b37a31ab3c74d7a14c05ea300a08e85c5b4459dcaa7db7ce708342a1f88b75778802fd1a93436c052d497ed32f468a249427c91ab3bac6047f7428730a44b29949a445b34bbe746f9e3194def1068255fb68758fdd6ce89e6bf68b215235658600c4b661d52767911e9a101de0d947e157ed458b6e2ec65c6cf44d15786cd2b91c6f865d00a7ec8f13bffa4afbcf59ba09b994ab7dfce08d225ec5ed890b0924693cf69f21c9560465643b0d284951ef45498807a4faa3796d7be6c4664d9d69d59bbd38f20e19eab60666deb63162957e5191de6ef0cd8d241b7ab0f8dc19f9b9f5bd92e433dd22d8e934ee0ce81608e068c09d06b629e7191ceb933d492ba710223b214f05aee584b930ae31dd2d21e8c488d57434a9f5676262024af7397b847ddd24a722915830eb09489277eee8a9b3d1ae0726b052ccd62035d8ec42dbf714ab375d242eeaa35d211efed9247a1bd972dff69248217a65494e0086453faefd6968b19d1d7748fabdf5a48f159763e27efdaa09ee1335da0ec5e6dae77bbaa4a8c9b95686385c476b44cc6e40f3b87fd38029ed09407cbd1406337bfec9380edfe0da04e33ad1fb6a25e9fbe9fa5106b7a93f2f4575c8760728bbd34a49da7ba050c063159d0b893a2b70914accca4b755a59f348a0a3e08b4af966a22c7d31d829ca048a9520db9560c8277d29f0a52c782aa4e50054358227cc8392de40c3aab283e2d287a3fd40df7617be0c1ea3e24ada18b66ff5b1e93e828754e31323e6c744f82bfa9644dc4cf8da9b62a108dae274559d8c42aeb4f0a2613f9d7773961f66e5124dd643b4d066c9fc574311a6478d199d11029d4738fd3c234eb15fefb3c64b8b8f8d287d5ac2104317f305c249bfe6dc647705d8b18f4e78c8deefc22ffcadf843a221a028edff4e13876d87072fbd71309f3ad5ead5dcbd4d718a69723199ac044f25eeb08e247a93d1f9f7e41d76d6834e6f8a6d01feaf4782c04a273458dfac64273e47c4bdfb553451c21e49e2ab09d75a5c0016d26f892db8adf020cf003b58411ef7cfd22d1495006215413cc994136864490800da9f8ae5cdd4cb201315cb53fb724e223b92b19b08c6bffc960856d4b41e0a42b8de4dd9c514078476d17b215496da5e6ecd6cc740ecaccfad4ce258acde8ddc06a0eb5e2d69b368dcd2f1ef7784c4ef1e2f5d5957df826de2ddd700c0ebf08d8cd1c6de0a0987293bca276d1a2f3ce92b47f5f4702dee5833a37ccf699e2f7df76ae0867cdbfa9e036a9695d9652a0e53f1026b835a6e974a8b92b0f3278112e0266ad0dcb80d499df546e2d339ca7680627801643d2dd32ccae461865c03fc6865d073a40c2f0c4c56f2bccc862ce9aa63e8abcb069134d37b9966ff0c72aae1614a83b60751aaa4a020cafbefdcc589e25f2ef5129a75784fb8c76f0a04931eebcc0774153cdd2b5fbc6f914fbd1dd1031f7eb650577ad5ae9db528f129be8bd82775f98d8c397cedd136b58f5b8d657fa9423ba5c90c2016d4b99502367457c774d015e6beda912f611712d928e1468daecd74cab74cf069d555471a7abd9f0d5400e61f93d2c2a9dd1bc29ff802c36b3997889f6d5c45fb211bf8c6a9e85cfacfb2a7880dab7768db9ea40d12af745e0b45af08af91df4a893a4cc6e86cc6a616ce9edcad840eea956d6b14ce0b69964b13d0464de442d5b1ba1a5875e51a4fa1693d9f8574825397ae9d2d24596f82ee5a6d87f1c7f9454b0c0dce4aa976d2009a40b7a987e6445f183e96207ae7b46376ba88202cb4bd9e0e270e43468ed94e289c1bef18454f2f1e37b5b25959a4897b89b73575977facaa7865943682deafcb61069e8946e6ee1f604d881ae0d88c5e9c9c71bdf4b6a83ece1a3734e4204124aa4cb204c26944b6613b38b68c7008d0acbdd39203ffb1f3e73d5d4aa0c9fe4bd0e34428d8c251bca96c2d1a37d7d63d1ca0b6a583e709636d6e1396d440b0127320bf33a6a2fe4cf319478d1412b59ef6eef82753f7a5161badc35187dc4fe59ec32c150cfde4c1a9af0f33f2f4e43911b6e253ebd00748672b42e1dd99443947749313f8bb4a3523afef87a9c02013a06089ea9efc5fa80fc3d4a851b0e64dae2bab6e44e5908fbc73e629d67aaf76304f6e2cd49f9d99fb59a47f2ce014c416cf6b315034972815ba8f88a321ff6e22569687c879c6a88f8cfa94d080fd7e3d704dca0bad1e912cccce6b386dad7c3c19b97de8d198dd824d71a1fb7ddc07ff0cf580d78a19d3229cd2e21c82398397e91623b0dbdefe75bbad9e5234c88327423142e1d2cd8ad0f4b65c329ecbda63a6a9eb7e940395743c2e893b9d24b82ce58e3fc48f664480fba7df1e5777105314fd24f21f02d49dd023233513021aca93a269fd2aa81d91f5b8d935b55edc13b2dce0b602b2bdb60470fcffc9f1a0270f3e4bbe54d928cf4b7a49bd66601419e9747d0e632a559a016cdbd1ffb4517635efddf3c15e97ff884af2bcc2a8fae7735fb212d058cacb0d06a139ee81dc3a3b17bd3357f7df28db40df8af0ad1d2e9c572cbeeb170ff0b7b510648b3a94831aeb122a7ea3173af9c5e2cd71a561a643089cf3218faf89427365bdc236da3af9df631b4b4fae83a60a06af327d85b7415f8948ca199b9af6a12b399364591eb11919f06465f127ebffcb3301b2b26670dc03efd1112c0f398d5a479d847325289b6dcbef7577396dbe36a9ab45e7a904e87c680bb2ba8984bd47105e591b0abaf395eab653889195b8d3fb2a7987bba2b0082767409bc1357efe34cd77afb43657e79ab1952ff2c92e4fb06a3b9bdf349b8474a337c116bce692307676efa7e0ca9f8255dec506ea95704042f53162006866e33badb71ecfa284945434a89ea2f9428326649f7580b87a51c469cc33a107f9065f02247f95e8dd3a07d4af7b40cacbbaee4f07379976e30ae5c212719880cb8aea562b0987a58d6d72ae175cfa64156b44ccafd2827b9787aad9555316729b9b5943584d548278002d71c0006cb85ae9e86b843bd8623a7be23691c03da2e1de312a9d415470f66cc033cc94e4498e0ae93639c79867179e7070b9b2fe5d3232fc254b20b17ef4b3ec94f301c828f0252e985ecb03df4dfb5f36fdff2e50c69f7909d43f9bac17b5e36c188c0bdbdaca1e3e84b2d681fad1e14cce3ccdb33fa6dea2f0db2c0cc51c863479e02f37225c88563ecc52eef8d30abe0abe6886c44c761ea008cf4dca2021d3bc140a2630631675b321fdbc66e6d6cafedd6775a63e47329f9b21e463991cc8a0e5debc00e509c8c87f1b0d8ae900a041e796e0e42512dd123f663dbf4bfc1d4a742c9c6365ee3cc11b193595bb0ad6ea3ee3df832edfc19937feebb3dece0c4d09cfe9b3e506413b9c7ab151ba74ffd5c919574bc4686fd685c63fb7cd4ce6713630587f583d2379c77a7889ab76eaadddbc609f2c99e8a5998d33b52fd084e4ba574c424a2b7290e48a09a1d3ea8fa7283429cd930fd567d921060687263cf75517df31d3fdb14f7f3ee8cdc32cdae4e68c3dc5ee51a0b83a8617fbf197f4b29cefae2f7c7335330913b3a2a52be19c71556314b7961c7c96fbd673c48ba1de6f064d4dc7e86c154c6f670a229cecc9be3475069b3cac1bcff51f15ac808a3e707228a91ef0eb51a0d79f1b55b893de78fdc77e8454593bf3be01ca4db33e5a0b2ee0a03bb60e2ee0e96660ca65e78cff27c4dcd5757f92004f3f0af846766ea05d9b00e62be94d669251ed25f61f721c9b1b9023b2449a373efe0af3c639809899ec81ed0996f0d5616d79d36f88760b9d80a3e302984cd7ed0e49b03764d448b2b96e76d35fb4290c6213b498e462d866dea560a465eec4a9f051c80de9ab1d3ee8ad31ff08305765fbaa6f147a21d3f7f93b7fb7fceb153fbeb83ac8b716af3d08739932dc620b9d58ab5eee1a77a757bffc40c5f013c7bccdefa825c3cbeb299c53bacf68a70cfd0be7ffa9ac5d5233e4e47ea83ada44a1710d7bf734f18f9b17e0963534fb95d6f54d8eeb1923be9943d48367f3a458dc6750b247e8815e1089b4bd21890194c2f75a18b4a5c6123cead601360c480dee6693b09e1febab6e0c49d08f1278db22aa5b6b6acfc9394ebc98c657a849634c95ce78d197d6af75cbd8fd6ed118c979e3424aec2d57b76bd8fb1193360e7e9d20b9b227e701a6d2255ade41b36cee7ae1833c1d7f54bcc659eb5157f4c2931dc75abaf6331acf00fd5386e05c696d1f470065a6586e2971c8aaf70ccbf3cec5749ca304f5e874274f4d63a59bb033e828296ae148086f7e53d644098796d2a1a49a21b1b750d7293003cb1e5cf14dd282a20e3bc3bb1eabfd0eca041ee9fbb8f8832637d1b7c7274dd3ea814076d56f7d6bdeefdb9ddda292a0554938f3fe084bf4840c2e3e237c235ccd24289d12d7be0fcd207e89e7a0a15cb79c61d4a220bd707c222f63c7b738f19a9d6c518d4f77e0d74746cb257495be5836a237e3205ec517ba743f95a19b5025206afa36c44d0c0fbef3292d915de5e45846b3bf48a6449a84c48482e1a9cfd1375132817a78033568c60def96f00bf0cdd69d515e7a0274692d6acb3ab47a1b5d1eb8d41d16fa65d1c205a4ec1dc7a374ebe4ab431a38bd9083a43a61c118cf78a445af7e9b28e66ea49e756357ede1593be060fe168964c572eda5915f976e82b60d0393ee62075aa25eb4091a907e275776cfd23a2d33c21ca3aa94096f734f739fff03e3bda5e4351f7f8b01957c86991883dfacf4e0e8a8f962b76d159843b82c8005f3a81b00789ee0fb4573e9150a65cc72ab145e272b4c952f7e9c9bc2770c78d64eedd78021f028f8f9b8539e196843f94164cd42ff0ab868b3bd0e6d30f3fb44df6acd35eca206afd0df5b3d2184499c57262f326fa4deb834b99027700f42a5db5c7bedec9fe938e331923a7ddb60a258eae5bdee4d044a36093ede84ab39879540d6e8f8cf5768a90922437adfc367d1ad40d936dce00c76d391951dc09270b2c6c209cf98513e3ffa7f33634bed8d29f46b48b1b38c20d374f2dd8cf8c6c7064df24491a4b6c6fc549d5ba428e2c62da7a529e9eb5525580e22524a268560e487c8ef339e156419521395a49ed3f27ebb8e7cf056a4866219dbcbb617e299e7cfe3fef12f79618767133df3f57e327ce4381aa069d65a73e8cc63e08dfcdfae90eab0d4c0d069d149c6b7c3d18f9c314396f271691eb7fccf928a76a29e13a63371cac6f3e4b3d35546768f9f3693a65857fba36246521adcc7b9d6c3b8467b72ff0e30314cd82fc75efbcf2d764bf6f9b25d9bc4797372041a3a85d763ccaa92d0f6da54929d3f386968f0f0246705463518795eb7e19f7c0cd0badc699eb59e915967118a8aac662f8aaf11cab7eb041b989b10156c24961453f7b34a18fffdca78913abdacafe1f8fc3882680f7ed5784ba07db1bdea0ecd2b1f9d4c14be3a05a736834a817aa859a736cc1dcc9c9f2e96ecddc26ea40ca34fd27d02e34b3fe473d3f660dcd25deba09941f4a927df9c5ca9012e289c37532312346bc192bb50466193dc6393642287eeb1deb98db18dcad5d4970c081cbfb206089d58787c8f4cc863e0e677ca8e11e6e1f9f87bff675f2925c71fc36a36e181e2fa4758cc332b763252fb038299744ba4615919b12b05687548a800e3ee54f56144d24fa29bba55f0cfbf72fd0408e8080dd20800f12dbe0b812010ee8f01c68d46ec0d6490cb7658843a755d5e83f5ec423e11538f9aecd8c1ad9b125f011c25c41ef32c88eb102ddb2b7ab2a3bfffb1853532e60cf8d5c3b3e451af534f151b9851afb3b36cd9ed9d4fd1d5757980b46d11e99fe9c29ebbdc75cf439611780331f84c22be345574ad57c61be93311d9190ec073e076654e702e37a11790934f9be0e9ce29559d7715899fa66e9e2234f76d903e6aa47d89b14edea211f2b451725ca3675ba4e22249385d9500d610655828873c25d6f9e475d2237a157d19395662adc815e4e3ea7ab847e38b636779b2ba3cb58e88a19bc301e5aae55f0e171bc9473bd79428533d1b0f516f779b569dd9779a72223a4c063ec6e396f94251f66fced9e552b8553e2b5573e7dcededab884954dacc513d93abc41289ff4b2dc0009684a5e84e881775106f1d35de7cb5b0b22515cedc2b4995ec8a3c41f04db664fc14f6788c7b878cb320ffb06e20f10ffb2fb28db95d7b6fadfcda1b6117b91096d00252a4a4410344589f7a1f319dd0cdd813469127f60b51d85e101d6e1d040a5e770cb890dd19ccea474486bb37bfbe5507267a5eaba4363f333b0bc87129279f76b78c0a1f1c81a11746974025f5dd9fbdbe9226b98c775ba72b53e823ac54cc42942d497db8009af3edf4881918f2de62da7db42c7ca7775455cd190b71f40e76ac4157babef0b99284b363bc4bf04258792563799f9830f5e0a8304295837cc12b2586792371425f8fa7e9c58a5826444c7a0b0d5d880942d95f17939924f2861641f13991c42509ac854ce3bbc83487d9035a16927db510f0e61853c674fa4ce6cfde9e8e52b6170abccd5393f89383ab4efce62763ae715765ecdffdda5a2d62f245c8eef16c2ee531afdd986ed8b4f6bc84b1e999bd52b4834f391ebf1dfe5011fc36cea19ed5924145916160af810429dfe4e7531725a7bdb0fc8ae901fa2d9518f607ef2b92e7904b122c365eb79e4afc6926e39fbb9b42ccccc2828479418df7ec140900163325cfe49c3582edc43107c7ae92de11c88de584221ac8b24a30fc732a894b7b6c1b2259e9c91a358fb0bf662d955e2e7321088ba2a071ac1db0f6643e29ea6b27e0504e82ac4321d6552751be79fa0a349d030e72b3b1ccec62b11fbbae2dc9a0e9dd74e43c19cf8f33483fb098b49b35963a13f0f0e75685a69b78842a7ad8d12cc46eff3b363fe4838fd430357be331781a4717593f7789a87f379d22f550bc685531da36e61fddd746fe17f7beb7338741949e066cd07de19b682e69f2e0d088e6ea478d9adf7fa57e4b039fd75ed7699f0fb07cc17b2cd4cd32b4fe099f0936f2f0cdd314b1272eb7fbac40aeace6cd913a6ac8614c9c57d3c84eb8820aeda82c930fe17bf05b97957a8771398407d9cdb579c2f400424c9300eab779c9da049d3b30df810fb10dd63e3576fe1d4321ac3c95791f6dbcdcfd11e0e39c429b002ea35713a23c2d4762f7619e1592625b585d5e27a0af1a92e4620c86f78460b3e0dcc4f22a2fc178b4294df3da06ea3e0b5c4cb5070692d3c3593010ae14ff34a25aa58a9d1a7bb0fa6753d5cf217baee55f73b0673c8054ad3249d117f6ba6582a6f5d0bb1c31766fb1bb03cefbaeff266ad15b510dfe7b9fc0eb0bae5cbebc806895fcb1a3b25b0a2626e5530440a6cf0a0c643c17063fae1b08801f16f30b4eb284f782d64007debab66960703892f60a3a550049bdb86f9ab910b543611d5c25e2bdfb6e1f6aaa58b93b82afb5181608b36ed2f0c7b3906e9f7a6fcb5d83faa329fa1d704380788825b6b04cbc6ad5bddff8277d04d4a9c0c1642a928622cbfaa9e9eefc71b81169d089fbbc39fa61148f773cdc620a39df07c8d0d3a8bae53f826a4be852ee5b25354e986b1ff0351bb76664c85b94364e8a998b2c7ae1091bac3f72e57992bf2409128907a78f7251620283ed7385325b289b397c7cb4679de5af7f635faea37870507198591df0f696f44bdcfb0de119eb7ef8d987eeb000564dc4bbf9353fe6f08382ae88d66c3e91f3d28d999d043c7db3bbee35e1b7bd85f35aa472b5e785a4bd764b1a0fca1baf081eb77545f7ed1ece54a38e916ee7bc605ac544c627317df9e503fbe4530af36865922ba6686fe42720e631c110fc0b57b81585fa4e6df2387fd60d18d80fda607b270d7788e95a54b39ae2c47ff328b53ebd1281a76fa54cab9ad76be1997a299b01702f8c2a0ce34e41c9688bcd0abe82e2918c3b5fa87ccf4bebac7c81b04a74105c962b7bbd1d9d48af849b4f74d20669e6ed6ad47e855d91da2f4a829d254f80160743a14892fe454dab7d7c9f9b5ee377c72f83002e49ad76cf4436995e579818869ddcd013595ea6adc44c82f37a3ef0a84ce2965ed8f347a1f09cbd9415f7d82e157e07ecee1d306f202eb44ce32f1611536d45ec3d7e82981de626f13139ca6db85da419ef0fda1fd291904ca1d646283a709e6edb82e00124e6a8af8008e5fa046106941524698c0c1ddf2de76da0d2effe8917220c8e36f6d53a3339c75943670e5ec33b70eaa12a62902991c5d5408626d6656cf717883837987bac85ee475326ba77138f1985c52b3545040dd66eed48559585856e15da969899cb2c699adcab0ad34d1854e9e5f32aa4dc30d38593d340abda3391f0b94bf713e9ec788e9cdb31419a8ee395763207466d788123251e73fdc35820ff747818082996276e957d4c0a368dcd671491c4ad94d4ebb30060bc42f3f6df3635bac27559b0c17940d5055573061ca4b20d273db216fc1eb791d8442555b93895bb7cfdff62eeb45ea797cf8d4cd27feb2015a6f321d6cd7a56a25bb80b6e478b2cd76e35600cc0f485d429bcacc87fffc56791d5ca649e39cfffcd3c31e795eab6defc63c64b40123f9ffbb4a50210dd5547f2f039a590d5421eae0fa31e5ea3e770726a7e2cfbe79ac18692d6c6450375ac328a2555d7cfa6df60d903ce4ab7c224ff19a7f0dea9bdccc1a21a5449fbe2f76bccd14465621ebdf47c38db30b09de3f2e95b777e9c4bb2cc18c2ad4a526ce71ea9685e0c341812e084301f80314f2af12f1cc5fe5b172e33d1548b2197dac82d3e9f979786413f8538920172d78ef7c85444bf63a91e18f75cf83a50b516033c61a9dff4daada0255539a3423747e690d5e3220a4213199fe8e1d5b0a15797e9e3adb79bc324701f677e51f819957cd71a55e7fdcb5f8892e67bdb2ad51c5d2b581f5fcce06aa34de5693ca72b3ab99e899e3311dcf94861d7af4970b23dcbec542398c2f6f22b43db68d250a5f9ed5252c44407b0eabba51493392ba7d969a13b356c7b916cfb15d08f462815203180047a6f57aa8c6fcea2767b6a61f35d7b3f32e3b282586e3cb630a7942f4cdb6c9bdec0cc1fc0d31974759391b19ec2063bba68e269182aa4b38390973c5e389211a65c53337e4517ccbfac7e4c4119658ed1d3461be620c4a3c171e69a94ebcb91735b12e604fe1e8193023942bd39915cde7cf3fd41dfeef563dad737188258daa7fc4537a925aea3f8508899e319ec002a7b830b8f509ea71ae30a928c76c187d46c99b8ea1651d98bb236200e3a4fc11eb85339627c17de5c5cd6589e3d2fa6222f4f70a5d251d22766c5e8cb6eb54cf86598d992747751892db67e959d0fc1fdf0b1749744ac9c6cc945463e7e0994cc525d4d5051b2dad521b5e313a591ef7581387a1bdb8ee55188e3bc606d9d5fe072452d72c14cfa81510f5d0612d03ac9b73cb9d953d149ec27eef2987cea5cdef134e129e9bb309856ef3fa52f892646f19f733d5608918f4053aa8402fa77c72ddaafb9eb9bb232cb57dfa044127b12844b67068b58463d0844903d51dd86cc399a6e7bc4e7002a5151f7236239075da5c91636cc44e3856b667eb07b1e808222ed6c661c6be7e0cf25273dce11772d18d26fa7ee73476e66ef4b1fe1ef6f58573fcc2f06894f2dad62a498f1500d7bfd4be2a93c432bf746f8f3f4ac410cfa45fc5695729831b34ab2603cf55c2609fbd1cf36715b59f71f987818c3f019a3cf7fcb37b19b4076e8dd2e8551bfef84c3168b04f7d1149af3efc5559a48887020884fc1939ac12800bf7995e062f84aa371c4edca59154b31e23346b40f853875120ca038fa30031fc41acf6d6924dfb2f194e10e1590c1a0e6cec358a7beef550d3e8edcd734806bdb04477d5b91bcc1af06af196d2f2f7884a3d516d8e3a9803e90865af9f10b2c18c70fe05f147d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
