<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b0e46162e1bbe56b8867cf75bbccbba337714697d3d5d2cb6d44f9069647661c11d0615e3de85baec10a5a515e0b7a1987008a5aa5cedf1500613c03022995ff3246c1619c6630e6d9c92af858f928c08efa35e883d409425e5c7cbba059ab126672ef8b779ee1ac922c34994e7c6b8c9e3797077f389a4930465734d6e3e514c659acd3c26d85694a847a7e33ddad7fdf90513f9d5c404478559fd1903190bc0123ed78299b4dbac673d10431b94be90f713989fe932790f9bf0c591641e49426b57447e02dfe1656058c1dd65ee7ecc4998a89a0a741ec142a2e4a8e9dbe17edfa2557221d296f0a02eb0fbd594281221ccc1465dbba8f649bb896b81ff98ef019e237acf716cbe14a71829f7ebe19eb14f203130fa80bb618a90e9f380c2e2d13c9e7b0b2bf02b7a5e4ccc69c478557575cfeaeed904f6366c36b2067359d36611e989ffa6085ea70a6b70d962a3d0263f83e0e5391a56094372ba85b45d7b2d76d1bfec89aa26350d6cc88611b55731a7abe1124ceec2385af0b6916ebc062b62551cd20bd71ca4887754a4dbf1ef725c26e2612c0d0b2e63095a8e94a273a93ec7c11faac3ef431d1cf2a4c647991d23b31b792a6ae7696ecfc29d8c297299bf12b288a02103e2ce84dff17b99473018eb602e3d85be8d740ef54c064d9ef5c5af016e9ec3596955445db03dd4b6aa3b4d80fbeb6740f33d722657e89c8b06417069aa642fcd96d47e375f3c516d800f56b0ba8163cefd63e4abf108972665eece1d2edbe6cc7b17af62470cd7a92b12f0e1010b04f894fa9e46fed4f4ae7c14d2c04f3a284b0752f182b51723691c65c24dc903fc9c2a4130b854726df6965a59198c05421a35b32fe6d808f07f386777667af89c86c96c813bc825952786590569dd3295aaff233ff1e41089826feb2d767f2815eb1b9422123e86296c0f7800536bb7c8d86de9df78c716bc9974add986602541aed0a0f090c5c320ba7ac85099d6dfd615c79b8b67b842e94b2830ac3268ba662787c28f115b206e643d496ac1e5dae46e0b982580ab9767a5043f1a5b148fe0d8866c54112ba6d0d6beb9461638b8bfede3c96f7291d7658ce32db105cc6552c1a3fe03e74f3d70c1c12636a9098e05effa681863bfe549255d8101587534c348d9534dd3d8d5bbcb1a14cd5673edb06a4c199f4677971aba3dddc72b6b84e28836e7a585d79e21294724319976561ee9718d60b7e167ee9128c41005ea70c1ef7c2daf258f056460ed0e357dc012a4fad6cadd5ddd605c9672a6c07d6f89429cadb84887bc7834bf1e3257ea5dcfca167054469731353c980b8c4ceeae6ad0f7c3ebbf5f10f271eadec517a22ee5cb072568a47b030bc403a43603b432d2154624a36ce7f3c4e0592d784dede12edafd601790b59deb3b43c44cafa58484259008392c8c7dbfe4e5e3a63a420a2bf7a9a799c5c7acbae732a286a2774c29e6a562afe0c5e1129491c5cb6ebc15c9025a562994ebe74bee1069024a2e4b78b039b2019df53cd19062121595daacc50434ef73e53b4fa49cc7191010473854b2335b0cc54b59f412ca65bf7924de04dacf75b96bb3d8ec6e2fdc36087b008c1652fd49373f7ffa64712d7fe5191a5d1f2c067c50fe9ac98d3bd604da9c3304d716fe3770ed7538874917bf1847f57a60e665e349a7f825ee154a7c2c6d510c5eb0b6b5f09817cca949a4e81ee3a98a82c5e8ce3792cd1cc31b7055791b6212a9160bb4e8ccb4f2a722341141e2a44565d1934588ff49dbeb78fdfd42472bf3af7daeb0fd4072b977619a364aa1f16b3f92537a6dae05c7737fb9742e53854d18fb7a1c0d894cda8dd8193cf0333aac58533b8934febf52f5e0a6079e1777b2d2acba459a6b7945ffa6ca035a9e8a2039e61706e851b9363886f7355bdefba11a38d311cc31b90fac6e100cf02cf53a9aed95e66a986c2d9a227da4776c4c921d62ef39edad279ea59e2aaff55488a284c777096c9281f56959a12cb1ccdb99a2abf15c9c043badbc4d326fd7295b6908ca9fe225b6cc62f43084c777a75a1888e45721521e6ad122d978ab28cb5430096747af25ea5ad07ffcae76dee9e7f8724014360e41ce8bab2deb136a1aa0a9112854cddd3f8b90c9e25aef58dbcde77de94d9671db8495a4732fd93cdaf03bcb99055cd219294b33a28e1e64ebe0bb8624d305360b7ae09589c13c94c1b046a2be89be0668573a0feeb57aa24085b33fba6b71f33d930eede8492c28152936c5412484d8a3593de4a253c9eee42249718676fa1a85093c14ed3bef814ea3a4c617c5628146ae1528c666e68f38ca535c24aeeacf64083c3f1f7971fa4c5daa77cf879dac6fe3d3459309a622727a4716bccf11282e292a2ddcdf853c3a0b51f90f4742b3d03185b4564e439592caa1b248037c39e2108d412272c534cf2cb6ef36d11feb95a67d3dc8e07125907803e0ddf00c9f3088ec197633305214366ead5af85f83be15f09af90ba661e61d0e625fb2553eee940206ba3953129df7b5d7627894a812e04bb0ea9e6d7652130f0d46d2be1555c270bd144db2de2b132c0c396458392177a017beecf3760fdb3f254bc702f28ed1548dea66fae6a35ddb1bc83ba2d602f0c8569437fe4ddedb11ced60838fa127e60b4783ae56317d9d03541ca1a675a4238d56a187fc968b6a1218ccec6f88e681c79779d152366d13b6b7237629a7bda7963644b76a8285bad470df0a53e3d6d15d934d60b0147b0862d98236d4bbe2a688c25e4363aab9532a3e95f3c6dd1bc22323f409dcd4d8498bd90d9ec09f4ae1da965274eeb8c0c9804b2aabf3c9f8cef9e1bc51767ddc4096e2e782558f92287efe5b6fe90c0c1fa60d63d70dbdc54a77197a200aa388f83dfac6bf484a9c3aa57a2198b22dfe7839a06fa7f19305f50342a72c62a78d1d2ccedd23f61dc17ce50744a417beeea23d2ed29d9806c4324aae850921f16d173402c21a13b42cc4d4726469f084a3435ca9ae1dc9f7e842a6225bb25de07218dcf500f3d191810d036c3ae07cca1d7efe01e6157c983a4ab3385dfafb5c237a7a683f7d8564418d7e2de02167287d525ba9465bfa761efc8a3a4caeaeb8d6cdcf51cf5bce8395e06a5f1eb7b84f4d23af22e9d66d7c0887b9453146ca85078664c535b139cf8fbf4b8050de2ad71021d128c514edbd63c3e1d644efb033a12262024ad31a4457ad55385799e0ca4b42a32bc067b673ce312de905305b068627a13a5d5f5ff3dad027a7c0cd6906d6e295009798ec1a0563d128d380b98633e35ae0169c3f081c9f8a813bb9b33aa428613e455e255bfb148842900530cb8029082f7845e50be6787c595eafe470a9bdf79c20b8bac5e0a6f44d2570bed677b19c8b6fff248747371885d225d5b62a66e38b345f7ba4535bdff67164c20040829a0adaf0eb15299496d8f3a220fefba968a1a7e3213377f2357d611c66c51a3bc5a37517fea5aef8b85282bcfb8f12c7694908efa8c8597283eaa875c52b301f249570c9dca7424e7eae68bd59d727ef5f1a51dc06c62b878d49a95c7ddc11ec3e01f13c73ff8c22fd8a3341af2cb5578ce4dd538ccb3d415772080f81637412508e5d656a2efc5c7b2c3ed4a79247ee085a4bf853c00daaa279bc88f6aa54fc4ce3392704d09c84d0b879b339270a14889d171c2331795bafd52afa0f9e568762f3c1f7d3a88e3d7855db8ece7bc119e474c6d97a7abcc626d0087a6688f24515d289b34b15678f0afcd54f31eb64d8dca536e29d39216c109c086f5cc1b593ef34f66cab8d3f6c739122371fb719462d11c5849bfff3a1f60a60b26ef02ae7a6e031389331d2ef54f7da68eb65d829a53a6ff287c895bed69f3cec5c5a8703bda422185294dbaed0a3dbf6ba3b5309845e310aecf9f0f9b565153af70c11b1f3925c3f230d10539d181c60e83ed827f69b86c1098b98333fdc01a156e6ff229cf217d4dfac1db31bcb3a9f3fe707c88ab9660463e104fdaf9666427f5b798d8f0bc52053547249ce793f39937b4cc3ac013566219814bdd97879432c1b2ef36f89189a78a3b215362459b8360b590391cf990c523786c1774816ef0863ffa2d30d11adf7c128245812b679916e24f436a33df656e51a62764266dc1a30edb08f7d2b8a431cc572df6fe461e8dbd3588b105849a63b025bbecd6b4e148d25f21a25d6a7c6417e10f062d743e27408257717966aa5c8a8efbd4f09a75f63d83521c588232a5a5a41f01e3c50b00e3c847eb089b5f133c9f01618575f805a1399f4a5082e69568e738350206421b6bf3d50a595f4870a3f33bb3e7555df34a8d45c8313b47f015affc79a2538dcb4fedfa4712c6f6562bca1f55e759141ffb7e49a77f4e5d5942fa9b20ba876ad2ed233bb7a46297c2a69f4b74f6aa28a339512cbc451d758c139b342172b0e58b9516b88fd3c2b68a4162222897139b3029b30aaf5d924ef6473fd7d7452ed8769439c5fce9968c41a9d3f19725cb8c27ad75a2c753a80180b13def0a87774b4ccdbd36adb757b984db7d7593696a62a49ab6a2a793e71aa7af49a919d488b446945027d842b1852eb93eb2db2e83b22ed2488b2300e0066f65cdb0116b4d5b5dd03cf8e4cc2e3e79c319a450b28f36ba8ad3f8e1fe70a045bf8ee81fe8657ba276670fe824c46d5a06c4cf20674ed1a95104ca301c19120e79bdfea26df226f4fc7deb1d06f643df4b18af0db63d37a679b6840628601d3b3988099ca55a4267b91d259e78fe0462b53c87f1a9adc0de0c7cf0e1ac55562ebe752a67330ca8e4543153088999e7fa89c9cd9ddc828d584fa2f131855c77303665724186a93aaa89afbbb91f5ba70649cd3015c969c240916d3176c903a1af1c3293b1734820ce0d593bf0ed8919067ed6b1f81459db8c5132fe0f6ac3ca2adfd40d7d94026c261de94a33f0ebb2b80e72fa35c0e70a8f945f2cb5050ba2e2a690dc167329f19ccd4994624804e6e445bd22284e811525bda3926a5a58f58a9e66214d820452ddf97d951d69a24482cd360bd440cecf358b93a6be86634835585fae82da43b0dc1ee40a3fceac0e19613115fa916dbb512a2bcb8f5eef019f6cbba0e8bc53266e0f17c101b935c98d8daa21e7c42c0e3979118e9d2e2f7714eb3a2a60ec27d5485a26ff9d3f1abd0bcf596844b3676b0da1ada66b098eb0ba6c00bb78a024848b818126a7d6a2dc09ef84f2aee9e948df4ec988c21b4a4d56ed3e95238339bd974649fa57d2b9f580999f1b4fb28c586910077bab9343de6050d9ddfe117e69af93392badc96cb1c56edd61132002f4c8923e19e0cb62454bafdaa1620cba0dfeba9db9e615d998a38a085d9a924541ee0425db3008c467de25e4217ba62ce9534cc2087b777116d36a9953d6d054c1f659d49cd750557881a4f8e3768fd385b368d33691e1fdfe41ff93919d9c141332b9b777e8d6c58adfe1862646e30e77671914037bd4438839af9b898793ab2eecff26f9261c068af6ad5342f3e2ed63bb4fa75b4ad894e1268680bbd347a50b7faedeaeede056b51235a5508e7c46b842b51264cd6572b5d91566b5be20062dc3d10c9f9b9a3ad6696a1747ae536ecefbc0ad4f4f3fcd20b2966559c529cc96b5644d9f2561e44efd525fdce81ca8e7a084e65b789d1c979bcc8e696f3342b68289e80f6150d5f7f61665fc306c3afd28c55bcb4388c16043fe630af20a642508935eb651e82301b682043a5990a400d6de6addeeac54b0fbcb4db832a63a4ee8f0f92d2d0000db714212329681552ea42f1d64b4ca533d53707d4f4cb29bf1a8c01668ce04832d3bf21fa70dcf44e4b93af6616987584d6d6a786ac3692e33efa0c3c8b4472542794ee95e2b83ab2f44a84a55a88ac59c14ee42c92570ba7f4f8b9598aeae5c6dc8212adb98c6b10bf0712cf6ab27cbfeae7d5e651c061730b9bb8636d6d5b18c508eae89d3b68594643b0bae1aee9f03580c1e5558d9e254a60ec7d0ce0a6c80cb0ebc647a0d140682a38bc7629ecc370097412f0168aeea4216ac15d3995471485af07fdc0e20d1e39c2469a376955e2913e917fad4f955f3daade2d11552bdee4f818c4730e78a77b9a345edd43b080ae05b800121cb101369b989d73142a2c2b783b60b5254e52fb4a9ca2045d914ed4b3d38dbabfb6ce315823425951a25f5394cbee302902dfc151d93ec8c49fb0101b4c0999712cdf3e9884f2da654809abb10036787b3f9f15d9d46b162e058573fe819ec85f259441ffb219c9e074324516d6812c6f8e346fd5cac68362b6edd7ad35c0d34a190d248506251685179f847a5c5ce55d94e6e05a7cccfb7e105cc7cc183786af68c4f220b03c3b9849fc4f7d2b8ef79a197d6af6d44f237f52e6e3c53cbd7faa3463b52dae218fe370c04d0797b5c7fd3f7c5ca2004dd0571ab9847788cdb20b56c400214a28e70cad23c99124306651385219658700869fbb8560eebd85f434902b0acaf2a246528f79fe8128c9f839b20386bc87b25759ff4a1c72ff24738cc534d3cab1f89d0e6268229bc40e6040321cde5a1bdee4b3c3cc4c7dccd4eb6171d293c57bcadf20f1b605a9876cedf9f6546538e619e535bd5dc136a672f09f2ea4d23ab91fe2a01aa270bc6b8904d11595578abf87cd2d88a56f32621e12090ba09b2ad97e6309840d0974ca92b04dee60fe4a64b2c3ab29b5e9c289078bccebcd763909a0520f528c520e819477c3a612cdf79aa792d755a9b8c1fac8bd0e9e8c4daeb858adca8f8955d325204969eba09f7b116dd428ceb855fed9e391deaf1684a91e98b643ab2b0666d1e138060cf744fedc997bf653003be9a84b6b1befbf451558f271c990010e00f2d7467a93f099292ee1ef602a4faed12e1145cc45e507bfe6d1ebb30a160b8a9f6bb1f32a4c4c25c745eff91be67f8f15e2874ede2eb5ef88aa7f237fe9b80ac653635d4bb67faf002bd4b87ca30208dc37a9b5bc172a8fb4c2af5d22cc75495f3792a1c571f5ac3ad226481dcdce3158ccdb7f05cc728b129eb7fb0d996aa9347fb93ef395849e6cfb009b8ca1e1e804e5bc5fa50c198ea9423eae00b863ed9fb19e267972cfbe804b8a536b72039f6d485056a884839b82838122aef191cf2c99238155801e18e86e9c43350f45cf4f766c30a6db429338e141f8f382fafb943dea2ff30d31f73ad8192554a07c27a1e6a249cdb214d839c70bc969326e88e1982ec3ffdbeac634c1bfb7f2a1c7652e2416f63f419009a2fb34729aeca37d4ee045deaeecc5dceea8ec0ae9123afbb83b9002bff1c578c479ba02ba5a91a3564a021d933df9619421783db96fd6a1f881521e5ebb3fc4723938803b89561914d88b60ae57caf3b0e77de022a15ea47256877def6f30c96589f948d1b8f1ed78898c8c0e04fe789801acc9bf11bb39280ade544ed2d28ccb7f5d9bbd45e4cfa9da62bbc7d736e0064a23125e9887d7d8a3188399a34a42f9a6d449d1bff5992796fe01bbdf2cf2477c09c7c7ae84e01dff956d8901495338c2aa479efd564a069f35a790b1c86cb169898ac7b303a786e2fd83d942ac5660ebbfcc3220c7e68d6d996fb0fd0ff6668ee31ee5ebc774b4df62a878925b8b38ac38c6635a3a41321afe94915190928ef787c0741add997865c83590b37b3890066a65afa123c777d9e88ea9f0b86064701a798b0fd8c3c1a5b4cf910be0759baa8b6e31d307b60ed4fe081eb55ec3a27c65334bcbf32a82f5f183c51895c967d8cb35fd5e6995388f82fe86180bb30179fd493ee553be5dfd54a6fb2e19e0478df5b224a2925f96c51c374310aa6006c025dfec68848f4ac45ad9d79a60880ebe06840646543db75b5507019684f10c4e92cde59462d62fb5cb5608cef622929e5e73c091688d284369659574374917ccf6615994cdc0d1e683136cf08389e6087970c3ff478465326f0d28a8a7b66577d0c87ebb434944370bf715d925c4032c343b2b9f3b580fab59b63f08bac552bf0c01c227fa0099e749ff53a446079ce29598c6112cd4c4e1022b1017c4ef93d202b7c22d1174fb83961f6efdad557b7fd405a36700134ca0ecf4c494cffeaa15e7ab6bd2449d6001b506d209457675b35e4ff42072c8499b195298831f8558bdf53a72755b243eae99c888e82b4723bbc247333af1d53902f3b7d76899b6358deafed2ea2653f94705e49430bfd7ffbb3102392db51fb35467ba3ce0d082566791ccc9d3c384afecc9690daf7a53603965efb7b0465053394f843f50be3d991a86305c137946d5f433ff8785afbc3d47cfbfe163643d349fcdd1510bdb6dcfffc553e3bb6029c34984b243324e503bb00abcdf540453bf0e997190d2f03486ce4a12e63359572d830a8a3bd10a2520087da5da0af19f12ef0aec6a9fa6156b586f8dbae6660314a7872bf83f6f84aae0187621bed67da9886564356e85c8c3229bdf6459a96bd1ddd675ce760e31ddecd762dfb64289a035c0d2dc1f3b3b9e06965bd33c485a7d32ede7b99796857f22ebeebf7e8f5acbb2c6c1b781d0712928d74e27581dd8a745fdf7a26af0ffaf44849897211a27a882490ec9a615b4e1f27df4a13f76d5ad0591aebe932014d4333dad5133e72a88774b4815271e1592d9d22a10aea8eab579563c940f788b0bc17be99e6068c29359f77eb1462843a6aec0793edcb5eb1e9b0c4ef7ac3f33e00a598bc764682bac0878b04135f97bff8f06cff1c52c3d8a903fc1018fb9d253d0fbd2611ea6c066f4727959e5f096180e922e67a09d3af0cbcb475e585063700c2b82abb7a94ad360e5d2b57cc16f55615b9c4529a9f83840dfce8f6b2e8e7f4855ff62b33e8ad499c604ec0418e6d611fc0a93210dd28b330806e371025f6c1d64a710b2862b8ce4560505e6849d212fd54f75b176f708dd3459928fd4faeac143158538baab47d19e9737928217dbef86673d9a811a2c42079ab010b3998c2b71722b9dfaf84ec861e5e927abedbc17c4cdc460436d384707b23b3097057e4afdacc076e388d92c1508805ace854896bfa154283e6bad9c30d97ef52dca76467310ef2369b75d11d3d13320be9e1ed4968d64bf73b9c478db4ef492b17afcf1f0dfff11bfa85d9301fb5cecb45da0bea4058389daae640c40d86e8a8bcff3edf695d7903f050f0369bc48c1f0aeaa4df0b79ae89e63549829f8156d0cf3bf81b14cf13eaf13a6e60b758033b5f91a93f3b14b55786d1d62b783efd70759fb4a829cccb8c8430f084a9f811a788d6a58bd4d3696192ee24cfdaf6e3aa8616619d5d7e3dec3d4eae07b4e393472a903c3505c579c874e44da41fed3fdadaf88e6edd00f96e8e81ab8655e1b443fccb67ebb3217abe77e3f0e536d5d09d4ab09290ab72f0fa1e30398a5e8ada1e8fd9844332d9e8bb30f33237cfbb77f4c877b8b5dfe7840bd4d7edd0e8ec3568e1b74e68b77bb45875d2fcb893f07953aba28a0bd2d1d8f9d60e09e9bf2422045eac0c9540a0fe764eb90c65e7587f79607cf142e3e6302eea3c8ed72ffcc5a46281261f500c6f659e6db8868ff4d910c31cd262c98646e92e73a1a53ce433155a8ce4bbe0a610b6e32f2f38f2b8a0543f9185ee677d28db74b3e22d2b72dfea4f5e2b4f48621fb0885b32788398babc1acb59e6c7a75371abc76299d3a8613ba629b7813fdd58f0a896c6cfb9e3827b8b653f06729191fbad939e5022688cc8a86628aa98bfc76f6b0c03b27b9a4a44ba25328c90ecaf99da0a53f2d098776db1f94812196939d7c19a5dae32380b924cdb391158e27a3bada8077b47a5031204ebbb55989731eff85d91df00158ac3f48300857b726a94298018577c4607bf1fdce34f993b97cf0a9f18cda21e7e83a07c9584aa71a8279abceb3bf882940b6f388239fb81cf7e57d7fff659ad0a9637ec5ff68383a33d7c5975d8d8aa72d5a25cf93d64c80e0bfd0abf66d5c088dece64f4f06e0e1ef2e5db257781d44f9e21ccb2c7e5b4d5c653a9b57ec2b9854e590f239adb292c2aadc0ff1e9cb395e7f7029d541ec83f2d1b477f16e9a81ea262e00fea4f034f90b652b875ffeba81ce92e2ab1ebd7f5748d0785dfa89ca24077ca46baa0ab2c443672b39c1da29f0af300e87f940206809e5ea9f01d631916e38adbbf8426769017d0f9ab6181bccd0ef0be79aabcffb079c44af7a1ad1ba32e0eac0cc48ea4259fc87ea8885b233adf5102cab6850a53965c45b4b0a555b346c84ac80124a9c15fad163e8de45e4772009b33c448f5b73bcf988af8b8c16891dcd236a6cf3d697d31feae8452f3f1da06a17609c3fed86423227f22f3d1277bb6664e8b52e2d81f2f26ea8b949520a3630d6745a143584412c281497b06f64ba3bc3d778ce62f2bf6d64e58edb0fe58daf4c6a1998b1257db668b908dabb4189553e2877160301c8fb8c9ef5cb0d847d20d6c66faecc2042bdc169e0e69ce0908293403e83bb51902385e4c5982066d64de6a1e9579425cb1360893a0f8341c4d3156ca3b7ed19117b08605a2d0736812c650c3be3fd8508b4359286f10a1e373b3741ac29fd1d91eabf2c478a3e5ab71e7e43094732c40533f392201aafa7bf62cff6cffc09b74ca7a47ff9bd5d5c5c3f6d155ad825d64e1408adceb7f1d3068476c922cc720be906eb2318fe2eae3742aa07c86b105a1f90da345b7fbf1ccca3561ba9a268524e599872cd4a78fd5562c0a9df5b2adde910afd08c6aa607d6aea878ceb6c0ceae63a84843d4871f41eab412069f245f7f99bb92b4210713a2f9f43703699b2287a01adc927bc8c9a63fa375a5cbbce4f2cac1308cd11d9dabd0e37aafa4de9c9dda66b75ccea98d73699b6a5ff97fb7f8c1550b9bc9abe31ed134d3d8ab4806b41414cd0e2a5f9daf905e3acc4d7d7a744f75a325855db5bf776ad3e32d83427e1cfb83e682406cb3ec78fefd3868e60df2dbf02f48305148921cc62ac8bcc0574fcacec5cebb2c938e2d6ec8b892206d584451025c9dc38b65deb990863ffc63a6a509f1cba490c0f9d57ff02f442334f74b63ef7e7972b8c8c5be16defe503297205e5db3a47849dd5bd6a68ff584b524dcf69f4e3a4fef6d09cc79e9737b8520825872e76d625741876ec6f3d7e2ec71fdc7f89ccb9c89ae872617016728d97a25a51959000549048147392a2d0ff710df751518d1a66ceae7e77183fbc02182fc399cf8293fc750e3fc362797a9b8cf128327397826d1f00ca87462064f09da88656eefbaa00c28c19933d09c7e0c536f546985f17f40a80efe07efc83311724f8f82ed9ae19fe7906fc8b51243e3294b602b3c2274eaa21ccf4da944cae0efced350e3452e2ae8d6c213f189127f4ac5787f74e609e6928d23553979326ac6e0c6128ea49516a9e35758f10247482ca41d9f1b6747f4269066ce056ea149adcd317a08c066c590d5b62c0667e5de93a330d5ba1b6ba1d90531b4b8ab96fa64f5cf382ad26983ecb2a37a50cc5c0a3cd8b221350fc75996f940616bcb46e18d586470319fb6dda12e354b296951ce31726351e031765a0a465035f6c792d8ca691a8379e7542c87bc26a07c43e196209522f88854374ccec6c95f4dbb994ef7c374efb2f5d7f4138206540154f040efc478689d8b4d142ef24ee1ded017112132352b55a96cb3ed20eb00230a404e052e8c8751685d29714eb35a27ffce76bb5c538b6b6382698b07cf47bf04ea206e7a8b11fdb327d56d0881bbce14f5039277fc404a9eac6f0448c8d404459ce49195dd6d2948c346c16071a68a8ef534b335bc19895e348f8e9cd7679554803a3feda376af0cc7dd1b6fb017a5072b2794baed6c6d897cfb1479735a04d0692de9b03d7e8017bbb29d7dca70a1a6ff8c97c7d0c5ebc44f668c25bb1fa546764db82658ece74bfa9f3798f193020d3fe743a423277affab04f5c53583dafe0aa25884941d4f0a6d2391a8e18158a12a0dbbfe6370785038bb09f96c98d96fbb972fca4642eff9aedfddbbc8351545f8f366da8f0c47cc5d07ec2bb33546ae3ad8a7332b9e3f6e3acb6df392efddee599a78370198cb76af999fcff8022cd290f1fdaa2c9b2c5c5caeb991a1944842e26ee156118463a4ad89d729cd77a24fe6e7604c1bdadb083b933c509122e41b0c11704b12d4a244b3ff8263e46c31a4b76fb2fb0e67fbcb46b21ccfb73e4100527c4eb222725ce76aadbe0aff5ebdb93c7d504bcab182ca6b4c6dbca8d9ae956eaa68ec6e122cd4c847e790c76b867cc9a672c70ddc8840c21e9f14f347c69ecd3858b8922c524b6b58d3e8b06dd6decbe4de1802047672e5c077f67ae6339c54159fd3addd84933264869a7062a08f4ddaf670aa58dfc5592080becc9e5229b3fff2ef94fdaf85380f73f91d3ed3c74fed19ac9c8b8d3571774474386c60c6939e35bf75310fdbbcb8e548590255da4caca6c97a5e98f8fc72934f309099dd49e755005546161794fcd34ef9aa31f9a83f02fdb6bd7775cc11613c3e744e515259d1edf609d3a03d2ae30c555a79d07d2398a2e235b657704b81b56855d5e6639dd450de4e38278a71858ae612c15f8f7a5f50d4a84b0a3661db007bca786557e11269185c568fa5c4ddb243e72374bffd48b26fab685d0c3da6a7ba2cd927b75608ba0ddd63da1723881c66d4994d3473dec24d937b205bcadd2dac5ac98758ace85d0ac2a41741ede3c75444d785249b0148e5beca6a54ed6d9b38bef361cac2a154172e4d26f1c792ff1d4ef3696a22b6bb3ca201dff6f727c1407f8cd206ad31927bfb3043bd00fbf63ed4bd98753c74815a2883f68a1a79919fa76e4dcac8da298ec1e01d1e3424a50b44c87bd89755558fed08941aa74713e828c822c4dfee6ca2c80bc1017b495446776020b38aed493703f23b7d337c526ef67c273dee8c31005415d18ad8d0b55703605087ecc1369537d56fdd2cde43bdf78d42a8a970bdad4c94822768620ae2c7ec39945d118712498901c20b2de836c94be717e453f37d5b5b1973788ac8e5e5bcfc195a64b99ebc9471160b6a716ed9afe65c8a76379889e4d08f4b548993d88504f36e0ea36e32fcc8f6462b83f8a4b7411b59b8e6ef4606e3f42ce2be91975e5bd99882e3ce11cd06b995d46ecbd1dbb2c91d09bbe01c21115efc89e68304ab5a9302c69ff34a737c32fa5072354d0c905f2f8a82e5ff03c90acf12c0ce1a1440104deddfb60265d3691193de1db7c6e229002f840abeca8e6909e33a45323376bb8af8eb60bdc65cea63d184ae52eb8f7af5197a7e305d4d7a9044e99ac56aba2b92164e71362318edbc85dc03170a365fc45386a736de38818cbbf6cd9e99c9b9336f4877435cde839693dfb0f61cd3c486ea968f9d09f9fbf6bba8edd87c5902229e03207eebaa7f65ee4ec49f7071921a45f919b00919605110901d0b37c0b8ff5b85508e27147cfa615c14a252e9f87d4a492e9167a5c14d3c264ee0083f768bc54af4610b952c0bef9e3e3e67732064dfe4395118aa19db0b97d467e03d49f65b52e8df23444d3727cae717c0ef3caddd4d4477f7af8612c22cfdad51f12a4ff0c0503edf7542481f48d8dde6b4a310b58f3f13543a273c47300f6f42814dcbfccb0bdbdcd80586c13122ce37a94ac5aacec5b88240e10661c1ec51e52787eec250d36f1ed0ee01fe921df6793f3d7286e8c8ff38cfde2e26f398b693ce201e9a159619e7e9fcceaffb4a78fa3fa767e1a74ca4800bb01545d76a4397098e511100102f8aa76251d17669596b8cd4ff1c4ccb007366c38d3635650a102f47e8cbd06658b2883fb270cb2f8607f11d9c729adf1359de3564fa6e450e599e0708e00e8179dc5d16fcb694dd7f415d95c7d50a3d81c3e5cc9175ea3d10388c9968ec466cddba8f662f968e5e3240ddbb461b0fd8e512dd0f84e1ff8d263646723f3455e5de65ab46b8fbefe039053ef3bd52da5b2560f9947d4aa004b3d5323b8d3edf554a21ee080ea234f90120dde3288ce7d11bf60035b59ac408c7330c9b02cd0c28e84726e6539e90f89cfefc73b3ae1bb6f5d9644fb0bd68c9831d3ddf5e0819c1b34da90161c15a6b153bcca607c7e8970446bb4ef655ee817240421f06f539f5b64ad4b61d321a620d154fa7144c4a11fe371bb5067ae6ee9829fcaa8b06f33485d720300348be44d164bd7e608c975133e3ce5a116061c1e2cde2b8f619ba53af552e5f451cb9f4823a3e18306550bccbf5d8bebe6eac054c34475e176c7e268ccb6f8708bc22841066211ef31c38415fcb25af6cd80916e36e1c9ad7e7abd0123644be71e04941059c01dba7049c913eed12062083d515a7d1279f2014c70b4b91d69dc1bc5960d67b892314b382d2290c2dcff2c1101864e659a091a3c9139296fa4ba8ce672b653135c821c31c9c44a5d5653d13d835635b06229141759fe0af3841d9fd3defd93c664ac1c7aa85b19c2e2c7293f8058015a70e5e06301ec40beea881d1eaa2cb0a4e67717d520cb59bd79ed4dd6aa487f4e5fd9d37b402def92e7701cbff0972bfc7adf502f7409e92d5f1048d6a644eb144657d80a64682518ff53c63aee1921c18eade7ca0f822fddf832f71c68991f32487a2a830efe3e0daf1c4048c7341fd42bdb82121b69c2878bf640682ce0c199c9865085c15d0518846630e9080e42272f8853291210015801641ad0a7da15cfd2a29ad483924480111f618d41f90aec4907e12444d557ab5eed3ed021514fcf9a6c483402006fe6ea99345952be108b23eb266e99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
