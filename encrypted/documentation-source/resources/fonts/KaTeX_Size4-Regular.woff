<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b54dc7ee095f41dee479ad085e5e7d44bcd18d21ed67f420f13293f046b2ce6d1435fd1414d7fa50d2691699b3580bb4128eb6424f32004b4998a90bde74a58c52efb7f313fa3232c89193f55e7a09d7b9e8345375abe56e12379fce85b526f2df5e8f6409389cc09547449dc65f42c9d630509eb366d1a994249d30f60d5c9b3f52b06844c87f56c6363e0e6b6242093088f82fb994f4401037274c3a35284d31ddc7f1c6d6e47db840f218d8ae5ddce1e4f6e9d268624bdfe3fe6ed2c94ee5a9daad82ab83a253204bda2ef52be34abf4d6e3fba1674a5e54a27723a6e9c805e0490a6c2817ba1019d95477e7a63d26191502a0cc0ce18b24cbbf80cf00e3e38b5238a9bc4aa38540d99bad358f7236bbee0d2277c58a241b1863a82fb27fe365f28dc18d724bcafebc2d460a7a8e5dcfa6882841f3afc00d4baaa6c1c7e123c92c2119afdff5957f3ce6e6c5e125e61e7c316d20b170f02b732c973e993bc72957b933c28838a4abb0e407062e1c89b54e0a38fcf182b4240c704af10a325b69ce4edba221f8094f46d70ad7e6f2a917d51c49d8dbfc25122b192ba2bef15649eea737843ac15997c90a8fc704b043d076d804eb0dfdf909418195bbbbaaf69b2cb9b44c5675689a1765e19530dc966a05116e1764b8a6751da2e888a1ee21f52cebeb524b0dc35348c650ffc8d8420a04faeda175725203f7c33c68bbe41714b5d546cfd66e661ab4835ee8690984d1f802789930b7e777ef163eea0f50f0c6430b618fd26ccd18bc2553cc5be3e5e96db1f91e060ff16c8ae1d04413503ae7cd385e9ad189a7d7d8262d46a55ae1679e6a57148d1962cf2dc4f35370a2b9a25a16d6d6d7f899876ecf5295f7a05874e6881db3619fca945d0e3fcdf9fbfddd7cda5fc44020b60eafcb3db8ccf1e1faa6ce60e715ef477ba4879edc4789bc2d271594a878c02c280891f609b4bf6d5cfcfcf7fd3d994d93af6ff31913a4ded6ad1f71a1c5c8a3ca8c5395cd5ae58c366c48f25b8990a20d888d5c5a3ce536cad2914342cad70c3a380c6140612599f3ac5b9bbb345dc077c7a41bb06cbb85bedaa4e6ae52308640cb284ecdd02ffb64cf498b91c66a1b41c9f0bc40fdc4ea5d6e80bcc01df7a124969475955d8f43a8eb0e8d63b9d0826a5d1ce89243b45eeccb19aeba938bbaa7eed39b8245f7024fcd5d5596448d34fe9ada4ea25bf577b0446b8337fa7c37c6e4817d2285e34642e5acb9a92cd414dfc9031b52706b0580969ec8bf976ea1755b31d6f8683beca718b23f11aa1966158e73504647c4d5c1d4835727103f0dcd23681d9700c381178a02f890deb2bb75fda72b41b296664600a793c315e4489c278aa5b5e6110d601112a581b4007c18ea27a3f518ba0231155d0bbc18d87286959a8c22766eac15e039a5f60e7e1ee727014c7ba980bc51466affe60d2aa0ed4b2bd8d532b5dceaf6feae7a7e6073fd32ebaca245c366259cb83667bb75c7592c149ef06727b136498daf3b2f442e536ea1599d3283af3c560549060088e683483471e554b62f37fc6a70b3b836626a423b112fdcc4e2f28f881ef29b018091a3d383d265dd75ceb4c00cf52b00927c8056924d2525800889d8d4bac807b4730ca79f444d519b6e21945d2e1e717482154e63b6bb1abe6dc36da4c89934f9906fc5794830007dae56d154461d36507ca705a287301815f9157bbbb848ac804c9ff0c3672c08c20e89b22881d4697fb99b75deafb8501460f41a0e70628c05984f5b1fb4c4b33ebc93a8ce8d874a10fa49652492b894156711ec90ee5e82aa2c4913a87d1a2f6a508d9f5ae88efea52baab7fbc5f2c4a16b3d24dbcb9dbf538b16f57f51e49292f9929b6cb9c05c145750cc61db980bad24dbd68160401ba03e5b2192084e9d9fb7f5808bef40d485592795e925dd1edca2984a8341c094ed22b70a404f549954feed6cf278a417781e31ddbc2e09460e7f57ed0f7ce06d64a887c6181054af34b76898e4f35712e18223c6e34e06c7a3c701474f6d0a581da7589bbd425719bf82e7c3bf7dd9e31d68a2521db9a2b99c3d91c77e2b0db75e3a9af22075fa42c2159ee04c6fce24ed0db488bf2d571cf35fea4b683952757da32d2e8709fa7518c0c6c45fe411f7de107fcb921401c0a2da6cd771a58d00799835f349d70754d87d603096d4e6dfefe33f3ae7943d82b4b4a8242c92bd68034c4c6fa95d8cd311bf3f45266985da4e7e6f89fffb9600a38b289f0b9732a89417b85ca15575e82f38cfebb96955905d78c8bccb42441b7f8047c28112e66b69790afb6dd8d7a100e4574cebc5ef0cfe7d2b6ba9fe9ac03360ff77a13cf854bf72ca00afcd97cd81bf8f7f773cb154add1de1dbc818192e80f70f1dddbfd9226525e5f62172a9784a96c2fdcb2d420cf15ec38437a5335aeb5a8cbee6e168acc009b7dbcd3e4a81cd4168e77b68ac6e36d7b58256b2061a40b362284ed4de9b854b53096cf36c253e47d4752eaf126135adfb736b6be74cd9d26bf0fbdfc5363e527621e91ec1fce9b38189ba5d73363dd5c164051c60d6990d21856a845b4896eb87a0779015b6dca5aa6409ba962274ce2df66215620fcabe8844bd9861fcd5d29bb9620b563ee89cf3396f950e5ffeb6b2f65095c3c8e093906a631f3b53c4f52e703604680a492b5af3b13fa30583678d041159caf887ab73d526e8a8e67591bb12e65700321b88c4e48d52bcab9b7a3cbeadc4d71cff2d6bae6870864414f5805a0f6d6995e23ad6c415048c8d28ef03a557bfa0c6473e61fd415cc3b49589da8d789a2f43381df9e8dd85a71a56b60670080967f6acdcc8662aad9fdde93a8224da526fd0d64774f457d28be750dfae8036ce6a62103fc1b59a42d5293b822e2929f3532b67f3e7e614910fd1a69d22b6c5b678ae86e372be1e5c910b31ba4faca49336b26f31e0daa59a878769841ef604a0f066427cb4a7ad3f03bd9d9b3b6aea2b0757b1120432901990c0c008ccfccb8f3258bdb49c98cc25a41fede4daae07f42993895d9c6ffc78cad2bf8130494812f11125cb3036ab4beade6fc46ca5287bed49208c152e20ad9a8fc177ee02523a858897d39cfdae9cde27cb0167e369d64ca75c5391fcaf2a75eda894c696ef2ee91c3c4f47c97ba95ab895499772863e63ee8ba77975a667ca91c5e6518c8772a5fe0d2f12b7af94a5d9081f0f95ce47dc01c53b62ca915ce479ec1ac22831b327dcbaa45e8d18e3bc589ea39e61e5696288cb97540a6c03ea974c3c2264d5b884edcd858c894e1bbb4cbcba37ab7c4c8cd8663184cd073f94a4fb946875a8b748d58a14256cdb2a180e2c7d37121295892ab74613ef94eeb2a67910384725ae0fdaeaa081dbbc4abf80563b5c2afe22735ed9d4c1d00d777008b964344adb8b66a45b269f4b104e833d77abfc99f03ac1faa587ca841beb9f9ecf807fb80ec4dc5d3dd77d027efd128cf1a0f50839a11faf16f7bf6cd5b0da07e1f2008a756367ca6832335dbc81956e99d3247b4632a42e66080201c27c20bda4f15ec6ccf0af55ac595efa117009da4c430c80565e13713e101ec2b9e05455531c702ced3d0bff61f30f25a985c255c90a331bcb42cb951e8f4b1891c50beb7cf76a6faf51f0aa37206a28c83fa654425f7b939b023740d4932657ee8fd62692ac691bb90a29bca529f0b7d164f978298933cb088fba079ea83fd397d79e779dd0afeee5cfcabf9ae6fd2861929da19b294fc43ee2a608e061d68a8b45436668a829a7b7a2c2099d07655e9b091c69538bcc48bd53b3d150c8666d7e8b34bb6bcf5d13cdb42ff9fcb199311302c74edc1b4d7eeef285c7436d1099e1b3396526adfb9df706747025455ae054c6db6e03979690e584515d49ac50ad984a998fe00234ef61b87a5c56f3958cfafa3d49cc15c58eb4c621fd1c0672dedee8903c7dbd5cca014942ac70991f1274b5ae362d6e21ac21c159aa165ea5c03b4fea1a5f8bf3d0782b5d8d501ad894af052fbe49ef77d962477b3d603537185f434ad8ac04324e1398dc1027474f830dacab813dffc4cd56122a513ecef11cf0a8219a1e4a8b9a15dbea0d4abacd06cb4af9573ce11f7675d1a1e3e31d2ce42936df170764cb710fb3acfb9ef9c3cbb275b10e2cfc01d224e59fec8318ff64b8dac0c92157d385b6efa88835301b9ac3858b6cf38f7fc1303df639881382041e5232a69cd05871ce8016a5ea75bf53b2b97fe42286b5d2c56c3af6af189f5d7b2ca37a207910d89bfddea8680a9d2b9952b660779a2ea65c6a4fa948d25070b389cc7ce83af670117e3be15a70b0c8882e3fb354ab43c04cb9cebd313b02e1618c9816930b684919faab1db4128ebc6669275159a48a4a6f11ee6d2d1a6daddadfab8fc45d884383039b7478e013c102c00511612284defe576ab9610b69365efafc1eb30bca4127de3ea19c763e6c5c3813664f63f6fb927a73007eee380722d84bab1a53f8aa716b657760d4dbebc444aee7d4a72851b7e7d9cff0f85c3a1e184c8f07f92d1505ff82894cab96d4208a0be9dc945a8924034a5ffb6cdde502f3d475dbf180b1c5d8fb85e4bd67587d1abe32fe00f1a2858044c373613c529a7b4beada6d329c0502ef03e6e421a6867f88321c65ab4833778665cef8dfb447cbada29204f1fda9ff65fcb6d37f177fd87e9ffdfd72648568d4f2f9a5737756aeb333620d600fade72d24897540e42d36b34e9234314c24074b914b6f545797ae9f5688a65de6f63370b73f169e4efcc04ef970ae003889262db488d295cb5a0c0dc80cf413cf75e8fb2f8221b377c3d7abcd8d9a80a16d451d19b53e10b42a1147ca364b86f1ad1595e926ccde7dc60488d7a82796b4eb43636fcfc03a09211908a58ba209bd65a77f3a045831f34189af68fdae9f4090b41e8c49695b99f3e38804c6e35a318ed45a67c666296587609e4330da0c33b676fe0c230a893012f3a425c6a1daed7333ac271b93aedfa6f9e31e23c1816c3a0e44a7c3e627b69af1067b2d976754734e4ef25536076b2737456f620ea631640b1550e0b5a2169bc3475c5ccad79cbabaa479e94e2770df60587f28dedb37f8951e2b19b40f223433f63fd66462901c10bc703c570039053ed624830a221cbdbd71b908fd2061c4e5995090fb42c1367645328afd13f4b10a480bb989d1d9e0d44bda2080157f2d0a41aa1c9b7bed6bf83f3141f8e4bf121bab14fe2e2b7068acd7017e1c96838545c5d9fabf4863345d9f862fbb06adad7b694c7d66460a63ef19c58f8adc232098c50aecff31e0704b314b60193b58c73e05809218c6d79e9ca0a6bb8f502fe38e13d6e8eb465a0a83725a458bba6f835f27468a868aded578040f7a0215b49339883594f5a71b0618ad1facec156f7ffdefe75e9d0ef1cb7c57492a9de59b9a05c8a2acf2298efce7a8639fcec4e50752b7b0f4c4c7314f45a81da2ee3476f5b74f8247c82abf99da4e9e4f475c46c60e1b9c79628b4c9582bedcda7291b8800555c74647b70d3f719dbf53077b2df104457b1008109172a84b314fa774ad269b42d5f1d397819a4cfb680b53460610819901c3422f61497dd771f7dfed6f2a1cb94fd250b21678d4913f7f754365157237adf18c0ee3f284ee023e3aec26f0557725de7d2a96633e0fd3c3868d8c2503260694d3e461f922cf3fbcf076d22ff750b8072a13b001cda1ff4122556a07a2dce0293ae12ea2fc35c496699ded5f99388644b17bf8e3446e8388482f1c12e433ef925fbe8d1f28bddca25918f0ce742c3a66104d915369085af8b12f1b925285de24618f495e8c2a1e477d9f953420d65c48efb73430bbb87c6d3bdb770f45ca651b97a5bfb50f5e844fad1315ee6b792968ebdd7dbd28d37572454423a7fbc6e1b16030781ff4e3b06fdbcd77804faf1323ad62af41be37fa5f418c376b805daf30c6fb02cad094ef6df12f4268a55a66a8863e2a55f8dc85114d09a5615799277871fd9b5b47d061bc1e2f3dd10c09f54a9d7f35af776d4c4844fe4ce6b1964a3b1eb99497b77e18b9590687c2fcb5ffd11eabaa9833b20f15b32c0f505c3f5b7701b613f3bd637e1ec7e1ad33d61a5f79f9b832714fdf4716b6d617112ee49b0f02a3d94e8cfbc4ed6f76cb7c687fc3930e3ab7e4eb02e202dd1c666d9d305c2d31dab1d0649240ec23f8e336b3578162f1f342c9b7f5944204e7bc4da08136d050cb6f2ba858fd1ecb5a3643f8f0e815dba6da13d144ede04dca0dcf48c8035d8036c8a4c4ed333e1785bad459c6b8cc36fea84b8b3271127afd0e5f7a1e5204c288c1228b582500f49be52a761054a149d5667770f078df492d15cac9943e1692a8b37a53548004f4c5b3b5e752d2484f96f78788e9ee44d6a15773749a8aa94b9f2e727a1aefb083cb0a0024d1ca0a476fb0d4aaaa1fbe6f0133319696554568ba652016d9af9a8b3232fb8a39904539183c34847fb4cd06c9931a658a03259eee50d5ac3e6871c50f8b97fde7800c9f471bbdb4255cb17d4299f5e71ad8d8fde721bebd2cfe9dd9b265b58dcc5f0e56b2a438629e5664c4f8c9c227118eb075e96f4c19ef31a59ce60cc80e5b88d611eb3d9c1d3eccb688b8e6e605421a9ca6857e84edce7e3cd3c231c4619ed99ed77fcfd6dd62cb3d9be890cd5c61bda1368bb90e87638c571e0d0ee79992f78a22cee96e9f0cddb10be92ae51a3845021bb14162f27fee4b4658a6547103c40ac6c4a7906818344e2f613520baa2a49976af8b6420be3735492da136770ceb0db9a0458b93f8edd0d4ee6909bba8f5b45bfb5498b841dfd446e5e997fb95ffb68c8b6163c884b4d1109abdf9eb6ee04553d21b9f0c2c4580a340bdf44cd21bbd1f3c2491b03d723b6b038ed35a13abbdecf309c8b8ab18e73094e846ef29010d50f7b71578fa81b1ead246f647c81241c11664593e6ff235301dec24cafeb70843053126c9e4446449c124299cd5f95a82cdf2dab76d449cd637fca37db2bcc952533e7387d08e37211f8d7f7b7de668f902b546ee4b39ff1168f2198fec84106b1f471a9a46dd5c5b84f36c5e775b73c6ab4032e66cebaf2bac1e69992883adfc913d70340ea3de1b2137c2bfc03ba7aad814d3474d516e9235d7a58cc6575e6cff023798be86925d5d9abba81eaf427645b92f4a07b203558cfb06292d45c5083b2d9b737ee0457e29c49cee507e7a07025eeb009d599bba198f9e69c9789c91f14d71d125112b1046b911a13734a483227b6c94cd7889eba8e95ebeae6a568fa6ebeb618610191250ba55d88823a007e2d114e17e4a0805a231f357b506e304cfc661ae7676472b40e54406772fef8d1561fdf9f58c4f4c55ac66d8023c1d07364de5302946c6ccedc43156d2c91c1a82cf217cbe058f233934ab508988da277d8cad64cc959ac2945be93cc6fd26b24187821450b2c7046491c74ae5412f8e8c3e63b2d528c110b379fe0f9219ef2bd5d979c55a131c8dfd8d1171c1e744d87dcb8fcce015a969b7f11625d5773961211813526e49b4fb3134057b36c1f7f31c8ac98a39d9e55693db1d615e13a165dd1c7bc55c8c5cb1af8c642aac35fb10eb3740bdaca638a7a410a501b7d76341ebdc7b544011e85a6bc1c8fd03fc984bb81155d08dbc1778b94727787d11bc976a797bc5c6889c9bfb624585ddc434b980421568eaa99889dd8757bbb82cf6cd3dddaa4b2506961877740cd12d8e5fb2d3a8d3a831945c7aa206fed2d1d3e4f1dea3dbf2eba78a7208d6d82df4195862a6ded275dc5a2b0bce000b52e2449cf3588cb6e611a587bd7e9c19bcd43c7fb318bb7e2db3f535291f7de52d66f6905be06d687ffcb7d0fc204cd0e0b1c2c233968ba3554e71c8e1bca09f9e4dc71c2e980a397b200d951c2be8c93fee79213b868f9847ffde4737a1e924a745d135d1afc45c26efbd2595736b8fa9f33d600ee22b227d33181097e1925489495e0882ee0865754a25814026aff4b750a2bf14cb749279f6f682d45634c5a4f8189b9377630d89c3f0a268a78ef6fd7f63d04fccd26eb92e2fe5d99075d3f123c565cd04bcec2449cca01d1dcc8efd04e638ea955fb490ccf323ae289a96e8745e93155eea63549403d3d89e1a57deffde3b64d925c8099d4111bb36dc848505e875cdfeb065526d9881617176d82844611cfe310300fcad47b5e0d7fde225b01c56902d1c4cd6b30571e60b637a3a8d01bf8266505885b4fa3560e514e502edec5b55fcb25dabd42f1e40bebe75b88b1bba6bb5bf89d6eb8712bcaf6fea11da22a0b9547952c41574d7bf6722090d93822e0d71996215362caae4d35cd1c5f5d639f7d19a483c5a50087e283b96714782e960a98a0fa6892b13df772714fd5dd0ba82b506e279eab1c5e9f03e0e0060770619863578d1b3c1c42a8d1d00be37569407ace2fd0142c7246c45726cd03de93f3b54ee62ee764d72e21cfc91d50a26dc05fa29b03e8cfa61809a2f7dc5cbdbfa695d37653231ce6c6d2c6c339109e278a9a6e05b2d28623ac0b384330fabcaa3be5204c9a282c573b83feb4e468749fba2d85aeba3b2fe70c0f2c9953e8d9806a73e0af7b6fdc8550cfbe76243a197ddf4cacd1dd3b07b301009eb57786d41bf665b55c8761a3449098775aed0086c38f7a7a3e86a4853e8b08b47fc7e004fd2cc81c023b4d1a753db572f92b60a3d9d337bb538fa734f1b9a4525b2ad7ac42a2ef8ca29283dde2e44d29f0f81794ba667ed624c5c90fef09849de7351974759cc30ce358c83a1191c79a442a52a73743e040705f521f693ec618ddfe01b4cca7c68f709b096373bfca5857a7dd98d0cceb0b03c469abcbab7c564cd9ac1551e6be8837085495e0a1d406a1781286e9b57a8ccd61cd9516f1f014d5cddaad29f29252077d63f1c5842d693ff8c90c0bd55bfe30fc860900574991a40fad56d4561bfb320d3b661ca962408175ff5daf632c2c7c26e5cd3492da8bec5217dbebd6bc9ff63ce6709595ef7e7ba9ac363cde410e0c9768aa55016eca46d6a8848e30fd6b6f05afd750260a546b4a17d0a0d46103ae81626ecf215acf74c66650ba8cf50e070aac1e6b600685450c5b46b11df20841602e7e92ecb3ce6494e204bdd3b9a96d61d4da3470a8b53e61706bfc1362d5a68f7645d69707e0e36bbe44d70244d18fe20c2ff2fb4d3400a4dffa3cbafeec697f3b3a1bc0d2cab32cdb45e77a5d5cacfba3a504dca127841a4eea0cd1c997cb55c7c309e48ae1797a789c56e6cb41bde936c075a2215f4c513ea4d86361270dfe192f47d2202226d0503f0cc9617a5d14ba7838917d7ed1e44a160049ab83949ed84e791427a3fb31a6ce89da35488129753a1451fc58504dfda00b3e697ba08de3848cffac07cf46b83938a1ea075cdf8a6a56474a5cca7c7459d5a3137b3854a0085b5045342a4d224fb0ebcc038436543d2a04f39dcc9931f5cf12c55ddc8c860f7a433fb68a6fbb70037769ec4ea2252ace0fddd14a9baae273efdc5972f16520723e154cbb3f0e75a216cd60262b876e91734650b6309a1ca8e30b6f958438e9e5642ef3bbb5d6bfdb8bc20b72472068991104c0395f6781b95c08000f05818262c7b84af70ddcb95e54054e9a7e29b480bbb99fbb9d72780d9bb603e53348f1c2fd1b7d52f23787e0157cbe1f07fcee528a2448b9ddce345a4f8c454721abc0a8b4b0171d5caa1bed57e2f4eed11be5c8ee9450ae9b1490c1009c56ea3d6e1c268143745912711ab3817ef5f29bb0df170b23de8f70239a1c3590ed0097a8bd766fe01f5c44a0c8fce332d5eb318aabb6e80576b52f9b66bb3df24438f1ab78f1aa7a55ec5b8e96473976f310fb635ee5a7f93f7d6c10ec181172e6a778dd709a6fd7605d71e56dc4e4b1b8cd1e4d6742a29091e1303c6fab71703ef38e854c04a6dd2c39222eaac20db0ce3c5bda4f9e084f3eef9d4216a62308bf268c11fb08f32be40ff1f75dc3c970fdd9fb67e243eb6f77e5038623097e78c45546407d24a67fc22897febb9933b1643b946ac9071310b0fe5d55f91b278ce19e653eb8a7e6aa8e6232016355aac0a8c5ce4ac1f5c2749229a12935fccf54d7f4afbcf9adcab91574c4822f88396643d3c7ef32483d6c721b229b6512f72dc61a91f05bae9c6506ea74e23f0ae5cc30fdc6552e134c0a02dd3711be4d046b3e85a98567d64a7e72eeb990195e3979bd844b2e6e760cb32c6d6bcbd3a04b27c77b499b71a7a33fdc787a6d638fe5f4b378c8ac70e7683dc94d390a03c3677261e3583aba950e90ab690fc3fdf8e99058dd8de753de65d811a7ad946409eaa13228a71ba80b98133fc23d7d7eb7c22d3b89b61e5f94691618516bff1f2ead98217727218910403d626a5c3f0ac07e873afc8b00908880075819caf019884c82c59666dda1ad74ff9cdb2f76b42ed2a09c46d1b86b0b2103c9615a9bca1ec4e963d8eb148b11e99625c6ace9ee0118051f512455e7b2a74f6bcfd961af0c012d93c6907e21ad2beba6e957b16f342ffad227beec04819b9b70604e8f621ce8591f7e13074f3aa4adefed8a9626579282a910f504daef076e0aeb06cbbfef985dc28923c71fd50c1a08dfe2514a42ca827a76136e2382b58e04ac939824b0933acc218bc2de08934616d123ae635b08e1bfe1e5d48606c597c81932594b23c5e12fe76c8e32a6eec5133dff4ef297322805d3bda9446bddf9ddf94f00552cde909c5c0e00e0992dfa8f1cc3a97bc1559aef727d9daf5ee38f9ec71901f0fdacc067f69f5f53887e45643516232280183437973ec19674042049cf131290723ecf0cada9442cbf4df2dab1e79fd9cfbf7ffc8d13a31a1c89c63354f0dc43270f55f6df36e55d47f1d20efa49f46915380c57b3d7f80ba1b30103a2361899ab6de1fbc4f17a583fb7aa77f5cd2adc21abb43bcd74c8863647f338071cc4ca4c2e2cb3a8260ac2d0113e077c51166b4e34ef0be016c61b6f3bc60dc92a2d2d5268d6453568cc56d189bdfa523e8f2e7b9c59da2cfb1b890dc37fd2ddb91250c6be1f6dc3b3b037256859c037172d06b9206c7b518e892626e61827c2b6a833a3aa6e49780c5ae013003631f9a43904705595d6cbf0659998f06c7705eded7de4656f39a0253569b1e9167258c0a670541737ca4e30be6f702e5d36586356571f8f3f4ea538d0c82b1108c16edcfc3478497731f342fcbd39c585a25050d4dab4d7de33b1f3d5aa6cf099854efb1e8f11dd7dd941e213680a38001d2d957aaf473f3f17c332c796e5a425ec67e7c9f0fdb78e6738717a996f983f179099ae9ee8fbf21cb04bcd403519efad99261f2fab0f553b25d58b5dd91e34be0f89bcf554043227e7096b77496f59a59e4deb53f4c83462ed189bc5ce1e61f4f0f7edbb6183e549b6d7e08545c71a278254738b83fabca03486f6fb15ac5decc610d3d6d679e9c84705e5723f1ca33059f74a828c854039f09d10c9d7fb9bd3103e111b27ce6d5b1a71037e49076a0aa84c39e31cc18c47c02b2bb4ea701646493357333f1be4188406985e2749839d923c44c610e192a0b0b2b8662893862a3198cf10a95661e847565377a092833f12272e28e1e4518fe24f7297c1315cc5a368ca32a8befa027c0241754ec22b9c646509306f85fb5a7a94ae911f84c979069da9f83d021b9abc7f34b82a1c7fb5c7b8e60e4ddd1c342b72cc607c869c481d992b83873cc20314100a14cea67542e0f46bfd8891a1cda6d9b5aa6dae71d895ceae4809037b6aac2a05a7e72466edd9faa17d91c6f5455b9b968ca41e8a6a10f706170b11e1d9fd087abfb560df357f970bc718cc9c905645dca1253deecba30325251f800f3631529a894aa0b2f58adadc0ce0ee6c3462cf7dc939cc364170a8837bc32be5bf0f35558e5c86689d3c4fbda38ed8c359648d5de54b7e61e2f3b0dda9ffecbe2eeb6f59ef75ef9b7e63ae547c6ba57d4a6e6ef0ecc3158cdfb36eeecce886b18ba706e1b2547d22ce9e50e67f7764537aad61935e40c50072879bf2db274aabcedf8a43e609aa1bee5dd95d6b9563b01c3454f086af2cd513d20f036ff501a75d0f4aba23dc0751a0688061f3b97f3c0cb52bc2a8c668640f2c82817a26d3f3aedf70814c367a26c0550d4ee46b5598806737f4bc2a50e76f340dcd7ac525a08d26472e8a0ae5c74fa3ba3d3a94cbaabaf7598c60fd4bbe8ca198e51a0def8eab80d5475603cdcb593d900352c0b6545fea74a19ce0ba4aab380333868b41f1f450b904cb50d3f2faf0dd990e7f18126f6063457f3abdb7655cdf8ffbdd33f911ed99c0da252128dd3d2b136b6565c49ab8c0497ad72e5c6ae647fc74e94ab4f0dba94402df261f7bd058fec209d2f451fab868e3aa73c95406848457be3603f9fd1c5c266faeee691bdda4c505748d8dad4cbd909ce105438e44bd8548f7fd9bea4885b1aad51da4a88a6c2310ab0eb4d1f24f30a8a527829f7706c9c9b05f50d531627f30ed540fa317deefa4e56cfb19a5743040d8db0d1017f575b85c70f989d0928ebc74a3f625dc4ff8853cfc28155570e2ffc5e268e85d6d873adc226be8bbf281b89743b6f72b7bf9d9da32403f05cff1865d5a7f0b491fb589392c8c5ee144a27cff2c08ab49c05bd10477f5d511a6c4679d8cb48be4f726cda7731613612cd0e0428a99d1f75e870e5977999fd28675d7c6a7094b32c4bb55ed57139b60da7e5392f6cc14f7d33300fc44b3e591e91ea2c8b554fe6851b445709360b832bd70f402e37c47adfc8290ebd7210694309ae03c12b6316b1a798788c35b9718ca4d22feb8cfe938bf5ee4d57ff84b73f3e818df41b9557cd3dacbb350f38ab5360d6d348cfff00d3bed24c2ead2a4a24c4161fd7f1244b078cda8c7b91e0cf9c28884d8562ed5ee5b9e7c643e1c6961a5c346545bd9a4b4a18d2a15488aeb463c5118671e103f9748386f9598dcd9a352cb23966c7dc960ed21efb36189e15b6740d42da36a2473679e352e92017eddb9d430b4ccbab65094206e4f110bbd94d2f4166d50650de14bf279f309018b4bdbe3b6063d09b6b7a075b5e91d6b87594ae77a7f5578484bfe646a70cc64fccf438bf0951dcbe6dadd38693ef81b5bba9720cd1880b935117da9657905bac2b6417dd899fe71474f6e9b7ec17e8e9451e4ffe7168aff514c46024e56ee53fd1f48e10cd48c1ae3259bb5c6d8537fbcddfdc7380da153950d98351f7596da007751a9ed903ac4827366474703d51331341f44c84084fc68843af4961733d9afc177bc5cc2b532e739b54c7638883ce7c487d7f57815448cc1e2bfc14d4d571aaa2a87704f3a570ed1c8827c0d5d94ae40e09727122a4fdda7315746717442d1ff6e60a80259b690747239cf2d7df92cf205df455f94afc33862fef3b447ffa7051518cad69a15a9f1541ff168e8f5c2fcdbfe54ec95a3913ea591a2f1d7fdd5c4bd3dc525f3c03973a9bbdc056c465b057a3f909afe4575151f71c2668fea4af347eb1c40ab124d7926f36bf7ef838f10621fda81f6f04add0cfe646a9bb3d0747fe85a4116412711e2ed406a8f1b6a10b172f07027562b321ae3430a1621a965103129f28fb59b5cb6139ca4f2f24af8007d02bce3e1f7c823744e6e43dd6df2df5737533ef37d7bf812573c878231f734130a024f27a8a067dc2cf1f01a7526634833dcb82b3de080b30b13c26c1b00cd3228db1396946b9d7fa1af5e07943e3e334f04dbbd56dc4cff3f4d087eb52c43b2f5e09ecaf83a3cf67f4eebb106eaf904d7dc525bac84e38d83578c557d10d32e6a3831373a4248d9e13a7b5b5f9ce3d351029d9ff128424acfa687ed2f9c790aa48aaffe8677e351527b96681bc1723bda8a2157cc1c9fc9c8acbc5bb9783c89a9896a47761201e33fdff1cb7f7b14085f2e5f7d06a2ed97ac80d3b32fe92da47302bf2f5124e5bdf97c6b4904d92e49305f5630cab360aa40e050eb3ffa4854c0de21bfe67bce7c89f3ac606385d003db0086425f39966f5d58f143750961a10a966344471451b3215f373f187a27f8d3fa5006a383573396507675de70e6d7727c427efd48174f66a25a7c676ab7a30c3093e42c10175c7f60d1e4c67498942bed0792d7b8f28dac44f903beb14e60d9a5ca998a0c736dad79e4034225af7b17c69487147854fb3253cc15c14bc578ded3d33f7883787a4c2d9858b2975f9002b41fda2ce9b822fb95ae7566a762ad0891cd47c92af8f6f71571d5bff87165c542a235a57ccc69c2f5d2703eb4047069993f3af09f8ce9aedf191b9cfa76629edf454bb80c667d16e868d644c3a8d05918ad4213b03e9e3bd06b1df8849feb0079690e0d02bdfb6eb4af2cfbc57b607df4d51ad98e13ecae943a53d78fa348f9e8e24545665caafa119cc8a9a9ef3ef1c9f03f0a18afa7a44d3ebae566d564dd9f7fb1a89e0e6ba95180ea512fcc7c2b190ed9e1f963afc7899d1f79219697e28f7338bb2bd3087133170cbd4ab33d2ad3f0204de7707e482e01b61e15c42a25701f679401d9b547f0dcc029b9ddf028291571e0bb48a4d1a06d0533d111c280ca9513504c5cee913aedf3b86805510a671567c48aa26c1bb03aa8787d146c7f1146617dab6c63add558c992792fd9367803c63a8d02721500b209eb5474e5dffa397879bc9e02692872f6e8271c4c88a87fe1e1a5c625c0d5eef11eac8304f2826b7ec8ae81042410612aff9d7d20e65740cdc40280e7343ede4429efa9156","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
