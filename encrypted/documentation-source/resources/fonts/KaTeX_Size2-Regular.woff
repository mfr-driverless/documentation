<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aec34fcc865092d2e810ef93d77d9ce7d3e3c8151c97cc08386256529e02683b5aca5d000429ba811850956d896ba147f6701e70a3a00a27835a89fc01001c65278a52fedac943fcaac1e409ad43c70edcf412b747ca2642fa9bc0dea2823f8fa15cfd990676f614aa19901b34114e62c4714397ebe3316899868bad90ffc956cb994655460aa404d60305c4c6ddddd96f35febdd8c573b3ad7f60e3551732df7eec1964af5f5f7e36d9dec0e3a2b4559ff3ff54d44bb56e179cafc5baa3a221487a1ea763c4a37a31ad1b55f86fc9e7dce235643167bd13bfbd7b1fa3c22b8830ab60ef630d375fb0e3c095fc9ba7a9503645a77a1fd2392b5bf1476ebf7d99c35c384f38c26bfffd19244c2d406001e6a2a248a07a6d1383bdd4d3abe429a29633dba3a0ebd639252bc4498d7c8ef36ac222a928c215b80bedd72189c1a6b338d57de48f9321cf504a5fd7c99b076172da4eec348257fe62f87c2429001a2fffec15f6d8f2c2afe23e92b168bd7e15e86ec489ef172ad0fc437d60a5c66083a28e3c05d4c913af01c6fcc75eb98e69924400e96cef10eef18e9f68ef945d77befdc1372b0fd7c253193bc959da9a149c7b68b121d7364d7c54cd95b2c1c8f393cc0dba1665c16c291312991fc9d46c6641208db6e51f24b40673827566b443ecbe508f052a77633beacd073ab839cbf55eb7a291014012c98a289e345598ed25e29ca73a6f313aa8570a451a8bb20e13668a985a8c09af15a5452f4ae127cefcb1a56c8f98a5da16386b127841232d2bde4a64da01bfbb24f9c63938a0469a7dd404b6007e54d8848c4d5e9db4b68beeda238bc1ed6291f82e3f6c19f9faa990792c38bee6449d931438a204aec82c5dbaae78062ea894c389d1b58ccc09b9550bfb2d75ed708d167bd90706945fa30bdf1ab101f8fdff128f0cba140cdb13e64ea3c06afce55dab75c7bdeaa56c5dd56dba4634867171ddef2a6b6f4fc7e75359010689475dff6dd302e68f59699a1aea9cdae8aef77e5e41706e4327c788f632d25904541cc59647c552c763ecbd3617428f25fc86a53bc1a20d4a85af723e12d5e2e4141f2b35e12a0e461a8d470a6652961d09ddd487bc603117b29a2a2e9c168c6542b7b6e9c652accfd1e360929c41eb7dc6613f7447d032bb9061ea7b3a6767fe8c389f764bfa367300e91563966a14de656aa3115c3eba56a87dc8bc0ff065b377a59a65a401b43ba5d290802ce8b18fa4fa0a2231c6cfb019341bdb77a280551d350416929150b503fe7c41dac30c60cb744e679332c377be7e97e2bd3daeaec89993dd15af7d29c48e338276e9eaa1ed1f1e752734202e21eaa9aac81b18295b3563a29389f28dd0fec8b91ed7bcf0c1770b3a7ecd029b6f5833f611e9d1ad6432563480e32a7ae0d9fc6fc31e2495f489ed4ef779997f992f9c33f3d06a895735d25a5b77ff091ec0d5d02db00eb23ba331cd818b7f2d6edd42db639a969c8f2809fa1f0ab6fe88202d3d4a27d0f09c62234c18a364ef923508d28b8dc143fc012ec4b0801f5de7935ea38646ca676249825a8f760df58d4de4d32b94189a5d67ea879519ac1c7c23fb5114aecd8b8b8062c8e84f1ea7781457092bb6367385bc563be8af5d461cf3bd23b72cf7afbc2407d610a800f8475c20c38fb2b25fd3fe91bf064ce4acff3d29ff6090fdb577fc061a002acbc1e44b349c588e01b3914004b83a12612d8e1118ca00cf9a2c93f268ad97a3fb4e0f1ebf102fa4df162d7002010ed11e1e46596229d954464725da60602acf0f510bc2680ef0350378e613a6c446d09b36ce102dab4134e2971a58d2ab8e4ec215d923036a320bb4275a3089bed3254e801e3aefbd3ff9dcfd9c346ae926253182a3ce16b48fecdbe1e17328310e43bbb96dcbb9a3a43aa56850e498d94188e6586db55f770d8d795c31ccc43f81415d4868cd1966aac81e5f90e4ee7b31f225aaba6226123367ea64d0bfd80585cc280874832385cdcfa09ba5c20c16688c38f3e4bae2156f7aa2f9dbb2d95601e32ca58d8894c508c450701bdbe63052a35f40ebbb12e482a386a75f27920a332dedf5e7998e983db8ae41a83f4f72f8f19ed2b9e5d81b84093a8c9322d5c86b768c8bd9d5764947db0cc6c518075d1f99b4153b0bd45194c09631ec94e2667d8da767c81174ca2390380980d8bc8998504dd10a105fbc0ae5acaf54915fd6d84c9928734855c1c958d1ef8b7ae406d179f007468b864a670146c037f8589fbcc0dfa5689ab5c231bdc308f096acb57f8acdd76b0eb9574b7baa81784ef1c097127ae3292d52a41d51708598a5d3602e6791ce45a1fa8b5600e226fb0b122aac2c355f0d60f13c5159a014437cb44da14631ed07d451d00957fbbfb12d75d3035b47b660992da3fe2a652b3dbd993ee1439f35489a12479da17e8dc031f6e3b3a02a06c40e7de22a35e228dfd350fe7c721d463d80a7b271314086ff844605f0daff7feca853f8cfd0d15145f8520ece706812f0fc44aff8038518664ae3949e46a9a8edd5641ff69547a2a5e377815dfb244ad57fcc132d14a488744c8c280d2dce26cbd02d73d9ca3d9fc60f936d5e92341a455aad926cb76ec5e7fbec8457b72102fe4efa2642de2db1e814de1d000fe0ba9c93bf21c9e1b866599c7e9dfe7e78e099b98e372b130e158774eb909b640f8f2f18b11920a8cf8956d0b4e60851d28be19032562707bb2e909ffd78b3ef5b445da3639f4adc21090d7cec945f5230c56311e072f75d5ec008aad189880df4af27922ff0dd6458d819f0bcd99e17a64929eab5197f91c90d0bd7440e77d67ecf2e0c614140a43381e6f5fff331c6be1bfda3261c352e607e536f415d87837bc264db2b50e0ec3dadbd5c03df2319e69d835df84296ba1890d5dcf06646531a1d7cdf404320001054004df585b5ab652548cb861e958ac51cf129de3ea67360c5d537449a445ab5d42b22b925e8cb134e0974e6936050e479661898075b0363ca7827d62870872324518b60ead438ccbfc3f8fd39b4d74363c5e6429c0e0ece5b0f614a6441628c3afed602dc16102199d229ad1bd0d8f6c0602ff0cb703a00f212cf2400bf1272520dcb7ca1ff50c1e9f7d1201341cbe3f7deabf28d403a89074bf85233b93c5404f952447a33edd852d2f23c2db6827c831bea208e526210ef9d7e0e11c84dee02b40c3eceaf1145cbcb2cd70224cb348b87fbc8029cf47463be8a0bd8d609794488a678f48058af1654b5cbf144af2309f34c8ba2f433a89aaca70d9751db3d6a5f92da1a398ff67a8ea581d8c48ee49923d70b552e780814ba03a650ef27b59cb3e17111a3df7822aa2c2e509822d593270939f175d9acbffe2eedbc540bd15d210a38bbd4a94c4d54720bff9cc565add3ff65eb4b3342712594dd5c1d6cd931d430b84d1bef5804aae83f3cae10fc69f2b51633eb035bbfe5b924403c65d078df7ed619ad22cee0ef11fa56346181920ef8b2a82ccae187e56cb463126f38894d0eaf35b3847b9d3c05a31407f6e01d3e3f8e57ac7b0d347850c3e7ebf65c33ae11d3a19a2430dfb48a40b6c14fbeae8a0d54904e86242d73bbc523ece3a512f48d69338582e666ceb9b34403821e26f8fa58229c45783cc359a04e631e6f7c87da6b620586655b1eedc24430f738d4e3864ba34c7a64fd9ffe1c16900c43d4cbea5c5d5aa0d9884d374ab71803b49ece30218efdc967f0a41157079ada1c26ef23a6b3ad5ba79f2231dc9fc43345b310422f9d65108b161fbefe1c82ca122275db6152d40c5738b871a53950406b1c5a627d2fc5eb0d67a70a58d38628d8ed02bb2e266399ad021017a812c7413d5683c47d75723f4edfa0427ba5c0ddd6d7fd64b532f90158196469165b8e4cb9b3588d32ca3ae51f46640f8acd35bf36bfb056ae6d51468053273104adaa7bd14b4f1248a9123583c8d2140429164c1b2cf5555d235e64562ec1550cd94c57395cf862dcc4dfa0bdfd5fcd25574b7422d96764106bbc4b9a1f594f4365b8dc7ef1df6d3a16723abf0de516c82ec6dfb7d5a0399d7a06eeb49c077a0644c647c8390e1f07ae4d329077541a8ed0c6fcaea6d5d756bc9ba0abc59dbb9c34e12e7e0aab48965328a3b332ed1829016db74732b10aebfe947b09a0068282f7671c23ca21ef5e5e528d0357ef38c4265720b6f7d5acc9b22e89f14d04903f9cc8e04a178b4c180566906ad72c8337859a854d139de118d0bd5fc4d1fb3ccb7fb51c7c22d00fa7377e756e6550f7752fecb97d9ae8f870ab36f0fa9f675c9250ec5ac81fc1ad38c28386432933d4412c73fd526aa1848eeae5b70377f2b8ecf49132f761caeef5ebeb6219570d63d27c58811f909b78f2efcebd522df8458475115e6b0227a2d2838c5b96ff515fc421da5d1ee28c23adcd4fc6b92cd4fcf382575c65c89ccae8939f2f9cb20e7e7bc591f27cd800f2838e772f4bb9b10707352434cb46e0bbe77f113e7c8091a78a0007f74b6f8434b79b1bd2212e4ac5d2ba762e98247f1679304b0d29c507a83b1b0a541b19bb00400b719d3fee87c6182091363c6923a2ecbef9b9823135e18d81e6bea26eb822c12c0b46a40149ebe0fda376ed3580ec569b718e21d135a9830b57810218efc2311eb15b46b12cd51f5fcf7de95f52720c7e98e471293f743ca63fa5a99e441db01843205a5afeb523903eccb8921b6961b5b96d5dd333dd38a8b6430f86b203f9a21f298f9c8ad91c043ec3dd65439b174b84b0cbf8e7944e8d66847f176017cd42c22acf002c0822e2c582fd53ce74c0a7e5ed0762677a666a6508e2ccdfdf01f0c047d9cb0201d42467e46bee0ede41318edeba9e358e466bf317a62f65b3c183697fb19e91a7d416804387fe4e15b14527e1d43ab589b27b850fb642b4492368a14ee0f5a32d2c193e0e1c6198041ff28bcc6ea78b4733939a64a9bfb2d9744cc60e85d8f822a5d6ac55ab6ba108e74acc161a8794dbc569f3e7add0fc53d7b1ba73edd3ddf478152e79cf3f8ad5a51f96d825a2919d5dc9e4e7814956331a6120122f10810115a8aca438e1ced1f90d673c849e2ad52f7d16a00c5b8cefd006c1e2e05fb91629d27aabb0ec870121bec716651527f3f1210997037a8c7417d7ab87c515eae722646ee6961580efc714dab213aea1924632d7e43ad455ff25f07b8b0f138ee638ab83110451865cb6e206ef9ee925bd03aa872c09fbad4163cce068688cd35fba61978604de4ef55ad6c0f1d14d6804b96ba6c92f26e0482fa9ad92c3c63a750911c64c5ea6b9a806097c4519e5e0ff804824680c697d23a4759125540577c18ac210eb5202fe0ea26529be9a04d4e788bb2df65cc7ad74701d8f8d8bc14acf02b0d61251dfd1670581b397f0cb5fa24c57a3957e19dfe35f56795eb8da14f2ce2321df10441efbc123cc95f5278b8deb72d19ef0d4dc8aebf794961ea57a101fbcd561fb8b74098601db4bffbc5b96c1cdcddbff99cf70d4ceb29d5fd9f2e75db0c6117e741eb52256bb335375921d44fb63e6738760a7d36f06649337f86a4b44881920e448042e34b74572bcf21e75042daa25b00610399fbfafe8ece5c70816c21638d242ee38db8f89f5b1f33d061d7f99e21657bc959e1515e41c8f946e7be6156072fe6a28f2cce9079daedaa4240a735fb0f37ce2c0420e32c48a604e25ee8ce81f9e48b57b4b4c3748fb774d0391b239bf3ae472ac6c371100d75bbf4791a50677cb9dbb4d52dedaaf829fd475b545bf5f897e9c5949b68b3af716086e517a60f0b4748052b74d53ae8e3cc8d94d16b4a86ff5b4ca8829e32d26dfc20d806b5bf36f2580ef4f87bc3b41a092a70e19da6ae204c90a25df3fa7954b297f5cc23861d0fbb5846570cbffed4c7285355c0ea5e296af3d8db7d0956e74dc61515f13bf27e6297250fb90b0033a49392d38eaf6d04185052cf0e78c7abdac5dba568dfc931135f28342fd008fe8792ddc9df460327e61526b90ad02c89f492b12e3a1bc2709bc78fc07a2f91bbdb089deb1bac1c39464786300bcd5073c443cee26385afca83d7acd06a12456d3c41bcba478b82929812c1583a404cefbabf49d51d5036b70dbdd0914a5fc1bb34c721b4b8435a49ddc3aafb058367e447f23d5677f4b13b20072daca1fecce452c79855a88c1a8a50077ac0a3836b816edd27cb25bcb1b120c10a20a038b643da45886f6668b91c8a3d46d1544cef7718160a8b87ff36ede6e07d9b8d535392893ef0559c0a488feb4d800488fff1e269385307f21ab001c0bc4c53e86e2a2cfd4af64b98a5cf40c3320ae62cc936a0c4f8b3052549b675c5872eff1e9fc7d1dbed851f81230eef91eaab28eea39ab8c6f26bfa2713f12d6585c10c23081d72752d4369402c3b8e623ab657d7fc80f66bcd0543dfd3e05b70b40405c7719e33ab1a5f0b6736547c94375849a10936111e922a10c493556f89c201ed677fd5626bba5c06e28d67382f6080c4a720b76077b651fb91b92f5606e0d1d45a61246b9bb528dcaaae2c0fe368e80c524053f76caeaf9a940d4ba2686651e7770b1fd2b304530ebbae4e39a07d1b68a2be16bf708ef124a15077da9c4b0cc6b28079cdd02097e6c5910741f8b33690d0fe7e92d454c09dec522ba543485a7f46b37793bc8cc8c078d2fc6a1c812b6ecb87296f9607117ddd42f841da70cd99a6e168cb48decafa1809a5b11fae47dc0c528148558ccc8e50586724958d6bf58ac42d7241356298f86cd9298fe22d6cce0634c60e91d8afb3233b428498b582f03ab56a901a18d350d7901963f1407528653b98ef6341e5ceb9df1cc24ab95422521104524fca2a7c6028818708aa9419953f1d8c99bc73676baeff0006c3c958714c18f057c233bd68f06e86000a1cd0890dbe6769950d80eb9c684dfdf86b88973af2419d64269936b8e2488eab5834897c3b51c5dad9d40d1defbb6b60e346b95e9b02ac4a26e9827d2939239a7f06b5df42ffdd18f1057a14d0009b672d4bde3c0eb232113ae83167022ea5e797d362c5e8cfbcb8ddda91af39a2cc8dd62e2ff24493497d06b4ea6ee2d2c7abf1fd73d25da16d7f8d515ab570b1e4df0ff2fd83a1cdc0be6031ba401cc069113706de221de2d36015f7251c85e6a9f8bd8abf325e31c4e58100ac1a0b1689e11f96c6777761b5862bb41e7781dd5eb690985a313dfd3a321112d8e444328abab1fab6ec0801cb099175c7dcfa368d8ed08cef04e3fc784b570befd1b1491b7061c5cfe8755443e722b4d784a121b2f6f66b01b43fd566686ede7a8710fd14c28e87d57d79f4eb6171167ac076b7376e60e517c6ce0aa08e5955b7c70b8cae0f8ca3b2def093cd4d8026e61e3d11e2eeff3d594d9d7e20f01b8d8b9f12566177ac7e1a18dc624ffc4fe2ab48e4b4064399c83ad4876ce4938a29ce291d56d428657e7d16a8bdbe12696dc9859004e6633edfec27b067747d1ed6ebac3d7fbc4490d7883000501de99959e368e69dc4462deaa883bdcea1628b290ec256135c619c867d8f2cadc28d7ba30cc1b4fb1cf4e867a0ba09e404194425cd08d6749d464211273725e5a8ed06d4c6a6fcdef82e492784d580e5970ceffd5102cc0e62575347056ef8febccaa93094f1d017d8b445df45012fe967c82fb7f3b813ea75910097dda6c16e9e7f1487def115fa4bc33fa9456a89943bd9e58f45252ec173d67e845d33f16c85e84c304efd845b2d4bb5b37f09fe284fb79725f03fe72f7483dbeaed29f46dced3464389954b93e06da825ea654a983dc63752e28f10b0443f5572abc07681eed9b44064b219902ad5b7dbbb7ae139704cb5e85d96f2f32c3361cda78280dd7ba0f645a6320b59eb35dba6170ab39eadf846474efef56c574427a688268935431a367c889db5c97bc54b98fb929efce94ec7dd0f18e84f5dd0bbb962b5cb34f56370bc47ce132ae0ea9af1627590bd2afa54d13391b0cf1cf76cb67393a8c5809ac1c1583e810b8d203bb5cb9b9ed87302ce3750daaa6d356a7fd05e757c6d98a76b5553b2f075af01be614d01f91b95237e8ed11070696d3516834d2b9bcbb0134712de0f550ef2ea408b5d654dbefb8d52487e812db77259c6b37fd62bcfbf9ef419d36da229736b37227b7afe00db0b81a247007fd9ad7ab1516dff8670f446c4868e10188e62e8497f05b992ba94f733115248657a7783d8820810f00db0a8fdcc2417a6466da9641f003b8d7e919fdee2949acd78c2c49ee4e964765ecf5b5f0daf41bb5592573118121464223c38f6979172dbbac23777047487eba47ddaa9d045aba9b9e4fe6a75e87f2d82017f13b5b0b1afcf350d06c29501816fb075d1b093a5fb2c43ccbf3b110f5e648495c2fe6be7589d852898a517d78a233e56a162aeeda5ea568e4b6697dec17de1580f2329157e37b164d581daf42cfd299efc3dcfa5f4a8a85e29e87d95b755b0304e5f1b14b00db9c068f437589ba4f25c37318cddfc299a479b68e04c56a6bba7226fe4cbe27c5850db27f83e5bb2080492762a3998e8753199398f32297014142b649c3e75d8d3db904dcc9884fd6a21dd3e4cd63a3b9f57fc3baeffa31c38eda0e9f1cca5b244acd1dcb013dbaf1dbe9421b53279f5a59ee5c5a9f34ec8bc56518c79b99ed9479a40376db7a731357ed546bb50e0e963d38a392e46b566999a174a3444128ea70f571517db0153b342de173b4d0e12592bd058e58c5f9ef33fb4712fd3250cc47361f77f03fd8abc9b12029d27848f53970384d6866fbb84c5899c4749e51b3db89387f9bc5bb60ba38fc6d38b60c83075613db7c2bfc17d4bdc3a7c9c0f2eb9c2b758a7aea2c4ad66e700c742795a94932db7749e6ebc33f0e5fcbf229bcacfca2eb22bfe106582737184f01226cc435f4a9844606d46093774aff1ca15ab0f4cbd2013617f57f1ec4ff27ce758b92169ca66aca27821fe1673d43e1fd2e86901d0d98fc83412594cc52546d5ffc2a36753d1b0da1ba9638eb88512ca72baf046db694b93c87eacd9a58d8cc9f24edfadee99b69a6b91fb96761becb1009ec7454256bd3b9d97117f3831e6b399a6a784d75ffed5370da2ba78b3e14b74bf2d1e41fda1496cfc5409e28b11671f70be38adbb462c8c2e6ff7c558d809ddfc8983d49c1b9821d0dad833313602232652a323b3d3f94163734eeb48a612974793634d402ab3bd3d7b0f04dbf2629c929aae68f217e5a6b74aa96d10b963d55882c66369eebdc9e14ca4aef2c0c291f76c81652a97b9ed7de32bb22c5b23009213e0e570c6fea14af2910e882630eac9b0d4470d58f5a5a79e4ba419301c8fe14f16c6c5e27d8aeb4a9c09355b81e55c51e00b4579547cbb2c666fd9029a8feaf0715ff27ae2801baf121e72cc4cf41c23433802588e7eec93fa11d348443053f1e6fcf9310a942b81cabeb8a7225dcfb1bd4516e31954fa57daa7a577e2a23eb66aaee0debfc6fc2feaed7bbbd67a1a91960c34898f31d66ae7b763dcf54ef07d5441578237af0cd2d2254523f9afa5ac8ddc0c03fe2caf2440c9f369620d598c1c5beb07121157f849b78684bafb8f1141aaf5886f122771ca717851c695735c6d23c55951edb5872f3f9a2f88b7802c789c9580a774663b993900fe8311358727667ac34f870574e21fcef5f5bbabe5f3d5f49934463ef239a5318b4b335c8dbafb14b7ab8bf7f5ccb8665f6af3bb4d17abe139f374aa508b81c203cb6d6b403863f2eb182d774d5379bb9f1d7e4f1a4ecb3ff26331dceded07f006ffbf625a818405c6a35c81f1600bf08d1fa3d394f662a93c4a72a37db1d239d88eec955ee6d4aa05e9184998dcae6c8bd310ac89698b3e79bab232fd11e18342c2e820f9fe1e6a6cae141c544209b3f756c8618b80b680050b91525b8d65c3eeb42d79fa60b24c80c976cc1143a3217d888b58bf569c02e68b17f2b693c76893fcaeff044e704ef3abce4a6f3bf18d18e121c934b9eaaa08256fdf07f229d22668fa0ebc01559f3664c4328b6bcad39a2641415f8fd2461084ccfa18aff5c722608f220208758cde6846748b37a563b6d08ffa19c165723308e28061e5f0f2d7b29e2474f8fe80f8f17542b33ce78d6d86beb1c868b687bfce130185974c087fe03d128a9c7265acd52339c3d55cb14db206412b25e18a009e67da05f3fcde23dd6fbdd27b5be2ee44b631a329a582fbcd3d311c365fd6d9ca8ec2ba5a008437454004907161e35bb6e8dd81a789d7de223c38a2b22cba085d1d69dc451295ba36f541db629258f5fd3bafd250d077d4cc1658533b9d60e7081720d51e591a3382402f5378e1d2a54553f995b559932e936fbbff50f0d826dbd81729c944f00ae368a8149cc8a9c5c387f573e9b3b02a03b0a56a06c79a5afe5ad0a1a7b430b70cbaac5d8c70a6cbffba34c27e6629e43f47e42cbe033d5e7b4b723b40050cac735a17a1b0c1b99f025f2cda16d20150439e803757d50911018c8c76ae40648d9c343795e34cf5b15bcbe5169cb18d0e6fbfa7eb2dc3774386550950a6bc797ca49c12b6ae49a06726e1ac03f0fc0b1263f67ec95cc632f123d06e7ee7613eb0e32424b1babb054198b7a302e92823977fdcf6dc62e14d5111f862a4a512ce6a521fe5a7c69a3bc04af263de828c225d2b1cb893246cc423735a01c7b2c233c10484f96bad134f121b1adedee42ac77622c1021c65c819fb39fba13326c23efaa9ca92191d5d387ba6323ae98dec08db017a6f9c9ad7463f936d6d26242c0b021af92a08b0a181ed8d7adae2a4700b15621730a19268657c06a7f929243535ade5a65d7012f6f9125bba15cfa016836f7b71f82eab2b050b613c6970a5afc2c80426ab86f1f859761cfdc56f32072fc112fcf428c873653e26130f1e5d6b06887c635e16b919edf6da23470d1c0ac1bcdde6e8545dd898f94f96a30bd2c13b9e2ead815a7507092e3299d2e1a7a5452d02208d7d4b8ee8719dbba44b707660624e45b793ea557f89862f32e8f05c961a20d55d01a4cbb2cb08e46332f43b591be06b0a2149d42639196002a33e6d2825df48d1461ff1730092dd117b4e95da881c86158e8125eb7574e996ab7f3d4037d1b56b3af15895d203003ed05a7f36e3a63078f901121bd1e9575e2ee3502fa5d0910a3ef624a9042d845c66b909ff32ac89e0b5deba429957ea2e2644f5f2e2998b265cc8e8107829482b14349eb8d90fe4580f99fbbe2bcad633ed3c6867078b1ae8dc80330767d41ee11232707ac0278a0f49cfb4badf3d0ef1dd99e52b37c2a0118e8dcb322d1fd79f178de1dd30095c01546d1b82c6e37b1287310cf174fed4b6c88e667d83c2d88ea8baacca550151c86f166f6865959de42c1d0f9d5416831b2a24b1f67ab5443cffdd23799b42d972959ac1b998c54dddfae4d121442296d5a7b90234acafddd6169289f93c3cf71ed1ca169496ae84df75ed691c27c6b1cbc6392d6a0118c7165aa316e7b181bb3dc66046020ebc77a35b530340c6f2f51815e197d211ebc294cd8864520f63f12eafc02769781604f0e55401c9cf729a56c3dc84a53e78ab87d6b7af33065f1ec4341d1b09ce8bd5d792d7693f68e4aa44c13800e53f74506e0cf44846bdd9a644950428b68f401bf88ec3338ad64bc3991455e10093e56d5f1615b7c64241af0b2ecc6de6691e707d5c39f3396b4c17b5b7ff4e22570795454692dbfe39636071228bee5bb434d3be3969d9a17a10823a372bd99657fff391f8712ac0ae112ee1b0a1f7c26d9b82d30053ecc754ffacd0f9ac38e36447e9e3d1feb855f9f7de23ed49ac558332a53970231e631749e2cb93ba73d073cf0d69c046a7f76c72f8020e4fcc6276329ab34b48d84685cc254ca07d61632e7dde58875e754689bee0d4a7ddd13a1e4e4f43f2b9c249d015948766c93d93c01e6b688022c3ddaa75da7109291a17d6ca35fc8d66e1310869b322a4fefeb753a65870bfbd8c85e1011c6e257b5f3f14d7917b23f9e777152cdfe64c41bdd562553f2da5c0d77b9d2a61213fcc3a37fa426acd68482acbd85253d6c6fb61114080281ed9eeeb813189575d47c676b9d303326dc299b4c0b6209923fc3581ccf2e795d0d2b97a8e24f6a6fdfa85fe55f079c0efb46907014507212f4d5bd1c23e96bbf986bd0f3fab909fb922a4f39fe12f32b3b304cc2f5b520697d9b085a128f6de560d5851ebb4992bdb9b719abcfa9194d3dd48e86f21ea8ae931bbc27d24301ed260303acd08b07daebdfee20c5e57626f15a0a8b514c0b20ace18aaf282987f29f5702d3b1d682538a5048ee7d44c2cec036701a80e11c094b65830e53f7404876c0ddb512dd2cc1ed59c102b8ea42095a1a0487dea71c725ab13494dc6e480689211863a5fa22d536a84c5cc78dcfdae3c7457a7a1c30737546ae9b5afab8a4fc590ad0da98c1476cb185c60a86ad962cae281a170089d9f5ac10f05b68e245572209482f710b02f8c6df9308e3dcab5055cbff6e8c326e7acc0807b2c90f8f83e3432e40572a017d84121a9719357b49c01f206bc524e7a6d6d9ec2fda887044a1507fbd9ac55b5e92858c1f8f15f20a20bf67c6c4da40474a7354988a748664d9b169cae39220a238763d7e021dec667ed7279f0560976ab25b9645e0ec9cd9db543d2ffe6df9ccf151f4c4f3d4101d80248e0cb0cfdedd3224d8a56cd881b2ee9c97abe74121aeacb0b81e6e1064c7284599f01d049eacaf00a81522ff8d27d5f6c368fe38770bf9dd83e1623157f67313a326a4a63b727216ffcec9629eb639865aae550da14133534e7828962c6d7660dc087d9ddd0fc7544a7e8bd898ad094ab1b82d3d7f921ff116bbc61beba2dbe832f9fd6fda58214223033008a063aebfac9393cef18f288e45028f0173ad7f45062d093133fc1ec2d43c0b1b60a042393d9c8f937b5f32192d1460c29f2102f644394ff0393d5a57f3922911a3708600f71910de943614db6584de7752aa4d68009c9421c8126045a4b0b5fe6adeec241329d13e1327859f2d9fa4cdc7d9d5d254dd46ddf1a08c6d004ccc3c2fb73900801197b4eb053714357e5d4d0b9d3d4d6f2f1f078f15a091878ebfd583a46f5471eb0c3f41da61a22548b7da1b1f02e4b432d59953a6f4a567c14c68ffeadff071f0c6dde97c0a74246bc23bbeffbc95e87d1407bfc4a15d1421a68b65b8c79f0326ad884234a8ea72b6dcdd68fe04270035393895245b9ff3895c2d606c63ccf57e071b1d41f0a8f3492fa73750b517e8e95167ba4d5528fd48f9cee339d3bb5a4eb1041e52087b998518853614687a59faa76e1948aacdca9cefc4d44b51d4b9ba6e8d4eb89ef52fd066c37d4f998bec4422931386f363ae738c18eca2e6150a4f37d9fe574158047204f663ee24faab9af97cb631bac2556cbfda9442f7254d811dcd8a11d3d2c2a18532b4c34a92051365f18dc1e073b974ec982c255c15e81e9330354ac118d79cfecd93a11e5e0f9329762a3ae2b626784eb44cefd13b6a7020618ff956dce949782313dbf4aac46ea3924ca3bf75d57106830873d439dec4588be47b1ca2f6d6b5b3e841cb0121a9455389b5a6cbb0445b1487097feafd077370e76142611968af6425dae7e21ddfb0cdf953dd8fd30e7e12cb3a80e5a187ed73c6d506c9c6e81bcd30abb3cd4464b60778763579bd7c4a0ee3bcbd9e1d0f13ee6fe5a876be15ee8456abcee8c6a02f2f21f7e3777b929855906e3468dccdcce2428342ead69244ba09a529a56d5bc5d58695e9e65b6199d04c43c5edf5d170503df5fc2378edc9deaca7735a0d48f985477ee249738540df1ff79c867e803f63cd8ae8b5361d1a955488cba71ddeb90158a43d0eb10e37ce8cb7f755db3e1af41683cee0768f74ea270bafa37492873a2647cc9baeda3891a9dfa3ca31a7d02b016ecad0a785af34b282faddd5e25ea80a80de7160998f19cc33b58d29bee9047d254f632d4fddbfb16754a188e5dc6b834cbfd01bb6b0010a749d377dc750efc83acfcfdaa5efe2666be52829fd52882eedaad9c018026e365d37507aae97bd69cd616677af8729698043af85b7bdd997a65eb8a20ab4c8d4bee2279af562db16d3524c5c63ece04276f29045478955449b2744b692b15b4d5c6eb1cf6183c16c8e09b5ebf10f87cf65364cf054020bc7b6f52d1b618ae572039c63ebf491a3b8114c176f9afaeb300f8ba2d882064190df528e0df6ffcd042a7fb2a657fa10d66273d25c9aa1ebf86bde4488102f6341af37a20e52e04ef4d833b07eb62d529f0bfa3b90725183bb3bcba84b16bb9737c3bc1372d12cba1e40dd18544fca49fde6ab4403b4125fe2ca7c85b7f11bb1979909b5cc8fd912714d7997beb910691fd4589e7158b91d3d135a35b81ec5842f8230c0b0f7dc938682ab9ef491d8b69317fb13f2989814818c570fc71bfa333971806e4a98fcabb4c32cd1af54948a8bb2136d2aa8b6d9f05ebd02da26458ff23bf17fcda6719b7c6528bb773bca5e3350e8510988b3807a11967ddf164337dbcdc96764c80775425dce0339ff74573a7ee38e8d87d72886e12165e7718c330721c7092ea278daf78cedcecb41b35b2ee4e266f99a952a247e61e0e0621ecae0e45bcdca610362d6a5dbe4569f366cee00020b71fb4e2a9ad20606bc445f57858eedeea278e699a5151c989f33310f4f82dc30f67ad6aee04c3d110a568c94a7d636ece0619cf20273bd7a0a6f33331ce6c411f966d7ea27c9d81ee7a455ac2a967391ada1462f9399411de8fd33a3457dd8fd341f2b1bcf3dbea61f9aa46a430bc133a4d70035cb00a992ba7c2651d0b90fe98a2b87fb93d047777a5e009c42f98e25e84989d59c299f419329a1266796ea7d263dccc1327c15b054be5329e103193fc86f97f4d841957e49ca66d8b7140edca894c0d6042625eff4782b1ec6675e03cb93d4999c52503e067bcb36ec58dadd8c4dc54de0f86ef2e844c9e8277c313287194477b0418ebb5133f92b8e8188db80263263e20a8cff9ede28e21069413102c3838e8ecd2082220237ba9aafc477ba785dc6b392c9f6bf0593ee8dc165f06c0afe7867308a0c5e617d467bfb2890e7194b940e6fcec9575a0a4dad97004d55d4776abe8589584afc81f64141784dd5aaa2955b46cc0842bf1f4b5ba7831f7e606161bcd307a31315a687006698bea6eb4f0ff6bf900f47d3480d311563e600d5dfdb38a8945f1b30ae1374bb0e8dfdb2cdb09938891f81d2df2258f6514b8e8a5925a38907fbb3fcfa8acdc436f9826866b0aaaf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
