<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f75a73d71c2582f75df591da5ee64667da7b93d9170a78225f86169fce429b3b2ad06866d0c94b25c72f406877ea0318e4a27e001fd3a5f44de84b0c09897323b3ff46cbf676d97e5bc1b7a574242d49ca3b01b73e0a6e55d42f82ccf701c41adeb185e05d69a7c67872bca3edda0477fb68e488907a038e7407229f48539b6b11b4d483b6b8a4bdb490fc61aae2ba4a8af6e27a524a2b5d78cbe72941209f7da4368e3dbdca1894c9e6aaf610219522c30ef6a29532ed15306af974cd2aeff99ce6c6bbf74e86f6a3971ef04d0a7607e2f4d354491e07455340725bc11f6a9f6c536a525e77ac49bb1afdb08cc9f91ef4b67c41402aab39377b0fe534e7ded4b26e6031f5dc50f6f9b1c55779c2f2f2f9344901c5341070c01632fdb7b8bd0bc1d144eb48bb3fc68c448510c144b5e6326b6c070bd9feecbdd062b71cda8c0e45ad187df5322977c71a7ddf33c9c212f0e5f2683b0f5317e09660bbac08e4117b7bb4a76b471fee65e8089d1d5560b369d5d0355c162dda0609a8933480be5fb3f4172da68e0f022b3e99367bd86e3ed61e90e6099e530bd6b6a2e2ff43caec2747ec821271ff120fb99bda1c046244cd79d5848196537497d75b1b00e4b0b4e7ea7324261b098e0d22942df3bf91dd161b9e83ef68d75d7a50b55361d5ccfdfb4e6bfe829ce0da021ed89c25d5ee5d03fa397026099942a89f5c4bfe7c8b8f4ea767efb275eb714d87826ebb6a75adb19b54dd877ea18fbba4d06921420965f9596be02739ecafef63adc91357051d1ee68772bfb422fbc6c17b1cb0b582ea070785a224708bddc712a0bf09dbe99cfc6b713b6b81e442e7e83f4da4377885fda145e97823c28af2bd33fa088b51e78f2a9b1dfd75cc4d80fe7b37af3f048e8e8419d1f04e6fd06959364071dc175c88fa685fa1c948dae85031c6ebd01a59b9f0e956d836111f6f0fe726e40fde11f23e1a997e21c660e72ad3e9ed76cc2672516724d16c9b04da7b5a980ec1427bcf446d1dd788d35f877c67cc9227992fe2dc1be32ec3f3f390b685495ccf1b09453325b9dc10c385fa47f10976a2385ce272d7a373af88eee9cea199bdc0b8231114dbea7672b545ec5b51f39183af3138f6d7f8695fb932887d50f70875c69f3011cf27391b6b250a21dc9547c5fad3811a73ac216d88ff36ca184875f96e3479611c56f14a4f73e3857eb2abe19632ed93402f312eb624ccab4b22b85c91645a351a0cbf3a656a1ea96b30e97c01b8481deb90461f42e50e498ed650855af531f1bdee3f20cf9f38e4c5547248d90363401c4fca06ff2ec6768a29fb07981993b423a9805d201ee69777fe44abac3429bb34e0eadcf0743401848daa7f219611a2e147fda69e81546d186465afdebb2678199278a53e9ef5e7a7291d2d09451a0942ed49d5ad803ee574e75b18e4ec95cfc9a21684a7ce8b503b8a622b812034a3ad601531e11d9e0943fc13cfbb9d85fd32d760353a130667015a79bf998da1b75fd74d8f63a8f41a53e31f2ab86e48e135f8d8d69d229ee884258f6f99719fb61f2363bf8e76919885bb7aa536267554a2d460a35655136fdcdb652a53acd020851a72ebc9bdb2e211be8af31c43cd22c91968d8aec70a663e18f979175ed42db924d159642a14133dfd54884e7f1cabdd3f3bef8ce01c77fc0e70646a31c6c412c1de76e230c42fd5d63ebec18fad40253cf4608c63ce45f0650ef6f2be780bf5ee7bda5a77bf973b6d84f83f72456eba77640b0f247d97d462301f747f59912a071134689a0605a57e2787a0fbfa5f4d0508c019dd23bc361a87bc1912f983c7fa028a387c18d5656f79db5a01cd8402a161bbb771d33a5e3a1b8fdf218929234df3c0fd3d3b51176e0fabcfbfac50cc45a0da1cb54ea5ca7d020e787b576fad4062162597094b4c6b4ba8bbd0f0457a953b98b079ae43e391b7cfe289e33463104ce9ab360ced92ee5d7278710a4a9210fcae7ee3dcb9601241bafc1eee110159e56f7b9accb073a250832e0d145d07462851017a2d68f38f90dcd11989e5fe76b99c8d5f4978465c94090f60165bb93eb84fa9d8704c5d844169353fee30d50c8ec78d635702f5d9cb3aca32e49a5254e8330b82d1276659d44beef00153982c7cdd8d533af56501d8cda263d220f4dae31263008bc320bb6f0ad8231b80a6c69b88acd74845fffc134a304646a68708fb9dbb9df8051b5c4b30f3c689d6ee92921daf6cedad85b2e5309fe69301e1d32b4818e869afb4d1c1dc67759f011c2c7d659aabfd26d1865ac63202f8cbeaf4be4ab7ea0c80dfa54850402af19c15875392d61044b17c5f4f34f11d71f2f03135766f658c344fad320ecaa30f63fcf84b409084babd2e16486c1f0bcb5049a0139272bc57c7a1f71158f83afca0b8b41a074f63e972e3eff91ba285e7d6eea610ac7b49fa009e94c25d670d470e9541567af9c3d33b57c84eb12ada8c712d54381a446b0dd95d5a40e9af134e1b1a3dbca94c1fa9ef5dc8b602749808cbbd50ce98f60e81b02bee30c82378104d132bec135a1b61520eed8732bd0e29053cc88d16db5d5d2fb1dfecb1cc2d54a3b396981ab3a3000c0e5c701c77fc81f7f64b4b57a15558fb5a24410f26bf59b4e0e293fa70fd95f90f31edb278aad598628a898ee048fabe95f051d79e6b20cd4d885044bce59cd709f01f16a6209c36733feca973c36f5fd494ff9e7e76d94783ca96135a72245b1c54644c441ce8f94828060293b469aa5085ead8f9ab41704a4838bc14f8a8f8f9fc3d44b0a2615cabc1f2848c7e69cc7b1fde3eb36f9a6f6db3c148b963e0bdf4df304563a44040d9ef358839ed44bafa7889babb23a5525f6e5f495c23e8064dd06f6a054f6be8af2dec63234d54d18f6c9a0daba69a1eda45d695f0c290fc4af99b25f9f20bda92530abe2a55fa2733cde741e6bf579d4ba318041ac647a60eb54cec06c2c5c772719cf9f37a1c76e94efa4aec35f58d5f2146cda2ce76abea4e25999174d7bca43ea2746b685e4084f3c05fba8e9174ea25b7a5cc1574b87ba32ad3100dee65960586446b00861150b6a74169595362abbc2803fa61980c6288cec7bc4520a695b558c81aec2126023a0b8be0951e1a2356defea891f3837f3b6d00c60ea54dbd0bd168d556b42d895c5b9517dc43db77f67299625572fb556df7e72344c72f2e4e1af14d5909f5d3d8254223bc631b33c5d87863867c1bb043ba50c371b0320667a6d1cb939dc65b82d22022167dfff02d75f66b59c9c4cb7cd60c48913a68e271bf1753bdf20512e16e775806d7c209c57307e02dcc6100126a6c03c652d004f6c52c39cbd4d4e358b78a22149718f5ed29426ed8a66d786331719f0f8476b67743405b25aff1fad54f60d6856668a270ffd79984681b8bd026c1071d49fe0e17124d79b7a7d43935cf272c9059e339fb4fd1fa496f21ba7108d1ed51628e66fcf80bc18617dbd6b742156aee760810df32496337ce5aaaa5becd1b897d4e7b14524c35a8dcd4def9a22eda091cca1afc846f1a1fc6b969fae21719c8980eb39a1ee02e133eb2d6c4fcb88a9fd0531f4a985003467daf1650b2230d08662564f166fbe2db90b7867f48f99782b9c4d095a86f45487bcb63d9864e97f9d8e48592087d7637e24b27632294a7e319f446bc115f6c5d9750bb8c233e53ba07368afca259c9df1b5a064565da23e72500aea72b1f3dff9c098d30a77b3be5130f58a7e6c53d43eeb2498a4546cf43d5f930b1cebb93b88e1de83b847ef9abb8ba7dfcfd42f5de28066e844fd3f0833661cded2c6ad2ab3691b6fc44a9842b51587201d6c786a32f7104574f19e95b8f1fbf515bb0cb12c30617673f789d455cdff0ee94bbc0cce1a6e97aad03e4bfef6e896708662607f001cf991bb59b6bb116d8d4ca794e241e371d32d6e7c00d550b4aa3e1688a82f5165d0b51d391a5734c6206e173d1a912935cac0cd270468dca4ab75b87f05d1c2eb633b9cd93ad6032079ace7388fdd50e9348912cfcbbc29eeac39310f702fb3848f5339e7591b563fc6a7917c5899cd54ad99c8bba0c8854fcc4b8fff81fb14e89ffb26f7dc1c97b67581a5db24893dab9daf78aa8f7d28e7d45ba99da26bff9cf1916fa21d005ff5988925ffc6e10bde4a2c9bf68b7464bca763619afdd955ef5ed8503fa3a971a96a571fc78c36df878221ad56acfb51bf0716a28c8f31e36612239309eb31aaf5ea676ad2a4978a92236fbc984d624871a59f244c0c4e1486cdd05b3fe3fa8abb3419faf128462398b23026df625720c130ad78b89f59796ac640b3f4df481565c86ca96be85af13e6f7dc6163a5eb1091bf458f759e3b5e78be9f1cbc23b085f880012bf9fb97d55b7974b3a4d91d78bd4021c4b97b2fe1bbe01aa2604cb1f8bc2c0e4eb6e972134b5f8c0693e14473dce284cf38c876f4dac0a253027fe2c33d9a1d4b5cd294d98e5df185dc7e16b04eb9646306a3039b72dfb4b1d9b377b9f8b28222c418ae35a79186704115872853efad91a8cc98fb1db9c4261ca71a62d15191857598fda1c756d6746e8469215665a437f3bf0f395a3999d06b91e7e8d6567598bc602967f6d235817a87445f7676f2e0f0d1d812d72574476d6151799a466b04b478bba5151f63b61fe775bb7582f777708a854ea8e0d63c64adb562d5ac22c4f70799c7dca9bfe798e03689232be925b43dc2442d018e0b01dbd793671cc548962ae07180f78bdf84ae9123b84eaaf044a660235435f449d3e973d81ffbd79f81407f0689447538de8b1807a3d79f24b8b12eb5d428f5a896a6904fcae50949d3403ac3fbf86d2fe5eab8c953f50c110fc3088f512b18160b32ccfcdaa019663ae8ec891ea66cfe7053052225900288bdd54edb984110bba63720cdbd901070541878fe33f4ee5f07460a9a0317c998154875baaa3fdff17071f2f6b99576d13cd59d1c2a19c291555d7a4187f06e171bdd97903d6cb26c4b993677bbf6ca2e536a4b12bb4ae6c7ed76ac7006d4325eca75dcc3bde1d973da3efdbf7f40bdffabb5344518590fbadb04da8bd76e5c7e52766b73508735cbd0b4378d4318ea82d761554b8792e52db27f078094a06efbf5e3f6c1d90ded0af9a40e168a6fa4f6beb823fb13aabc00dd4531dd5b6835f509d7c9657002586026d3cdfcce4236d2f8bd34196328e4e08d8fd0a5a9b61b36643801495ce05a20467c7e5525ced6b1a0d038ee0bcd46a08c35a798023dd72545f66200d4b3fbdf1f830317013b7d098343827fff5cb6f1333ec02fabd3e01b15243152a51d3098c01dc5c222ec17efa155269d3eac6b24ca95aa6518c6b2221b6047fe71b95710586eb34f26d117d3bc62354a76c15d6bd35986f98ac0bcc93d2b29bb52a743053e392a85f2a41aa7ab58a719da8a2ae2ff0177ee26d773890c5fc832fc5e5ee5f89b9b6f952e9f35064db263b84e501ee19016066f2dc55d1c17f129d13535e6bbdcb9678d337db853fc94f40d5f62abcac7877e0d5edf2ec4e33894c07658a9335d11aa05edea099657699edd141c11a56adbd2a099b875608fda95c63af396d07d6e14b5853e7a573e6b938b05b22635709ee0aa9049358b2b4a570a44eb862f3918299441dffd2724520613859545fa04a69505ad0ab946942293a1a1c299ca7a3efc8c11d2b5262666ff6de8df63e1d38e440a7a34e0166a26333762fed2b47bf71bbd3a5289cc6897b1c7432a5cf6d7a11817671fed93774245db9e5b9cd9b09c78be148cec03ae2e705c4d40498cddcdf7819ace4e14d5d47a8fe2296413e277eb4e52e9940bdddfdc78bbbf431ece44d00f0e889d7fc77996695c2e85fb694abc7873b1c32e2b8af922f22e1533431f7c37a9c38acf937082bf9d8eb0eb753d639417e2ab690afd2a4e35fbaa4db208c0492a2cc63fa77de985bc1d63f3ac2e15af2f03b9fb7d32c0fcd887f5a1b95ddd09f45f9989e42500da169a9b9e6a146b4e4fcb9af154df5721adc43c22528bb28c8913f0826f3717966fa41e5b2f7150b6f65a9bc918eecb9ce4f21f570f4163d8132a17e35d5f376f4ed605091b816d5fb46563acbae67bf7b497dd2d7c7aa6e8768f3c7ffc7e721c73f1bda71d65b6eaa1b8a2ec53d07d6cf005303d020215a719d3cada1ad232a637d81aae71b87f6d923d76ec5ff62ad781eaea42dc9055028cc35f9693185d0445b60d6bd8a66fa66298f487b25d808052d12dca6b09a90671100660655e3ae9d46f657bc0e397a39c3b74aba52b3224d08a06b8171a38fc50e0f7d27c082cc0a57a4ed9e3496268d6bc69f39dd564e0c1bf12f891b46fe86a32f4c407d9c46befaeb10c9e7c3a0e03658a1b1e5d2d7ee9aa336f06d5ee154b92e949558f63da3dc9364ca8d887b26596d1f74cf59643ee7a0202736207ab4d2aeb8c555d87325ba0fe702651462945b3f057d2e44ec4db7403bfda356c292f09966c5c43d9f81a47663d3cfbc4e2ec41cd7047c9dc973a9dc7ccf7e29f2d2935ffda73e53667b2a962f52ad142e53270b51208bc2e56e415275dce7f38f8eb048a221db4f0110763a4a8a41607601f5d4ddaae9c83a5232f5d8c3889f6070186f429efc80ed79240666ab77344dcb10c5fac3438a07ab85c602ecbf5ade6a0e6b5e4e4d4343366c3e71830245df7d08f58977fd3c2025d8f712a5459ed53b9b8dcd37e05d239d0b707fb047328ba9c2d93fdff005d4d85a19f33c4a094fb735530c9e2613459ad0f346a817a21da5dff07d6ee7d053838e440205d1b1375bdb830cd8e71be462307080445a318e48419adb6e3c6c755e1699286c0f0de6553f6ad70b4ac303537dea52ac9ef56ade977f0222be922d3bc34f9c874c738a19fb1a388a512a555d7e43918e92601ae83a4daf8ac962917e0e2a0c2f5215a5b3db53b6ebd822e7cf8919b0a31e2b99f3f4155a421a517a15dcd08cc0fd0e9c2b39bb2d488852a98cddd58facb4b7db174bf20a4a95b24d8359dc6543791b8acbbb64a17ea6c59a44a640c849f7f89d223c74ae995400e9b0b16e1488c4eabd1bcf78ba806076078c93e7f557e3745c59a0841ef4de941fab85bf998b2b9abecd1753f9d56a12d3c543c29e13da0cf88abc04f1770dc51e54313a9a61bf5f25e262ae2edf19ceeb6118acdea265761aa84623d963447fd03ac0922e3a266ac73bfba6dc3ce4770c40915412ee9ad5af631a9b80bc705e128878c79bec4ad064b7b7eeb424827349c9e64ba656c37be711500890ca089adf1697e5d5bef576dc9001741093e99479ca14382431783830774d43e1b569ca46094feadd50a7daccd435825d51fe642c6c5ab5579e131d8c3d2747888606345af044bdda52651d7dc62b583150aac794e62faa6b496f0571c815a7c10f34b3fc1126a5cdea764d6f43b0241ed2d52390fe914f0f2fa9eee5c6829e5b593ebfa9ded56fc9f63b14f5fcda0242e9daffcd152016d80d87af401b496a1ec13a1721f39018197670853a64e5cc883807d5234f5f06ad0ce2f4411532780c19dcd356f903b6f00cec984b1bfc1b66ca4a160151147ac103eaa09407b72e8f6f41fff1931121ced9f64e00f6ff2a9859622d9eb4fbfb85e707f51fd2f46a8dcb30e396fe951289a2fe20ad7de583b38ccef75694ba8ffe99cfe5e4649c618d47222414fc08959ff1acd101cda7661298ad0335f2be8cfd49486c606841277d0151b594f6ef236c7554cb7dfb78fed3870a9351755da652855647ddf9b47dfd31600f4919e79ab41db3296fba46b0f06ca71ebbc5f1cddd0301c52b92ed66b37073137c2adeba6ec3949b2734446220b93f4e78774d5d6dfbf05088b432ac8b34f232a75f4bed05ee6bedcd4ee2efd975f04ec5122e320f5c93318e47f62f2c80f388418579be72bfcc24daa886ea88d6fef3c0217ee04f06f2d54ab9c94d69cd7eb153e328ace94a4f7fc6356dd418fede70f04dd4b2434411ed13c87f3b60d72b5d23eb050edcdcf1907e4d7a4f8a577bac67a3dd0cdcd2d785f5798091d1cb8660501821fc5277bd95ad2e16bcd60d505c1eb3a6e973ef0123a6b478a9f42325ae5fd4a73759df837827bf768290557a60c00df36cbebf3825baff3f026a3f7fe0d792b284eee84b8fc4898177999535166c611b3b234bbe8d6b135b43d6c371235cbe2bf4216cda297e7caf300310b24349b09de48624b7fb045c11f51be28453261405024edaf3491d5f7cb0817b900be0d43ab145fd4381ae6f94b66d4a162c339fa841a0754cd2249f06aff060fee504356e07f78df5aca11b6060a6139d9d78ffb1c70d32cf2c2f4285e352fa3a6c6704b15c47622917ed38aa7dfad4b5b8746c5b5062e06e8e6388e445fafa964b6ab7b4a34c4fb57cece4ec83e9fc25b464f73ddeccd91e03f7d20edf303c4e5dea844477ce84787f2daa663c0fc58392e501337d3f4297cf0f6254d31880cc3c8fc08fc1da2e7027a03ae079be4a6a78968fcbb1f526d08d0896bcf032736f56fbbfe31b694b7a031158889cc8f7996bf81cc568e94aea3e79891fe98740f28838a75b728107a6974f58330e162eae1e61b5969173f2aaa553f2c5be5437472516b9c0dd4b4421ed42c8046ebfc942afccf53acd10326fd5f40180b3fbe9cb98423b52b25d134300d1d67cbe4c1ce2b74b57f33a48ee57e6c58c6c29a7ccd08bb3c25db64c434fc1f1595efc58ab7a1a7fac17b59767b34118f995fe52847a739c69208f9e13cf43d57d9f6afa4855fef717ad66f4d30bfa94ef6e5ee8301de422b815a19dfc4120c3fc7e054854f73990a7aae86e1864d7b115124b3429e9255e70ba3679c7853d5a899cd47515cf88ac092db91a73578e8243fe5df92cad68f9f6b8a265d2ca97bbbbee7a746509b7ef60257f9be0821548e97787f514a5b96d5e228459af7c55f71816c0003a5b23cb8b5668923905740950cb9ab945755924c0330a4f7c0755de1744c85bb1f047f7f95d4a781e563ec22e4287c7cd5c6c1dcafeaf8281ca8cbe1eba6ea16796c591f42e53cdeeeadd05d55b636f429ee926fccc954634bd73855d40a66bccdc983e4e92103a496756a10056e468ceaef8357f2ddc70154f254d6b186ac28434f947afe42b90482f94554103a6e25071a3c1791a8d0165b08b3523d70e552b796d8bbfafa5c56e5e9a166d0d099ef823b630d3ddcab58524be5bc71cf62a09707f7fa2ff38a30dee7f6f78d96a4294146f4b68b0ba30f9f7ba50bed51c00d207217aea556b8febc740abfc7babea39f2572a62b781e310a8485657e1d460b62a869e949822a88519cf4bea13ea724d18362475ded8173d540bc76d7311d49feb6c372e95cdc1aa632ce9c0597018a365d1701ed78dced8baeed7da2cea58969c01708ee69a5ea72ccb497afe0a3094630ff24475632bec5ca8fda9a2138bbe728a6bd184f1f2eb6ff0c0d42bd72921b67d80be6f7ac0edccbc17471a02fd2b67888b4644f839496c744a4aa1c8bd74ee34998dda9f684da648345ce89463c9ff715c1f34093905a9fb6a945f32bbcc12125113069a4e6a5b2d68b81153e326327d98a13e2e18fb1327773f71dcbf83a170a97f74dc0bd000b3ab6a8e50b3e01617c50ea23f8f9003ec3068f4dea560890c8b77deea408ae09b8a761fba160afe94ceb2231a20b6070df20dff73d087b5ca8ea29342ed30f5e89d7cf4957ba44ffa57728f7a68b2a33ab9dd24979dbfaed393fe7cb46d8f4c3c94f3b5d6e0d0ca871817b5a511ed11c9177a34cb78983651f9914d1c2566ce3fb5531a63a28854d599914be2198d01ec04467e707bfdedc2c4668f6b141f03975cca317df4f74f10696d286d7018584be1aace97e2394d0e133cb693c36ea4515f158ed9a55780e1c09bfd5b790df82e73299022125b13e0cf5e99aab56058731be9f8ae862b95059e2e9aa6ded7b664b7f1397e41d8ca5520a5d7fcf838392090ac50bec5b94b0648e66fe6b54b45ac685343bb99ac42e842c06b404c44c066a45c885b7d2e986a19796fd60bf836d21cef3fb56598a38f6dccf2add8e4813acce0c8cde40333872284555934126d47679470e911a1a327ad270e902a1524a93791b0d782523b6e382fc8d79b80e2f67c5873d61bef275117c89af2106b6ef7f8ec2a3ccf507c31ead96989e6d6dbc16100caef9a6e3987ab11266827641cf29288679cd031184c5975fc6e1b331889e927019361a6c4c2ed8f5df532c6c239a2e175088953bd78f74510556ad78f79c9988e22ea2a90418db4c161ec08be801ffa51f27bfca8b4092f7e94313316f4724aa62a4ad8d4382887455db5104b0d8440d96dbb23c19ccefaa0fc4fbf62e80acdb9be6e74fca6edd6d709c42be1cac5a48edb8f94c6f98d4a805bc22030c4bce61a4118fa90d2c78b90d808ee945c1f82a0a7f24cbc94644af39528f8c62969331b013ed52d174ef85d5b88f769959856120e001db50f7edb8f47c27e849310d28aae5d74455fd49f4933b63d35b968d88e9659c46d4cef416e5012098dde3f4f9f87cafda23a99bdab0e94a528119e3c3daf6d68d38f2403a8bc024e9a5c67964760050d2705b652f31e83afdbe9ba00cf226d705cf28b351ef1efa7e837a6c758dd3d704b9206d02b338fa4b18d4bbc83540391ad0662eaf15daf0bb10f550a1a656fa53e8b66fc2736989e31a9db465c6d65a848ab1ba6a9cd970b9a13c74b37d715880b717c95249a5adb91f1068eb9ee4e0cf7f8b0c8dc6b6bc0b463ea63998f6b178789522408c36e997cc082b891e53cbb99651ca12fc1ee0007d1c02cdeb01295dcc13b4284fedad4440831023253075a617b6ca2b8d81be0bd75fd068d60e12d2c68baded8f8663cd133a9a6d2070a27d5a9264ea5f63832b5832c3f7ec516e36b5e5faf85f028f06247679372b91d86db071fd7833c8d0a2747f29ee5040c796111255e9f9c495cc6ff0bf2ea77b35ec1acd0d1288eb2563f83144b708512ad1583687828b467b30fc455e9e4ee0e93d0535da0845c007e5922c35bdcb954ad93afbba1a485037f5f76ad5bb894a639bcade690d91f0d4ebaa214f956670c0754ee8dafd7f55815e1d76756212cf6bb24281237048c0c7cb33107a434ee88988b85466cfc0a59ac3dcf43da8f99b556ede8d415d6bc5efa8c31591826005a8ce81b254d9babdda704997ac53f863ea605f2f71263980c4472af3f8adc7a395a0f99a8eaa9a267ecad9c30f88a29a0a0ab4fbc6dae93eae79ac829cfa22993f451b1b09786358d3d6c018d81f3c7b2687ce4a92c4d2faed73903afd500eda70aa077ba7bd620781901c599c81c9f5ca2964abb01f44c98ece8735cfc771ae755197b13fd8c10703ad22add6473f065220bfce9696f4ff95dcc6993c97e5270a22cd62170f840f8075ab429ebc47410d4f01aed2a838424e6829fece787295c515652d299b9f24672e5d7e74e89a76f44055913c754b37eb47613b1bac232f414dc2d37fa412092319f16a0b6c6a85a5398181fe7005b91ebf8af6acef05aca1e9593cfd38b1a8bf099fc9d26eb5423463e54eb3cf623357b3564a710c43f1612189828c467173adf212f6a35574d5bb6e6b8974c6efbd3e74ff1b1aeb1693eb6485b7905b36a8dc9d938b226cd9232ba53868a52410b364cc39130ae650090a176429ec772dfbe07f0ec3598512a7abe6e72e6c8d35d358cb1b143b485b4d0a368f70e82187582d077beb30539c22a39f4282b783d69235ff5563d7264b09b2e3421e966e3b1384d943ca86a3279b6d95caea43a85298eeef8b74490aad195a685fc3e4587c89906276b29c2b0466b7dc2c291bb5513f64be90321c41a4a54d2c2cb55303668aec4e3d19e975015aa55f508411c91a1c51a233b9d28a6a8544cc5a4d82601784efa1a11cc751d135a3623de229d07be838b768477bc594afaf67c34ec3305a279d61fa0277e0da69a9ddb57532ce1355b983abdf352dbf1a8aba9a3a05cfa64c4465b71373ae195fd7ca050269aa11098eed7b42622d516fff6217952b29745106e9239a9c8f6a03bde0ab898ff71ed4c6427b63b581f8d13a4053d5c16cd3a4b754a1de34d859af6851e175bf222df79f333250eac96a8e7761b8e3f727f390aefc55abe7c93d93ebf135051358cd6b3d81fe65e219d89e5863c614d6aab0d2ee525fcbc2494ebd9e7aac43a4268dab184d5f1b23f661082dd94353f151d23756988deea9011fc1159c56b9f86b820e6ed10d3cd98ac40d9580307ebdbcbfc10d637fd106a3420623ade9b7e861c07d26b50f2fc738a29661e8c255aea99f896871899a258278c5848884dd39c05ef3584d957dff84fa4cfdba3285ef80face8ee23e45453181b9e321982743aeadd857e478cad930baec2380b8c985622cc74c0f7c78b3cddb1a5d46dab6ece33739ab8c2a1bc76ac3ea8f0749f6bc3f76096b0385e282d41ee6a607e47a7ac21eeb3b485481c268e9deed6ca7ee2d6d9434b770fed7dac561f9734eed97b35990c2981ac1c46bd68f7db1bdffa62f02f00efae0b81d645cb72d66a3bd0e24176777560cb11fc6616a32bebd52708c10edacc99742bfc26a97cb9f61346e4553c37ab13e1b5866643a671c123e5d80385f582ff321c6ef7c0dc012d972d706ba86685720b69139697c0d120da01906cd4b8dac8ad53f59c24afd8e329c20d0f793e54966701def6961758d43be310dd7a370d82911f4dab27d90662e1a4113cfc372ac4c1b7e866940808ed4e72de2321bd49239043ede39f762dc2da4fb578633a4859094c2a96084dec92d2c8808e0141ab89dd16eaefd0990f8f5ca03a0f7bbe623a8b19a5807fefa1dd671ef4e1f94dc4039e7f738a006776bec5beccb7af72a134878b4356991fb151380fb3a67480e03da67fb616931ca6a3cf9cb4fc32169b5b616122405d37f62fcda9dae1f204d02b30c057e37ddfd6fa0c315b22524e4397c180331a7652ca36d3943810867836c4a3d77e5388539c70f0ebce83b149850ea009425ef890cef4a1756d43df6b8c0c45f2760b4998c974ede9ae744575749dfb4390ddd724e15ccd355585f0a332f88596873ca690b8d9ee815998d4dc005705eac070d79ba0ef75d1ef4d1b1ceb7e0a0017f902cfed44c29201e38a3160d50e0ee66f5c7d2061559534ce3e2dec05f5c73d7fd6ccd79154c14c15eb8707c97ddb0522e0ac7cb45eab46fdc84ee1176d87ab353ff7655a7803a40741c230e868d79f907a6a7c70416dbe82e53c58e864fb8b9cb76a0767a9720fd6d757ecca0ef0dc66f0aa9f113da6038bcb92f002d5dad43f1aaeb8e155707428503ab7ed947897810152fdd7cf83b890ff0247def8aeff1a8832b1a2f676f5c88cfde9c7d4f007e7ea531c685b7019e44663fb2bdb477d162513fe316c77bf07b273d015237a4ba022641b2639913e45a0dd0992632f0ace297973cf29c4e4d6006bb370d65769e939181c7e5bc73912b448a0f42d6e0d7cdc715b3ea920a986c4d1ae0ffa1508a5c50b90a2dd31401a69443d976a9fee98201d837679e060867c5fb9fbaea0c4b12244b9a6ca60225e66d56468e0ce7a327d17aa12020ec743464aeed8da44a64b7628d104f7b816636554a8cc7b9b71174cfbbfc6eec0213cce701bd1ae7c7179f8ab6321ce2174b07eb02e79e91696e9a6b3c66296a81c1829bd5b3e8c9e1850ff8a1b885ce2ac33d58c4ea5edf651137254129333bce6324363a4f65610a301103fb8f0599e7959da19b752d246c9f0a25b2aa04366ae5e2082215b3461cae5183e88c1cebb118fb96d90cdd39ed0f832f77ef69e464939756890e3ada41226eb4b218f915a3d598e9edb8d77b92e5f0649a7cc3d9ca2ec66cc1297dbfc1f5775617579e01415d7ced393c66f4bb5cd2f6b18102ed8830d67849dd1a5af40eded74c7758643ebb613dd7f2071825772837d87db532ffe231e8541725996fa86be3de698d0a831fbfe7d1ba853480b1ee9eb6c6e5a0a9607d659146f7db6e6760c97474e9c10a43f1bc30897928cb9da029181ba6c59a3dd66a046cc487aa132a827bab55aad89a46c4bb95bdd22fd8ba13ae45b78f4c334eef3c183e35695eda98ace77041671115da795fdb5d9e4597433efeaaca4db9a3a026d9f283403e53ad70282bb7c65aa0a3477363439bfc4eba82ac99b0586f7d7dfa3eabcef588ecc2800cffe669dc9d108d244e9542ecafd0f4f30405a7fcaa73c788a96416d1c064e8d755420e69c09239ef42ce3191ec79c1bdc2648c7a8fa2ca21489a842c3b2f3f76e1aa048180fc4ef5241100d6b0f356e1e0669858a00f7fdd275c2207cb14f28a2f2d2f80d2e78b92c7f25b9403b040bf48508da460ea8707d6b7409df521c90ae33ed128d5520f57a81809ffa59fd74af9c19db9a8d00776894a6db1884583c2583969df437c5c19bc05d7cff99a35ab7cd0fe700cac54c5cefd4262754100af50fd40545f27d65e8ef380ec1aec7025a2af6159aad6ee082e2a1fbb1813638c181661452aac8773c2a47286b888327913fe995aa09e6c87077da923b0bdf5c8d40698ebd18d6f11a6510461d7bd7b4c6e060e9055935e5e71d3717d29c06775f9f7dbee616707333563e2344a055f0ce7d1245d3a8d399751081d081b5ad126c5661ce91c94969cdc4d194eb194f22ce4af960b4909ddbfdcceee447ab1de7584d107e0092d9448acc7d263d1742db44c1e61047f3e56242e41cff243e154f21a8b5d0c79370775386f7f74a84a0cd32468c768d9a1520c200cf97ff5b18f64640a3ea561b2fb847e93e5aa9e351ab0d5cfe37b8f5ba1847fd7f9e5325a90d7166f209570493a2d0900507d1ea4eb974c3e7066e33ca53647bc8fa4edff5f838ec6180c5996c90d8aef54c8d59aa2ab34a0a6f331159fffb34d08ef7770d7195f0afa1015e1a8066b21c55ddcf56ffc75831ef5f50c47055b640aa20f8a7674e7a943bc701ac48993577ff74af7ec7f88a31aac82066aeb738dbae7f021b25ac2613c2d3d3ed2d3124105fb94aa159bc617c9419f93b2006af638189f7aa703b17b0c1625f50c7d224bb24e34e31f0c3a5b4e5ca7311d76fa3ebc2e46b73fc20bc70105a49e5a332ba258d33c7a924d2905fa2b1402367e61eaaa59fdb35f68e51b5fe858b32002c862e37502c9590b9cac083edaced2da55118a802b3f898077b7b5742b69280fcbf853b3a1706bbd6fbee2284846cc147ca1bee3460377a94da60a029f9567777ed2c16ac90ab81607268221baa609058f6c959e6bd68242c54980e1ce195f8eecc913df9cbe2f32a242d1f661ba617fe1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
