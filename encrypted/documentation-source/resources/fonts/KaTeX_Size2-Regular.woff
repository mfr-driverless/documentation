<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f18d2157006e20516416ace9b5b24ebff0ff9e438aa970355c142f155b1f7b8f5d9eed539576bd09924a0edee412d1b6fbd59e60ece4be3e4687991a3c875cb140f3853728f8cb1d844c17ed3291804cceba8ccb47149304708852cd79cbe470af01d32c423d6c66c12011c7670582f38d3cca8c6748c163179e428e7ab6d55a91fe97d934a63ed75dfee81f8f24880c15e4909d834f88098725ec7415b657b04eeeeb779559cca25600a03cac2769710a9eaf7276a037b2cb50a65501af7fdd086fa077ac3613071dc984127ae66e43ead109ef5ebc5bb7a0617c6963079066034e1d41afbfe3c0c78908aa6cf34101d1b15df8b7e190b430d2e2ded27120b4bc5318adbec8551b3c89779d1def142404d231b756cf95bc9fad9616934e1d7be2ab84fe88d773e58d77a31ff6d44ea72665d8925f2abd6f51f8101c8719e6c8b86b91065d9ba31538d4fbf0b1d6f5b3a6feae840b029474888755e496de9abac56196bf58e6a2fa97e5c373a1b6d89f32f91114066fbb7326f0b191aafaca54ca4f3982aaca92b0edea64e02bacbf52f1775e609cbb498bbeaee37c8578124aaff6153b2bc8708417f1a38d6f450bd67a8394a918337a4ec5e5bc6689a2cb5704479cdc563e51643177288ed07ceb410ac2819740ebc3ed25e7e58228d6f44d2b8cc29dedf5e544d3596672f751c1519cd5fe8a97eb01eef96b64041981d198bcce4a8865a6dcf5ec835bf7dc4943102cd7148b7f94e372765d152ed78880fc435ea24f04728910adf00ba998fad26ed90356e8fb689b708aeb26edaee2f513984a977988d219eef97c03b98b91c87c865d4ade5bfa4994ec75c3d1589712e87434638d518406ea87d47ae6dc154922f6faf68ce978c26370f702918a415761ecbc0ce84faff46358370dac74cd942bcb435c561afcaeb28e839c1585ce0071d1001d6d6050d6d3591dfd92e1c7155d80a82e580e8fea2c4f308f43c56cd2f3573e29b6825e0bc2e1e9686e18a9d8bbbd79fa6c011cd0422ffe98f116942bc1c1e6f39850f89b2e38762b5fd07377ef677cec252d8f7f82cd47cb54bffd1137e30f24402316f2631886d074a18b3d81de32593d4cb72ff41d9869458ff44bb5a05f755057e75acb9bc27eab83f0747c6c2d4aac6068a3b52bf68f2cba25f52ac57509f2ec58b64f4f48a024914f396b647a0079ad9196341d8826f7957a6f13f9312e923e174725393797d4d683dccc371780289c648c21a76c5c18ceaec128a4f5e3f750d0d590bb567395fd0011f376312936a1c86569b5e44dadf343199f5182032e3f43fd6b3982bf265184c7dd952a7cb5c0af4d06bc1f59c2b19af27be292ac35a7be4990c4a1172de7de55e5422db4385b51e08afbc2556df7fadbb7ae5273a86d0da556372ef443f8aa1cd64f34b454aa7a32f2ec2b00a400c4d640fece8e766f4799c2bdf1b023fedbdd4dbc47407979baed01011ce365b150377514d69d82f6c9724586159e0db5359e77b398d1e2242ecb64b9aac140decd28c0f3eac2e8497648371a0f4f4e6a241c7baf60acadf08139dec3664d7e7a0add410cd10ad788798a05d69bb5c18533873e9b0e7eb4910a7723db173e79e9e92d3890567f7f3ea13ac11ee0a675158859e82d408118c65bd27887235c209482f9ea4e42ee2278abb601e1560ca746693989be9c3908bf41ea0bcda8ae48723cd3dd2bb2a23cfd16d3708c649c6f14fd449b5f4d1bff7abfecce29149f3c0dd25c2674cf4b5d609f6c01fcf10a868f0378a4a29e4b43a083a849ffa884952c1b8301ec247e095d75f86e5bbe3a1fe9af4e64aa045dd325e8256d5ef737ccc9d6db81e569ec029d3902657e6ccee68577e6c8bf47dce063f0a5513f6c7867beb3c056cea59b7702a76104c964e35da88034c16ee507e8d62ebbb0cabfc9beab35d9ccdd09259d1115b0c414744d6afc5aebae248c62134f35c3b834ffc6445a1f0c64a48d298333020c4a0419183317e7c95d06c17ae62e8f1c90009821a283b162abd913173a7f8b001d69546462ff4c0252dcd86af3853b8577371f16663c6f1f2a78612de6536c798cb5cdd75cc171029a99cf49c47a46cf3bc8f383c81bed033b32daeee25619b499e58761ddb00c116d52479696f274e4a1d0588dcf878ff2195c5785009b9ef3e9dfd1a859a28249d2014f97b64be20fc13d5dc720783ec8bf7b1db5de8c3750f4bf7e6c08af4475791083b0a1fefb885377bbb76dadd488a5297bdf9b8eb284fc98ec310b80289dd8dd7082f9007570f48751d73343f655724017bb927a545f058431a2950bec5b89d3916fd27b03f2b43b47ca40f412a65ee44dd625f4f52225bae203940b8f33ceeecf018fdfe0919efc682139af03e3adbbb6446cacd7f79510bdd3ef7aa775d43fd666c78844101a00479c0dcfa7f9bde4332594d7e1bf730b03eab450061dab2c38ac03878757e62e552f8e98fed75cf514b301d15e4487121b4d3ed640b1119ef3c1219af1691efb4d5df35aba8f8ed68bfb0db7b8ad6e1a6e9afed7677cffea3f1d5af6aae1a513699e26b2e4ef37b5c2cc6046fc105092c3e3cb71bfbc16d326cc8e7c6c1ba5a5c3ff12a140aa4c3ec62d26e1f4404e93f0c07d8e9af6ec7c722e6ee344dcff6fd9107f59a7c6efd2afef80c510aa37775003294d03f083af5d8dbc5fed1b6c19d97093bf3bca7f9dec00e2419ec9030c5e4434c374899aa10861e382ebf402f10779d9dc3ca132210b84398f4d72d5a31294a2c36ef230d2442a3d3d31420f713c34ae6452d8599b148b4e29cabc8ad7e01a5b1511850e05d6e827fb7c14dea3a77dc827e8e03a059feb080581c744a1c5b28863cb6d56de0dec776d1dff07c546931d50a21872588ec3407a4890d565fcbe9fb52fb6547578bcebbc69cba13046bd14dc26e88cf414b7a32815290d8a249ffc59b8042c8afe0d87b7ba3224337c43348cecb3645a3407bfb63fe5d55762096c43faa546bedff8e0a97214f0a47197e1aead4b12bdfdf46e06747e65ac10e1d459dfdc9d49948b08d6adcd0efadb32690cd8c48be0ae9160964fc332e12fa49b26c5208ea5ac3e1a860a3725bc556312f172c4a9759445f2fdd5087fb46a2b4bdacee7e463a4e568cc15085717cfbd69ef4bc56272dad081458b556f9bee1caa8f2c11e8f381ca2de6de7aeb82aa10ac14d06e07762eccdde10e5336948ee0f7bf1840757bbe8021c48ce90d9c37cdef3b5cde4f1508d8b5327d43af90fa5b6f1ad1f30645b06207066854e89bb3edf5a1dea77ee0b48260c6b9f7e70b2b85f9a0667be5b569187030bd2afc4f2423cafc18e887bba2f0fa8e8f5b6e75282cdd2bf79b53ceab28b0e03946e02de7bb3eb12c0cdafb4afa333e4d702dc3b058172e6c115d430c5803a6f2641a2c1d488378c7bc8baef60ab05e4e69b2e0396578ed339fd1ebab12628fbb6eeddb1c1e5dafd359f5042d3a0aa474c6b8bbeffe9616a8ff295504964b6d70de854760131352ae7fb58f6ee21941e441cbf9d10100adb1346b699c44a565cc578392a8b565a5b7f9998807c2cd2bbf0bf2b0d814487fd31eac7146cd50487b4f8e4134824959c659a72d2d6ca942fd474716638016d2397de0f1595f02bd12f25966dfe7984f3c9ded58efaeb7e39dccdb64da0c29a143c3423e30c01c159cfb1e7a762fbc58c3f7e8016ba901ceb9d4090dbb2820d2b2b7a4e9069dae4c2e659a04443ca54c5414b4e4c9ecb753c17647819bea57f730a373faed7e7913e3938c6d06ee668d2c2fc5346eac31bb21832cb9201f723e76f8e5ebd5e8560e221b69d96ff52a37c5efdc4feb09e0741c3c862464933a31f01427e8fa11513b689067f3ec212f5e8cf7f54f9bf511a746cc8a09032e406556abbc3e97c3a1d555c97b79ce908cfccfbc932857afcee0b6009787fd2fa8ffa27d8fce0be7e4d36a5f8950fa8e624e3962368673a0098729e29fdc1130d69b317fd84f8cda1d9ffb2d2bc6d441044a22cc559ea6aed857c41967e7e18eaf57850638c2e7b43649cf2e35432bb6c68619434c6858c521c44747d508520d8a5ca2365bbe7d96f05e2258405f25645ebc3a71871531e3782d4498a674627164f8ba2106bd61c946d994bd704938139c5e448da0f2379609ee70158d67b02b9ce4f3a48d460ddd9077cd30802d6788e0e8b5e1cb282ebe9930c0b92bc41f630905180182164ad8bfb26758c19d46875c8b7eacbd663f02e570881da928585fc49714dd685760d964cfc9814c8c37f812b677d1175c722fb3d634046767497c2a4e4b2e73f596e8db3d172ff5dca34fdb3cbbf1e72ae714e787518a5c5f0a96b41892e02b1c931efe9bc84a9b8d50ae5567bca67c0eb6450a8c3faa4ddd90b861b51d2ef10f267f455cdd34a36aae3ca6097f832382f1776265a4ee3a79de399bfc48dc55d503813e1f5f9cf41ab3f94dc0996820c497a7557fffbcf942a6b57cb51ad5b21eda42bfe82e1843262d17897c2aaca593f3a37520e5facc59c4346ee9a4de03cd19498a7fe244e562b56f749cc864c609d96586fb81d097c4687bc6499a0176a7e64d08814d294e43f4f1a2500f03b416cf46f20abcc179b701aa346ba6d9f80640c9f8d5625ebd5d113e87baeec0546c562c5f58b45cb701875447ae9e7302ac2a6824f78395745d4ed075ae3df276f05d71f1c4bb1af5b047fa13708b417d7b144bf3762a0202908aa5ae6c1fa7924f502cd3e00317a268a8e6f0e31e9f83780c7fa2f120350a99aece82d8e196951ffe013f14f614b0a6808420102c91be2d39b248c4e0c9bdc5d5b552cd81643023beb5eb7b10c1818db19adfdc85abbb3484e1028578f024868fc8de6c530af5392edeb389910ca31f55fed5a7565945edcd0511bf1407d6002ecea0037fb352c977bffceea0d0d398b3da1ca8bd32154291772c660cc895780d018bc6f215f0b589b67db9a792b1f85a81446b460640a58629d681a3a1dd6e07a0d976c1dbf66b3d05386d552c8c5c6095be6e8d4866e6232393ebd59900790a3d9062c1fd4735cf7f46c4c7c365b68ec1fb0afc0dcc1b1ffcc6f5a8ebfd98af90b9debd60331af8a2232d0a7568b9a3d1d56a5ab8bc0f288da85385cf14db82b004dd0106d62ac8f124f9156db37492a83762b5766c64186eb6eaa64dd59c2ad8e180a9073d7015ccf4f811cf57fe155c1b487a74fcf17b3ace36b99b1c306996cd1d0d8b2d8c58d7a05c89103d62c0d57bc4e77a8199c58a1cbf5383a56a2f3e7c649e2084821daeaa3f778f8078d49428688c1addea99ae146f13ee75c8350c63eb99856c03d05afdfc2281c5c49e21556476e3b8d9ce66c919c651cb7de9daa0ea8945f102f1ec0528ecd6fb6a9cc4182c728e4c51a356a140122d122e2c3af24350682026d61efd7ae32adf72c41292edd745718ae13aef1b344b6ef34ecdd0784e40766d3365208cf7984dc315d9b2cff511f640a414ea1dac4a98fa0537d12ec0f04b020fb63b4cec67668188e79f3c124d49737c2e7f3a99915f3b7148e944d12adeceeb6590906f064c7bf3aa6e821b222d434f2648de446821044001ba8f04f54f768d3d63e8c13c6f3d391d6fd3342d00ae714fa7aa9c72fd966c479ebee59a4f95d40a1553c26ee5b37bc75a6dcf19c5b447a53f394d28c1372b41557e190986a55a72e649f24b7393b20d3c7e3f4ca001d4c7ad6a5f120c218fea978b50c3e0abb2770184a8c3798e53b0546d39d0db182e805bdc030397f6b61931eaa5fab2e84788bc230ac6236b25a1de5fcd33b1b34fed19757087ebe0ba37a645b73e97f22f6912531a67d64025d4cadebe6ad39510c3c02398731ca61158394f8388406ad87a922adf0f5495a4fde0c47af0b89fec85586e018911c4fb3cbf1b3ccf7dc16f310566bd9fb69ea082f91825284e2fd7dabcd4306f0b95f3c44b76e1c5de5626fc0d215299e4c29dae3b50ce032b04d7d0f53684a0568a96654e6700b9ca3f6de45a53d35f5dce679c63901356173450dfbc21dd0eb83561500050f37e069bb84feb2cc7fb10daa980ccb173edfbc0af6f302aa6f3abe3c1c84f6c108c6b77766b4b9db5141632c5b021670bb45632e6490dc6dbed539975591d4b7eafa018d389c26e603c2669f33bdf4158def8228e49f1b21c9cf94c5baf6c9dd68aedbc6a223f376e84fbb4cf0a9ffa0e8c27a63dc14a7877990fc1fba70fe93755e8854d463f59cda0788346149b3591b1d46c06b4ae6d5d86cb817eb2551d71c9d985cbe34e74a1ee72cb4667cf2cf2c7810ebf609107846b29c8430e961779a2cdb446fbdfdbdd80ae06bb87c10032839a5b19ce6c4ac9e131a23c4a9c376de41dc40410d6834e261a590e650e851484c5e8d1c2620348e231f3ba60dd9d489787cf7cc2d72baa0153de78a461139f21f5a4d051cb28268e848a327b63d887fd92026f510e50c7ceafea2816d4991a46a826b77b385ca74857186235c27faa9b724ab99900a12ad99fddfff25635dfd235c7741fbbca68192fea2cddfb6c379b2d64aa27889c8eadfcbf9c1226b8a5aa9c6ff96b79f57b320bc477fd303e05f2e874dd8d568c92c2d4688305a986f537dee7d18f943f709bccb13f1fe45fc027cb2d737b51c5db5d4a1e1f84806671d9b72fd77e09a2ac5c76f7119c314a2a505b044e5d7c2cb3c62f893abda544d22cfc2cbbf593818af95be174c2fe550473bb3165f44153cb870653ae7d5d3e2afcc7b4034ab806e2ea7db82619cf1dd8e7fd5815a59dd81e408fce40654c24e6494f20ac764b8593751787736c7b30df75c7e28e1a7e76dce35bde8d5622ac7aeb956474c92f98ec3b2bfec1c04e199253175560335578669b2d877cd1d6136c3cde2cfc2ae67497266d2227b64b013b0603805a5fdefa43ecf452c9e4db7f3410fa8e1c7ea66882948149c77b60f5dd5aeba53372bc19f70b252601e039ab6b62dec2050acc5c691f456ebe4a21dfb19e8df754c24f1a3d22c34360a927cdbaa8b92f078f1c41ba62fa00e6a3f60793d3287412c9a5673fed81f475728bdaccb2f8d2c4d9675b9a8ce987e3f0ad237a76086ccdba5c904bade8166314be4f1e75e9d805aceca26ea7afef48ce582d5abfa4c6fe9af40ba35e88e6c1c4a887e822b9dd703b550df204ce3f5d42bd62c41dae6c9efe05deba33a73cbdd7bea7bf125f1761662aaefad91d9e040d20c74bcf57ef380112d086e8249b85228634a74cb31af1e18a00ea5c1a1a97f0a77b359e1fa3e68c5b12d16b3ca821f5fd681b6b3e01ad13507745b9325b76904072701a33d4ef85cce7389aa1b3692dd695a407f35c3939e8a60d021a85390d2e3d4eb02ec9da0241947c272bb208773d18fc62b337a9244b4370a04a5bfe7439378a11e7b2e6385c4b5d0da4827c2626d13fa6eec35405feea5f44cd379526f5f25cfa5904dcb5f04f19a14e558a33308b5a43b8e7397c77d7362bb3030b3912a9dd5125118cec034eab2c4c83e9f847b51b98e9cd7cce1cd26c2c52562c1d4fa90e1ffe6c65a43a81132631c51b59bbcbc2852794f17791f6a19dea52753eb833a77a40f66d2880cac4d9684bde43630032b5c62309bf1e4cd794c93abb6fdcfe2d07a312f7b9fb55a374101d7dff5aa32b32cfb8a3f3e7f66e6d7b7e5e0aed5321a096280ea3d92ad62d16cc18567fe6504ff05db7328031d227f3e2078e2de7800558d3139f37841be448121eca923d0dfa8cfc5ae606a744505caba9300fb8c26f14c6651117b0f2ef96380ad4b259a86d361b6a53dc967fa3ba6865806ebe6f73c43ab2187b1b24aad6ace2288e46f30f7b4f098c312f2f6f396c9fb4020c0e3837f981d172eae29861ee560f7fedfa8acec269b1bef84e1d51d71ace31bae4236e2513d79ef570aa5364e2f2271ebe3c4d27005c0544c5756a3df393619a59a6f0e2244ef66d7a4f3f7db00a54c1d967b84a4d37a24c419cb0dc7616cef987e32c3a766850a00a9de66eb0f24b3d42d89085e7c7224a1a45271718c253710572a001941b8959c3a335b50a6bc1c04580a8800c7b2baadad6e9b4d74a45dba73f08e43df17c305383cece24cffecc216fd4e46b5a613141a4f93ccbeee67158c6474f08a1e4fda208fb39a721fd04e8edcc473d23fcb8546a65ba5726a76ba4cb09e26c341c91047736471ff419795cb1c1715562ddf8c27fa915db9892152ae5a2361d0e1edad9c0daf641109e743a22284e3034afd479428c1c0160cc183fd999b3c4a892f25286194a03605c81e7bb22b3d3260f58fbb9e65fa23d28e5f1b6fecad15c6a3efab227623d7820f2d3ea9b246e2b2c4e596dd42a009b6a98fdcf0151a7e892fc827111e8b74425a4afdf1ac7798ed1e7bf136100f34bb74675e9dbd054a28280651ec4a0fcd40708160e5d3f7a0dec27ea32d39fd525aebc3cf6e14138be813a775ec3965a3554eb971f5298fb4d87c08a2ae72f9399a6ca9ee1fde79adecd00ec2bb02fb2aaa9301a3978a0c5dc52cbd398b3e13e31e4cde317ebfcd9f18518296ae1b15c196228bdcc3c41b9f64d23143e8243887dd5b3178b50aa7cec011bbad807df6c45435797cbd9fc2d7a52e76ebe5c8ff7730297f87061f8bd9da5cebf4ad438930a5950208a4d9ccedb9a7430f10f2ecead22b17d07f45e94fccd57b568a40d8b83afef4394a69f7c08b66e7498cf779324561b9439a4a84ffa2f59a38baef69539774a89b532274a54b1b5898dd3379ead1d1bacd72db0f02c0d8a2d272e0dd4d43e709a9e33e8b3129f8e054232892194e04cb0b810e1a7445e6bfdff3179a6084cc5cc2528caee375b50fc71b520b5efce0feeb5dd4f6f5f3349662dd863319fb502f1a1a8049b1481cf3397be2ec6964bfd55109cb46d7e4db4e888ffef512fe4200de870610c1be4b1737b2dc87ffe8c75ad0a5aba190a0060d02a47f79a37a536e141d305465e0a33b54af0259f98489241d36336d04d9546f59f6dc0fb3d68a38dac329fe4e2412830130c77bc1a5f23fab3b094dc41b761af18f583685d7c97f64a6180d15f130a6bb088958c233040ea465a8d3b7dc2d06f2403ef51e172ee31c4d5cd339d3e0527c0e9e79cbf6aa00c17bad6eb9aa80d457744e5220431441f48da29f22de029dd64da86ed25e2e195c7dfcca9bd265a340f4912bc04de672b08aea0d7623c8d11e4ef1e073715ca05ac9987a219e2f4b92f2ae9e56b133392652f103cff8430f4994ac40bcc4d414a1a794097a69e99d0f9966adc1ba06f55c23e94fba9e522505da82a5bbb95c47ab4235d4b6d7d42abd4d7c2d4a82354e28b741dfa44f04265c1e1267874d307bc6ae574a906ed8c13be2ea2a9ed34e9d3a9d2beea35e3fac5c94824e12f832bcdf14ecf177bc7aac8ba1a8edf32d12b8e9506973f830ed91da24d0fc04b13eac282aedfc7f286a8b52608f81059549d1a651893b06067bb9a5b6c198ff66ce0c9db888ad569c76632f575db0a1c200762d4db3fbc2c295d409468d03265b44b1beb3061fca83e657576a9c031a4b64a8b18078de0bba2fe18058628a6c4932a570b05095a58f34b19c7f235feeb931a2b126b67f2cbe5df9b25641a2cee6aa7e084c7c5dd91aa823145fd5c5469aa96cf0e6cdb0686fc4877efcf496c4c52c53098b7d109f71d86e23a1d021f7e72f31ee648e3a00760dbef7288fa328b17e9733e9bc9e1e2e05b0a58379d1f0a095bc27390e97ee1a188bab4086abd5448e74683de5f9baafd9bfcb11ce34d907e523b9874cb14264027844ce37408548174cd30548a7923412f47f675f62bd73cca226ef8453ddb71120367ab68934bceedff3ee78454a6e739d8fce48b938df1809ef2b1dfb51eeff113bf569c60ed1e884b6e928806fbf02138c11036b45887a14d3ff1000af470a87fe697792afa6b55ec8270d73a04c8f4c4cb72fe7a58bd9ff24309c349576296ca92a1c95c8eb4927b206f18f0140b1dddceaa0c4a08f201d9637d1a2e771ce70985c1bceca128a76a6ff94e64865910be0f19238523a1899144330c277e2fbfed03ac1e8e3564a1aa4be672e26ba732650f8a90b795ac785977b4f8fc8d8fcff4f88c47f5f16db777ca4dceb2edbf342a5746768e6cd017863be49df5425a95011dd4e5568da40c61d237c480f30ba7190f997adeae009a9ce72efff25b395627e28ab1497ef62c6231abff6ea67da06f7d338b7e34ad89adcc2731ccf2a54ed65d3da00c4ad462177cb255585f12256b6ab0839f96ac097f96e2251c62dcdd62bf7dc2c3e502f584ad46d260cf526432197f5c9c5aa1416011916fa41bc5ac4969bbf3e693b6e4c951aa6eb75025316d2e804f9c2ed931a707571bb21ea8219331e258527e5a709fbd844294a8b3c468b68627d63682feaf34d33acd571b5acf5a5575ce30d7ed8dcc35d8fbb5a0dbe490f9c3823bc4c0557a4fe739d801ea1676a0adc956a5ee1f8712537f39667e31343caa5dda245f83a444052f61e6e0e0eda1c8ed754d2f37b4e70a50f485af3b044f7ff8fa36a26b70eb82a0ccf9379f0ef66b2b2c32baae495ddb50077fce464d74d06ba88c79d14dee595f6b42739954b3cfa81a80596d32ed626664ccd49a52a07907f9aab1db81981622611a42d06ccaf3ae3b6aab7e93dab9169bf7c3febdcaa5f1021363b1c4d8b840678827d39a956ef336364e2429893754984376080481259b631e6e6db502cc4bb2ca0d8d6a19e40b6a67a7a64cb21c19571ff12f7ca16c70f8e10fe034ea16a71b4be3d5b84cb8ef6a41004f987093238c6494402ce974bc34f982cd444a16efd7434cfb46ae3df9249603577b91ab0a4b64db59c96352759beb4ea903bca2c0c182aa16e054c51eb58bbe6d5734ac26256c354b1292efcc58a6e93ebc14465059b2df6620746029dc35cfa36cc6f250212d36e03dd1474299609b6cf0052851a639f1559792de1e8c11ae1ca16f95028a12577e1246d6ff377f536eedf9c20d140bc4e6682c99ee35ff1759b86a5bd80f6ee7327e16585fc6a0e3f491c7b456fcb1b08c8abb95d39d620bbfde556c1873beefd781111b2ddb761628677b535cf1b54b90fd4a1b927f4fe36472d349bce786ffdbe7b44b4fd8ab12ebbdba1d78c4acbc0170bb1736b208b720d7cbd92bbb077b692f8927ca336e9cae061d8d89a6be7fac6eaf095ca5c51b7bb35618fe5e2609fd14e2ec144c006f8f6e7060e77f88b82f21b38680ad26117c1059d172c7f6b2fb0710a47dfe60fa38b52f1d5ba36557ff31ae04a1951471bea14f4da231cbda87f153aaa631ac71adb6d7634cb7099a0fb5062f33a3625981787d63050fb6e726577b5f387b000bb34cf5c8672800ccf72fd1a50d92d4ad4a237dc536f978ba8229e792202ec699aa632114ea218c3fa4bab6e054e829b0f85b646a269d96ce5714ca59c1388083eeeb07f33a4b659b0199baec3f95fc0dcf869e83c7725a35c9b2da824dbd07af69b4fd6e0b91d4198d7ae8966e98024749928a8d9706ec6f6851c450610f1679df7b3bdfb5a1b5226ae194b02bf55b26b756b3ddc143d749f83ee611f7d332560b09ae04c62cd75d10d1d1ffc68e592c62adb6d7f92347440340fb0e7db3a548bba237be8f53defd07098de9f8a09786f4e8aae70e0a5de6301eb068ada3cd9897a60a83d18b89e035d0fcae4925e69aded8ff1ba6336202787a5b858fee0565c3f15b4b2e4978b673e7125548f1ad8b19ef3e94ea57aa070e552d4aa5fc2e5ed4f3d84218e763b36b89d972a5bdae6cea20ae4b8cf33250f557fcb30213fb257da02634dc8d3f015bb2a551987951c06b9f19362f6659793f659a328c3eb07c5fb37f833fabae73e27103969c50775b85779a990078fa5f59aa80c5d79928795e09869266467225fd65ffd886e3814531eb8b5735d08f33f9b5e3a37a44a0f8a87cf9885480d2b3cd17c6751cfe8841c72b138a2a541206f93c34911ff71388b89fb312070aaab94dd7ce1838bf947aa5b732563eee4512ff8f4f46edc160b4e1b0728bb4226f7f1126026d599063595e3f3061f6c8d06bcb8c3031a6169b947bf0399e4f59b8e8c1a5b5656b4b54da9dd5bd8cc9e6c465fca96517ab3265182896367e2c9b1ebec0f41e48af3071bf2aa7e9a3ac2ab4144017a6baeb419d98f460f3ac29e2e5c1a062401b7b491037c5212d6b5b21777768b7523ea62d799a2b7b519ba315eb5f9f1d7aec40ff09088a7d398ef2961ad3732420f63eaaa004818f36d822755e69d9fc8d2d7442a017e0ffea977b9841f6a21ddaa22cb4caee2548f2b6f6778980731ec7f7fa93c3caeb99793ab6d95074e8b4c1a697cffd5494cb61a2df6500bec1f36144d6689e2c98a0e4c594d7dba83f9ff0313ee92c5f8ba0a86edc8aa942cef7b50d83680ebd3de9c534af660427f697fc7352e56d7f1e429210a9136d7712baa6d536f9847f8dd51acfb605c21417ad475360e8ddc355c9c6ce6910b66259a6e6a90f661c27c6db21a61f6a7a99d193b7cd469762d1cab451786ca69108324e7b7f70ab495b83895ee88fa73ec6401e40e5bf381f647002a1711784d6c091901306c3171ccc8009dc0f049beeda1d65fe3ae21302bd661e3edd7de7169b4bed13cac73cae2af75d4c36e27e5e0a2853f00a335d5a455ba62c47bf2149b0cc3d7998d2edea98e111ea70be1e88598a923b5d827eae9eebefae784cffe8ee8418a851ff196c1ee626ace3411782cebce137edf75671610b021558626753b4989d4116793338b9bd57753657463d3e34964a76b1b4c3e72cb1bf913f4ce40b565c25528713bfbe154ca8abb52741d859299bb4c81a261ea9f975e728e34507f6cc96e6e3396920d22d15a37046205ff5c5530f19a865ba174bc805a62e0c7537c6f042477fb96496e12ea1cc6000e5dc2dba59e953804aad5295e5a027cfc3965edae68b5c1ef3b2e5ae4fe1e5eda78997754adef13e7212d4efa8831e7d66cddd5581619f3d6cfadf6c54432c4bb8c54f3e4a1c265ccc01762502b01db60b7d0bb4bc7dff3b8cdd1c898936e8115d69a9169fca0778aca217646916356e2e635731a338f60241c293d2c0a2010ccad922f61de0e5a2dc456c13068f0493979447622c0f6d82204950d15aa1a5aa59eb7830c502b71494903df2f86b38de8119030a0d52e8ca85526a5480c02b4e9d843d26f15bbfe228526bc2bd1b792ff400846cf37384a570a6caa1ae040b82b3b2b4e0790570e317465a6fec4d5f02fbe61c45303b96cc10947dde5e3a91002368a9697d5e60c71b76287d0129b2e47b03090d8bc89a492d352c73e2c135bc1fe23f2a5600de02b19d2d025c998ceddedaeb6ca581cfb8ae865734e01008d937776ec22020654fb77c4e334ec33ccb06c18a7800b8ff02b9f6c7a9ad9cb7288b501bc2b5239a439d41a49ea44ade8821194a100b2bf464c5824ab8967ad4c4c29e0db5c4e2e976e66579d7f1ee4c46aaff64a312740728a4e897471ded344ac5b68ceb095eb8950735babe43c5c232eae064907f79bac58bbaafcec5cfe48cfda27b21caf152527c39463837a19bbf7f49735886135720730afe9da2edb076b2fca8df00d554b7913532c2c30a7b5d409f8334f91357c11d032b670ca3144d0e2aa818ead484b55c4bf6451447948759c70f1201674177e76ef3daa68dc61c9574298a6ee07d489de546291d930699c0e1bdd20146c1f3ea7ea2866d0bd386c7ba37efb920170348152150b45527e61f18af9436754908abc7d4843b819845ec730011422eef82495f2cca1c87cd5da2f5254290a91aba9489765a4fd714b124caf5fdabb57b76584211246fe706dc46413add5d3155917b0a1db42dde1c0a832e42e5f688af0ac1f3b73ad1c7130df3cddb62a6a3ee044932bc7ca79020bd5404a3951476f7858d1cdc9be83331bb68cb1eafac3f4631eae62395b8d0842a55c3fbb2fe13d13a900725c1f0ff3217c2726fc782130bb3a845ed3d22e792004bfb1cecfb87390079b0f44662964ee664ed2e0571cbd35939e83800d5be11fab3b51853d2dedff42baba258ac2d67d55476cf96a912e2db355f2325c210f339fa447b64137d65a0bcfe47ccb9b538e14f6d0c5c84fd9b492bdbd7885ea7d753fb43468564ed868f1591748f271a2fba469f0f5e0df3d2b1f64f4fd797ebbce29462ea7ec19d2aed6fd1c360358ecc3c608b856d1abf8511c7fc52836563a7f1912b6d4df76ba94ca1089b632469234e21db52242ff7ad7276a62e625e0012c71a162cf46e565d731baeed180169ad273dafe5f3458ff0b7e2ac93a6699ca711792d1902982f304401906ab7cad4b7add52d1f64745e9a1c1c932cb1f51be0f664e1fc509d0e948c6da95fab8a9b523cb89ab3b2a8e4800af48eb236d2d0e61f6b309696694ccce971918b653dfdeaac68ccd96c022bbfd3e83316c8de8b103fc034da1c1a4061b726a6fb991915795c54b0fdc608b850116a5b997e8988e1a058ef997e14f7046a3e3a121551d847d128906b981c548bbfec0772ee1aacbd36c1218404e8639ccc1d0be9cf1d31ea0e68d801791f31268c7c53993909f0cbb5eb6a7a11afc005ca2bf1e8a933a99b0109d1572a8a2ab554af07b444c01e1ab7620af0ff1ae6aea0d881d5f9c44d54b31eff26a1db42b1a6cd99cc79b63f9d1c84b01c1f6f1bf675878c98680685dd328a1fe89a55ff3bc78a7b83f5f70cb70867329e5f5292d68a6ad186b9436cd764218df05818eab37f621d42b8e6435ce0646102ba413692012de20e220736b0168aefe6e70d22b1cae2b0be4f5f66f9e0b3357226ad1ca5df2524a8bfdd226bc5c4459fb75a85a780e070e52900e45dd61360d55698f4c177e4b4eea5c932573a8942ad297d3b9eedabad834f80e8fb859a643617325f4806e8673f7a9c2b366005ee3f2e579f47ee160bc87fcca1cda9f081b89dc6748748a076b59161710380f9e7cc3a2635ca4e6779f9cef33c00089625be4bd7b149cb51403868f2d0275edddaa5daab01bf66b340d99558eda2afb49d317531e32e741dfe57bcb311471d8d2809672c2048d2b27e170eeb5648ae6cbe7cc1bae8a11e9b7b837524ea03c25385dc97521dfe61db70ff40babaec686480bc4bb2ec266fba2b3d549088f9bf486cfcd44a28e4b9f0fc1d2a81539ffa04c71024c48d3f1bf78e46cbc2a1a6b27f4de082bcc707d638d0fdf5b28bb080ec27be7033e3a1f8f4443d5ab7477dffa5d5ab6aeba57fefe71d2e323188d37d24a4cca460e7da8c47d785f53d67ac2d2738404d828e3c29bb1752509f728a82bc72edf2542fa9995d679d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
