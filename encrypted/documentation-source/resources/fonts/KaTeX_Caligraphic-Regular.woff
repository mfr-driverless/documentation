<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b106b8f8d76d193b828c34aea155f7b605da434181cd025e8a13b1c34667d908be4fac4dcda5e65ff0c70b69c397be5316fd6f8d9bcedc700e8e3b003f41071fe30712897ea771a62be2627204423f8c563a26e370a2c9e2f4ef1460cbc3b4ab97a6c51b26f0807a6294bb55a484913c63cbf8c6c8d070f303715d47b65a8e24efca39fcf9d5d6bb5559b2f2916348901ef5a27f73d98346ae36b572a34b3f93830ee3c4cc6d0f6c7a0e19a41cad3841505037c0593203dad69fa19292fe210747defda883535ce2a1741638a4ef5575a46ea0530ee2fe59b602cba4d561e90c3e509b794b79d6181ab665f04d2c96a0f03cc60babc41852fb015da53112b3c4c398ebf907885964e2a104c8de3438178ff5ce6199f4009f6df9967aff7dfc0a70149ab3d00261e05c4c12765c8570342682fcb83ab3b0190d061ae8cdda8e00efb2cf558fb7376edc4bab27330a019087b6536bfbc2660c6de3f0ed196ae49a79d14010faddedc99afae7a5e419215ee96d91e4105f647cc2622c40d035e8a9a4700ab498d5a19a5f34b1dcefa43458ccaebedbad75ddf1afdb05ee84c81360abcb5b99febe6b153d85ba131c807d30d1bdec987a249e479e56019a87e3e723026f3799dcc5c44f9946cbe31ce28c1ede13ac3b33cc497b5ca0238d01d95875b519339b7af8d26d8e943b9c570eb70167258c05ec002a318194cf7785ee9955ea9b58623f5a9fbdec8ab2a030e32ed04e866b812e849b5782da5eddc0a18db1ed515b870d418ca931c3a4c760473f11e2ec929195ae84a18d8319410b6e7ed47cecd411eb149390b5a433c023637efc0f9e4c679d0516a690037f052fa0b152dc1916d3279916f41d1ace3f4a93a108f62aeb29065629a028654af602592523db2ce112dc4f9d19b4fd4431d1b194de935d62832c78db70ade267391158b92664534d8bfeaadab9c91a93259b518b88bd6e21709cd91531258886497ca656a4dde39af84ac2cb4435737152be4d25577572d991bd8dd7e45734d05a38d07c021e4f6822b58eb713071a2dac57881f6d566c49dd237531fc98804b880ae7477ab9984dcce69e3d0dbdced864470655b26b47b183d91cacd3bd10a6ccd50b5846579dac236beb58264f7314254fdd1bc4cf3332e5f3436f5b9f1fad0db0452377441357520e3f722b7161c3f0104d741cbca85bcd3d360b06ab0e4f7fee7b7910dfd124052a2073291dd84693a7585ee502cb00d10ef24e8f4334cda4863ccb49fff6c9c0e9d5ada6ce2dd2070eb64f37f8e1f720c133afff949a76c0f9830a2f3d6662a60f002d3eb3116b9e658425bc3f883366619f21e6c841901426b0636c774f94f315d99ac56c335dcf6da0e82e604457223d3202f67956bfd154b2454b092a2176e26960db7169ec2c7b99ce34c9de14e61b0ba05db5da79fcb1bc91863d1ac1f01f6a6e41c882c159d07bb22a3b5dcd180663f4c73a6de3557a7a3f3e0b06932d3288e8dbf53502217aa5100a5078afc54220756b3291d865c28c0e63ea16cf2ed8efe6571731e219b3b2d77630c6eb6a8258a7d999bf7937367ae7f5e8be487dce38c622d51af676e5fa921972141a3a617532ff97dd2480553737693cf7cfc7e2be9daf1143d43022609be9e563afa21a3b20e1570d7e244cb836af2c51b8af1c43b8e5b55c02ace6fd43739a832f99684e8a456db7332da9fd908f459d256b4888b7613dc473eeaf69681664b56ae35da911486ccb9660ea36d7c37d55ca03f6974bce78c146a7ac5fa0115a84c6b44af49b3d5a27e414cd7abbf67aa7bd9910639b7293bd56f69073fcf4ba7b439fb0e846192e0ecaf224cf9068e7d17421f93b3438cd6adaa0b39cfe471243413ad3ef98d1e06c75cb7890ed937acb70fff3ec3033ec11d4533c77380308d513db4ea36ba620b742c03b534d2bb212aef873eb3a1e2671d93de6f1a40a21f24f36b34682a54e3321d16c5127ef8b88ed681de3a7ada14df7413daa7057b4e311ed961f237dff3f42e400d5350e2543f32360576fd552fd5280ec69e13b21cddf8898da882aad86efa024effc0bb27097ecfbe382609714c6f931b1bbf8514e6bf61d08a8e14bf01bf63e243b019a72611b7deabf580a64e3786ceef76c8c7b8223d2c0a109b8825ba67028246f61bb93afa4652e20b46c4d5b2ddb868a9db51744d522cf758a2a05ae039d3a515aa8241e6bbc91ac80a438e3734a949033afc9a8c7e7afbaa4a6d4b901ca15811a45375ff8af2d308b059d3a817426a539160625a31d720e388abd04d84ca86b42c0d0e3b886529cd4f64798c90ff9e93cec34e24a1de364b94ae9270bf212e87794168a29f3ce0a594f9ba3d4681ad77c6e59b80359258c0930ac13448e3194aedd9e4ac42b0d0ae38c1e299662ce86c1ae4379f10fcfab2b0bb8dd3463a503369900cf45896550f43a3360c63f1b3adcd15468ec224eb153fcd56ab670caab193727bced193364db2ec8d6a2b97f6b7290af3cf0d37e84fcc13139b84363c1d59463e9945b31d57827a8d0c9aff3416f7e4c53be85a0b0d8e32c60cff782a7b796301503ae815f7b49ee6b62163742bc40fbf3bc0f7f1b6d6be391501041ed9e9f7aef979a729fb6106dadcc67b2e7d80fe62a3dd5133a54ad13e165ba677b346130ebbae35cc6589980705cf7cbefd4fb24a9b874e3ab03fcf545e1382681a2666682e008892e95d35a07119f2f3da8788625404e14f1f4952151324abe21a3e2b459645059720f27054a737b71410117e13ae0eaf8572f355d8d46dbdf2b87e2f400c8b8e326208062c8e0503771714c4fd74b139f3a96e262f71db62cb55d56cf00542e7da363f78831b5d76c4283327d6bf559468cb8be792876d23cfcd1aacf2c140b057cac1f5d67862e173a7bcef2c2651222f00d1b9b82982d92258921280f05f9dafdd3c3d17c1926ef1ff15b31d1bc2e927d38e8fa4a60a32c9b8943034c0c3fc2a02a5eccc10170cc88c31cbf01d5de81abaffde820d74b2587e252517d592358d17cf6f9ad9463f845b14017a1eae0bc02ac55933d38ba77b9e976d99fac0987b5d105bfdbabf91a7305e3c6df42e455cf17045d1879e5108faf9ac26b35ff45205b92fd9d7e1642663f201d8ae81c3f6f7bfc8c8df74690ba22f3d052e7ea7c97bb810294f701b3c750f8c2b293ab490623ac4fba335fe12e6f9da5b5681c6a2d9999084ee7a135eabdb8ccc25804fa0086b46dc96baffdc5d658d8116c700a917c9d556bcef3ae3436e33edcb9a217367af2c08cf58e5bc2df5ffcbe9d19f208287b229355c8f946b6aca907d4b7bf8a876dae6f19cd5607cde31fd0da89a52eeb526ab23f472f05d2eac371ad63c819f5b777df3991dfceb922b0b39e70c18bcd559c98122436ad3297b3b7f35f3416cd326fbece7b92bc30cd4e6eecb7fb8b6f11db547d5cc66249676209f33b6c480c728b4bb78dbd171c4fc26e227db4ab00f875c5511720f8d108b67895f493f981b809bd82439585b92f35228d95f75c6ce78413efec76f1853f1a12849f6ab144419348c04fde62b046a96cc33d9c32410df927c1fdbd07501010e2605ba8d2d1fb49dc8cf6b67ff12632eae64f6c4eeba1678985adcd524628b8bf4cac1f0ebef8182f4d9506d802bd053b8c24b168a2face57073aed5e4bae69af902a48f7b6e854afd01701b19846565fd13a8b94a164e3051f40fe689016182fb88626a1aff2e5856d21dc29faf48dbb0f4a202e388e7bc9ddbcb77785c1fa53eb3bc12fe9889bb53b5faf6747b7ab5611bafaccc30813dc4e8a7fd4d6fa0c6967f3511e70a2ea52f498ca8452e4f74b8640bf8768c3061a1bae636fb50b96cbf0bc21926e4bea5747954d87fe1a79176c81075f2f0aac55d67bac537778b54c201d832f86ea9790eaea75fe33d644a2883faacf8bb3d21535c1e34789d672348651e4adb6096567e947186c7d3c4891fc1076cdd9bc88d21c1208a2283d434e74f67b173b7c5630e9e485cad286723ef10d957dcc31346cae5f789606fa2ea128c7a12ddba08d46e8013ba81bf72a1ceed2706ea39a76005aba45431ba28e1103e0132b5b46e0a3a1d21165c0991811a7e8cae63eef3797cf0a3a82750bb9353b7980bca06f572d9217747cae8a47212af1c9795414119d334f18abae75964da4df673782c23c86da45a8a26f3e50b49a19a5ba45ef18f5b07b037b72d622c9ca902b095b6defa9022873d4907d772fabe17db0353c35411318c79b0ece17d79ee84e1cd3b893e129ad2dd455c1d09a3874e29a85d0cf34b1268a519fbf7ac0ad8ef4f107056f4a6ffbd41edac0430bd3595c708c512c7185f339e1bd831b6f0658bed2b8ec603ffb08c042690ab18b289cf1a2a755cb995e05f96b39e625fa0243492d5933dd3277a105b78427b5bc49fcbc0ea65f9e1050980cbab7aa00282bed8cd2ad0cc42ac14091b437351bc3e8284bce4a8b05c853d357fa59fce7a82bd9764a08fb5ae063b3812c2c7af918aac5b6769b7e19c17b2c7b913f74478ec711ad57159a8dae3b976840bbb9a9b086bbfdce56fc66bb3f1203815c7d6c42b30e6e41596b9ae68cc147c6a0d1d93ab32e957efc785522cc0c5577777b0dfb649e56876b1f8fb34b906348eb8bf2d9d940dedf4d0fa35a0490a0a02840d5e5431674dfbaa2f03b03b14c836867406c8b43d9c45ab84569217eb8b1d998f7b67755148e8a87b3efc811de404276edfec08dbaa14ddb9cabc23557104b724a0a54283b08d77ccdd8896e7f528ad02565c2e387dd39403e4be50c73b3b1136a35ed69b68572f14a8105974c1e26b6a672fe4b1c07acf80112e920c9497678c60b7159fe0568866e487400c8442a56a299fd8f059ed8e520b62e23dd371fef8e43da03a5d4fd51b51f5b087b24e0148976b5d9a7a4a307fdc115eebf9c889a3f1bc8f5fbd1807c3c459dedfcd1328843aade0e4178254d9655020d325f02fe93b636ca2338f98b3601b0b3a7c9f8981a372d2662e0ad8df1be14ce9a3f3c57807665bc54bc4c77bf908d61d2783d525c3deec6e9b5d69fdd9d4185a653fb8337e8ff64016dd6543cb332932778c8217c0ff43e61cdcb7dc39b33d00fbeff5c37dfb9a1151a040e3484b202d1e3654e472f79f40df570a228b44d74a1d31d273f7f1ee08d53a4b84117e259546e7f1b43dc5fd987850fe210cd12404dfbdd7350a054b6c58f0892db1284e218ec13674f812e80341d3d2e0ebd67b74cfcf750044f77aa8712f62dbb763186cb5c812924e2728b70f09821d6e1f132cc55b2b72e0ffb98cc376fc7030e862e3eeaa7a03af88dd471b8ff724e75d6c8805062b91f959356a4c500bd24a1ba5255e31c44cf7cfb34130bf98480792d66ad45114c55d6a9ceffae5cb430e486b76257523e8ed8bd4bd4b6e6e8c9936977910e640e2a4680dfa7e465064fb47d341e1ec12e0cec3899b787727e3d6f45eb7f85734884a533ffd3a0c2cbb100d4a55a853539409597c844f5746afcf3a378280240be7a0ea66cea75ca8db54ce20b100d078883df008cc6b0325fe5298183626e79326e33b8578b7a224c72fd06054d894ec6bb683eafbb76c7d8b8881996f166dc92ffc3890d278b2d6e983579117a25bdd85cfcae552eccc8ce147396c776e863a39f8db03ef0d7b5d4c336e98e2acdbe4138da7f18abedc3bfe9cdc55ee76068d1b8f21ab019c094c59d130d7861042c1c259f57e42093a9a1a64698339b642a8bb23c1856f8c8319d334fbcbc8bf6c9412c3bef31183e6dd2caa34e0d96bc9e86554cd0decde19d72545f427a495121ef80d225220fe2db1550532856b03c36ee72b78082f16d0b0cd6917505e073cccb9eb5734d8fa1c886285651935ead7df42e0ee183d96befa171be0e25afab518547d9cf2e52928fa447afb6b04b481125479b396dbad3d7eab87993aae64c35c2bc2b0daf7851aba1c08194fd9cadb4a11eeab0d1cb8f63892576d81fd5dc25908e00f08f273e1474e0671d6142981dcf3c8a97cb2467765ec1724cb6f797616cc612ed58f17251664705ab7175c701ad1f9ff6dbdbccd8a908e38aca6fb5558b2f98086891d9710285b3d99daac486baaaf2de90315027787aa472b43c67a66484c0c294f0dd3b9a41a871ec4c27f4f3513c46128833b3f87bbc25f479d0dd9411554143f90b28da38fc55565ded0fe2cb8cbf4bec39326779cfc7d5c5de2990c7f7f204e41ed4fe17d2e0d03a9068c3e6888ed585c67c7ef4447e93c32d609ecf5237679fcd4b2f063f8f15e1fec8c39a3172d3c9772ae8ef2917a9a4e7cf5aa782ff18541bef41f54ab0225a64981181d7f6a17e14917626c878f8ef27e273385f4e15ff9985c2cddf3bd60618ce5bdef6825223dbcabe9479e1fc35e0c6f2cac62384bdf9398f8c8478791702cc1221c5e511356612f68e002f1fa56ee398a25bc95206d75ef3fa290bb85b8b672129e72d079e5e495419da7553e2e4ebab83ceda981cf94ff7a6a69f0c825a77f3b42ed9bf989c45b7d367a86d2c8ce91d5d4ebb6b0bf0366f31207dfbd8f3c51f0285e08f4d9dd08b37904db13706b15493872fa6c100f7e23c133fd9033465b970ec084629fed97600823bb136134a88b5697a1862c60b07c9e6145e836d8dbb921ede80b300c5b2532c0ed4b524fe1bf822cd97049b845dc0e0f6a42fdd298ef23d7cfa335acf83020addee73e42d462a0e86dd43c0b69daffc180d6868e1863dfeb9da4850fd51db76ecf635ba9ed3293f453d8e93a388d85790324bd34bec99e6edc52efed7c26e13dccade8eec0786e88c07fa456734871b8600ad15decc6860a1f5d52e57612ab417ec5012ce7875919307d3936fd75240bb82ac8525d06bccbaa9ea7cdcc19075a5cc76d0ed9bc3230ed40a57a2f2b8874eba935b0a7a7b39efbc837e0c1a515a860774b58fc8fa689df0256f3140a33790943b994074feac39b51744f75af3db607442dc1d5331a005a1f7cdec9ff5a5d1e7a4872542e7205ddd69b6ac7f4c64ffce1d09b5a96c85436a1ac7d220aa1bdc95a40bf03dffe3f6ce04449edeef6fed71973bd57ccf9b8349e1af59c6ed6247f93eaf26bccc9a97b929532db0df21934d6b3d2cebc6a683ddc57473bd4da450f2058f0147d00a6c685ed4e629bc0e398b67c532381610e6718f90366f06b915c2ec700c4c0edfce135c3ee8ccb15cb47d090b143ac9c4db99e68f8e8ca3065b07ad75e318d2e94bdd746ec645b8403eb54a336d6bfb35790b8f52f43f3e27d799fb9320b42443c91da41540d76505011e914cb7d962a2b4b52fb419479dee6241f7161c1a428d317d49b46429fe26113847544cc5cb0dfed6499c33df44839f0d73704a9702c61e160aed126c581647acf85441193f3cf12f3328de6f90466793aed6fb1c3cacfd6314a41658bdd8771ea34dfa444a98df1df50907763ea60e39cfcced469878b9a6e34675ec050020a37389dbf2570c8cc847dad5a0798d0585bacc39ca8e91a4ee57886f8c1b0b66879630be3783a4a5816241a5336617331c2354849d46c884a4a9a9c7a94ab51fb337ff538c138517f50f49db521d1033f0077af63b3b55e64e5e81495f3138567ac362e38b94cecb9b349efeed6c1b24829d7db0c3cd32d17f70ea2311401c8053bb5f155e4afb11410bb351d278759b20a14c238589e2529f90deec33362e06db6f510a0ad0ae7e1545e2f86c2d3615c36a235e07d86b8e10a8881226add93a682703879c164b590fa1f6292e5a79c24694115dcc206f7a71590aac8ec20328781cebd2268cee54e987cc32b726b380636015cde5751f3224e941cb4662304ebf73afab7c1cb54f0a01bd337f8bae5fe22d12f3134bdc1bdff60a497910e6fdf34701f623d01520a59d8b05f68de344ec71bb6f311faa8a4e5afad3badfcbea45d413514197cf508a9715603ef8f4431c129bbc0aa2e043bd9e3e97a8611107700b63b978f4729c723261397c85533fe4c92e54a6c0478f5f6feaa07ac377b225a4edb3c8d60977d2ffb478ab634e8209c6a68c601d4ddcd16a0d87e2b6e0a53f4d1a55ed0e810fe366f0ae196bcce10a2af0c48dee3797894deefd71f6bfef983bed113e463de8b5cdff9ed372256a943abaa54ee584d8068ca4eaa036074963cfb64f4d75f108a7e423daf55adbb4bed9afd2bde13a26783059c753cba97f71b9de0e7bbf10608b66e30945a25f1a186b6c0e5e918c6c15250a8207da3774d46c645a8ec8fa8390d7a308b8654ac64b5a7a672149f407ca13317533da7cab2046890c3fee51dc7e97069e015f1c81375c9f5f7e28f5e72906b6408076b9b2d3b36640804f9330f07f5dc9b70353d95e602d9834ea302d8de3f30274e69a6659c4484157253f4ba4ae9c47f01a97f89abe9090143f3e65e8fdd9fbf496004fed29f68fef43952d571abbe5fd83c9fd13ac6095f1f65caa1d3ae2f1ec40af91953ffd6da9d4b8719d7feabbec070b39e24f41b84017d9a47cb71837b8299cf197f4de3b8b76ee5a7271624d30c220283d64aa02fc93fe221138511039e140fb34c5e15221c79d6b4d0e007061969c323d17ea4a1cf7e81f2a88f13fdc73fb5065b02671acfa20f24f36f77ec751458868f29a54315ac9ebebed0158884c267ef00cf7acbdf563151547854ae721f2cb8d01759faa7301834570b49045622d3afef0143d57ee3ab0f99fce452564f4fa2e6ac5393044048c1f2d840d256bbef900baa9085c4a311025b9b5fbf74d479d988446a11ce4a079017af04624c0cf8e211cca921e13e96dbeaac88dc48afa99e873d8eb821a9af949966a23733e99627a4c812239b74216b9a4720a4d440679fb897f73042691103766c017d1b9b9dd2d1ae17a719860fde40d583853eeb9961340aba862dd6be59169b60fcba06baa91cf6a9c44d2e3c358ed92b6240bc691fbfaa264a5317d97c5c2f7a95346b86343b7424b13e8288bcebcdeee17289fa360488bb879148110717e23c2b7e31b58e3eed54d18fc24082e8bfcbfc5dfee484e099522e5986a48b4c0bbeadddfca2b50d49655c1d57506df5d1344f02afb9684eb7c1eea78a891437c5f6ef66cd224a6c81078aea06a1fbb31fb8c6c2ae9ce5ec4065b47840370ad628b4fa6c23c77ba53100cfea5bc082517b04d026a93bbdd3795196eb3d9a3dca8fc705f58f202423f13b80c2b4dd30cb957a5630fea6d7d719f430410933519f30b9d91002fd96a57cb9c7d18d2cd9e2d8345658ae1c612339421c636dc18b6c88429439fb8fdb2e60aeec188eb459ade3fe90626318c8f0a6b1131161a2af97289c63f8d11dedb759f4e865a02b09b653ffffd178c2785972dde4658b21d8097fb83a7b3346534523d630fd957d3a459dce1ffa53446cff0d183fa7d0eb66f0f17ea2579a2e9fa9debf6fcd02e043e4849e7488e03522e5a307d5b54c770b5d7fd08dffef998ef47310370ad74ee0726afbb2468c086bfbf59489424b7edf2baf6e33e2417675354a8fe84291e93d3ada31f9b88014273fbb5fe5e66d5edc5d5b0c97ec226ffe001085e521a4b9f2c3d973aa768a338c03af301e436cf7d8d6987b4a7596fbd6067a2baea27cb18021fe4fdc18b861a98c6ea3fc7b7c6f53298a65c7cae394ab28d93032e72bdc2d853896886edd926bd3ab4001b8377e5c1f170baa705d5742d3cd894ad51695f74dda77dbb98079cf6560a420416c58b10906a4e12785f94d5c43db2cc83ab64a41bade341a76b0b1cfca9c2891f8dccff3ee1aa8d9e3c9dd8ab1e42320d5e23e927673a99132ce40703ef4e7946f9f10ba8a7d5946f22f053a2be898c474a7b0d5c7056d92b7f5584f10b08122af72a7fb251c93b66be2fef1402bcca231a2fafe05138326d61237f0dc1071f10e63909cdbd974dccac6a899cc87fbfb96697c972cad0e1d149d6b8bdf111e0f5c1534567fe3afb7f66f15712d2b2605a25c4fdc8f6a20e88da53e6d4ccbb82fad75ce10d15c857515202c9c76e880301749e4715c2091136902d19897002a4591508dca6f48e603df66e0577daee79c209410878db6e4673834c42727140cecabf76c0a3c9a98dce3ef6bbbe46e93fa75716af6cd593ce898329aa5bf3e9aef68d8d1c805eaaa05e1459ab713c12ffeda10c0333da8ebb308aba8812856425a58e344925791d70ee98d34db2ba0d13b7be64c22d5f509a1f47a158fbd36bfc2fd1e6324f41c10b1c748833c1491a918e0e01bd30002e903c9425712e7c6e18cf0acc74f2aa448618bf459bd317f2de473adb104bdf3f75261416465c61c10411ac988f971e781e6e644e5f3db82207a8738000aec87bb86dede6a93c952f8bd5ae7871bb4b01e193632179562313f7c0a774fbef0f1dfcf51684f4aab5338c6a89822d6a37f4baeed6bdeeb2fdf53137e1a6c8e84986571289880774db122abf711507ec8cc7c0f735e240ca43fb0b3852c669f794dd32fa1c0375a18a37a6b1bfd5816e53d6d71d78d640039efc961b73ea06379c116c649d81d89fcb11987c8c2c48784c903ceaaa31f35dcf48a6f17f8a89264e818df65abae8cc5dfb91cffe5532aba671aab5cb4b164d11052d2f5cdfb58c195b5954613934a7eb7a435dbb9b6180253547b9423022bf8c9a754a54e75d63bdadf42d70a5a54c7f7be8c899e013a2f83189a55fa9e98287334da68e34204e3b35bc8e1660d5c59a540761cd0544d824eeec633020c2c8391234f2deb2142e46fd01490edfe1fccd3633148d13f16f0c2f1cec8286879cf58202c6b2ebfdedb78706f572fb2f8aca7dfff86cc26bc5d470d1d2ba00368fd113d46820cc54328447eb99ddeaa3318e44d3c679c6ebfdbd872ac5d95d2e0db9e1ebfefacce6ce06c7eb18e1c45e161663b609ddca87b82f17c0e650fdde42a5ed4d709ee362c2a88e9f73b9133579e7eb7abfe019b4cc7924b29f859459e640bbc00542921ae52d6a056d05c68b6e133f2ac7c1cd4463413eb454f3bb9b88eb820a398f9c9dfd84adadbc19166a82c49653cd55670f4e14c5eb27ae3f703b3a1ad0f90836ffaf4313a55b0b8f1661a758153f7fdbb101881a8e0646556c07a7196a1b6492d1d058f87ce7f0056bda40572b7e3c6c767211b9d92b57ef916eced0ff2664e9fc4961a3c728f75b4d10127fff15debc2d5e178eb29d6d5fa41d84caaeda33d3582a634288a3690466727f5366cdecdb9facc9219da1726ba685cae64985ac4d522d1bbbcb97b9817be980ddbea8423371aa18a083c9821e2e2da5957eaf3d835255df355517f514dd9d27badf05eb3064b2d20c94c7fa768a72903029323ab0e5df4879bc1f93e72c1d137f58a4f0143ae36895f4a30989fe6867f9c2d4b0f0636482ddbb83c72e3b4d1a14f001d53561297b2732b1d1ad3791e2ee6fb6d58101617e8e0e1e62d04f4013800605053bec50eacbe24eab1509557ddbcc60a880a5db49f9d741f8b10d4f481e53f64e7a331dc796190b516db82e0914f008a59a14edae05be7d04d9fe2ad00178ead462433dbd6179c8a6c3f067629081fcf0dfb512830fe6b0a273752157f94088e5e5e6aba0c8d9eef0eb33d45acbdcea02436bcd3a27f4ab1dfa9ebe5ec92dbadd6d1954e34a502e05b63dc9e7efd332c6c087dd4b8f85544395c5cfa6b21c1594e921934362b541e999bbbfad2f26cb7d1fe593e8065913328ccd70930d8740db5b266a0d2f66a2809d5079ecf79c11e316b8d2f603086d82fbf4719055c7296f7207cd537ddf426e417a8ce77aa8ba2256c0ef3959f1d035b6c5f9284cd5960a5d4fcf507a3dd1349e9577a04db9010683606cd3d06e20ce583747a024d568f3ee30ebd0c8bebc8f27aa05efa5aebb7e6a23aa5fe3b3c532bcd5fe1a9d0c68a4b8c921980e6c9ca835edccb88104d99b8dd5517fc88156165e639746faf713b741f7c3d5a93fddbe6a63e8d711f4ea3401f28f51aaf95d0cfa3de78742bdc242cbf2dbe718773ae511f0fa72c445bfad3159d8774935acb56b595cf338bff2d7f77ef9333e7bdaa610d26b35d3fbfc1649a9796ad890281cd218b0aa6e318fcff22707d6d97e6cf1d1141d9dce05f4ed7fb64c01ccbb490974a42c06276cd4ff214f7c4991e0205e84d0ddfcc2e1b550197546395ed57c1af003afc7ee8a5d2eef84da5523b04f44aeb7bb27dca79c643a20a11f4684304655996920136beff4e170165cd1fead1aedf5b139fa170c96dbf86c3e574079ee12f59f0add411edea25675e496761e864d12a73b2b4b76e763665146ff8f7950260ac3628fe09129d9c8a7bce3451cd8a7503f85388c34c5999c7ff587bfb75aaa72cc2a0394ccb51aef4b4d0484951ad01d60a569a395bd39a5be32d263de6555c4fa412c408557a9ee1c6b66f8dd28ba67eb9ac61458e5f35f6579607a2b79990ed76bedea42373a381bac6454c92a16b995b0862077b2e13bab66d4c36193212e0599511b0758eeaf2499947f65c52776829fab6640c918270e897cf3dfac7c6b50ca5199cdd3737806107febe72baded4a029531f857ab318f330e5ab18c7aae94d098acda90457785e33fa7863006cf700507d4f9d974b5ab10a6bf28064eb189aa9debdf7833795f351699764059ba3da00fa2c24fe63f029be980489c2809f31d9a53f1a356c86745c0698168417af8a1c09c66eeabffe4d24ac6b3294b1d7e2038346fd6f13b3e7eb4886a30bd0d403ee29fbd9760de4e36c9d844b02dcd138cdf57025ad5383f444ab5105d1eed9dd76b2bfa69924f09661a973ca011985032feb0990fdc20b2953752aca8fe2f86e6a3a43673dde8d998d9f5bbcd807a982f3bbffdf48cf01636b3b1450dcb6cf3a2358df281e2c53038928fb76b679728ab21cee5eebd30e3857971622bd52787378ee1e01152a04d39febf62f87fb533d581036c2e8e7f1b4e87f1a7bffb4691180325659aa66d869c4b6bc42aeef5ecd503f505d42753b4004cd829a3f8aea71b1ed573877f80a48bd77f793cb54a38c457f1c1271757d38aad4f4b6c68e60a2660b8f220d78b8c7cfcef356f8ac9e11cffc76ceca61b82e8c34d428cdca7bf622319bb8f332902d0593196919b9145c59b187a2675bd53b88c31b5ffc28327fb768aa9e76be7accc21990ef74d15894d088ea2f93ed1d64c8cee53e2cb8fe10985d84ac02f6e67056720d336c57292226f2c5987571b2d1f92c78074b9eae0d42ff07dbbe907a6aaa73960e926f97f1be190323da81a280d76d32d9f96b5f8996bb61704afafabb9637091de2a74302995508d8e0f7e9cdfe288fedd53efd4d1a19b105c46da13e94c8202f5d7f321885131dd37dd53afe0f1270a72ccce34aa316a54935ed780a216594772ee5d352b7697bab45a0d1b090242ef4a8f730c854c493d97903fbc8397802e8b437bbdfcde087bd954068d7c5f3b582fb2be312c99e51de666aa42eff647d62b479001782d000268cff46dae8551d3a1011894c13415bae5f7d1e67bbaa5b2973ab89f24eaaa5df5a880a205fc4dbc0b85435b1cbf347a6d0f2803304992b80f382b2a083ad865a757e328b1f92f122bf28336cc73fbcb1c604a52420e77a7a6bd6a67084a39d3b410c1bc4f2ace6b5eca6ad304a0fbd497b62666492f75cbd8d67feaa78022433f0588ec393fe99bb9baccf3d54f35f7dd67813f838310f5f0814f0ee95e5bb05743f73a5547cba598110039c57fd3b26f60fccd4ae151e74d2cd7645f0fe977ad542c40ebad8186bbf58aa84e9c601d08add794359926fc8ca0ec69e25be77187fb6577b8bca8c36079e20a7f4a27dbf5b00cc5b4569b74ba864ccd2f02d470f5c2e0eb0348558c3b0a826dd3a29d1680a2a6c6d5f1d0032a2b40c392a1ee3cf01311d357c66a5e7968be2c5b387a961bcd07c614d865bf54adfeb24c0452d106b7d43905b22989a20b39b2477e4c27eeac4c74884d6880cf9e57ccdba7f25fedabe7a9f6cac55e5f694f9573fcb4b5db335df9c8309f1a12ac5c5d25027aea3fad32a35aad6efe0ba1cfdc079470ccb7c4f045d67bd388d2bf79b6de07ac4e2842578f8c3a2f4e1057ad15210d4d65876293c8bdb557ce72d1032622b5b3cd4293be6d7d102712790919c2a5373b68c317e45455bc77f87267341059e1d2b6084d85446166ae4a6d2290309a303a7ff0c58327cb9934a2926e766b8533f1dc70ea11ffe985312275270fbcbbef599a6bb7b9abbf879f27c67541d2bb67bbf729b3e9a28365c4855092d62eb5ab9599bdebf21abfbb817611642775d4808878ba932626549dba19de375e4c327456d1f8ea33837fc85307e8ceef929ddd114ee647577af908810fdd8fc800375de32d9900673578354183420d0bfccf0dde67952592a83e5bda8979993e873e9903f05d4e4956320eceaac801f96d52b58b24499c298020ff6136adf891d4d6f4a39900f24855456ebc55c798d8da7726db7b61a1008e1d562e522b226fecb92823abe3df073259ec6dc79f2c5268fea99dcdb878c6add70802641a14e4fd6026ed3ed3ee40882961b6d2cc3ced023e950cd8580e763214f1fdcf7ea4886f7c8eab437fc4d79efec90bcf759df63edc1e21c72ba36e7b119df473ba5f1a18fc8f383313ace5657386a468c5a237639c605ccfdc2ee10b6bec405c695a3054e2f5857bcde1f3279d23148fa76682401475078562974991aee76d39efe661e2b4f6b77affb5068f7f7654deae1cf7b0ef0878d03b99ce05bcf92ddc5f05659f74f0b42ece32a2448d2fb6e82053a4db6c1c7a6391b5482161ccbf8b28216e38a5688931473be0fd502856ea5e7554ee7164c1afbf83ea3f7c1d468eb70b851515bdd854bb8ac633156a7618476f0b9b0670d1634c00ecbdc2ed2e54623ad66d33afb1c7208741e24f7218056b83094a80084622227f639274e6609742fd7b317b8eff5b7bd0ac26c710eb98807cfb1f579749b116df1b8b6e3477b34a59dc753228ecbcb7fb2ea47770cb7d27107c4075fb710679fd4d2d23048bf672d9e2e269304e4e07d8d4a21417444d0f6e7ea0cfeb59119e410558ec3214a2d1e27040d79a20b57666eef22a42c17969dda36f9c2365885d7bb0215a32d9a88a8fe90281d5a0f06dc8b825c08dde63f67a337e3c78cb75e6794887daceadd7385af9772d7d647ddbaed515cadda246ef630a034d2d377dee630b330955926b7e6ce4784695cc5caf9c5bd5d649e0e0282b524cfe5f83042829597c341334379665dda05486687fbfff936c6499665d000d24d203b51d6404ca982e7c37fa3b061a257e3a00629777263da34ea2d984265118ec901cfe67470a524287c4755ef015099182f415a7491ee910f320c0ad311b0842f0f2de66b1e3ad579a53960c0f1a883a05bc4d7fd41ea632eed40b4f20b6d3c5efe66bee7d9312a640940e0bd1db9afa47037b1416e7b875d5444bd0a0bc7186485af62b0429dd674266fce42ac226bed57ad47a2c8d6a07f5d1bdb2a79ab05df8ac7d16e14bcaea78ce30c5fb7f4fd15299d6622d3cb5029f353aac7117ff34316e71aad0ae9fb2d388556fa54774a4b477b70cbbf8fd51942b79189d476b690fa0ec2fd9f9a8add12103fcacb396fdd8a9c32442b9c07163fcbfaac84a6bec9157196037d26e6575293e088d02f50ed5c426cc5b94e6b42a60131431707bfb4a22255b4fd083625a241148b6570d153af827fffcf5bb8138c25bc83cfa2f4f1491b2c31652ddb0f9dcbb46cbebd382dfc780551242b895ca5fa7bf85e0c89d7dece9f76db6ca6aadb14b85b3f9b7712056476c3ce4886e8caae0d3a1bde96a1482a43b115f57545ff18ec0b5adc9ac548d38a14142d0245660aa0ba570636ac53b2ec4f8e31fe819f3b605563a455ea2a78124c74ba2ddcde921c926354ff9a6f3f94b45f42c9c81d7bf18386d57c181a213c32f8bdda8f5750909c74b4503bd2d524898adbf7c818cd851c8fbb0e50d9ded0170aa3ac7544b98236b538c72b687c77f8fd9114e96b7dae55dba23b5a8ea97dc0ba96518f566299ce0e3dca4a6be36657a703894f6927d8b5b72480ddf04eb28e89ae60c5982eead6bb97d4ef8df14dc020441af170364bffe8390667ebf5e09d8286aba890e55be5e4baf5981dae7324bbb885e1d1d579b2eb322422008ec20e6e6e2653729c1c9869b381f84b4ee555ebb0e9ce7b786e6edd91c4e64c97855dcbb887c19e1f84d85de600f2eb020c8c11050f8cafcdb663bbecb25bbfa1d0992d1131e9ecce3ac587fc760b1742e9b23e7d5ddd95b49a2a1434b8d7b77c43eaf0eb5f8f5916a205b0d6c5a2d8af946fcb298e967a76bf111f65b8b954abbd05bce981c3b0de5b1ff4689e4566a3ae4a7b7659efec0cab1ade7d6b6ade959e7802f808ab9a753974b8ad8ddf86b73338f5f14fab86a06d9b315bc533834d79de7ed2735373673dd90aa91441d0955e62749f6da168f68b5efa9a0bfeed563b57a7f919b537b06be69c0a02d3c5c4e3c3425581630091da843da2747664516e92668012ada8856b5681c96faa70e3fd5f40b12e40eb011b7bbf6d3c4a09d343f923dcd3c73b0f5aae7985bb122342e68a094bd8ba221e376f86bb2aef0a1f8bb1d3fc7f663e196aad0acf12108a8357e9bb046d2d0d6ed37523a77e26202fd5ce94324caa471abc19d48837acba60a3b3a95722923d9c1c2b8e51c1c30776a15f88575ba156f57fc63ec093a5e0a82f453ca0904ee689a901f8233e6e90daac73dda9ff9dd76e57b0c1607755cbd3c93e9c93c348156defec6aad5548688cacba28646b6396ad05198114a3b1aad6a585e98d548c193ba299ce74e57b95a69a631f7ea5de9e8434eb63e4fd025c51e2d774ec8eea6bc875dab37492ccfa97bd276b6934141cfc74c26e3aeaedc1067e3fcd3e179ccb53f86a236c8a38d0f7d05d155f1b201e07ce2174cbe459fa2fdfc7d0bac6848d128e7eda3d117bcf0adb1e4a12b596f9491bcdef082178ef4546d90a0e1436c2ab425c5c19b74b8e53d1a3736aeecce2a904499a7acae3210d6c0e238c263166e03b75a6f786609a8183da60e03eadd191e356609215eda83dc5216a75d6141026aef94b159459bed693cbd055f7f634d64e38bbd9798234a90120269136ff8979a0995a876abc1ca1b8d69f3fcd5fbe3695de8574d29ad325ebe28a0aac40155a3a3156eaa6e6f3d7cf9bbefe9a7e24df9bfaf1b59173f887f25172e4edb175b12c793434a73faa0a1827d8212a804c1bbff9d5035fef076ed386b24e0f7cb1f1a0886844959c848097bf3ed0e124b59cd8220c32f80036e3ad5ed37c7c56e63685154e4871ca656b004ea54b6009de1688de9829da91a05e718ba3cfdd700fb73e23e3c21097fca43f6fe1dc1f2cbcabd64fe3da69a940e46d964cd2d3a0ef8b8c9e45bd6e86bea5c0f664447b0f428dcbd2281b910c26f195857263928a8803b6e485a8267d576b2a84d85a37c9a3d981aba16a5bc349e1869c5c219bfeff3ac3fde7401a5503fc22da7cd8c52f1e8e7280ad23e3dbf194806d4aa53666fe375ec44ca58f82e30575059cc44c2c1718b32e2aa1a1dc429ee2e7c9f9e193c8f239b1833df35aa7398388480fb2fbc75ba28ea45654f63aef80c1bf0a0cb8f28d0d4243d9dc0030ddd35e896aaed8c16ececa6b4b6d6c9270c7a100c8d11e4549a384299a22ecd2f725c19424b3c5c511077fd9b640a618b9f7550c377b65f3427838c8ce9c35e3ee809843d414ce1a5c94dcebf9bad2fe86ec549cd6f582c27e55935b38d04e2f93a687f53d1fff3d0768b83b625654ea9077701117df536a9f0733d462487742c5adee8b1c1d8aca1e30fdf2a9c6980d540b86d3aad415123cfc1bd6caccc1ae1d3ebb70513edb48ecd48e530a100007e2b412a07dbc5966c46db75da9c06339f4f8c803e2ad00f9ca2f0cc3b196b1240fe786d85b0c1ef348885d8155ffed1156bef48944c5c58326fea22d1884c8bdec9c03e1b56c06b2c3a027d544d4435021ad62ae35e862ff3e0731260bb9f81a74bb855957f480768d42ded76b4dca3e7e06eafc1f178914dcee2adc85a155a9faf56ac5225026fec8c06b1452895cfd7a89d6da1d107fed928f533dbf9d9de100017edc07e9717619693ebdb784d4ffa87c9abb874b408a12695046991b6029db659f493fa68ea63fd4e4dcf237f0d173d33b0739a632e443736dda5f6665f61b7e50e0e17623780e80d0a12e0775861ae8fb3adb7de8e6d792e9c3effd7b553ba6e05c891c3269d55ccc53e63e1c403cb3af6b8dd21f55dde3241ba28f32e01465e98a7fcb1cda7d898dfb52a06664ca424e45c5ef16e7778b98d48e2cf596651008e6cfb5b8aee00000320605554c2a477c499195d84b29b1aa7a09cc17208f748996113a2b59d96b10ad0e5f0c1855b92091ff38b9e5afc7b80c9841ab7fc4c667301f800b7262bc007be511d633f3eab555a931de97d07f9b1409e021e603638c9b39424bff4459ecfd11843880eb2f72a4083fec24b904cd2e6b8144706306510f00f4328c1eec2e769a1d1a073088f2cfe39dbc6cffb9dadc655fa5c47937971a63d625dbb36825a3cd356d9102bc581039536f4bf656ae10ce90f2d857b68f36db01a3ca5536c2976dfcebc99eba03350be93247f919f81ddde711692d9d6e833f52f236d451453dbc605cd59bc0b804b9b68a4a5003cee60b772eea6643987c0151f8f1c64db24350cfac14764acaeef234f20e93009768314fb19a7eabd834b388909684c63ba5e75a3fa7e2a3cbbccd36ba5f8e6ca9a42834fe3f2bcdefaf27279329b8c6b93bb51f28379f9c0d3dafeeef39c1a34b9214a7af16bbd1cbd31a7ecafc18b4c5a0a6154f95b13516cfff7f2ce71e513c5f9ac2d2e6887cc37cd21f91cc07a40211188f82e506dd76604d074ec9ea4b8717afe6991705dc4523fb57b7e51f8208489753446","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
