<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee3d9728890ca847e4f6de0a620915b48d0c3bddc4ac59dc01239cbc055f48fffdb53f7f5e8f304abd8139f7ab3b41976c451007659d6617bb31dc904cfcda4b157c2d82b09961b831ecc490212479a459600fb9e2cf67d7025a172e09e63dce6dcb53bdc4b0b2d78246631916ce615c21c8cedc520daaafc1f010f5678093756864cef6b8199bb34270a6146d5cab96a767bbd5a2464f9b5ed3d6ad8dcb1f937735df7def827cc2b2541b1f2418472ede842d24fb38f29a1ce89e2bb7e1a6740b9460aa55edf45bf2f563a9514bca0fce2004ef8923f30c5d464a72eb3f08533ffff194505c8e08275b55f80c5354aed817c2c6216c2a9640f43ab89c4a8bbff2d6027349da329394dd15d0b141063725312c97966972be7a3511d853e6aece2d7ee33d30b5b9ebafa86db5fd6934ae0bacd1821835809201d8f443f5eaa664ae7f69120aca0fae35e80554f66a8da1e451c54545e0e65243d3038057d0e20ff9d4dc0b968fba4d5a6c5ccfaccb636f9f0d1f1464196eb96ea0ffa91694a2a5a908ede807617a113365500f407cf6daa8cbf5de00ec597861fb4f6d82a66ad9ca9e60011474481d7f059af8873d92e507b7bf1c183d742ffb1f871ddd12b8c60753878139f3798b188805521977e3856215321b3e3f8bed1f213505626806711da2072a7afe115508a426b323c7923561ef71cd600e5f7111ef6ccb2520d8a34441dcbeaaaacc37d9d4d04d70b5bef5b49b9e7cf52a6695d8698f10a296f83edb43d441a3b446b1d77fa0b1f03d40186f5247a9b50cacb95f8b40ed3b34c071f5836e2d977dad892326594b93be30c44f209087d81a1718380936baa6c2070fd8172062caaa98f675b5ef8ebb73377804302bc8391f0855bffdee43e6619471fc57708b0d53e2bb682ba39bfa5ecc7e6637dde3176f5a919569dcd2aaae18a3effaaec3a67c82514add2232e86122179855fdd1d703e5563f3619424c1c0e787b065944c044e1ebecf9a397af48ba5a0853d9f2ada5b641ef218d43e6b1566c44b3bd5aae4c736ef9b9d1e3ed37e604cc821a90da4965992ccf0958b718f1f3a2a6f02af9e57e819ccc0f644d49cec6e2a8505a0c614a71ade980ca18db241548bdd1f8568870fa91c4f05d356b5b019cb27b9dff37c2cea1f256cd2e6e6bfd7b14e91fa97be5b76bbf5959b041d46685fe7bf4340f9068186e81ed67403239c9aa7bd7b1a4ca088108423a66cb004e6fac27a26248c52f59d4b44a6c5349fcdbbe8ca31fef3d9b0f39b345795638c1ecd2b7c25a4b8472e20121878ec1662794c9a82f7eec747842b3d1701d8bc6edefcdae4a85554ca48431c11186310b8e0ba1a8f470623ff92817817fb8b5fd6217626de49ed9a81a010ebb6791fdcbaf1bec23daadfc1b0db3a4366e6db65d255b1f5faf7f9d297c9a88aadd5278bc20da1268309582e4d259a61cf96da1c048efee75047d4f068aa6097e402a480366d8ac5ec74157ce2565ddbafa7bd6d3404e5bd0a2b0ab88db55e80c8ef251cc11aafedc89456e41ca157c4b047231bbe35cb3814ab7ba4ca23500fd056a9fc300349d08589d7a8fa5505784e0bfcd45b7bf3d950bd643b9d272d553fbf2af9091eb0eb46d5bf78a151b8a6238315368c3521e73cf6a82cd1c1550ec7c4d473fa7f6f92754b9d7d26393b64d4417902c319c0ff53e5888fcc682c03306dc070c4ecaca118b8f891d084aed5cb89234b6837fe33c4849b320e684335684a37904934ddc125945fbe4e5e17ccafbadc3a6becb60839257527a9cdbaf370bdb26042040e44a592b2fa27973c3fa334db6ef7a211bd69cae7d152dd6193325d4f85c34ba01bfefaba35d47ce0e51a9187cc858ff469667e6b2145b5355c65ac3c2f242fed485e723c1b1af32a0699a927fed62ed5bbfc2c0160e3032cc489b7f736a5a9da5e2d224f4368f00949b604a386e86972ef4eccc29c5f7ced31b7f3ace1d855836b455598de82d778fc6606f650df495600fa1e5c839e1e703543cf8abee6a59a5a9194ffb7e42267dfdb4856273945ad63dca0084802e01dd129d77c1dfb1908187102975e3909ddd2767b8b90187dfabbf0db4bc3131f55e6ba184af1efa0e34ffecae24eca5b972ae368b5e3cbb166833ff2294e058e9a1c3aba198d296577e5a2299c6d083082b551137a7a5ea6a214b3cd8d1d4ebb1610cfa90ab8ab695c3fbc9f13d4861e1195f3164ce0d9b96022980e2062d037ff2368b2b9ad684b4902c79f69efe1677230a7f2d2be4333210d3cd9b253ca5e1715df6c811a70f91e61ce767fa09e7e98e75a928f07a70a2c4a812d28c32a7ade3018bbe83dcefc37f2c4c84107b3b005bc79a224f39ed36bcb51400dfe941f07d62cbe870242b7acb96592eeccd0234e99c6a9d99a3ce4173c2a325d127e72e61b3e3b6b4372080666be5e319efdf22ac60acb5789151a262570c2dd0ea4ae9abb08d16a8992eddd83ba98b10c726847edd0544650df11253913c5c0285d62013a05a98e393f8e5bced102851acdf381c23d4cf109138069a9ff70dd996845ed55feef9b6fdfef4dc36e82e7a9f9038762ad72c658d455809dde68df1e0d737df6ed2d2176f7b147fefc1ba449a33b11c7a379d71e5464db9102bc07fd33d5791197351d410c2cafa3c3c89308a9ea88fbbf85b2ce9a4e6b05c8df9a69863664929b9b8c3b00414d5806e64c996bc340db82961974a9a3844a85683f5259a83fa7365863e4bd9fd1b60cdda94bf24ea07a2c6236d5dfe57296639d393be228e98a46c91461c4d9b7a48cb4cb2528f273d561865fbc9e0d9fe839bd09297a39d74943706a0cbd5d4d82144b5c2ba05598b43cf44fdb0479d53dd6815c56ec0efc10afe77d3406f110fc3af940ee8d655fad45976689d1ff4a86c2eacef9ac238e10fc33e48ef1644c85f97630e76e0b0c1b8e877e4cb10a2f5ec0f4e72fb73bc697973581c892eaa13825157e68896f0fef00866a5ed601a39ecf4c35da8923d411ce2490bac49510e560c745fdb9a0e1b5a5b11ae5fc40333b3b10388b22fdb256c7da4ae50438870a69104c1e9a28765482ae4d182c93a4d94b6c93de5a4a10d409f6c8c44df6a2e7e8057c292c508e3fb0bc95fdc39f538d8e2b4a6221dffa81022f59e9b022bfd380eeb763badb8fb97f499729f5af984cb70d28102db59420510811318d15aaf42100e3ca1619589c284675a8c84076b9da4f5d2ac43afdd43f89a088d9cdf207c14d147b227d5962f8357f6b643ca8820922ec82d73c1757e9b77f3220a00eaed2d249f8ecbac413a765dee810789fb50066889fb2d70fdcfdd1c5ea2ffd5ed4beb4b35458b241c222bac991f27ac4a6413072abbffa02b51384620213de1c7010561089aaca21d8cbe359e1d2b94346c67096a9812886ed4db5d6d6c41752dc4fcdf29801a7c88889dfbd9ca2d73414953ddb120ae12d5cd1c39b5c602a3b595b4ea37aaa9c251e81de46102ed3eb806438141f6271565b97ab2a6b4f448d557e0166892d4bbd78332c574b962ff6584e819744e2b7b310cbf15382123092ffca4a87d1750ab6bd2a77c3e03dbf53e7723cc138f14d6ae9670b90e860eb7b238cc6f9ea681176920ada33b49835d847184bb923e3d3954e6e3dcba67bf5a4cf1c67eb2c22141377581b0fd4681654cd79bcc9d655556c99bf943a71c1a521fc5ef2f121845b05a43914047657e39eeb043bc5972201a48db58ca3f894cd31692eb03db2df041a75de485fb0bf9689a8beedb9f48042c0fad2ba31a5a4bd35aa3251fc02aa6212502f52b6b759eac32d5c149d891cc26b0b35f68e235c1ca366725954fe16b3fb8e4a884329c0af59cc18b61f901fdb9441499abe935aa2af316a1e999f619c3d5dcfb32efd15b4b2cc98194deb1de779f4658201b4b9106bd95e293656bd91ee0f6b566ca690ef07a8afcafcbcd66632bdda624850e5a8012938c641f96c687c9853854a6a67984826c1f9131ff929dc58817472a37f977022d4f68383b956e0a6b7701042d44dbbabaad63ae1028ecd6bdf0239c7b7b897546d81f48b82d5390f0865fbd3df744910f5c52c70430890616e245a289ee899786d8fb4b8322ee0263e16bfa87f19c29c5cf1899e6ebfde5f074340e37c23aa8b29cb6e4b860e7481b2bbdcc96d5aad61713e9a77f976053bdd6d92397e200e7ad31a4345f0c4e442e4b674903b226b60cd6a9b02cf5ee1d8fcab33c4682908b82d23fc14b373846af4a2714a8ef1cfef49df68b6ef0d018ac2be283967422c9e6d663f17e09cbccbbb6fa1e7c2642f796bc2d26f2c2b3cebc4747f4f998f53077b3401bfd9b72f785d7bd31c8f8bc30796564377c6beb413950e8695878c2c6af7155ad157c2a1a80136c7107c691e147634343946caad0243d3470dcb00dae98f3c20dbd021189f4a4a0aae40f1d0721a4733a5990a9a46f0a56efd12b6d59c5f579e5c53c7dcc4dc2c777df44a41481c13ffa08b9c511d6339f10235c3890536b2aa20b1a469acece3953009ff3284838e501fd073d65e2aed17073960ad599c9cfb45c598cad910ad441d7fc6a5fb6eac3aac2ec9bd76109d6cdfcc72d4c45103a6960e01c75cd2b9eb3809abd06912fb987128ab48bdfbf5908290565583bb7c8e693e18207af66012c4a6e4538a1a03dfd0189f0a87b20a0cdbdaa3f8f802bd113b4168a7b262cd866558738a6e6506f8e810391abc6dc17a54ef7dfde5f623b2e7c4e6e8b67a756be0008f8ab4c8a8c4aefba249ce8dc728115bab76e31ad8b39c385aaa80119afbf79522ca4437ef6f568993b6db4124c355b2be17a822ac4bfea359e5d2156c69a64c003c255e1c49fb396b50b75f490ba1e387c1d9c98d9efa616b5e9344902a99ecd3658da06298ab393757f6f05a76134089b5d4cc46b8874908ab84bfb7231890bf80c524f0d01fdfb2bd57ff0ef1694280cc0f3e5fd0cba4fd840c2e884a8f61226a695f94a6a38056ca0dd69e3e1ee50cc92a3fefa5647a255c9f64fc2b748d3e41bdd114caca0af20dbc2a7b756a072d6e38754d799992e73ae19625790bf612484bccea4c5af2f7aad237951200014fd3338b61734df9c76e360c8a26362400ab24d8ad4182b8ecdd671f7966ad559fb035622b374849b0cc91d5f3fbfc88937f4f76dcc8c3731e99f6863378f215208c216bb7b53b0d117a30174dcce71c723932a6cda8ffeda8a6d02c1c4f78c0236a6d771969c1489dcfa39fff3712aa5fa22536cd37e10115de4d9bc995667a8be3c8d1fd58920ade16f71c9e3bcba17c8bd15df5e2cd15631d81dc00f05e66923f2b4d4430ab59835330c253a23aa9b52d332f510b18ee9ee2b206762d7b1bf02bff0b84a79061c7e7864701a19350cb3c2af8faa830e681bf3d736d6565275761996f8c69add815d18ebe166f22fdac6567485971939b7cb137037638403c8c1d54a5c0b8fb09d0c73476f26b4f60ba453620c6d4e56dae71155018774078a17d8067019b8965aca05d77f08a6e6139474c83eb46093389360383bcf4d874ad22193cc6b5fcd69bf603e42efb5a4209e61f421d3d0e6ff81f47f1703a5e5eec0f528e04a2f3fb323d0ef76a693dc3698d95e5abdb65f3c5ba383941a1c238a26b3bcd5c2c5c1e31775d0a2ab5cf7213a58a900158da3eab5b5daa3c95e25f2d82f189069285c342f1024b17c01b8ffcaecae4d8e58b5730dc1db46ae4d0b505033e4e05a3b9acd4db610c20a8055ce1936662ee1209f1af051ffb2ae8114f694798a3f22f7e916a5f38c4b2bc53b7eecb3c43c09cea832972181f1588a0cab69215b9b20c2e4402acec0e604a7f0a11eb5e9c49fa1cbea88309326a3552ced4f35ccb65e5de6e86e5ef0dd4d46160dea8c7603f47f39d38677019fda035ab8f7674f78c4ed1fc86938fda6bdf7d5ba6bc999c3cfbd171f1ea665a619e006fae9bda9a7c81381a90959b9a6a80e273c6fbca382ea6068b8bde262adcb51311b3c1356bc15737b807e8404c5112047d899fa92435c964ca3134a571aabb19b498238c6f355b6c5002e0ee1092f62d172c62afb2f63ffa0b356048bdc3f05974348ad8fa1582fb702081d905d5579d48b4c8c2795adf39448d3bbec2ce2e55263bac4dd684e0498358b7dea369fd152f6c83f142b0ee5d016eaffb5b3fd4ba5ed1527813273823ff5841aadaef35f915f9d5a7278fb76625924767c47a53123cfc3c656c64a94c5d84beb3e8ec4c8180ab358068c014c28f9df68061f7cc1c7316d6ebbb7555ba9d05c6e32f711a72dea083544a08eee8df1b0bd786092b4cb00d62a5b037efcf763abcc1232b0f01eb02adb34b44e78991ecaf0e71dc243e1939ae050eb1b97a8a0b60cfd3aa8d47c188eebadb76a2403448d38b3d90953bbd5838b9191134981e09741d6f5533746054129361c03d618c11320ed837e57b6ef68daa873599796be227cccd12cb51e42294ac134321c8d81e17521370da089871efd20e741321244f9ab89643e0ab4d6b2585afef89bbc2d99bcd3f0a0d14255d3e8ed41fe4094100b13c6855291e6618f69f41bfea2c7cbd992791d30c0b529350c5da16f361ba119aa63424b9bec32c409e8835acdef0076a1d69d1c83b7fc02b0d03d097ab95035b4aecffcceabd7749c7ff99c9e44890de3cbb9e5f3d8cb2e02df211cab3a80c0e3e132f41f1811a6384b5c567eb4dac39105cc94e5353bebb5b853f58a2b2dd27680d0d42bf3261e96c4ad485d0d11d588203dcbd1abf4b028165e3d88fb6a41ad11f804f530402770bd0b2fa23e636c69a9da41fbfc156cc1aee14716a6a6bed41b15f24fb0f629401f87d23113e182255bb5c6317e32cc7105102d5e7f66abd3e014c6ba586efaac68bf15fbfdf6d810594b93724740f1897009ecddeaf47153ad7cf4472271522be17b7ce46d3d3419c11cf1a1e686440659e53cf0239e3238f3b183715eb87678d758acdad16a1579a56e184c945306cee215723775d94ce26d3c42ac9721d936ae79a56ef93ee27fa17030a1511730c14bd76a7764e37c286a539dda9e59410c0fd02d6baf251aa56fcc145aeab6dfb23f60166f35a1078d56cee086606f123db63a6947357599bfd13ce788bd1f8186c611ca6df5ad3dd341fb84e78f45a9b431b47857a41058bf374561424bd3b443495747bbfe109b9f44e3603083ee49cc3f4c85e6e18a60e4fdc245ed9bbcd4e80c873fcac1b7e17eff8764933540789c2f684bf123c4ac29224f046527499b838fd97c7e0fa271a763db4b9f935218195a8c40465bbece43f8c85a7ffae9ff05705f822a7ace52d7fff1f91a1c1718548b90b0f7fed51e6169bbd4c8613890221c491a642043a4c282e060b680d10942825a6246862b164842b228eee0cf225a84086f2133d11c33cfb36b593ca75a9ab7838755a2e8ec6970f411e140826791a8b623482546b08c137b9c9372807b43b299b97fc38bd6f9f499f532e11c6d4d05976933ffe22ca8bdebe1eb94647748b85a8e6e96d35379c71df9c86dd58b126ac6cbbae43e74d0b34d0f6c6074daad5d8f6d5cdeb3029256dd9dc0231a68e9759b8191e1458375f3ae466fdd7b5b051eb62d43e87d97fcfad4435edd019cb431ce306e967f7a5f2bfb878649be17c7db71ae02900841ab94c00863c48209b7bcb3ed42fcd5429168f06fa5ebed90df31a44d4f37ed4b0757f3208c9ddecebb84c8357c2b6d04ba6cf95998fc56f0e47d7d95c4c5d2dcf8f777f7ea30492a95e031d546be9c25b80f4112f1ef8a0f2dd03b2d8e9c8e43013e8660ea4150b467293855678d34a1f353397aa441460417d2393666c73d5d00f9eb6bc83def54945f9cbc353724127b78156403b5426f48d39b0bdcecd8196422a8d35dadafa49684c3fb6fb47587a46a32b2206cf098119a88405063e7b912da8d7869022a09af571c47cda1beaa9ca3175947345e019471a864f81e4563959a4cfbae551f8518c44d2b0ac888d40489c5172836994deb2a15fad069a45f4e626f8fe1f8ad3530aa278b43b8a10ecc0d9b50bce1d7fe4542d80dbc5e7bf4b13e05e4d156d224004f55f6030d8b5079d7408e9f46e0ba33df3240fe77e4867c0c075e4503deca27dd59ddad21aab3082236590f4d8fbf2ef84a140c0078a002db9559fd28b0e1365d41733934732f8c9fe6d798a033ce0d382d6977608754b9f77f589d1bbcd26f78e3d303d40b93d53ede75a4025af1ecca8a1a0aa89567e13f73a9a4f57c1930f8b9df0b5a88e9daa21128e67f7f18118d35802d61d5bf4b8958862ee8cd470eb441df4d6908677ba553c95fd5c70da945f9033f2697c4c932207b6b20a7ae1a54e4b99a4f3db8a289631a704eefca6196b470c35a8065ee5714a676a9ea1f7467b81664306dfcaad643245bee2893c78f897e5454fc02a1d5ec74a15c18e05e94345d6008c8eb043d23793530529cd5bc896e12937fe285f336f1ca151370b233256de9dbc8fd051f35e64aac7065477d6c6dc1d6a0f55780b9962c5c8532c845acfbb9f54eb4321f5ffa82fb32e0fe9063ff011ad59cca7e50badbea68c889d277354d43f1433d9f03d21a309e739eed4c1d06b796be57c2ace96ee093545c646ec580b48f20418579857eccc75292350e4084b9ead198ffdbcbd5b67902aea4929200927e739045ebfaa1827a3fec7e6099a7aed61cbbd1f63b51661a10b318a76c026cc28457cafce108641acd3a1d75e8cbbaa669795cc01daa2cd3049280559e51e208ec5f0a6f1cf30cfbd176a9f2fdaaabdd6cf7dde56bce0040e496be306336c3460366621f948f361c84104726680d53781fd3bcacad0dec6abef3cd5b3e7234e799941fdc1ff9be0fb7a9a4ce038678b190d4970aa2549c35f619860f4ed791e9b95c1bcb3c4f8297b74f5ffb57c63f8a60fd70761a390b8705e23884da8d6530d2814b01cf080eae4440820244053bf7a337218362f35083339fb7ca7d1cf025559d4ae4e956747c5ab749af27cb19c7395c4918011eeade4a34495fe7c31f8806b640b02a3addd40d1bc7820ba9f88def0700a6a528689c7118f866e0d22d73ca7e731d98ae67d53cbadd823d764807df58f6123c88c79db9e3bf8e1788778ee2e68125f2403325397e9518f83460f491ab6f8a066cdbf7389307a80e30fe1f790fba0127801f9577b054e3f36784ba96783f0c44b77bdb8e1c0e728e45d11368282201cb2ba99a8894b10686e7ab76adab65d0357245b275176d103fa6cc6fbbb4f32586469d417b7d21cfd35a6fedbadfa6e0ee798daff234563238216aa34cda938ead70a6700dbea1062f5d73c98cb9aaf783b74de9ca712c4d10fa66684fdb8ae64ce60c9f46c8c342add98e074a805c1c049113ce7eaea0f63342719becbeb21495e944694b06654f1a0dec470ccfbc22438d73354b87842110d4ac77c82151f77475567325a4e62b562b0ab73d12a8f59927998f9f3080d7fe0a4183e34b9c3d26fe537bded7c98e214c45b757dbba023ab8912f1140196139a39ebeee18b5fe355c748dd503d127de16535ed96614608c7ca838b8fd95a252512fae2314c69c08a0acbf4da68e2a0df6234b2396fbeb0b49897056da6524062b734e99f3aaa9422d23d83e924d66294ef11292f6c966e425903442ea5eb2131540a9a8b4a9fdc37be844ca438e5dbc8701720866361e8d5b3a6a07c163c50b75d772cd6a2dfe2ca6b2af5607594b0ede4759ff90f573809771bfcc8946bdefe65b8662d88324a7c782b23dd94587e4bb227ce62ef5f389f4a52ae2596254b9a8d577a82a4b87544ff5939eb9760733b062493ff08e1f3f684a641ecdc8b72b494e6f2ab46dc93ffdd0ef9ca63581ae6da1da4aebdc4821db7b3daf723a4bdf8f1d0672f4a7b7665ec93c9da6bcaf99ef22a79bd4364aed958b0ae4fc364ec45d85c110ed6e7f826e997dd87b40de9e77dd0111d439f3bb09eb55b6e0e0aacd766c64f0b709db59857e48df815e875fbda77630dda6932292ed0daef062482fa528fa05d69836b915354fb50890ca0167e3c5bd77d31bf68d27fa6ea1189fa607448da860ac2b0471e5bb1cce93df847a26d7e89e948e8ed31681aef3c038a0a16129ad765d9ea7e8ed975154b9bd0f2d9500d748085e4d00c78f3c819e84fe3988d3e62ea0d1ab1de853914453c8d4801f3a38b9ef7f5573723ddeb5466fae01f78fcbd95de768c79bd0a621bc607dc81d6a7af18bb9471ab0a600778db67069ec809d7044a764b3192d061c9eb2036e3597ebfb19b6d8c55db4663bde61c826ec5a746a62da52ba259a457dc90e7bb8156f9c68882d490e88028212ca988191453282fd7efdf9e53c35ca695184251251e09a3a9bf0a9440111ebdae6d74de68ac6afeec71334e73033a44c84f2b76b29cc7bd8c21ea382c4baf72d4e69f51fe1f60803df608565684d0daba76328051b7992980cae491e98cc3195334fcabb11a6792d02a4798841b663052a8b164741e0ddb2cf0b87beafcb8a40b90478c15c9e651beaf41c23b9fadc1be57fd14304472d0a1578f97330c98f9f56b3bda77cd1d68685daac42d0b890653f1c64bccc1d819a55f1480fbb7db8668ef8fbffd2bdab3195b60191b715e685a6250cbd3dcc44cb5df9a83eaf71d7fff9513f8b32363e316a8d3604e5004e6a4f9bb35edbbd40316ad53283567b3157974dfa4543a95841aacf8d0cc18b676f246a369ffab7ef6f22698e9d3a98702cee00ec1ac18492d332711470c0fb44effdeab54137ef40d71006743f858d128c5b792f30d07f67d3efaf9ea5391566942ca33a17b3fb6e0eb905142b303c4f0b9c8652b10e344d3e6dc5797e06251cbf249c4f8275451708600e44deeb3a4fba45a2504938faefee33c84fd4f759a5f70a3d50685a008fae744d2b6091b496e4bcc3587b57f8f2b3fcd13ab5d7038efacf0f85d0ac826b1425c51f3c9164c930c7f17e8c928a308f0f98b3358467e67507fcb843085caebaeda8d719896e0c540789dfc4facbede5362ad83a01f31b8e1d0ef6b6899194b888a587da851da1a44671cf0a6fe9437a5a89e7dd0281ac2630bde138a0be79097c9fb3a27e5735b24f2e35158d4d8e92939bd6e4db9b8db7a7208afc3303dfe6dcd80629b1b05dfea70d85c34c11f0efa3a7890556a889a6357e0041e83903bc9ba25575a58cdb2a23f9ffa001f4f4d3c9d8390e203cf5fdea58dd2eb9708f9fcb0f2b7c5ed9615ff4998dbcaf88a5bc379bc2502514b097f74b053d41ad2f94c01b710674f76f0941a2dde5a781859d192341a6cbd5e6fee1ce9eb7d5c7020662231e250785618d8cf3c234c5ef156f163b365fc1d4c4dad60becc5282e83f44ed17a440372e494f905cf179bb4a782fbf0a5d26fb975458e909a8b5e7f8f5511c200e949ab5091c8c68cd6e50e1e4cd6c317ed2ca8b647f19551b69c5700839874731cbb23e38beee6f6b240ea6231c4d5b58f35f66a9d175396a3d2048a8cfcb5f0009f0d74ecaaebb4f4479c00c13317c69c6295ed33bb13f7498116030fc280d626df48233956dfbe7e5bc549c9005b4d19e3a46854a073ea4053f71f2b156ba93d87e6fe1504d0888868df4968f42a7282ed7d9162d39c0e488ce2b3725d4f90d1740809e912cc83e62200ba7016b95bdfcd8c5df9fc2ee6de239f1a8c501e7b5edbbb545cc51929e3c2dbf327e896c90d1d9b302002c1b98f8962fee79d4d29c598e7539aac7c8be9dda8aa949a78b1fa39152854907f2b2c32b3421b5b52856d45b85fe649351485b1115d21cea26b41005060d6796a51a52490390eeffdbc4a911b7ff21ea0f9a98f12e42c23977d368d7d68935c8af53469de75698cdfb0fdc7767571be91d2daacfc75280c018962f0518bb8bb1b150294315ad67b192c2347d413fa43c0068a136df684d7dd614ce8ffae10100444573b010b4b4b6b9a2b975a1d945fcae9e4291f67614e6ff68edefde9aeb62dd2ee978742b327e6f2f9c1cc6bfba51b1c3b2a8ac6d15479f0ece339b55715a38189e24f84ed9793bfd02af75bc05d0444c74f80fcd05289a051c1b449d8fd25e116dd1ad43a5fe9038e0e46b126cd3622073198f239830cd4cd4ffe438187a2100fd0fe7ba0defa9ba765aebff1494571002544763780cbac6d5c1fc6551b6cf34c6c06713236efb28830b0af0389ebe6b7e283ae9b102bb504d5a63335ef042fde2a048b7ba4762f2ce40387ce961037b64cbb830627f089688955bc7a15600291bbe3f09bdd05a83194b7ec5ffd7450ff12b28bde228a1c7a5f2f4d6d56cd34961db0aa00f42ff24dcda0f24ed81f1512ed5683000031376895aa040668c9bcd5a6c059bc35db08a495e2e701ac8a22a65b8f0248ea45d192b42e8c5efcc82c91743dddd8604ae6516c2703de914cf4de0621f3ce2f2a6d957fd99d3768dfb5c05655571368750ae18b7490e2fde9c28a33daadef582e511e38aaf8013ce0d1b10e0831c447ff03e48d65a57ae2dd422801b58f45534af3c0ff71b889ba4880eb2d7ef881199ef7aac7a294f9d195009846178640551b1c4e885f3e8b6fbf279d6767f6a7acf26a1537c415aee06d42a7d43e29697166bc2575f1f93ce8629fd437b4f2e4e4c390366350826c5b8d44a0e8a2803631b4efe0bfb579001fe6aa39b0ed44bfe142f49001f6b42c1dcced9e0042c5ad4e404298e26f2c9ad782a4b17d5fadb1f8fabb23f07880667ad2c9f38c9ae10ae4db154268d2e2761881c62a91c273106dc17fa2af5c18d270553e418edbe3084a402787c70dd56caa18c58996a75f32959b650b549c40bbbde4871f31617ae59868f19410a2fddc6e55fa95956ada610b2f0b130ad073846c1c3005ab501f0d4107b319c51d38210194010844e945584ac50a66c07781123c0d78b89831929b02a80683f9815d9bbd3abe62c86167e6c29ce88e1567886802763ed3e3799cbcedfc19f8e7ba341d1910ee41225c232d6b974d453e562107bd2956c7bac3337b502eea7599be2268a357392c1b97bb193f1d867e89246f2f461b75f27788abdf1f2da01be8defd60a2d53020659e0b1505e24b0d108687fca7dec3d33a696d201541f224cd1c5efc62ef65eae07eedd581b9abcceca6fcc4b08fec4bd4a9802da8ebe3376bb1dda4dadf4d8bf7d12f30ecc0bf0e000c6cd2ba17b486a47851a3be8ba183ef5db9f528279e4d2f9c9f3c41fb92b610d73977fa7d6cfd8a158081abb868562867fb4fce2b7ea126579df054cbb99c9af3ba476ced70d851693b221f9425435dd5cbecf6bcbfeb386d6359a2b27a0943c455c1a0564e040da1be27ec478f19c340714d88d3ee52b878825d010bc8371c7bfeec332239c62da9f8f0c6eddc11c4aa85933a3f992995ff963d6bdc202b6a98c5b3897a8d03dd2b521e6597ff809f843242aefad78e7b3409e6c5a8a3f1641502ac77d8f5dc3f6d1945d1b5f08015ea4ba185657d12c5a59c8518a0e1fb9a4679093b142e2bcb984d31d175ce200ddc9802e3fc56b04c15a2c92687578bcce3ca68b081ff45f359a967f795e406ce4207fba56902c81dccfd99c5a13ecf6f5d871a84226f0d285d732725941634d92c218bba10cae74fbe296d7f6329af00c7cb8216249c53936b43add57c6d513c517c6bb54f3a8b781fabcef52348afd70b3ec9be14de4dd1e08d3ee854f4c2431e9d520f00876d6b2ba4ccc1f3801fa20069e564206fcbcdb5ef70d7253f80952676e0e8a2a7df4e3d731928ee4a64248f03f4d88284eb90fba1c6339964406c7998756b3d7405dc0ec5f4eba0403f15175a1318df7cb5691aeb4756f39b7814110654e388ac1ebdd2eb520f5dd4fd02bbe558ee373f836641c193e81cca0d523f9a888aada7ac60d45f9f5b1675960e2e28e3aecc2379a2cd734c047c2f780abfdbe5ed6e02dd8a18a67e3ab00a5522d2707c945c77ecae2415b4465c629578b074fbd2d24bfbb70f0c26584264898ac95d27ff4ee13f1a716ab2f67a8992642a189c5e65fb96c3cad69862f18ef17924ef76e96b3884fceb65edc01acca418eba4927b53d495ccc22618716af35c931c07d612a0f2617f8e9d3fd6a902478d6592d4544696cafe94832522311f7e352b9699ef3b3c1382413b54586d8199190af8b2cf7cb38723b9471bca61e29025faadbe8c88406660ebc8a70d1010c5a2a9f6cf9448a64e18e7c5f493143e5437f44f7b9567bd5cb796a300fb4dd4c3f97963888e597bd9f42250d25275165b9ba95b6dd4edd6ec66f3da878fb7061f79abde75ce4d5074c9a53904138a1194dfcf3b2ede9dd40e057b6209e69f318f4e91e0494b8924d84034cd7d4be6ea9107a24d28cd81e3b1da2da66963005725d560475ac0d16b4a6880f163e3b2be542668876fa8336c6301efc6f745070edf5294a89bf66bcbd279de6ec0ca4103bd8294dee574d8e35ff138945b0233aa10efc51fd3956ce5cb432028f9ce37306f505b712d6d90e3a522185dd36a691e07eb0c03f7c5e0f6ef98bc2bc4b2030eee9d0b898577a9c1f9c7014dd0661624ce82cbbd0a7b33bb881f065ab760e7496e3034cc0af71541c7f63748a65c95d0659c3d976f654bba200bd3521c98c45fde6ec9591233bc1b65459a61fcc014ce626538eddc25b3dd6cf7839405caee5301e1a5e718c3490f2dcff978d26c60dc490b6bc8fa8277f80f7b750be68e132a8ec8c092c75444ef7a266f9ac4ff2fe41d44e0fc36ccc1372c889089e7a9bb7736a5d55b8d82ca6b7f129977f7900fa7fd17a6e70576196dcd96d6ff8ef8ec5dbe79e40f43f2babca669ceb4188aabf4238e70495638bea081108fd087f16c27e2e60f7081da3eec1b6de8435e5d8fe6d95de0ab4dcc04dbbc98e18df20f7b1df80c0811d42d06b3fb796c11568c1aa3253694e40d468bfee35b2ee924e14b9b3fb07082bfecec63f6758fff06c9d334b41fe97d71bf51dd4ab7ed514097bd72c2c82c5129d7e8d61e72412c57773ed51bd20ddcb94da12775c569d28d29901ecbe98cfccf4364f4d7924046cb141781951113399f0b1473a47f5556c807d0c98681fc0d288a3ac259279f7cca12a54a4b980d1f9ad48061f2616e7b1e795815bb076e0462991165e721e41fb893d4bd9d75b447db980b2bad08ade992641284f60f3f320b1bdeb3bb3606d34d62c894379bdf78875fd12dec6b5814bace25022720549767653f621bb590a8a40e42191fcb0f9f44a04d99358d943504c86a769becf1029e315968fc8313d993b891982f5e6f1a17e3285133c2a4e51ee4356ce18bc4170c264cb6148405b54ccfa5cdf8517bbd592ffbee921fd215493ca44c015d0877a9d08ec275e515e0b82a65b6093256be8fd855386778cadd6abd60698cba890c3da519732244af1dd97abfe510ec4147030d44cd4bdd72c631145f6a510d31a61d0ac11f0534301f42360a851edde24e7f89e589d5973e22a30620d6878378af23958542cda3e4e8d16c8bb376edcbf8ebee07f2d9847dbb8adaf071be40e71ef895a3225e84da451cf968db108daf78e949ba10599ba22d0d4085d215d8232f8b4130ca82a6ecebd18735baad8ac9c00328e9d439545977ebcc1faf736bce784b80daf9e4235746656baa19a117a5c6e79ebb23e077bf4f4e9bcf13e0f6bb78a5c14a291973e902c83ebef90b1ea97cfeb455fc7ba0270de74cb71a48b3f9649f64973d65309930bfddf0f567f93f225b2721ffbcef2cdd917aa90b696fe9d722e7183b8335c3876bfc6be531fbe51f0daa6d9ed1c68874df18d3a7a214d9aa776c60f5a688f5d62702953789598928d02069a8378971194087a79321687a6c035d45ab5c2b20549b638bbdf6f087ae8535f71ab8553bc41c060f19c79145e753a6b6c4bfbd0f3a89ebd4b1dc86b22ddb3634efd61a9875eacedecce1ee8274d271fc38e2c98a1d7e745da60ad17611d7f98f2bde067e53493561c04c6f519350ac388806f38e6b1db7008551f9689f766e2fa7216b039b92ba10475ebce288acbdb9c99ade403e9084c3bc92ca7bd4a736afda57c5181c063e9d76c6167692503346571f2dd04d57d358370feacc0e3630675dedc417d180b12240807a5cb575f950417da04c08fa8ba835f4347232124477203c8d146b6d044a87ec0b4cfcaf510220bc02de917d1bd6eab707dfecb702986f1c54916be8c94758fcddc12271eb1fbb24456d5758c858231df051224f78de29f27be87883f17acc72f799d4a7d10bb09a4ca52bf599568288c30f01e8c915b22cf4ec0356cb1ef48f6dee0b570a2f6a3f65442391cdfea4b9efaa741308ee11096cca122f64afd70e3d39657d563634c2919566f6afa2e36d58ea31e70efd8c871264d4200e7ab564d95e04a331ca17493c6f2494957f652f8d2a710ef2199230ce6605e166400abf1db70f572f767cc9d304443fdeac3d0d55c9a1e3bdcb0c24e1d23d6a2b28d5fb2419f4c4ae178ca10eea39e9a109d8cb3a3728ed60b3dea764e14e0ea582d4c19cf233ec3d5013edcc688ed2731c7cd80d3dff85384b1dfef7c4eec1c68c16114c89daf094bdc0f2205dc84f7dbc4ec030ac4f274d2975ea2cb8817a9a23ed4a86feb164c0ea8a4951ff784875a4314c84c731d0af4a852a8dc7be7b82f574c8e7e631536f863c514b5c2964b3e9c51083f2ab7e2bb61e827e683c16e9698de5246282aba2d805f7ce7c52e94f9856d2e30af7a6dfc8b09895b88197ff94fa3edcb988c5a5228f806bff8ab86d5267a262a740e045c9034149f5142349b97ab23677710b213212571d71fd38a834e2be8581f469c66c63dc1b6af1775760ae6de6e23a494af3a61c070486c1790f6a31798525369c2f69cdb79c753a543a9edd1472418a6121474bfcc51d4ecb8a1688e5f327b432747f4c9bd2afbf51ec95356668bc38def3fb63ecaaef2dd098a162c977b3020722fdbaaed314ac8c959a72b2d3e1ca0e5fa3f7b524a158b223913be8e3d84715e9f014db44f18f69325f7fb977eb13eecf439778ac1b634d93988ce1a8bfd5e882c28ebf333df2b5114a6cdd9ca13d857ef03abd1f266c7679502509a0ff26195713c4cf95e705e4bdfc72592ab5554e9b3f2a91de826a37ae2939e15ae81cad93c2ca987d594cb5ef4def54b9b78bd490bda938b37e3488835809d136fb8a44527b6131a8ed9d743f79ba107392d2207fd589a6d102914f4e4cd912533e0bd1b18f9f7d2e2346770008683a3562957f21633a84641db0fed91fc9c85f3b0741bc2fc44cc8a615b8a64af8a456ab3c236196826f9274694f647348dc24f45344afa51ac82994748f1c19e9138664db01fccbf599eaee710b7208aef83abf09755e06ad09cedfca72153f19fe9fd81f023eb30833ed95589f07d430d81e328c21bea60b15cb2dc54ec91b28ad25f8887f11b270f7e7f23998cb29aebfaffb2bc90c4b7be8acfeeed3036210bb90dd4844e511e90672dc6ec9a24ae8a05a04d6caabfa478f98de5e359a6ef3c25012c462a1b9203fea43b896c9313e445f7c9c6912f13a92a79c6998982698b951df8eecce0f3f2dbb8a388eb35c69aeba634e468cc3c6fad1f3aa55c770a99f61e40a80450413e8523a198963c6017f5bb8b557427ddadf0c96c530fab210eef8deec665d0a419cddf620b2041689ae792c1d65507b02a2ce82eaa9bf30bd5f546d4f282e8cb81a1e7633f65d1d9d306992459d704575d98d279e2e13585dee6e8dd568ce511ed71ddb6e1cb72462df9074b69bc23a9b96aaa121faec1a4f8359a1eba41bea8dc7a51fe8757c02d6a21f71eb820204ce294e0e57e46a36f976cc77c37f426768eadf4d0d8d5fcef4c9059778cb7b423b874b56defa6dbdb996f13bbc39319bfa8bef9c356c643b719f666d510ea537b5a6bb0ed3fec6493cd4e3785c95f7fb08017f603e02ac06a30bedc48049c2fbd3e03da889644eba9b505effc044b213f7423079a626e16790e0dcc623dd3967cba82866bcd66a68c2ab6b10718af93d04d793eb92735e0a878a8cb39c9e0f24bdf1300a79eda64b6b4bdd988e9bfe5709f3856733183dc86c467a80cc79dceced566c1e6db4c3f94be2e00124312a01ccc36aebbd07ad630a69c3806321c05aee900a71121160950f8cfc450ce88004d4b1c957250542145dbbc26c75100e6514a2453cd73926bfa034e258af2a68621ae876d0d60bd4103991e00b92dbdcbbaf43c9b04702ef2eaef67395569045bd1e0c0805763a42318e8a9fcf79cc3fc42ea872f5425fedab1ba95111013f90b715d448ffd0cbaab41bd353ffa29d3136192648b4c219a41e474e0cd8ea806bbcc777d452261f103647729ee6250ca0e758d02bbd43da1dec7323827525525236a59dc4c09a97501248485de6d2226adab31c4c86a09b2cb476b07a947fc5431eb2043ccd63cc3b1a95b899d5a062b7b451411d242e99322830cb2592f56c99ea01b27c6b7130acce7e7c48cba17dba3c1f1798dae7c692e16d1c3b3354cf6a01530f7805dc242d30c4350540cc10580fd94e75a9d898b442c639ea37ab99be4e2abcc157e003fa03fdfc22eaa6d9cedfa2f893160061162c2cccc624ccca719af35caee4ab0ed0865a0669e2cd46dd552ec38d34ad2dbc420854d4d8ebd00b16bca214a311b7a905048cd6c0d4096b0323147fffd6dc2b45b4a7952e720bc5a5a08f90d8ac0b6569df80e9f66e7ce25ad3c065f219717a50fe1c493471daf48d1947b20b20231b080e4db4f979d7fe0377e8f4c223d043d4f356c22d785db2e5d3c01ec8e744341572226dfa852ceba58bff04ff2f5fd72f7cc55ed13d0bf4e2f4e5504704d441524d1197e209090d7920072a80ecc7d8955893b0d9a7a660118a27fb43879f380d866affc5212a276f969be7c7750f06496ba47cd0de638e1ad541a69da3573d7c595d03aee3767840da774d657a59bb1db2348b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
