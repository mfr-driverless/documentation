<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"738b24f71597d5dff38681498da188b7e488d20858dff39a2201817e6368404cc3039bd8319d574c831a74225289ac60d9f9e2621a68d4c67dee0dc523e8a73b04f14b3c3e55711fbd94d0283882eff8ce79708d5c82e2964297168c4c2b322571372d64ed65744ec9c22bc36cf41f4f33d3f3e2531a327b457d0b11d270a96ea87c02b4228c6cb02f777e06f75cae1e147743aa51e4a2ef15175277e4144a17bb1c1576141a4958f314753405940fa3cb96519ea03dcc64e49588fb6029a8f0edbfddddcd6bc83e7d8423fc35a53c92345078f1c180915606bd52b09c3a71791e989f77153a921a5df3244117c8103fc7090aa2fbd06f33bd5a20a07d978c5236145ececc2d5c2ab1187c2d6ef7cdad983d5f484a6c5986292a346b49cfca252ff3fa5aea013e3bdef2270e50f53591efa7f4001913bc92e0f8d1c0c566284acb206e54217b8799232c49df44b52e47e0d875c7e937489f9de6c037e2b908478e4e562b5aa2c25fa06f2f9f0464cebbb2af4a20d8bbe4fd575721d15cc186e1029822cebcce95b0e326c2fe29fb80feac996561a04d4564fbaa99a23c317bd967e01fdf788b3d8c78c1ae8ca2d295c39f731136c2fb842fe7dbd3578ddfa52a520f2d47102f9449a910830c714f231b492c4d21bf65cdf8e14c7f5b8cce035934840fbb8bec271bb4b539fd7c25b3a54da994c5659538307dbcdf7bf00e21ad2d09980431b2f90cbfb9a8968d161a5bf91f9ecdf2a998564e0c0f7bad6de0e3d1ab9b6049a4458db3340240155226e00a1dbca8c5ed0d86b277cd3deb59e3603c87a9edd7eba1ba305e16b8261908139341b822efa41caa096d622045309e14cf16a957a5ba3702232eee652914f5ee6c32b815b5ad7abf711a4609a0f99ab2b6fe22fd7353d5889ba6302eafa9f88f1bbbba04d86e7dff20a8d58db91e6d78400d56bd63f3103d3fd14fbc31ea9af9d4a9acac978eec4e42a624553b81cc9d9f7c15ecd42715b580931ecaaf900c22eefb834a2de4f519a6a9ba805a21caac4404914d1f95b088cfe25b7f30258136a8f7541cf2ae10da8acff58ed74160343d4149e01886b03111e72c7eb5990af3b7ed193537acdbb42bdddb66c86cd8a084a96f1601a8533dce2fc9c0e6fbbf238ab93992cd7a0ccc19b27c8a79d37ee93fc4fd7d54d21e2dfdffc90286183d53e84d1da6f5e3b200e0d08bd33fc10435da0604a5a4109642efde357ea7aaaf08603352bd8ebdfa1e9eed0a1a366832ea7318f3008bb7f7ec44e5dfdb7567554878c7058bd905c99c86d70b6c2a7a84e69a46feee24f477cf957130048abaa9e3adb66f67d440641ddb06f312a226956c1b40844329c9778b3f11c92c0063f81c5ba4576c5b176c5d39bb6487f4bef4dd71dc32384e5f7eee609f70b4edef25eacd84d0c1df5f7c3cd98e446e3c22887e0a43f6d69cc8d57e626819601767ec6bb46eac8cab586020cd15fcd862838ffe65973a46dbbeef00b3f06c421a4c02bcbd3e3fb384b683835a3d71e6ac253f095713f8e56c66937fe50132bb394d4bddc2ec82d0fb1f32b67538fd8bd9cf4e2077191daec130edd74cd7869a52d06c4faff9890032e47c588ee22cc1633f40dea3d255cfda589777308c883acb584f1c9b2023c2131586f8f0ef79d7bc82dfdbcc909e63fac10a392160a3fddf9d2d5e5b8e3899aafed31d917a7c0b5b94ee754597a8533d2035db7843cfa5fce5f4d492d756d2515016932953752d0dfd2174542b8e0be704484d63aca993627bdcfd4061f80b4c0d07a6174c1929323ebaf1c03b931a0534e9129b01f9d08bf38c04f5dbcdf645ab63b8d5114fb61194a1cc73a6290ba8f552d778d9da6b7b3a8ed2cdd5e6a368ae9e887be86f2fc6f6ee858cb09b3dd5920f2c9e2d1aeab061dde789089bee0ca0b88743e37977a5c9dfc4bcc05ab49b85bbb1e09a8b4409e20a92fdfae0af948de6c39e07ff4005245dd20b829460bf8d994b2151401f963d6d0667b4fa460898e1a313c5f6453e85fbee8379f93dd10a75c87108443f6980258e6c5e4ff50abd77a1548761c2df8f1fe9f048018973b244a43fd9e319e3211eb25fa296cb34eb1aa9fee154d4d90b828880b4740201b42a2400ae11860235ac1bc412164b0e43ea1e967da6436bc545c427598a7948d3a44648b5d0120efbb799bc90d7e1fb327ce723aa941e223241620c2cb25d679503886a9accfd944599c0b0147431936d11e6e5ff368455476178baa767ddbb0f6fa1cf24a60ca67b8e56d9cf521e38b42e5d3f7f6be02aa844d6d44980688ace86542b0e92a9d6afe954579b2f6c76597780092f161e24a273278586112508ce7c74ebbba6bfa80f6ff99dac1a4e8533e46e3e289a559560aa6a18d34ceab650f98742cf84bece0a300c34cfd0c820cdef5dd3250bb49e16992f1292ad9712fa6d22ce3e812e2bc114ffbc882fc285e7d6e138f3cd06589c925ffb6a24bd16bbb547e802124e17f45522d144382d1e460f21bc9a4fdfb1f7798c3c712a7d13266fb2bbbdc8818e27709a816be45f2e74d264888cea3a675f560fe9c274d90dcb564205eb6fc0538cbeadade221f7eab4ab39f844e0ae6a59908b7a24e7f3481f8200fc09fb4de9a011745eae8ef2f39baed765514506f46203620f106c73db877402fd33d22ee6199952fa96f87e4b26d8b4a5c6884ad283b435449f9286a59263fa613abe06a8b410ed7bc9b42600456f2ddf55288f397262b27e94499f6975cf791eb83accc7e81cd0c06f503e23eae8c2bf70efcf7e03660e9372d5a7dc309e44252936df51f7261265569a196cad76076351d73b11e51e090e5997a82b5dc8141955daaf668e980f0f6ecdd5710bc0bcb24099b7f36207f99751fe7529469e803d511f2577ce1167ef0a3191f761dd1f68cf35257d46a9b750548c27c6e3863fc1c35c6b307bf7768c950387bca117a87e9d1a1050f13d6eba5d651c6c61c51bc74a55544ca41d57fb27bca20b9db1294dc63878a5526bd72c1073fdf89f72718bf8045c8e0e3b22c13469636b3ca852cedfa5f30a96edc855ac88b7f84fc92ee4abc1b21cbc6bf71f853603c4e7f7a71bddac4f67a1692509ee523deddeab6b423c5087175b93ce4e3bd37108b6d0fb2c6a4edfab10f567e61f2d3da915e380c46fe495435906e13a0325bb6ff2e1255c2a09ed59f8e910d929618ccad1f5f9c14da82eace7c83d1952033ca209a634ffe3a99a954d38626a077bac3a03372d7d682197be5d1a00e136c6e8766614ec4ad6291a82d2f7dacc4532bfbd7e31c6636456017acde55097bc05f0b5413a48f90fa75c358b7a100d465f18af64a77886b38549b9296b7779f3a6f692dd3d1a47c5029a076867af9ec522e634df0a01be5ceae64d9859d8f2e41e16c59d4d35e717e5a60444aa07e41ddf19239d061a14d1149847a1d445e4d2bd2f7f5cce39f0e741e1f384970983978826aad8eb2f16ccf87892371d5dbaf00dbb98a56d5985789e9e3c30c6ed5311f78bbed27c1b3a9fd92fa2de69ffb6fe8f9ace74f9994d65e7379a01d8d806e155a87cb059b2342211372fd606ff4759bc442392e3b6046532b39d14751c930b47e0fb38197ad377dd637ce965688a17e2a0c79289727d44becd90098d14a8cdd37dccf4f116f5af2431aa605086292903c9b4abf3031d51ba0deb4f76a2cb5e6f5596064945e5ad0060681c2ff8c4acab051238ba40a5fc7c32bc812d4269b47b7d752cf79bbabbf5ff4e4a8847b06e0b163cd1c3575cbd3932de32c3282be631cc36fd7242024f4f474ab174fc858ba9a6741e3b5eafdcb4efd18ebb060cac6bd21ce13eb53c6706a7fa58b6f39989c3125f92b700efea3654d36c009083b958770a3656a6f3974a850232343f65381879f71ae0c1dd6a6f1b46986913b612e9d25980fdf375a7abdecc1a12d10427818ded6d3495f600e6fc2d9bcdfbca8c72ca9f3aca85e96eb67c092aad4617c6bef69661b55a917bb6cb011acfe0b8413f68c46405677a120c2b13edbbcecd922d63a3ead431c6ba6a1215c347f12ec9f6f538402bb977f183599a77ab46ccb0d0117090f579bc2926937d892db47b8f4b517709ae070df3fe9dac0d1d29d9a70591932140574a72b8e388cf0e55b59be5098aa060024d28b25825f2d38458b1eea67b42a4b2aa679e63b657eeca6f7b00194c9ea656c486d71b0b3681b54d01884594dd51af08ea16d328a3e2ba046cefacfddf5aa47e93978ee99a77029b82fbc10ec9dbcad05632eded53581a3f3b01cd0be05abe6319ea0987b990d5788867a532ba1bcc9cb889aeb638a7314a0d34f023d5afda1ae2a538db25797dfdca52107529e37ed3addfee6383535a49b2af05ae485dd88740257e05122fba742e23e3b06eb3e55d9860ea8ae2ad445d5e2b2eeb43b0e2c8b664c917888dd82dd5f22d74b0bce00a25415d5491ceec8b2e5b46c2b5980f186c13d743b563906aae18fac9b8f46c06dd731590e05aba337bae0af17631d6d9085103eb48105cd8103834c60e01e3c9e77dbdc1a7c398ad81254273ec0a7ba706b8030d410d36b90d410add5cdf3a363ac93e0062c58660a343fad03956dda737cfef1f1b142673f850707830a9ddd869ea5ea9dc210e8a3be814305816904f8f7c18aad1429f930547ad4c08d31150e9a64ecde3d3a52edcbe6c9b7b872b67f553236ce60b1775102d66870080b3064abb544914dece963f8e33501a085454f24d6295a92395f2fe79ae417c193ba809f552fdebde6b93741594ad183fda1114fb96b1a0bcf11ea8f2f8415b8de6cb66222b7d87c37722b32fa98c056d8e536a6f0ff33cea8639ee9ed6de48fc9f9cad9485c0e941e4739102c6b0454d729b8c34a3e445ed754dc874b0b0ae6234cac479cdce63b942b36be83d54f3c07eb17423b4a7fe38329c1ac4f05f527c2ebadcde64d9defd28ee21983dfcafa2f2b5be577b9f61281741f59e572681ec6d62dffa128a98645b76ff0864843bbf88f5a6a71a4afd758760db28422a126f3a78c3cf27ac46124bb91a27b96c7d2a8d2101593c510d5fb999238863e09597b8bae0dbc0d7c41293116269337a6cb44b64d38864e1f2a550647e7fbdbaf07f1e84faf090c9022a84c57f888b7802601ca82544e17b286b927c61775c4d7c7a32c0bddc65de99ed09a0a80ab9bc2b175d9029aa2489c53d37cdde7fff5d0197e784a04d285685b27b0b6f142f57377d82c7ae13d86ab63b4bc55cce5716b0c2e49da364b590cc7fab599066371b3220611a2f927ef7abbaeba5fb143735911b74e812c1d4bf2462f83633778d1e161eff97973866684bb5fb54a8b6a625994dbb250f8ff054c7a02acd4dba07030675b4812438ba0a5ed8681aea6bc8e9c73de9637d4ff3e1a0e68ab851fe6739638c6e0ba248ff443bf9eac83da45434ad35c1a8d33b65d99ea7d2e36e0e3bcbb870b0fc3fd0db7280ccd277b016b3e4a3a5d90ccd2b43518abf21fef72068283899228e37a1737c5f2cf75633d5a49c53587ee1063ec30d8b4e84000d51750b87a45d7e71bcdd015c137717f682bdcd50a7aeef2b90e6eb1a1fa9f2765c419e50a3d65c895f885be2aee6776baf9df9fbfa34f3f3eba35b9f4fa1162ff12ab939de6b7c24df83d9f7d3f1698f2742513191a8d5d7693f128a54c2f148d707f3df951f0c2f117e032dbba6f162ee4680101aae31293f4eb3b881c172eaa0afed1a3211464cda304556ee3974405013d8691ca381c3daf5a47192dfa292e4c927cbe1cbf56c6572d0616e8741aac4bcf5da8f389dbe663f4ff36a8f19c2035a27b9ef9a57ddb7468cfe3de9e07ce03d9e064bdd944ebb2cab01fdf5a22f97d65949f22132a01ba182d313c6ab7ae29894b4794947bf045da9e9b554cd04318bc6bba53adf891944f36c9c3be760b0c2651cb946632f4eb7ee180ade1827101d948b3e4f94c921e0e6c3371077a48759a06d375b25998284fba6ee4edca9d105d3c30bbed0bec7603b7accecb7e61ae40e7b1bea795a2c301ef44334dbd02c9e775e31dc5f8ce0608b6f5781a5200e02acb4487e5621c0d0c4f9fe7a557c3ec098e0d90f37eaa3b866166a76fd407fb8c37e3a949f4f62544f732eb8e83981c9288503bb2ffeb3ba7b0e79f4f8271b1db31c08c84c1087af4da2f087561864339fcd371445434cd0ffc851467936fe3b214f5b29d276e94de436bf7b66f2b0a2f2c2dfaa611535142159bc66850cd14686c6b27d5f982595ee27942e5a7e35b8d24f0c988ce29b9cf63adb4257c3dcdda3f849d0aa62eb416583e78a3d9cc147534c79a0051d1b6b69a06ae1725720ba51941d6d2e63487d528ba58f42938401627dc782dd0a0b021d09e6a9f9f445b70e428bbd43db33c380d501fd122a62f9fd76d85b3344582944647f7bc5b22f35ced10a00c7b2cabdc3aa88e4767934b14b4554fb09250deb771d5939a9e8736593742f0a2fa9bf0c5a0abfab0722516b07724fee9fb98daf292fee6b11e8347ceb4100b1df099a66f6188cde834ad9dc861828bc90310acd5ea9b6a378724485b606fcc57e7cc24f7584b0428b4abb46f90c97eedae240d076717399ac90440768ba9b58caae605c79eefbc558e910c27378f78634c274ffb4e1d0f443e736c5601dd9b44f33160e680c06b8c9abc17031cb43cf3ddd9b4dc806c83694fb4ef89b9984c5b2467d446db8093f2af692d050b4a775bea45b34ab9fa1c5a7c01709d34ea46b7caa71668b38e736a8eb355400a5b26339b2ee63815a2131c240a34822183c9a2e543c258f6d8343ec54754023ceb004d78d3123cb17a207fb0bd97f561f410bf64c7f1711a5e775a922a286808e726239dcea2b6c43f1982b76b0299fd5566831a7bc402d5f7847002659316f9c6bd2018c66a2b76e47d792147f057ec74752fa41d9672385af90421837772f72684548e78cb6e224c18208077eb419d3ab4e7bbdb0d1c74bb34b28be7377362fc3eb9219d4d60193abadd3d5678a05d0425c711e3b32ca4973af09de2a0a864bd9cf81502deaf90d5b5d104255862d712d7a6421a386dfb1afb03372d92d4e7edddcfc7b6a39a6974df7ef13370277a6e61c787772c9989c4db148ec50f0666812cfa99053042f94b90f7ab604c5dcbb733127a41f171372d3219b65808ce64a7df13f19e7b9165e0d62e237237f0f0cfb638fc98d5a122ffa48e5ba36eab113d5d55733ea7eb88f7337477b3f306ea86333fe951e3ded738cbd6b8f425bbcc59c44655d3a720255213386ec918b9f5fa27d819b6f25fd827ebb5c029d173764f6165d85d092342a46616377342367b53e82b0617cd3aa760ec46c0985fd812a5bec5cbe9ac265140dfe36292e3bedf91adc28878ac696cacd6a73079075c1c730aee30d209cb66a8e1a968aea9ecf6e2b8b91c6c20bb0cf97a3216da1fb644dadb03a342ec218f4a529b8f9e6d5348d8000acc769c3b5bb1f72ad82e10c5ed1006e1c8f4f038c5cb9e4d171990716bd5c640f808b03ac9e1c5a1c45fcdfb91a8f2d1fcaa6f7b29303b4cbbe8971b622a33de1d0ed2b44e00fa1bf88cd36c33770ba7194d18263bd862e81b12f46e6f0a109ba5a22a69d5bde56abc92b642ff51c43df4f47cf371ca53529338219ba58996d4cf80930da5a339a5b757a7f7a6810123548abfd05af562ecdfee07e4ad694af645a59a44be306108978c22612bf4932a4a84432fb5a417de80d465b6b10cce7858a187bda5f5135e2d96886dc64df63cab137b190b05665362e91f580020c7424c2b6609cc9454a1dbdad80a805a101ce2d5c5fce3921fc3218ff9041e9c9f298e1fdcae02a8fc3ea104cf749afc413dedaacd558e156c636b22f0fc80f042244ff001a5bc6b1e65d03359f3b501931305cc2494fe04ff505ad693fbb862a0557445e8ef3a59e5d359c0df8845a2c8fb0e9f5af3b5b9fa6a21811b00d50e5ad3b8e87ed427f5a8585029115eb3e6f2be9cc0af8a37e78cb828b1ae8ca2f2df3596bac5536563c34939652314e4e588f9c5e48d38a8e61a90b27635fac9e52c511d4cd390f7048bd9283138b4f02e6c50e2533ee15533401bc2cf45ebdaecd376374433d52bd4df28589cdedef5149ee3b3dc3625b11e35f28c66bb92663e96f19a3fd8e55d8b19d3e2c2d347f4777fcdb131a217ef310d317b774bed40a5bbab3713491aa50d1e326fdbf107485753bac1ceeca845a81f4e60c1c5674cf50c62c32bd115a42f0e6c311fa49dc4268f5329fcb123037b2187c7ff5f3da6add048cff49d588f209f344345c4d2420e34d7b2e2a94e32664efaa97b286087fe1011bdd5324f4778c0f7cbf1c77bd5527baf4506b580e05e5ebaca1296edc647b65692aa9f91444f781036f666f6427ecb81f9d95f2136cb38f7cd18ad31cbe3eaf8d9f68486cac299e6f6307f4f74e38e51cbcf36942b4e6c7cc09a3e9f7080e12e27fd58a0f9f5cd0035c48f3860f06cb8dc0ac2054b0289fe28cd305dc60bea6b3133c2d154a1755bffa14dd0575db271765ef6cb69a782de9c11cafdd238bea4472f29e099c2f9e9a38a69c88277fc25f764fc0750e3596795090a413b7ebbeb024c8c2b335ba15b2a0591168366ebe229e8a91540283bc31a4dc524c3e4c15d4aca885abb4be87261a7aa6991ae12738d7e8bbc8404949c8a6daf43f003257f579a82e0ceb1bbc53dc1434ede63cead70929a2e21386149d358baf9dbb9ed7ee21cd2f8b34f1e2e4aa18d5cc118e3204896727fa6903a7ed52eecea55c1132886af115091ae6b88039f93d7b41bc5e2bc364c5652f73f82c03a7e8953eadd283ad9b3971d67db1627d02bb5641721424058beeaf26488fb1a03a04a62be405cde861b2c20f22562422db944b4780383bd743f662d746231caab25486b71f63d6763f15a5bfe5c82d5d8ba62bf7b84592c018b7ab0a82a0c51cc45bdd8397d09c8e5011842de1e409e1344ac77ce8b876552cbbb7f299326838f71ce195aec4a2ba92dcd15682ff1e96dbadbb82a76168ae593f9a3a84c037f86f014656418c478ff72bf3fae4fb42c42c56b4cbf7925f47bb0d885d83265372c4446f966c6c23f3c6f362600ad355b7565143c5e122a979a658cf7a62f754250b66d50b3c4eec9f8cf91921f156548d77e8ef202b987094cb4bb76fe992715f21c9ee8504c0e3b51045e22e5ffd984ff9eb8d3e42927a58328374cc2132a8f8681369c9500238b267ccbe14144c753bb15a769fe8bd72476f60ebc6e5849d9976891059c918550f0b18d5c5c69ad897c878b3fdef03c77d602585cdd772407995a3a51ee1b75ef480eab1d75111b8a4ba2e3629f978779ca3d521e08db1f5176c1ad1194b30e90292c649ba98f5467c44ba74b5682a3d411c424608e1bc16626cb177bb46002548a2997b2ca2cc33785838579d2579907e5c9e21822e0d661aa7b158342650293fdf52e0f69fc3f2b66341f33b185d3eac0814a0e7e85ef8fb402ff7059f6b4f53c4688d6b6d346a8db01c8cb942f8629044c9d68ce28a8d45e984457e0a9cca461e0499cdc0c412840c1173ce255b0e41f90085bdf98bf742cf7530e91a91aacaa91c60688c97dc544c3d73e2b104c512576ca3f705c7790f5bc39452721b5cd6a77c2ed57f8bc2b9afc800712c86e647982a9140a5ab18e95e4b74a69c96d98fbad98f787229628b9af3b0de6877b9121ee19f11a5d4e525178c1d0879cce639cffcbdf147a15285779e926b4fe7f0a867e534af173b7a5826cbcc7ecc0b9f4830a8622e35e2d51adeb095638cda41f0802b1e11c817c844d3eb16905c0c7b6d2ea9daec9064f7fae55a213bc13f191c4e46d8f9588bbfd4770d479a979a0f2162bcb1d0d8cea12ac77170b0ff6c8142ad4988a37bb04d6c73c4dfdae4ba5e3fdad0e6205a1c2415b8ace22f8b20a2274f9a868c2b140a4a3b2e5ae74e3c045d0e3caa8227235acf7d00495880d48775070d8e75e5267b09c5741bf0ee1d34e60516e0ecf0d09b63ba9625e19e0cdf1a1cde3455aeb305255d6f1f1a1297ea98714708604c3cde5fddd6520af1aa1cbe31804f3c5a45399537a251ca360c56abbad276d665bb0551fc97ef79bf76d15c2382eb40b3a0e3506c4f3cd9a6b614a6a5d549de99af2c0f55914b8d08f2550d6bf8325e3e517adc7cbd7a43cba8d0d476448bda6f16afb47bf075bdb65b705690067c111d43dcfd64abf4b4d346dda336f4c9b54d56745289a815b27b3d365457d51115fa960d1f70c9e6b0bf195d1e9c32092efd6865519c29526f0a099fdce6ab1616107e1aae5530fb27fef19811c96c3abe24cf78f6dc43bacc86c3325872378c11c8eb3644ae3c23e613d9d9d9456a78f992bc361f67f9bd15c291250358e94baacb5bdf7d5eefafc33f4d9da57972cb3a3114a17eb54bc6c81bc0766ccd01fc0ae489aff9f3027f64e98f3349fc1fdc53c38b4a7f13dee9782fb2e243238ead36cefb9b96376f94411a3564893256db4a5c611406a4ef541250ac7933a893707a35546c8d2cd9fb23a77f1cd4b9e5b3c1fd49739e356b957e96efd817d0c0dde3099f3c41a16bc2773f0e85dce2bf9eb86510275153e0545d62759520665f589df0a12105457792454a88918610567e2e7dc244cbf97bc6a5ec0ed0ac35df7bcc3fdf82af9654d5a159d1d7875b2cb1032762125b3af18e5d08ebc28afbdb047029c1d771b82f7acd9fc8b1db81967aac9273445f2593dcad143269071fedb63173374b5d42ae36b906cc199575e899c7116ed741c9a9663254df13527b556519834d9a1b18a2e94dead9ce55d7e325fa876cb3eaf9106fb883d5887315ff2fa3a2c0d4d2396ad0e5912949171dca0902a0bbbd8e9d1675147706772b5933627c5a37ec71d19a336ae4f870ec88277265f987484d817f51246a8fb80d474e047de5d2f4fb45e00c19c593212f192ef6f3d7beac59b261d49b4d7538a33f11c97785d686490fcf1d42a66cab50b90bfea4f29ff772756b453c50dfa7c162ac8b536e906d335c200efece159f7ca40a7b8ba2ed7bb8eb44c923e2e1c39d8df104034c87fc4ea24708db2fcc6189ff48caa9a985e5a045cbb1cfde2b35e1d9e6028ea76a7a225bb9da300322eadf0ce261756315a18b965914e619d5a6ceae78138dbb7c8506a3fe6bce71c2cab06834447ca675be3fbf0d200d72ed3088243c53e7f2f21a714db9e07183f1bd11455c0b1198acb36bef10ce685f4879defe5c6f1a78292c4cae4b08430f12339c6b8f1e8c55a7a823057198a4339393eff350384f523a6e2a7269aee5d413fb9d68eed32744323cc187438a39dac44589d6ca83d595e1d5207aca02c7dfe3362aa38b4b476967c3b244f4793b934e00aca3a28f833a39594856301636a1046162739ea36c6953a3cfb252b14cd81c0b9fc8f1c4549a76833f4b97ced7f6e7fc22f24709c5a1807851f1cfda4f4ad76020051271705624cdf8128fd70a962a436e1194d6d6a65330232b18409072aa7cafc6fcf366c6332d9ff7a8388d7240ce53ae5c20d8e31bcd898f559f3d62d7548f26db4ba2c460b1133a4db891b063f74488d505aea2e62bf4e6a377cb55767f38dd2e8bbc5692cb741c25a261fade8624aeee8ae9598c036d7970325f8432166bd613f86ae930d50032b527755fc260a3d0cc21a693abf7d3241db9a8d8b20e0f564bb68c72c395d8d51e0642098f0f9081262a1230f70bc35691484c980525c9309df940ea6e1622679a9f6196090d50ff77b088a7a4184fd95c57d7233c3ab48da6bd933cf6cbaa952ae43a6f8dc0190ea7ec72cc1684d26405e3957eaa30129b9e0d3d4ada5c1e529cf8436e53ceaeb28be647523f289cde6732e03602972709e3f9146a28909a6f9b0792e76b0e1b0ea50c318f64efc53ff8de459548c997a1943f24e827c8de56fecc133db977611805504b91720c2abf7e198431073e241d3ac7ae9da4688955150ae86bda764d336eaf0e07a9fb258718324b3caa0078ff0cb377d0aaa521e6d523aa73aac7715d63e0e114e7f282cc8fb8566b572bb2af9213c41802f8b2fc348aef51fd1014f5a6a5d170070cddea2254426b1ac3ba783e7992caa0cdcd05f012a0c7fb0597b6bb2f1f8f83896b575deb27ef942359f0a42639c8464976b8445ff8f5aaf315bd057cc92116f076fcaf959b398bcf9502283aa531107132616e4bfa344f993f2004b4b032549f3fb6e518b9de26e122e76f1484aced0214b6aaf054100c85554d8d8e8034500a28ea992ae6283816c8579990d0205cd31e56374f49fbdbb81f5d14c8b6a9065e2aa4a8d8d10f8fdfb20c53ea42b8ab2aaf73d2e80ba35da183aeb86f010e3c9e0db28a817bd19e1a633a019a1e7397de76af034c21246bcbdab1c86875743c1be484ccb924ae7f822802763acac43d1289a1e2b79cd19514e02f8f36ff01f0f8ee1ff0fd906e1ee46317b6fdefb5a363fbd95987ee8b96f59bfa0886ed2180167e8dba676b972d102b2bae0cd8464d8883c08b971e098d3bc5a473cff4642d1e88dc08744c60f256ac0d7fc2de86d2a10d2b92e4dc4b61a8cfea1bf3f7a64f0d48a016757702d0c58aab2844772f8651b787e2c2c4c2e5b260b760ad19a7edb645bf66b644f6cded78830a2ea2fb384c77e36dcdb925f431113ea47f618691244c2d6bef9b702a905f14218c4030f9ec3228dbc8f74159adbd096e83b62e336cc78cdbf2142bd995519e19d095fc856092bf63cf5e246bf562c4f4339008d6a28cb0f8fceb40f15b5060f53ecd4d9bbe9b519d10701144756233eba545788fec5b4d1ed528bdabe7ae8722a87ad1573503b3622855de307fd9810120ad588c58ab9a57920068c7cff83c6af392fe0b8130f14429ba491e129d589fb58ed9d6a99fcfeaef24ae94feeb914a4ec625819e778010ec583f494cb88a715da72de73f39b628864bf9dd2066f89fce29485cb62b8d61e62a9159936e1734f952d92546f2f5746fabf330d2cd0bb9d74076685f94f92123e6566fdba2be3d046cfb9c9af334d146f43d859ac2b100ffd83b83949aaf2593181adc91aa97507708e3fc14b7361bbcd8c7a3b2ac53e7df06d22c3a7b6c03c4ad4ab06a9ae2654c5f1995c568e2a6ebb97df8dab69440dff3e80fb57df61b8dfbf6362da0fc6e0a0e588ddd473f138e15143e931bd45c726a74a812da0075f8a2d9a747317d16a71182dcd4a7aed8d030d2d354c3614983c1f8964ae2603a65774336e36ca2e6a54365afe2ce2aaa975facdd305e70688ef93e05bad5b781cc65ed06b762edeea942d3a1baad2cb18c86720623f85a84c0d0b3ed8bbf0f8c627c8945de27a01101d30b8a03bcfc3103fc51bb3f8a1d035e2fa06f9716313bba1e3074e4ecb00cb3012f29859f90e79d3191e09f3b6bdef025f710f26a0083bee16bf0cf3cf5d29218c18ecbe31dd719acdca55f40aca3c0c2e914a9ae58c6b25a9f7fc837430f6d9c5e9c6948559478bdca4f318cca9d9be5a826816666314e0507d235a2241b511905e7749b2ff7157ed9c08989a7dbaa372d03d0544905f6d29f2c93769208c8cdc3c9adef252f0de448eb2a06718e76885d247d6ad23ffd8d8d21a34e48aa13d7244f43e18db1596f558b7f485485ede195743cc8e55f43db40a2cc5132d577eadcda0f694c5e668771588930cb6c7f64a1dfe12cc3ba97c032be94a4f86ddd21babdc543720d22d0f64e0c91e68419f7b412b74bd480d69f65abd8e1a18511467cbe8a8e2bbc3b8c1df36b7cba9bda18a45a39fc76a126d4383644f0e2d735d4c674b1b9206e74a9131bba6615f4e4fccb74f4f0040621b71c9978ef4abebc50276b73c2609b5205116bae160e76192d310cf70c3e1ae675dd6bf7e2af914642cbc428a8d9d7943dc8b4472f9281d39000edd6dce667b29f12fa9f4e58c9af61b17405ff99cf1f669844a5b1408b7b6df60b1dba5eb89a05825de04d199ad89c5db5441f96cbe57cff8122ae7ebdaf57c9cd4dab62ca790117545b1e420677b833b948b0a867d7aff4b526922f1aa9f479bbe3aff0bd2178ab842fc1eab84bb54d4ff1d02a0f333dacc64c3cbc9d874931ebf452e6a1deeb0f2caf67f6440e828d0cb63d4a4b59fb980643e1e4dded480ed193cc79b08cb2234cf58ec72f799a021406b98a31c3125831477406d0e16aedc24349fd7256e8334795c59064078323862e63546e9d8ce1bb4f8779ef43b280dbc9e59dcfbd49c3d013a14d533df4ef87a143564b02860e0c7e6168e971c57902ed7b88953cfb498ce4fb7019133f35daf617400fddd5715028a42d87d47a6bdffe4fa793de1aa92eb8cabff132304b1db232e1dca2e755196a4451b991d199ec796e3b9b98ccd87b59ffdc831b9faed047531be9fb8b2cf1d6e0f15529ec7c53e8d7cb0ecfb9bcff93b551b4179b3fd381ab7d7f6b16e27df7d28f80d7da81ebd45a39cb20f442a71e74fd2d633df74b6d4568f35dab762ef1832084ff021211825b83ef057d79401081cb8287a1d1128e9491456e546324b6d7e3abb5822df31a80770c9d10d63795e92c43e11f8cfdc22a89d34a6bdfe7c4a03b56d8c1ce26597e5258eb8ba35cdd47273710a9aea00a6ba6bcaca8c8160ff2bd8e810bd805c5752c759cb3e6599af41d1063cf6ae39264975a974ba1b645adef40a459b9a7293d4fec61180105935647389be42c4eb87e21ccfa05863124f586b8d39e12723353e0409d8c7d165b343e2c320b65816e7a618060999d318b1c1ec55312a610bf36aff83f5a215c3831faa387bc431164d05bed9d42ce32f54e327ec8bafebc3a73e2cef786635eee8f04c66ac041a746fbd1be795a8d48e6133a11ca12127c08bd54267106a12658db18bcf050509607e41475073b8491c68046a00532f1b4eee4be3f4d7c234dcdad92636792ce9f8062e656e0e369d5743663b1851bce4ac900850e75f9b17b0a2f0f4f80094c2cafc8d21ae5ab8e141626544730cc06c93ed0a10bba8f7ea4023efac45bd7571e95329a2aa43436bb81389277804a86b949b0b6ffca166cbcc41e5bd565b650f93bf3e74a892d8eb8ad2bff8e3abea09e28642faeb3080924feed7c18ef55cd1e6107fbda974b5a805d1ecf2019ae18aa5984ed3aa0e60a1f95acedaea51d7e6918a66e8dad73860dc22b36af1f47115b6067a528a9ce12249b443f5d58f94b22ad168911730757bf98e62591b289e6765b31498ab0b82713d393c0858b8c5e757a8c96872aff1b461514187c99201f0b81fdf90538476e05e0bb96375fa898959b8623a00be2f41ed38a28c1e42b35668a31c1fa06c8ace8eb88a7df5fc88d1dbf5507de89e07cec2f890367e066c69b149fcbc590768e719a522d8759e21eb45f6ad5d4353df3d011d42763bcd7777222422678b20ee1250cb0ef7b18a83ee916c70c5a4e82510a4e8c21094e3b40d4dbd094f8df55eb0276ec12f97dd07ed211e27df77dcdd0f8f44e62a3a1df70930b4634741ec96118124a0466c13c50f2421cd9d7e16fc6f75d3fb3ff43fd55a0e7fc35ef6fd5fb4e090551e45955b0fba8c787f5c66045d3602894590ac4f825d40c4661adc0339128f26d3cb55d6d0948245d69ed1522541add10574e2439698c2d4ecf61be021ce65d7c42d651826a08dd6ed1d9ad9320efa3ad2caf06739942cb90d40be1954eee58c5e0a280647b476d361b5f3f3edd5a244672705d410e3ff7f555e61aa899d9db0c99234c896c26ca758c47a1c6153410b87c3b8742a78ba0677327fbfb1a70b541c3360f67eafab52c62b72df04ace01781fddbbe04b14cbe5eb0065384b681cb6e9dfb0b1ca2bd44d57f661f0d835d3f619a6a12ef78937f78c68e6a421011cd037277a642f2b96ed4bbca4556d566559b827a68ac2d655067282e855801eea37aa8461f1bd46793cbe774979a8611307bb4acd57828e7f7648f3a53ec1f053fb227e711750744148a8dbc5f53dcf53d46f0c887bcd0c00c69563af2352bf18c904bab60ca8f71831d1ab2953210e4d6821efeaef60d006d842810f8ebb88d8ee10ba9c02d38e54c2044b538813607c3b77cf26674b6c87dc4f5d747ad7bae8e43f0cfcd3234b7729b9fe6b26372732038edb7720b35dc2c09c98b16f6e93be4eaaf449529d07401820922fa935f3020d418123dafa03c8dd09596d4939f7508500a97ea93c7ddcd15144602ff20dfaf59c45ec4055f2902a14315a275bdad1f5aed3736e6fa4d97cfd9e61461101941a7c4b23dad540e50916179426a4a429c937035595ef178b4219a2edb465eaa8bcbbcb542ffdb54a35ee1fad929d2d5b0976e16790b874969a508cfe526dac8d94aae198966665236183cdac9358260ac477fd2200553869eec248cce8efdada1ab338242f0b78a6945913fc32bc1ca4aa09b915b1e5084a072b8b429c8912f72cc5373a59a8547d74ae8fd462cf0dcd14b4c39c76ed2ad321fac3a2cb17b63496f7e5d1ad2c9aed23f81f925d7d8af24d046c67ef3f6a0cad8ba9d55dacda04d8b7e95c3590dc7d7cb41e3363235dad52fdebd6d53ec0ce86cf4e872ad7e202e7217d3583ce8c90a6a1c5093d74c7f715bcaf690030208979177152d32142461625cc450c4c05d1bb7d058bada9ac762a2e131b7d7d01c548995b16be99fd1e2e50b10c7f2646c99f8d7260e7ea4348a3e0c02817d77a48c24cfb259aa4dba92be74f9bf635f2b60e11639661a76495189d3cc3301744a6500943900ea1cee8be831145f0d20825cb5e891ac5781754fe9ba5d97cba164185ab03ef772a823dfece0b3e8bc128a45328a4bc33df27f5988e74f84578039104f00fef185bfbb5256fb07278531efc7f81f62a2224811fcc85c3398b31077beadb55b0592a5a7179654afa8bd3b099ccf5a2bbc70810fcc8408a08d080a4f61202e4058d31e7bd0d43b7097bcdb0b48aa2b76da16505042c2649e80d6e210f4800446a1fee575fa556ca00f81b7619823081e0324a814c1a7c73f1fadc91ad160a0f673dd752205dbb877e4353c005a46c17cbac5fe14b4586037ae26b4e4af56f77bb183a2a400b91d4b2d82221ab5627f47d47f9e532f3cf65875cfca836a15d3ca3b1d2ef868128fb90734b0bd681aa1ef838d4674e274c5a77cd42a2a5cae725539e98107ed159baec3589b92eb47b4e82705605ece572f268776a982e7ec7f25171c1dee97ebdc6cdc08267ec8e37b0a6537d60af823c479529fe9ddfdce5d125a68f3ffb12675b76dfa28f60bae2302639978e1b8325fd752aecd83c7111edc646176fbe5c88981db7e1bd921bf64a07bd5d3464d9a041d8e0f55f9f59cf6b174bb62af3811e58565e6cbd5163f94e4081fcef23c503006dfa2b6b3912e64c73c3da9ce40e47e370eb9d387877b4cc97df6afd3fc476d0f8e66f34bc15d407489943ccc9e41f61c098a384ed66b8fbafd65b5ecae17606d6c2bb629e6fb0b13002b20804c5a24299a9b186824c81fa27d52551912e50d1decc4b03dc7fbbf3914ee322420acc2ee21cf6f34bf1d0816a825fd574017e6cab3e35d019dc91e4a861dc8bbdbac845c7721074bf958760467efa80fbd1293b4a5817ef94e0bb6ea45baaf411c0399c1fc213155273b88c6a0dfe44068f6ba19ad7e40c07662a41ea5faeea547b911aea89e387609ed145a039685d91e23c6ecaa01b55e8d8110c950292eb1a1ad87b587f8a2506d36f9623e6daf594c49cc15c2c4c8cf4effbb28e19f83981bf81026ce646c3695808b6906c89311357f2f4c0e69d3ae63b5819374c42d8ab06db4ef995d1aa96bc40292b5a77c604fe350b3fc056f1d787355558ca298297db0184f3c994d074f0357a78448ba7e97d7def3ed1c52a17049cda34f514e9e8cf32633bc14100e9d0e7d39734e60e956d8fb8e4f1a6c41a37e3da4bc21bd61da72012462d3849db5766eaadcd4ecbe0b55b0a7ed991bdda26ec377a86b43c25e7812aabd835a30e0a8789766329c054365ee0b20452183a8eace4976c51451fc7f208da2e26b4b9a480bd03ae7f081d91f8a771403255de719fff0980c5dfa7e6e663a877b85e829b81232e336cfc35c84190abf269dd6af1f2497fe2fdb1575e3a526280063512e095dcacbb14a8ba12de265d017be71f44726e02b361c5b35799e7c5a0302a3f532d276bfd3737cf665ecb7ac6d161e7bda6580f5027a599a16a1bf8d8a1fff9fa9ca7e307a8fba04793d5d6e5d25d10cb459f8bf9924d3bfb2355b51bb34aecb2d066bee36a4ecd77a3e4c06b7d1ed6e4ce524fc2d3f2c556d0e13cc1e047e3a3f8f010c7b42d05a5167eb68f5f6c15f579c53f6c0c3799c18b255dc95ef85f5d48701723df128b9f7b3f181d44e89cf428708041aa01707fbdbf7d0aecb80023f7178c02830303549e63f202c7beb6e44c28939b17fb82ff273bf8fc5679eb0ca2f20148eb9bfe7a0f7a78ae388b634132305033e5505576a4df609f694959efbeddf95bdb0c10182cb76de90ff4fc8491207240b6b16c6bebe31eccb40cbf0a51b94ce3a6b19c5272c60e10a30269fd87036d2d21564c33334735851ee33f9d339c73f9293fdbeae991f7fd880947ff18ffb474f165c247c7b47cfddcb9292291eeaf08fca69cf99708f9d772b65635d070ec12e76ffc5218b5aef6becc78117324252864bd38b091f53de0b8403a8e8139f32c4a47704a049bfecc8b9c8a4bd8562add7942db66f42e65ce38ff298722daac9cf9e7b4e18044a5211780fbc1a555e2dec7730eab3e81ed5be1c2b23148735783c79c2498f0c6ae90e5c4f6632e1cf62c7e9b60be3f3d56a9e50bd41d79a641fbff2cf0c2464d60dd651278d29cb44594a8473b79703cfdef70369e58dc6426d1618d4716ee6e2576e60733c0e290d83eed2aa573eda1069747639efe37b633178e8cbc0e92bca4ca247b27214e38da7ea5f983fa24feb42b59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
