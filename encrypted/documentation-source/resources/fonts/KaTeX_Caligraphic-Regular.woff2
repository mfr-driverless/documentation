<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f66a53e9621e271c155f48745ca3209bc5ebbeed13db653164710142f9d048cc5c764a8bbc9ffde0d22f8d654d4f19bd7fe4764b5e084417886b9653a56a1b37d27199f17ba2be2ec785d4ecc271c5bd2fc99722cdbbfdb01634d4732760bee5691e356df0f808a0dc7999d0ffa8062b5133e6164b87d7cdcd91f089e49e451eef51e34cb163d8c8bf331755bbf38242432f608c57d0df3873c9a882e54948cdd7255430787297a78999fe816da01830055b1a8c024f1d3f72a06b2583527339f8b23e5126f0e83d340aec6c76a828466f91c719ee147db5751ec669c86ccf53054eb5a2193b40029cb2164c82694a8e1cb1b1d78b00fecc87951e709d370ceda79904d09e579ae30d4394ef74fd33f10a234d971c023c5ac4beb1ec65fa80b5008c63d57077a4f190b67b6f7aa40f79f30a5c1d07945f9460d6c671cd53a70d5ad8ad71f544ae3c86cb50a9691524ffc16517036fadf59b6cfb37ee9e4a40b6e8bb9e72ac650bc36cc5e2056131628b4514af6bd4e03184638e9965d66079246686ca050ffc363fc472809e33bf83ef7576097dd604805025fe95359acf0e07fedfeb0ce63242631e2425808a97017adf72cc73c58cf9d630e21b8055d03a4fecc17bd2228e1b61bb6adfffb7b63f70ec2210a8ffdd9885494e90a1ccba1d898df8f9a2481c410909086b01c05e4ef230ce834816717e6520a4ed9f43a624e0a5b2c7050637304c2548ab24cece875a24cd4e17d7f5e8e284df1e0617ce5503427058ed2da19761bc4091d9661eb995103c3189db6c87c4b11fc25d72b09083970a700410fc0e591b714592c80cb88be51060b6efc28b6e03202132737d9325fdcb9c4bf35bf0210b7965c674958a4d66275ceb8ce99ab2fb280292a572222d159ef7b63cab7f423208f68e1e9f030d26cebbf2febdf639860949b0070aaead58cd42cedff4661b6774adc826cdfcb5f6fed910c2f1b01f5a40c8d5db265bac880ee829aaa247d18b1513f1d4ed5bc5130a097a70d2a2b7caa0f7d4128a9d19f8d36661a5d49a9f42094b3645ef560c524973af189fca05cd9bbee162df427d4e9dd39889024a76cfcad2a027eb6d0c62eb279a6b58ccc10622ffae67daf5bc7080e53c775e6ba3eec4a3cf8e793d0115ac05be6dde9086f0a961d4194234146480a0c2c6c2220c8188a334dc4a195687e948d0f7f951b9ac75cebff11339e59befbed59204973e5c32a7a34be83ab7c5f897ceb9e12bfbcc1b78779a3aef570882ded45a6e0d363eb3fd662d0ceade530fd1c9edc280bc31901969e619404164bce73715928aaf18108512c06450643aa51950a06524e57bdc57f187ef2669657356d43fff809b05b5a1b7b62f54f53aba413394be64b0849b6377f1b7c94240cac9a49c746e478703d25632252517103eced95c5868243e7db8babd4fefecaab97a3d1593463c4ab4e09bc71827fc0f60d27cb55a75e86faf9bc06098ca688a367bb0e474e15f0bfb641fee39fcff2d1a26abf4d6f71250b782297e377db4e266b1f84dc53a8cc03326ffcc426ea3ac3de1993732d39899f41b10dbcb07eff788a7ea7ac67829ca4210165801c3273e176023ef49c70ca0c91b59e36c3d2074ddd7e6e4b3cfb12d2aeae5f0620b4a7a0e860ffecbc547d839b7f4d944534a6bc20abd492f4ec19ee0b4b80aa211fe82d4427fcb1b1ae22b1df2c538260ba85e3f95215263ce5403d07f17ef55b80994ab85198aef19f1307b848e10034b94ed1bf262624c41dd68f18cd33312c1ad0e1da842956b4741298352b4286d4277dcef5390f4d5c5b0506738e75ccc9a773bed88a010015d7039d478837efc8991e0ed695893619f060ccadc78887adfd7d57543901abc7450d1b7f021374b16cac1e2ce1e23c84d44e4ee71c09c986957182df616f2210319b6c663e072e1d6c97f3f89eccb36fbf96b5c03866712e743b6823ed31873457f8b150aa9c4ab7cf6130090de1b565b21c114e805a26e44bc26d6f6e081527101adb851ed84f02318e9f6197e7a626f66d3a55678350bab6c9374495d998ae2512045b2cd6e1fd1c49100effcf871dd36eed33a1ce051c247f43912e27031522c1f6efdb49deb3b4835dc850d435675255db77510cece960b4db35cac3a1b81651af98afffc598a31efca6ae23029a6ab13509de22b92653c734949fdb2e6291d56c966a8c271fe2ce5d8e3f1dee1fd322353f4ad27caee3c85dfbbbf2e5cd9698204d310c5b0c1d14dc068d9c88143ece3a0ddfe0723672e2336d3bc86fe89d5e940161c34c5c104d74d053dbc976beb3ad1b49f89baa49ce41fba8b1b27a234114861bab4da079cf86cb6ef635d5dc5d71f1a7cfd17a466609a16206854c9c9a7049080ea9f05117ddcaf3d17f1e1c16942dfd29a3b0a41f33166a5901d225a66cfd1fa2b027700f0de0a29c34b7d3eb13b21d5a2534a4bf044d7b00b27ca649a44917b1eb2e9d2ef5d70b22145288af69b0d20fc0deff84718a4a4f9c0eeaf35f57f0b4e9cf3b95b336fdddbb8fb212593d2fbfde76c63b463add77c7ec78f28b65c286a120ee7f09de38de4478394b8bfc02e9d7d50daffe77a27856d059ba5c3dc23e28f7ad2b3162329ba022825df7b2761ad36adaac91bf4c73b6f2ea02d0b6ece9c7a9b8c771376b86c49e89c4b1f22531f22590caffd14cb369cce4ada2cbc6e6c5cf5f7a2ba44f5a803d99244b0947bad79e660344f1c87b3f9c1f9d0e39e0d9effc6945b83d8e3564e18d9cbef817be5b35400eac8e8af1582d700e156c2e77f1b0896aebeb5d88181954c10f55dbe67cfbbdc1d44cc5abb734024cf08ba926bb89e90027f4f947cc46c79c271947dc5bb88fa31c3cb451412c6197a45f6810e6da6d1e3f0f62a9c93ce52145efffefe962625cbd40b24ec9316b1144348e3ea23d30efd60fac1ab0e2b061b69244db538f82c07f1b7e245dd0ac4a9df1c1bb110816d4374e2f572e7db264dd8f820efc3439ba0e8e4f9d7628e22a9d5782f46af87ecfeea7c495afb2b74e992be57d4ff5a9643367497d8428d74b298f7e3fa1aed454aa5309aa766b5ade3a1711c677b57356a014f776d9a230b182946a4baf2e11181f6d2ebc5a0b972b3068f4b63e5bc77bf69fd0243b2079b849ac8543feb77bb1bf6eb5d494620cd4ae733becf9ea77c30861d9a5d280131070c5b86fc2909eee0ff11b0e8c062cb959a0da178eae36e94cff56b203a470d9f52fb6b3b8faede12abd21bd70fac6840ca0d08849e3f171ae9eaf578003044e3a918c02997b2edbacff7e0cd7cbfeedb06ab41775d906c6c8d370c69cc64e647453ae934484e49722daf47c6cfdc345afe4bf3a799e6b9cc93caa08db5722ac65815aaa9c9e013efb0e230623825b570d8a73e31a3208259ba5c1db348f43a43d056f214ccb4db687b4e82242b2d5cb0de458e2b20987edeee710c66cfab9f2e0972d9de91856e775a2ed49ba0e1326d465a8b2dded7b92fde0ce0a222e8689e1fdbfd8a88a7a83730e91e4575bcdce3ca3da98984199988cd323423a498d3e9c944938d33cd4cdd919522ccef8d780ebe36d264135f3f13ce1f55f723172173fa8f78052e9af41bc3d754258922d91a16c427be91010b844baf079c785814ed67bbc4b43e11bf5909eb55717fa3182772aef35b1d4d81c51716c51926af559247524cd073e9c7fca6bf062cc84de8c4111b8b913084c8d6b4a0f6f0c3368f4d2c768fa5e196141016c0e5dd4ddb0311227b9774295b04f78fa43cc342c37cd616c4d986093418bb80ae56dfb7639d54d4e6c547fd73b7e0a6c37fa2fd94887212d898cad750420e673d2646f5a7ebba866055b0d8ab39f268ab15d896a0d82a653c22de006ff990073dc26966e85631189464f332cd48600fd248cd50ec2fc98a368f9d048d173efd227cab6bff3a22c3385631e173afa527b460535d6375795aaf1581007e97f6ee0afb3a750516042afe104de4a0909a5601349efb9e7c5984b6261488a77cc290d4b7bea41f8b14bb09b838ec2a00a7e7e9fe5f94b0eb7aba82adda96755d0436eb911a4d8659d03a64dec7635c65cf2200586275eee296a20784edbc73750b940248ec919717bc384f703743be91ce7acaad176b6cbccbca910e810dbaae01f719b67d8432e24d006bffaa44c25669bb2205568e52b0bc2631308e2e3002662fffb887d25c779cf5c53a391b532a71ec4743afd8c970d644cbbe53ca02daf858fd1057183c91bd998222ca2b03513dca0c9429227926b6f8498307e20cfcde3592b42749524ea260755cd22874c3323fca755458c3a1d6c7b54d29a9d589d9059d30037fb9f944c3c20203abf18aac8c00d41cc5f31bef1b7178c4227d4f304c2fde29fa67a08195a760e528e5233674069f76bc9c6296d120025b0524faa8cbea621277cb61aa64a70014ad79967258841ae663e66faf34f5f738808c6614383e2f3a4ad1e871d38d36c926ace76a2fa56b77614b9201eb364501f65dd9a22eba141659e7cede6e10a547a4a369d0b6fc27360524fe7ea1f586653a633049f3d709fedec9c5c22645d9c8536c14936591ab9ca532a7c644084ab40ffd11e644555bc518bec81e2120bd4ad52d5bd18bd088d0b53d1d9b81e789790d54439b2dcda93a9d99d7179eb6061406f5decc11ad6b63391b0d3dfda5efc479b29598dd0f4aac72493f8c0f2075a712c2af5c4a42cb37fa51823c1deb02e292f239058d48b6de92a1b715117ec82d74257e9e36737bb57246d3e1285f2b53237e95455c32e86fd82a8737d20a2d7619fdaf00e3c01e00ae17cd19ff3a6dee6a43611302f1dd900a56fd1522fd96d7153d38e415edc7ad66fafea29a2665d6dd93812335ed363eefdf443aa9b4a98cfdcf8dcc829d16c30cea65b6c9c4208aaff08e833811ee9b814dd9ff943aa4f9502974c2d45d7ffc6ce27a3e008e8eb178a2ebfc9bc3012dd1c25524fe21525fac624e5684f8c610cf3bb0f3a30737be3a5ca6e84ed9dfc921cf4d3182ce0989a70a60a07edf0490b48b55e51c73094be5c9b09010ef7baf1090dce2071248c18834dd657918912bc07222c4eec95d8b1fbf53c704bbae9df1db92619e353045854e87d5a052106a087ac7c8a3d275b38503fcc689387918dabd96778e7980a383932da0d996fe2204b54dcad074e6dae5589ed3771b724f2cf7bdad88cae31f96c3797c9ebda9a30c0f46762e3603d12006df2239d063de998a16fdc77a12d9727a1757e001abbdc12081b2772ab3229356d1c2477b2ae2b7f5a28adc2d75354ed74ae55369f0267f2b78e08a9cfc32a3c6b01cb06f1c70263409e12c0ee9118685b38a01d518582f31bb39b45390ae6298eccbadd3a8b2fc7ce16e21c3e31c02a8a4acb9f0fb76f1410d4ee201dcd72718366558fb2bf91f023c14f7914005038717c61b783a2e134e704f4c75aac4b626c27d31165f0ab532ed8c16ba1401e4c3125d9784c5d123865bbff5a4271e1ed13dc85ae964510d950b7f4cab27914ebf625d6008819f7fc5379572aa560619e74c4eabd63465f41effca3ed1d7e1cdf10bc833349f3979ed931e55f80c06c0bac06b2d8fc71fae69c7ffb428016ddfeca7cd0e2ab48246361e3be9a62a0210b6c21a43154048b35d0f2cbe80fe14e5a2df6458ccdfeb0b6455d57b6bfb7efb8ccbb7f8e1cc93e70aed58c17d1b4386a2dcaed18cb9a67dde456812943e56b894580d519efd3db25a91ca74a3ab59d9bcadb78dde2bd37f9da05afed82bc6349528c18588075dbb079c8276aa4c65bc56456a51ae233b3b918173ea551cdd24e9959f55bdb7dc2a07996872cf43c079dd7716fc0c64c86335cb3b4a679796faf612561944b90f96a2b837e3d72df128d9e918107b3fe7db1d720c52b7c3bd953b798aed3d299fd7da15a78cf12cb821d2461f4400e0fc7e2e42fd1953f2cb1121c6180e10f75c1f071bed325fb0f9075656fc78d5e2197133cca5ea90d53e4723e2eb5aa8068586e010fc52e155a9b08fdea6628b229dbd096ba3cfe7f05cf323a7311072a1643bf74a8f933ed50c6eb95b3d5b475b2de572466de5036620171a3271b3a143c0deea04d4748c371cbbaebb463a36034254648def4a50b212518986b1952d0319bcad4c424bdf7f0d335056a01ce9325ac9c5235014465a5886a7d0dd2f3e3191e9a7a78ed52ed8caa64c2d94dcd250c0e06d1fbd9f6373d26bfdf7ccaae9c16eb6319d308b87d5b71117d4a74eaba48b3b2e255e18866dc77150dd75ac863831fee1baae7d38577f66146bf634041e87a4c3c387ff7b3481e8842065b67af492526bee750e09389409a043353d931517527fb64e820a7bca10a90716359b6126c5c910dbc212e0fa958d15401f362fe13915b5e02aa3373a503dba0ab923361e502a1ae4ab8a45c4a7487be46eeb95d5706a7cd7f60571866da26cd54616a544cee31d159aa647a9b8a275f1aebf0ccc3cd302b13af8aacd48aaab154e5a2f5b6ea8b4fe914f2ab7e6d51cce93653c05fac50ddf60858cd331ccb69a6f8bdeaa5c0590fdc3bb2ee079958c73a69397553d4902f688ba6823104e99435c546138e52eaa1993f93a8ee6d0e0e720e4c7d04f407cd52540228f52f8e3028f7226cd753c5d93b28a97d5c3c39df42f9c2448b1f6ca670df9ceffc642890f14aabd23772257ba118cc64878ae1b9094abed4fc399cc065ed91e0c631b7e5d63038fbd36bf9e3cdc628eecbc33f82ed12098fb1ea19abe1d0d8d74a0ceaf529727463081c8f760b4faa6eae73245fd67c61bc5efd76a4af570719412ea89f3eeded25443ea4039f863e6bf7bd57b34c69c34ef9060ff8662a6e00e0b906431c26e083cc1626004e0e76bb510e38f649902f5b246f20f4e18af2b5f04fc2e48f9aebb4f8469df995a7cf001fe05488816f222a558f3178e01ef29fc731bfd83148c0a4776581f58ee7119e0eab60dbae2f9a33d8d4843c5033f7e0aaedad69877561b4774b4eb8acdae6db636b1b80217d6eac4a99c8d9e6b2de272d7d2ceb503149b8a9565e7aafa711a0a0e6a356c6493c1df561a0872d28a7aba495339dce8822e16176613914da85f1d329991f1cd790aab7c3a304ddcf04432b92602e31563bda9830546b8a7a254f7abf045243d3483777472ede461f6930e55275aefcb5e2ea0d0144e2bf2aabec73332a59b144b22ebdce1aa16f8ff7ef9df4a7285dd447a83e7eb2e4ca49105200727c27ded52dd65589c0f4905bfa7c44b89ac7ad0a52edffd4b391c523311706c7b25547d2e54ea17b3bd42f601fc2c82b8909d2002e07b490304f2ca8ff4b4145481debb963e9f79005c16431b6cff3fe2703aff148ec8d7a307907b55dc8645eba456b3f478d034754ad4ed5c4837f2efccdd0c164d634547fa124dce3055dd4e9cfef7ccc38a19966471c524d2c37cf2d5227c9b028539b25eca5d91f4a7cdb025f3454438d23dc9d68403f101e4ed3b0d2c2d831b6ce1e3cf0ce0fe086bb33063e0fe2e97ab1890c5aaf62061b11e9f45f121167fad41fdabf748fdb590b6cdb5f6e6a8d3fd203533686f6bec0b95d5dd58abac91b99773bb73b3d4573e640f24976da4c9351f7ffec8f78a4c7a81c8af70ab9f9c3cd52e0664806c8b473e4da34308c25392b7f49f0810389294b4b7e40ae42868ccbb0ca99aeda4a5a11e36ebc44bf02d8bdc8a5310529275e3c1750cceaf5839fa1498c004dd4e6515b585a83e08f831c31e645998f61362d6c27be0365c02fc6e839d563c5df2e459b7729c7c060cff033b7ad56e508f590a64af89b4cee89fe8b9e992349d952310cd3e33ad194d3c2f50d11fddea315271e36ce9af00697f52a75664b1f2678fa290596175a2f02c412daed60b8092050f71574f9d91b65ec91e32bc22c639ef812125803f41befb6737ce17970b3cdd1e519eb2a241f80782a3b51bb3f903f7c26f7187b458651033f70629ce7cd7dac240d1f544b7621ef3febad1108241b988c78ec3be48424215c9d6d56ffe336b671ea7cfd333b452d4ac30de6f1ca3f356dea3cb3d5a0c180b2441dd05708934a095424875ca51099bc815226c26fde4f2e47846ed281fb397a0057f0dab5487f007f60de14b825972e8c339c62b06e19e47c5116f4d42b59a0cc409fc3a54e95a6ca9d6bdbdb6ea253a96b8b03eb1995b3257a2bbcbe356a79bdffad70866d9f24fea27eefb22306f4c5f3d435182ae2a601d91871cb71743dd7820a74a600c9c144e08b1e026dd0f3707851f6220a8a5539590315b94cb7544ac2bfdab350be2f723ee4e3847e036a29091fbfff4a21231bbb066734788c8ff57b3c92950f362bf2fde3c7fef5a49b8f082c62264e6d81313729ea72e310a8b9509d5ddd836b55d6c0e0c51a2ac0415e31c555203f6b63d1f01a7878b6647e311f6271a556091bd368a6c8c4a3fc0f96e29662ea53c94cafedfce4ac77c5244cdce5931cdafd2502c453d08a9282fcff95ec3af5ca877e77ac8350135df927148a82dd49a574a51c4e0855a4b12597fc7394084822569c2dd5ae72eb603a776f5a2a6f67cb36b16bd34595e8d380185d4ee9c173e76889b96ba81442ace9f34296fd268238e200963c21d2dbe33f661ecc05f91c6abc68bbff433b38feca2db5459597670b0195e527f579725d435d7187b7a8e589358902d9dbaa7b860e642914b1e7229d74fe8c00fbfa5b67f665e5be9133677c52799c2680df06052c57e7261ef25b29feac4059be1e7b49b23073bbb741251b1936ffc3f815a19b48cdc40373880521c88a3854e369347ee4764a3089a7763e9cf2d6da0ea44323d0099902a38c7702a36d9d6974e5942258945a1d03e34c2b3ef8801f9092bc88ea5e814701da9724ecbabee56b33cf1fa6a4c6dc1c7d9799f085e36b90a1f5f8e1264e0aa9767c06f1d10718417646f180aa6732bbc0268a3ed093187e6cb7fab58cd44f1253d0446180fe7a3ec382a360a63bb8d0cf6a35e26d6dafe614d0c902b8efce41d8c4b8f9498b07c7c3b80a4f376b71c1578e547b9c65f55b8c18f64b1401d5bf1394b303e371a60d83ea71f00eead863385ee320df0b59619fcdb9d370140a916ac9e1da16c74a41369c702496cd3ba177ff2f1431d9f47ee7a8f66fcbfeaac525a9d2aff74c79b3abca1a6a84829847299be80440095bcebcae9d19cc4b59ae019d8e54820e86fe8e5c3374e8a5ea70779f350e8f88e0613e48167e397f74c8eb661dacdf761f114ec72101425856e5e0393aedf5e47a73a0ddd2e94f9442c8be545313bc29a68d0ac7bf6b06eb2533d30bf21673877c0af6a971531688b00492ec8a9e1b2d95566df2fd1efdd5e19b80c8c058624a8368ba6ea9180f7ea4d1adb7ecb4dc09d62fbec1bd47bc3ecd5e8ec50ab016731d4ef9917b7eeddb0b0ae100bdd559fb45e7ef266b428ac3bc570224f5fc150217e47cc621c119586320f5a1aebb34dc33b1f68abbe0cce27b3e95d0adca83e58314076d2a3de1f006b97f926a705b57aa84d90b9004de4a7a0d01feea13b84bd3c574b6b5e890aecda7355c7b55edfc9eadae3388acda56502a3dfa6e754ffd95539b0619d1067ee2f024fff7c4e9cd19d1687182e158543f7e93a296458c51a7f2201a7614f46b9269b2cff350362529dba36c680cfe96502c5a3b541a5291f70383b5d44e4cd782bcc1a64b766bd855261baf1bcc67ee5cb646ae7f07bf22d31cbb06fc2752dbc3a6671dfc3d485a09b56494a3b917d2c8095594f76a3d7a5fe3458bbb07c7c6f7a638c0a8452366cafcc01af3948b01852be732e18de4069cf4158845a97b2db5cf5607e5483da145ca4ad52a54cb1809bd0c7e9b799c5bba5708136969e8bd0054b7bfa3d207226bdbc6869ea711b77c0161b8641ae5849f50471f282e063a4b7a2f5d2356cf1371c25dd4269742c82caedb5e2674bbe7336a970397dec10c6e216e2594f6e89199a5e7d45fef033d8632b50daa4a23f291468b09c23949c89b2cdf1ce3dc20aa94065fd8f24e7fe585d8a61bb1bafdd8d8ade2c49d08dd6dcefc348e59d0e1a0e69f37ac434de5155f4f838a736d37765e5c07af9f8959152a63769720432147147fad9f7c1aeebb51ac6c170f460599554199c31838b87b0d2cbb3a68c3a21612f4762521b4f1e8c5db7e4c9f5ae7a885abd42f54cf25e3369486b96b4594c5ef609cb16196f289d93434cf385ba02286984c5c992b146784f4de297fb6edbc923e362dfda26be768842d0720e49dc3bd1761dbbd6764a004b7350e00fddb18b4c90a5976a0150e95289b02d8fac2ad6dcb296d0ef74c974869a38563e1e546949b5d6d1580b098c00ec68d9c8935a4a420f277b40b8003578fb1bb68e434f13bd113edf389603cc6ad1ce9991cf7b87ea015097c3dc3d5b38880683307a41ef93f693591cd7facf65139806ab90292ab0348beb369fe554d95c7dc8cf2c20576cb0c007fa2ea44e88ec230eafcfd5b79a9e58aa422ca05acdb4efb1f3a1352d61da41a0bab61be6e79bb9f210fcaa204c2de68a44a0c790b65e94eb6ff42859dfd23846686828f9e24191eb40c84f0a64dca2e2ad15b7c5415c6f3b6733c834b58ce4b46b818ba3d707bb42860fc2fbd0db7ba83946d6dba80c2aea94a10281f181b20361923aefc4d869c22eb9b446e544be115cdb692c9c65d6e8e45cf199a76657e5a7d64da5b58ed0db09ddc04a9882105788b8ee76d3657024594dc5d6bd1219f86f8b60d67809fe934aa5147366ab3daadbfa27660eb924ae72596295c529890055b8497202eddef9d01f75da12cd5efc6024a1a2299fb43b5011c9885d78086b06b89ed086f616645a4c2bba7bcb46921a86f33246c564c950740a64cc2abd9e8d51fe570bb123cbf667530384396840dbba45baf15ac14576885d06cbb44487ef45831d694b1862a420b747cc429ed62cf1488a1f4dd131209787853d0cdffd6f971ad77c08de50eb107ef063f0ffad1d96a70c1af5deeda2bc28fb41b50c30404fe8e4bec95f5303db7fce52cbcb34bfc23830350b65a1712a3d142f58752fed9b4b144adafc08efb14dd7a9cf1ada71844017e12159cd7dfcce70c8e31fbb4d669f8307baf2bf94cebb8fee687c02eac9430e4eb0aa9ecccd4ea66b8705a9701bb8f0a838ecfe6fcd26b816894051999962a8f9cb2096abe831f930c2c2227c1ceb00a1b805cc63ac05b97353e333c09fe499a038ff17821b681621f6ef91c536eee83fcea0bbc53ae5d299399d717d86fa614d13ec089c30c00d417b86bf8751d42cdb8a760157a44a1cbc29c2b87d184dd32252b5ce2a5dd99652fee96fd416365bc80cbf3144b98e09aec343d07f789981ce99e3a533a948aaf18f3d3e2ad1f8d8f84f614f528e28cff4bbb103ce4243858fa38670e28f4bf594a260572756381737f57e384a313bc036ab41acc1dd7cfe367242d2b81b962d2842c49771165b3370521d64a9f6be222dcd040638df012e9686af9c8a3a94e81c1e0fa7449c8702900587202ba3693220131831d22102e74f32bf8e79bdaafb1d7305b5afe13b67d99ffd967fe038c32f3caa542038f6ea39dd7a87d08ce9cfbe227842d9fb4982a4d0d9fccfb87acea45d3c74ba408dd829c29848d1fd0b2b5b712fc9a777574730b2d7bcf93b68a51fa14533a55cf57ebae6d4f263f2fe11d2b75a09fcd7e0242e041afd6409c9c87afe260797b3a3af97e9ae62ac5f4568864ff2c56bd55279432e8db19e3a01ff65333ba804a2453b3ae9c666fd6252a87d951a0c2ab24d010fec4fb6b98a790ba43755cca2c34a12648f27124c2cbacb72cfbae08ffc018be7b35690e9e698355eae230c7584d8b7b58d2acc86c385f32e9f92626687ae2585e01c0e90c7fc876d217298f6c87e8b6c6fe6f8a5d4d1a5790501cd4da8a73457863f994d97f78528c17997ab25dea165416276755054cb5d640dc2a80852ba8d502df1adca9e91d94ca65aa8e742f53ab9c2d4a9825cd613fff1542812db6b93d72356ab9e6e77e8192e2bff0ec5bacd8ad0e654b0dd23ec7ced3e5d7d9ebf4e31ecf1e574b1e730f2521e7a622b49262c6e57daf0e1bd55161efd85ae40f80df42a6641621d96b400c913d579a7993b84a88a2b1087afed7dc3fcdd8de3645df6038e398bff5f4fee6cce349be14a5250e5a98eb79be9f812afdfed232a8b85341b29adc48e636fc143afdca86c641f80c1411306e87a4ad9f7878665fb3ec31b0735d7e49df09390cc5531d269c365c14b74eda6ab4bcd1b577c0d8aa57c38c81e397197e80f950095ad5fbafd518770bbe48dadaf2f977568c41f03d3620f5a6fabb097796dd823a6b94f9018b1c73b99a224d63567f73faf2c608dfec366d43cf3ab546051a57353e9f728cbea6b63f411ba676bf22122d78aa02d5dcba24ae5d42a414f5132cadf28a21ac3e97fe9a4dcf7afa2f6fc27672174718d30ead682450c3c9a61eaadc849c16e5e2c08aeb85f666dfd20e566bfc1d155158ac853f375c1efac32d75719e329e485dfb76fa6ab5ace5f1cc11fed5df753d3eb656ae9fdfbbae36c7c0f4d954c2deef935255cb104c1213839971fbd7aafdf8c833a5816e10d4315635cd9c6591c76c5134424cebf5f1c0d4bfd5dc442d17329417bdbcb09b62773263d3ba149a90405a6742104ca6bec02303794e996d0a981096bc0ec892b9fb5eb8598a185506fc8b1a8f8b393028f0a25def58b313f51aa7578a7fcb567b33b8ef7b9507692d0d3fe642f08d1e789d666c548ba4c9b0a62c3c9ba42bf5b6a9010687c58218c24d852886ea7a7d035659a6798986023bf181cb4ef75106c366f5ed9f0c88b5b0f447868e7ef284bbd2d8f827774f6651798f3eaa4b1ff754a2d51677696574d110b82bf7b4fa9daf7509f081091ae5ebddcf41de75ec13a8ba76fbab905ea3295ba2045ff3e3435271662e868e25194a60cacb9b950fa0728877dd2f017d75f09043a209202897c4e26eaf7c4e53335d8572974ac068ec00f41652428747d63dc9e0efabbe54963bfc5a9dbf6a2bc1dc0f5b3738bf835efdabca59ee561f4e39dd1410472d3d3cf2f1739bb0a26d3e1325cf57630cb3be7005459f1aabaad732c19cc54ef6daca69d3459848f7ee6b1f1ad70b6927623040b8c7a4a7e291d613a1d6a387544911120f87f9aa907757a48a44bfdee0b291a1f41aca46651aee4a08b4730d0a5e6e1b547c5973d63f75d0d84169dd4fa082c534a53a556578d23033849cecd989e905bc6b9d71ce9b8d45b98aeb3540c0debc494141bbe518ac6ee2473ef3f3b2b044872f937ad0f3c431b6d68e21af3c048c4a96cc5380e81ecafd1ccefc2b6b66135b62ea5861402cf9226fc44b3579db3dd793698ba3e6765197339372fad122bbe83af7061bbb51f3b31825bf00c3f5c2a56b8e8aa799cc49c511a9f371b243132e51a0b9f41e053a6f7ea37fb8df33cb7bd83b9c901e437ea84f437dd6dae1bb50c142b49709fcd00c693d009e9b56041fb0bf1fc6b607dbf59d1e3e2d2f0705cb317035f623d674c128982827287b37371d196630167df9c7b094a68619ea12a45298ccc6924dd74c711451be09f4fcb213adac899f348a3e893a9d384090d2b0db3cdcb15c4a10b5fd6a47e523bf85c70c511a0f2f0d51b51c47ab499f2cba54408b4b76457819e93e3138ccf00f27f5a25d55c054590e760f695517b22147fa2d808910afcea1bacc6a60d139ef33eaa6a647bb367dbdeedbf47502c61162bdea9719eab40ba0d955c9351a60ffb52900b6d2877847d7ea5ba3c8e11dfee37514683a7354d741f6fd7a480a58275e3f039801090b856a3caad78ed305b2a1e968d3f43a5f5c36d698442f907af1b18c753249a932ca418f9ee7ad67abde4d1c57420fdccd3c312e2ff512de35de2199f9b2dbcbcf79cf8c5c1fdc394c756239ea0b81ecda0baf96fbe829c685d128a0716f4db66f992f0ec9aa32c8545026f109520cd9482712bfb1362827eefba53bb04e77dfa4bee34153d5dd71444c63b735e4e3929d7d6b6aa7f370c0ab1e532040dfe748362e5ff5a56e751f9eee8d65cc9f8dda0e1b45323d66b5d9278d0a92552e9540d04a132957eb987bc594369f6f770428398dd09222b6ed0ae8576664d13269e39593a1a5124fbba6078fb6cdc831938205b2838e20ba70f7263458b68d004868cfe0a3e15a6f744da1c13c1af6f0f14792d383936691d37e4246ac2f6f5427540ef9e4f348cef9070387eee6d2eb6792854696dc56ecc9f15a3022ab4f9d7e29f1dc4f3e74d94ff207fb88c4ce782a207333e74997dd5cf7f55328097f0ca04f63415097c4506c2646e494a9bccc9b955cb58b04921867bfa0ddcf024f5f27454236289b2afa530fa7fa6fbac7886701845446dc4aabc9907d21aeb4b5504ac40567b4a9253d788b0bea904c7d2da92ecba852a1adbb7253a2a2cfec7540479624e5b03800d3a7ee22dd6e5ef9423f21751e57db337f37b189c63588e4322260e08e474254bfaf6c4b2de7026ab1b155e8c8c562352e98ebb0070b922b8ca10224f4007cb797d960f64121ad532af6b837de346eef07a669ac46ba071f027b08d81fa796a187daa20a7c2a35858fc9e8214624fc2fca9e0fd466b86e64f49f9e1c64c04afa332045801cca86d9ca4972a70ba6b61c35103b326c461141f2818c700dcf36a030a791a53bb4dcde8785d9650e52219d9c518d0754012a8bbe01d624264e0d246aa4a4847b70100d6a8c8bc6d6fba9e94f15d2b5080bd8db9258d3ab9426a3b3e9c01dc9a7cf2097cced3c088a9e778c3a7bb5607ca94b836937583c2f79c05e2e6c38c2ccafcad730c0ab01cdc2e47f75458efa5c5ab90aba73a187b88c5ea30a1a70ac741719dc690f1578ec88e4857dce777767393d643f7b7f990825735ab14864727cc39fe12c2f6f77c3922a154360e195b4d6964f635fe4592104ae4050d6d574ab4ca0eab4f5aba7c438693ad9cb43dd31ed7b17f1b1c3a872ccbf2e857a27f7fb9efd409f6bb626f2b3bcae83c6255326eb5e9535c0beeee32da42a1dfeccbe0b79dc0ad1e189ddc8e6f03cb3659b7ff810327daba820be96f895e708df842f64ade3aacf3e76460f456e198a458c5f9b48d2b095e84a77d7e6885bb5fc5bb3bae96ef19d80e5c23c382c9babff4e74cd953d56f4d544b10a3e391ac636058f939c3394bf4dd478ad071960f889234f21f03c3649ea47b79d8943cd50640ddfa2a4b751c3bb433a5cc394ce1885af902ef4195ce7b93c79cf5991199ec7beb74b0ce6d97c97224ec906dd86927a4497db74adb73176a632d29acbcf2150c0212c5574b71b5e0db99f54b465d0b07fc84ffb3c1ab1a5ce7909746d10e2a35fee3db0011965382d37d08dfbfbc7ea8838c3ce2b9532389d2d779073141611cae000f93cac193b9a78015f925a65101a07934078c8738dde5082ec389f1b25d08fa9181164cba318fe25e2f1ea02f95f343e83d2300ece512da873532daf26a2edd33c989c7c96e5893aca879154b785248420566cb708a2452f683be322414c23869fa4875a36dfac7d9329b2739d586b2aab9c543e507319b7c66812f216062402e106aa3b5a6a654f9a91be5ecfb7610011a932d03845513ffd326c32b2b08fa68a827041247cdc6a44e61ef8bf1129129ba31a2f4d861c96d63573ce6522bd4a9f02926e456386414395b77c6217dc6dc708b15899c8e2a59c9f4ea4a18c484a25fbc96f26dd9e510b0e7dbe5cc09d0418e7755d408a4c205743bc7ba96bea0abd42b54269db490071d769d6950574d94e892041843f737b556e08e33abf79358b3084e462392f724905995a98f07e97c587f83cccda6f2d9721a02e8d244fe03599b6f435a6bfb197acba9ba90eeda7948db06d27be23baec4f1a34103ada2410503710f840c42392d4a7db504bbbb94b0afc5fb71ee7af2e59985c20893a505bdb607603d85d6625862e084a65c4e19152571c04214ddf8a400cd45e0a4780cc918e7a23f7a386341f58bb157db024cd6a30e62e5a40c2cb562739667b4dd5b062882e0a23915a0c5e513346acb0546c7ea0e36f2b7784c58aaf2404be7e1a5503a6e0458f591b8372e472ad2c8eda697323210534ae482b990da9ebc8ce034b1bc91dedc152a1dde92b3c674f90d161e47e1098cea60958ff4024e1947aa4f57c1fd00edf93e97828d18071819ea70deda891c0e791afe0b0fc5504f00e2ad14cc3ddb3f3482b763f82b77514c2c8a1dc31153fcadeeb202db03fdfa2ec4392e895757ddedb28e6f82fdf83b7ea00be6a810009e49e9b1718e6593eaa585e33537a0aa0b854d8d9a1b8ee0a200cbc6a7c0a4cfbee779d914904bcccef2a9017d70fb299651df100a8f2f5b4961c95a53f27728e49f8718f97504e4abb61f24bf62f4c9eb010890dd58623b9bdc7b155dae05edca972b015f81cc0713364af47487e4b79440aad8f0c7d3401bf255dfd9836ae6a4c41c4e7e5a03967bb081fa6ff701bee8ffbb4838a8150bad409c6a0afa630df8730d738e5752f6eb3f83d7b6569db2d777b644d9c3617bfa52428a4e1636bcb35ce277add0aff4e5a5caf60168823f5ee41b57c673acfa56fff5b0f091c0bb908cc23eb7a8f7ab8251a7c5ff09914909770a7828b83ab52ec0d4649ab309ae1d5e490b39550763b546890fc9cee663f99f7c9d99431ef6d91d83853021b9a331cfdb06ebb403ba7d129fed3ef8d626dd7cf3f7583f826fe8731cbff19063fa0db65c591922706ee59a9ef4ecdf0de01ffda5351930c606fad03419ff9b0454befe9e3fedf76910f2a424c095c392b2506ed1e5ea46b49a27edb053abbf31965a02fe2f4078ec00fba17a2cdc629d9b7fa457f4d6a34803d21571aa0b5d7af0d74ed3385cdaba1783ddd1f795dcf41080be011b18c2131b9eace2ba27da7591e367ede270a84e7fab6fafbf050128913628d551b9c878a25a976bbcd8813a5c6a7286d5107d0e071c124ab136b467478903ea01842787073aeb4d514d717350a8e042b82e6a404b68554fbaf81357e5b4be5ebf69ba74104e37ab421a41fc3fb51071a771638b331ff61ce64f2ffbb583bd90cd9e7c3ceec4866fc195096539329ce484251ce13712c7187eac499b8be0b7dce051cd7355e46cec807fa3dad71d479c2d28f93b9f6e6a6fc469a8776ee397358b462fa5135142f5076be8477b784836d90d57536f9caa6cd0b39c0efa1e52ebcc69a76b107581670eaa2c84b6d73c8673d600c1645ac94ff24ea680b942b98491c4d56c3f0ac3299c0ef8359a98489bc01cd3e860226098b9a2ed222d579bc9280e65ee664b1dea6d895a7b7471f62b96bd75c3424381afa4179c74955833ef02b0a5fb6424c3d229352b5fe296d4dfbdc682069288f151866b3048558e8ccc6fa8d9df18e966812b8d4c49e4492712d86a0f2cedc268da927f1342b1b788f958f8a6a4948a4bc621158d26429b9fd45baa278375429653a5fb57c3c8a4b385d65e972d3732c53ab11b1dae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
