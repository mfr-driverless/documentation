<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91f20376df5d5aba3b75d7d2cd98818c173114974aa86d7d42b19f3b3c2c577cbed2eb6fcace2c179ccba9cb4c058575515b0e451efd8e087b93786cc2273fb38d1e0e1e1f168450fb5cc7f963796b73bde4c1e580eb04f1a2b695ab9a11bd5a0b3b0f76d419a2b1632630d3d7051b7bfcf8ce738e936b7b0814f3bb45f72f7fc587e6bfaee87942fc47bdf7738527579ab6020def49b350cb56920818b79fc60628adff6429907189ef1e434cc0f7cc2bc403c3459e59a0c1273f5f356e555991a67d09939961f541bb6cf583b10d3bed06829df9c032010cae8261f3c251317bc3268b198b6889597383916cfcd86f248673c3321a7389a897c718f00afd1256503f3b391860bf6ad35e953c4bdb07adb584adcebd957030e87f8f50a89ef9f1f29bcf285bb85d7429fafabe4648a5c9933a54286d21c3bd1b6bef593aa51c14054df41912420f7481a7fea7a397fe0126adc23201bf6bac0412fcb0447d389e6512d16b52375f9c5d8d356f8d6ceb93f1d87ad37092817858cb02633be30e047b511f2dfbb126ee2886c0a0fd9eb6649d40bb0586d070fc00071fcab3361b648226794e9125d123a777c9d269d997ceff76bde7686930198c78009b55749d0d4a42f09c42476619d59c18efd1949567a83b05e37d70a89e8ac3f8786fb9f0ada9f8d6a3f1c3cc6848a9d2834baa3b35591a3702452226fc3613d7967036c64916222656ae730470f717bd2661e808bf94334c6eecc0c1e04c2e3b6e6b399f9ddebc01acb6388b7f152efbaef333f926ad8d7e0b3d8484219cd6e8461db75cb99a35fea0e8c35b659b5962b56f99cf1d863533572e030b9c2eb79ef4f160fd290836a485ac372b7c560ca1ddb277db57c816ad4aeaaeecd54ec78d1a0a95f63d8a4b16e70d879f8972ea13bf7928bcef155f4dea81534f59269a405b0802e33042448bbbe5876b0c935ba13e8f8c20c68dd50c04912b9e88635b70042bfdb5792b71526eaf94032d2e0b92b9d82c646f0818831f4f846b069e51dbaefd6826d2febbec8a72ffab9585a0da5ddaa7dd4025a8b311f619ad095de7c2313df68dbf857541600a95dd42a4b08389865da8ab1d87845861336c26ee38169d62af9414ef556ddbf545122e8cb33f1441a815de57e83c2a0aeffb45498de58c2be7ea7749fa1266d19ca785becb0bc9d5df8eae88ade7071895d989aae7608702beb09a4698479421f986a402a34555caa91db7bf4bd60cd38acfcbf8f97ab4aa18c7667e7e895c52837df434def48bead49a4492b48eb2e5a2c000556c6eee34474cdbd93fd1c9328806aaabfd72b0fb72c0dd2b89863e6fee6d7f25ebc2d741cbdbc21b3f07eefa6d87d5c8f23672c3f23c8784d19069ec0b52b323272da22397fdcc13cb31a0959adee65264c11df3deec8d1056bc8b1fc68e1482ed8b46e381da81782aa3228649c56ddf0e3834b082e3661eee32d12be3d32dfe86b8be09a3479cf216abe726b8e6bc0d27dff8ee6ca8f84b24eebadb3c73897ae7067fbaa31d59ce6c06cb724fa362ea1ace1cae4dcf675add27849ce95b04b61086c27373a4060bf94027a295151409ee9d61af83ee06065d893304e2ac5c62edefb3c8f04551b176bc53ef5419cfcef77aa62847e395364de72830d672a51899db19abb7a513f1830bcfe35e0655ce9795a18d54f55f4355ebcc0094e24fb2be8936197da7944d0144420b76053672f4f7a77d424dca76474c96082d30c11a4fd58c63412fb9eaab920b9f84a9a0caf79eb296605ceaa056965df26c241efc7bf5a31aec7020ab0ba25e3f01673b94a29cc562c86f004f76b6c75397785fae7f0d4908e70259c36fac3e528cf990feccedc59ba80118c72cafe1b26f85bbf5fd548261e015535379de43418cd3a3697dc66c2db074f093466865a7cbf29ce241e686b69689abdf461754a63c7186dafb71441e067833ffb9ac5f2c7deea53692442f7d9866f6b01daa933b528c0245f7f169c4d36c2f8769227fa1435e99a6d3e00b1ff1b445a4b293231aa5a483a22a77fc54b97dfb01357f6833b25118b5db12759b52efc48222c4f7d0ae251d154ea012fc348c4111ddd132e34f9a37424a91f85777cd7ce17d6d104643031f38fd4a39d262332e89e3d8718f64f3df31eca92967dbadb2d03208c4c4b762fc71e0d0e4840d1ad39867f7acbb0d8dc6a8ebe1cdb8d67208c0067fe2a01f82601cf6c5dafdb27034e46f96622bc192d93636f69429329a7600fffefa17c522b24bdbcfabc89f929778c87c2f6df9fef82d8f699dcc5be499a20cce0ed3c594b1b452c4047d72a8cf795e2c4ca50324c4b7657d6243abe634cdf19085a00d9c658ec5ec474950d635618d889dc09eec9f585258be6472500243ba00534bdb3f35adefcb97f760adfde1f9f592b6766c6bf52cdbc5d4574aba672feb5a114b40d4fdd8368675c834eddc26274d3f7079c2dd7be02e1e20c3e9970ee1f5af6225f7892189ad83ff97d52dbc610b8f5c4de4cf95ae4497e0049604856a0d6e68ca4e7e40b4d17a225a8d2266809168174d279ad4b2236b112627f96c1461e152901760231c8a5376ecf0185b510999a26502a96f64d9f837bc015d5810fc7ab61dd67fbb5179b5a9528f64e835a2e5debeed3baf58fa9421213b07e2635d7415c6a410ca5058e9540fa4979e68db50b17feff59b4c0327b3e4edf90f8865f3cec1c2d066214cef738944dd1ac4ca1ec107b5bc5aa308be84bdbb5181e7ee43b2793679214b9b1dcb1f5f1938d5ec325a13fd52802481aca95b198c6fa654af0d656162e5d1a4c629390b41ad34d192ddde426164fcd02d3a2f4521ff931251bda3e0f04998b53d04778f71a4b717b135829af0352d9f56ec081a3592fb3eb053d05b911ea99a6ba14c33569bf1acd30cdf54d845ec6a0a2cc922dee901dfe84ffec3b5dcc458ffea5b025573fd2ff38c9697309b11c859ac9199c4b9cd66158cf89d60b49eaafb15649335724cf216ec6b222ba230bd5eef639024b958c99348fbd7eed4f80b22466541cbdfcac6343a8eaab1471989dfe978c31597b04afed6ac428aaf2b7ca60c98795f813fa8cc9dfd536708281a2a76ea4bbe75f12f678535c4fdfb4eee4b0dd91e945c54835192befd71aeeb17ee08cc75876a884b44330533ddfc11e619e3d62313785e5837aee90644400269c2169952af344b1731aaf6bccfbc22a4beea3c7f30f1059bf7cb6042ac72f000e34cfe6cc1ac430005db51d4748cc772c5f8b67d1a2de0bf0923dfa8fafe271f1a9e7ea73a09f5513862d633108ba313330b473bb011df00800ea78fd434b21d6e58524f9671fa5bce04d045d998daed17e7b86dedb7a7fbecdafa49ad336dd437d7c523a1c0178c3ce2fc78180ce04f3b8ad82e32052b3142de4d1dc191c94cedd1089a584d9d8220ea0b9f70fd6cd5f19ad1e63bc4c7999ed64dce26d2d34d80681f4f674895b24ac0c932c29e16f163cc7afe43397e859a608619386b9bfba179e66538c42a2f87d82f97b0ebb8fb6f8c4f284d3b3d86f541a9c0072b422545236ccf6e88f7abb2d54c20d4d774665d8123b0f94b2a70bdf73db8291c781a272518364e0a11a806a8215bce78203175157b40c100ba79ee034294148663236e48a7892bffcbf0a7c83cb87c3e1979a069bac475a69089f3bf4f9bc46cd01a82cd567d556c6e501221bd9e967841be64122c550e193a2337cf7808e06f033e9fe14dd6d668afbb8d6cdd8a5f8837f1b636c6a3ce708829e8e30a6c8acaa112dc21e24110fbfd4551173f0a75d466ba712cc502e424dab32e0f3ff73978a9ddae0b9b51f0ba627c94e5dd55e2e432d76dc81e7b6389429388b84c0c4ba5fe50cdd1cf84af7497d62d108977bf53827529266e694edf38776ace3a29367472526030e69d4465e9d20151fd4b50c5ffad46d677818988bdc88582e4caedb71ec83f92f5b35d930866127ba07717acf08765e370c10a481dfc2a72c6bb9c5af1403c69aad34db8832d8b2a5dc962b1c3873406bfc565f8bdb84d7db9083cbd71a9964da26733cdf4a8c5386317578e12ec310c4c7065aaee6dbda02878cd96921363880a26f37c06dbf67ad7d939b118918d9ba9ccbabfcb08bedc398aca7d3111dbbe31d6652dc79ff49736d258f7a8bad1dde0a9500c26c72ffdaee89be258429c5bcf6036830b45fb4537b27641f4fa3a1fd59f235283126957365665970485c8e07f0f25d4e283ab922527adf1c3dafe41de859ad7f4ed39d487417e1cbac8549c4a9d2a721a6b619f7bc4877e6cd897be5748db9dc5f5c00e00bb335cde7b41a67ecd5cb79d88569a00055b063b636e36235b83ea3459c46b44183276b3865274e31b9c98b612e764f4484b07ad804c2d75712b044c952ed53a81319f26ebf9c766ce5e179a0ed3a3458cb32c0a8ae340411cda50eb3691c13f7d426a6f35e66afada7ed75b744bd975f25101b085b87295fd68319842e21580186edd245e342be9be01507f1e00b119f7f5f724a7d3d8e0bee8b17e84accad8dfd8447339a8f573410482199cefa7b9da6f80ba042a5cdf850d61a8e95f50f816b54d4e0f48589fd7134c76cbfd588de62929ab5e4435e9a0c76020860473c7aa7d990021fa956e74eb39b2419646e1ca0fc07d890068999bdca26231007291339b826296e4b8c1190bc21fe44cd6fbf1978fb13b1ccec460a3be29a5aeab1f40d4ea6d1cde909bbe365c708287881d8053684d68051210c5dbb5a5971e0547cfd8725eca8737a0517c9427849773b3553481a0402c2b3117380bcd1799c25ce090eb1fe97c60b8b32f24de9c9e7767f6961e7a7aa1892cce5d450530ff73a20dd8ade6442da526b9173bd50bcf60f5a3c745df8ddb1e8ad455b5e754ff43ad66989d4f576ed7040c2ac0fc0ffe8c099aae2b7be93f84b403771b52ce0d3f2db0ffb6e406da3a14698b2c4ee77479f7dc64a3a296a94d6ddd95cc73793dad8efea0a659ceca78b4167497295651b4a6febda1cd5948684f335e7cf9a5c952e12fb91485a7ba32d52e70e8e3241529463d719587b2a767ef3ff8d21545c800e1d50bd4ded084daf84ab54d0afa58f2538fe25de3ce174caa8e4bf4da8a645003641b0ee62eadc5014f4833fd5407f80bf61a7ea6c8f6608adf5e4ba6d76118ce9bb1b25be1c2c23cdc0207955c3c3d704c1ad25901cfb87c281bbf409e15b4de12431d4ab58fdef7524c0c33a1bf1a147c389dedf1fb94b1a8a16b9edbc19da4c68f0fe0eb7e20548ede6f75c7c77d31e8adf4fc09e62427bb1f67e8fe49e4ab612ac96bd4bfe25984b9dff9cc769545243c66195798f7423e608d9abf4d266e1e26a28182528f766ddce74b226cca6ce72f4b533e11c1407d9c38aa10f401fabc24d7b07d6423164a117556aba793db06616591c58c6be359626dc3e23de4acf9b3027bfda1a19ae77047d4372942f6e481a2adcffafbcafb491cd7c416bccbd0cef1cde3fc4d3db8db3a2ae2914fa0761fe22f700bc2e4cd72c4bd249c992dafc42f76b26c91f81376dcfb6ec0e6457263f9e427a67173e784a2461e149865bb870dab2213fa83a03da38d29d69fac8b97a018dbadc342ea865284d5239b961aa4fd6cc200a8dfc4ca56e772b84cbc7d33856fb57b6fef25d06ed54e76e39ae8c5117124bce1273dae7f1ed647b58b4f23af67ce98f308aadc1fb0969513af4818031552a2df14464a5379ee9441571db0f34cbd1bdb3ed072c343841eb2358ed74c5fd7dfdfdf0c94cf1cc99bdb5cb8aba9dfed9690c0cb304a10dc71861ee1e326030419dd50da86760c4a748165b324d93be6c610a1ceb3972aec1c7c231b0877ebc994970cb34a877c63236eff2e41b8e875949e261837cf174b30f083c076d1eb86590bfceb191fb8ea52f9ffe867ab862e750b5a86b86b80c5714f4c839c41fc80081813c131a17ba409e5b7bcf92358d79006a7edb29ec39d1149d5c3628a118591ce5531c79f2b95be2703e6882c07398abcd6b268a4463f0dd40346a3dd1dad88c359191f081101c638f2ae9d58d5948b7ce46e8849fbb3ccb26413cd9dbd3434622618683f8dc3a92520fa8cb4656100a23930ef8c25e3914d242288ddf39cedd7c3eed97cca6dabcd3b72138f3ba1c39f089e24e677cb3a245a748ac0eedf50065a77a4ecb52b45a2956aa81051ae911745607a43d0c23139bb5718cce7448881be94ecad2901603353a66611ed4c213415ba7c4cd7d2d760de690923b5ac58a23d9479ae7b4f34fca3a1a4c24fea12fbbd4eed72819211e6012f3a378646562ee292c42b44cafbc751e5175e41ef8fa6836281f17c8b46758285a65ab11886ce46268d76b721a65fc162a4c398457b20e2aacae1589286e0f5b8bdd93ccad2ea595b0212856e0419ec2b5edb272eb5048dc2fb30375e9f4022cfdfb18d486f85c15a10378fc33c6855511e7f22eb6707267ba322786fc2195984ffd9164194d7ae5f945543c85d1f629498ef6ae28ab5cba5ed6625330ac98cfeb8a99ccc9a9cd74f383b581f3109b5a0944e1b3cad5308401d3f91a41bc3ec954826491362b16ca107288fc612724c322d57d038e16f82454e1840d1035f5ae03bf3d4c9edbb3cd8808fd5d0d5a08cc550384c43187a4ed65fdf69e90f0d3b4eaed8c1e7508787d8aa297956585de67535f59a036c49584d7d7bcfc9b34df1cd0002b0f071c8a7dcac6dacdbb76cd169e2b3e9564cb13fa091b5261d9ea55ea084749e8685058142502fcc54462d0e1bbeb002b03c391685c289e0de0330ff5f8eadcfd6c7aef9927d984e4e624db83fbab0d22e1fc0a1917b66f0f713750b18c6395162b9f38ea4c18f2f868cae03af397c40ba9abb1b56dba6b77c9800b7e581754b2030bdbbc82553731fb9e29589f00dcae8770ab77f4cdc4ee7192b0a225a0aba9ddc03ec157f36960cb1852e35e096a96bb7c0686d96f9f421907dadd12ccc391908136553c83ad9bc2b99fd528a702f3828f909172dd8f3fb09d2d0eb13e94d5f22d4c661a1bcff6efe105e2e4b668dbdc52460ca729d6cbfe50a9450eb682348653d14138b3a1e183839a05d888710f48412e1dfd641a873627182917ca9fb4b5a76fbf0b141004155f0f4c34ca1194baab186c979554ae4be233866b87b90c55d0504d23e29333b78e1be4d2a6f8417a3d3c849aa03e232cc5c7275ef0cac22a02410e1af84b992e17461d3820b57876183a9062d7d00f6dd09188ad447da5322f78be6c826869ec3568bf468f0d592f4a03ee8abfa5ae6e8846c6e7da3d9b8785d77f45cb2ab688b4de693c4b95663dce73b9d0c1b6bffa37dcac9d7afea428a0e8645bea535a45bef278551c0c515f1b6a320c37cb73cc8b9832f25329ff40dcf823f3e2ccbc373b417498d9419f0a29c7213cae8c3f9f8b42816f18fede94197d54d904a51ba4c65c3b2952f75457997c4c7c3dba9cee4cb607857e65699cf18165881e8b27b32f3f6ae2476200def64b29cf8bf505ad1f2fb3db4e4ce84782963933e2f489528bcadc3110b1dd44455c2a77b627b12c1ac1afeb74ff9a4c72b91efa4e4f9e8ef51cfa430b80fcbac903a738b86181d7c6276c1d3cc2389873243178406734246287e75d6ca3093cd0a54ade93692e1f0ad8ddde26775de13d831a860879e30834a5a720a3e9124dd21ed0ab759178b0cdfc8e371265e3dff1ebcb689087804fec64132f2c405d416e48018014c8eebb22a87712911a0f00626e9d689eb3fdb4feebdff308adb56a2dc88c52b90302fc3146859c44261efa38cf47eba417bfb5d592b6b8aaff690005a75d516672cf35625c57b6e3317da14342d898d586d97a34e00682dd9f80d058532e4c6bc02e983351c4ada3dccd7da84a965fe87673443fcc37b4ce4bd01fc566ee33674a86fc719a546c4c5a83dafec935aeffa19731d282ab168f4e34b9d74fea18898db51747689e91e15a21cece45f17d9c62e86640854d6a19a4f000e1536ad78608316cc5a7d7f392ee99629516ff872b39481f0b70639a124831d0cbc32af3af039c299cd9533b5bcd7a1f80335ce6b74a38dc3612a545ee095bf1acebe2cf3c10ac9cb9329f8dff2536fd7c5475eec881c8dfb2ebd0fc7db584fa440cd78e11d888d5d42b19313e49de1fb4c754a7289e72a3b89273f61bc74d50f8481a9ea58a948478437e982734f3351136bd868192e2363d6dfebbc2176593d0a15aef1e98732f6daf12673cc74a88625970815aeb5fce3e0cc762f8b3b744555f87937d9a790aa98603a8fce90628014d43cdb91356a36fa550822e9d8318ea242e9b048ade66b70d40f012c05bb772954b6672e5e566566b17bf48dc2bc1c999d829a367ad9865376dd6db41cf24083f2dc1e688c08f9bf3f5c1bd61d7fe3a88d2b1af588b0f8184eb7d045aec25d050f0e549938c2cb9352c5a638bf413c80897447e7aa7f77146d13383ded6cb4ddea200e0e8729ccc0502ea0305014c994452c6b754fc4a31a914015b2929ffcd55b071b8c46f8ce5addc1549cb39820a93f4436e1d077a216a90685036e96119f136c72762e5b827ebca2db9705b10286dd85831708ab5a89cb278e6d40f6427039b596b03e9495232c2b9c8d13d5c4eacb73e8df5c5508bcdff36c46945febe58a3abcb75c8c9890f1b6abd35f314733c5ec0b6b4ebe94c80fa47e6c6648701c1f4d27ff5dd2c0980e448a587bd04c9705889908f0a799867cb0132038ac0fed76bbf5dd05bd06e79c15919cd403740698827bc78ca75a2e2112a83a4fb0baf3969477fd49a78f3024bc392e8df49c639bda005f8bd3fc7ae81031067da68df25ab2cb280f7a68c39b26003c3d2b877abf5f227248429712c6f6f607412834edaeabbd2212e8e91643dcadbd60875b45ec95325f9e4f9f2461ce6023be5c3440f81b53a1be1fde593926eb7bdce06637233f604030784772f3271ee24f09fe28cd59d92209d0a7973a63ce935c0248f65877a98c9e21fc214c9cdcb0cf28ef90cab88256199506df8df98f536565d19bb30300ee55156f210ce6f66bb48650a79ac1a17f037678fb4c0c63f8e7de96e1597d3f9a28b27a98eb27a4fdfe8bfdcda1477f4553c49b6251ec1725cd908d911c78f71cdb0f61cea0d35ff95b266e4c7a81d9f20bccde19c1d69b1c131fde8042342bbe71bd0bd75af3cd104925bb6aa40bf067c7e9d171c2b0cd188ff111608a2959b0eed9ccadb51389296cc0b5a9d0d516b3d1e535d0dafdaeb0e6011fc0cb1ad8ec001a55ee35b34870db0f2fad5056cbdf80333f197e2b09ce38404a2ee8bb18d34a1159af3a990af185a4ce034707cbc77c28fdf5f006e8f07f08447734777c7fddae26dac980d8bfa976a0f0e64db10d4050abf62f96bb6e1563788d029c4ded198080740d82e2fbe5750f86fd2d5ffc71cdb005dbd6e2f5893ee593239e90863ab42274407e9b94721d980fe2f93ae1980f37fc7e3a5f86ad83a0edea0aa7976357294fe22e9eae2d9e432bdc7dcad382d943fe1901ed6f73a00417f1c0d97e2a4adcb604e0e578741fdcfc3ddb6a1969ba4a5d65b46b4ae7c23b19197f899181c74509cce21c0b84264cc3867cd3c2e23d182f3760bcd5ab8d88c39ca71ab4ec48a2f43cdeb24d3467789abb2e51590a7e2c6040f2e9be6e74842c923ccc670bc7e2ae1d827b0490c3864ba9f7776dae3c269db41c67d52bc959c8c68a2979e83d5a0a00070fc27c4f5b62eb1b75894fe84f261a8a11c90cc10affe899e3ff2e7cac3ae04770783c6fbff0db7fc1923ad871f36b868d0bdffd5a4003198d907eb5a8f5ec2093dbeb9770bda6739dedf1a9132d1770dd264a6f4046ea050c7d4f2108f4c0fe21ead18f140cea3f4af75f42644784f29efebf8715547baefdb12d3fd54457f8e7a3bcb6177a02bd97f46124a0491a31b3a57b242cb79db410556cabf2eb3faf31d2ac9d38d0a74b208e9f432587f0b742023da536e689bc5411889374bf2d5b771b3ebb250fa5b14ed2d345854ff9c8073e72ea32c9f335fa6caf7f54ffcabe55582dfe15b320b69145ef03ddf4c1c920e8c44f08f2238f3ea144f0d66d2d2943a53e19c7d8991b1e568c4429195eba00fe742412d573ca7c3d6c96d1a59242b18dd652eb66701bbd1a79748834b5ed26a3bc029f00debbb081019b691267969059473289363777c455bd6dd94a1760ab6c90e7fa8eee5fa29620c1f794f77f8bb209efa37d69ce67f6b14315746b3df89fa08d9ff84fe5826fc1b1ab8148eb0801b4d2ba787bbf9adb3c5a46b1af81bff905aba421e5a25011c17319a57bffbfee0e9c049fab2443eabaeaa67b5f6b9ca5085346df55a3b4ef0d47aae2c4bb547914798e42a38b0528543a02ed4cb39fdb9b650288d68b7795ef85c6570f1738738406d54a26cea8130627f1dac9e06cfe8f22a3714464c2527dd295b32ca8c7d34bd81564d9753356cebd872d2e4ccb06ef7ec7aca5e8ab17374f91ed1577734fec6f1399d9c5e9c2580b6730cad11876d5197916e9650a42f709ce2235080823f97743dc961195d32e85f2a6bdcb884bb635a6fc2f45fa8d42b2bfe1bf76ddec0debb26d4778cadf6c4f1c779064be5abd3c02dad1bf367f8103a9065da3185cbb8a5abe2922f03022ef0c9da6252349cb9565b08719af4139f7154011d1664aeb292596de918c6a31ed965302774638d7225c1adc8eae28fa6bc2b45baad64c847f85b4b5af56950ccf973ba7fcf3b3f2cd5b5633a2c0f57283c5739fd09113d30c2c82245d277a3ec932d12162bc86523b830096c9d1ff54c2762ad350a68c90a56f25b120390e0673c91f37aa5c57393e7db959d8aa6701a5ec38aa7ee690402a5bad33edbe14a568752350b77a4d359d19e8db9991e0813f17652c87faa2745a356b5e16793a9d4f1cd5075f85b2cc9216a689a957587529e8a5843cb6464762323a95c7ab5c5b8ed11e3464a5848781f28e75ce093393f699ab3931e932c4054e1c45d7dd2fb2aef7c5d8f16817ecf1a0f6a2ac3e711c78311adeb22843d469c8d20be77776b785b707763f2e42212f6b7de9295f27467c5d788e9e7e950bc65377989e6724c2e0e12dd375e636022ca5062f3c5f52c53243c909028802bce43753dffaa3ade254dfd19938ee5a1899f23c45aee774e43f530269363f43634cd5f3f3db4b3a293de301cad156f3e18d44db7cfcf64ebf272b3f116017f9d6053306d5212001bf51b58cd033e78339d0e235acb38a5436412bad785090bc1098550dd482f1c311ce9e7da9c1aecb9e077230af59f21466a0680a0e394fedfa1fe22c81b8a47f563c5ce6f84b27e3202f02c4bd3462bd79408fb7075c27c161db3941476b4926702efdc53baf1da344eea477aed514239a45731e9c350cebd238cd09d0b8bfb856de72109272d770045d3fc0d85f630d5eab2627fc3efe270f8fdc87402ec0b06b0781bb213f9d4dc7dd3ba14564e6355865a32c78cb22bda9e81f39c4496d800f8f2462f7ca5985755e00bf713534f062d84270346f49edf461879e57db3bcd3b5a79402f05abf4b8b46f3a916beb9276238ae13938b787f1b65718b56c9bef2b5186e17173af03ec5cae779b347d5f6902b2d772b5340688779548d803b35ea64056e5726f9135029cc876b0c478034a5423d2c64db0615858ceffe29d375992695bf7cfaca2b9cc6f977536506710860a1440181172df672746dc574b13fbd87cd91ee17538d5ec015051f9a6c946a641e1bb8e858c752f6ee4af35670689e4cfc37c3f639b5da4adf1b003baa013618f76f45b4b086d549e593c32289b0ff996166ba450c9003bee21fba3b33e71880b6b2d69719137c99c44be26e56f30f1b956336f2dc6c7a22a0b5838a167c1298d395c3997106673bbc6ca12ccf4106bb31cf51b9c2a59d658de3088cb6b603b29e9c0a59ed4c9a0f89a9ede658605a2e34be1de05b7e7b2646c02c36973f603da34d9940c5fcae01f6063146381fa7ae857b44c4573beaa6cd04a1d1d0b9328366b990e7a2302825f1109b88f02012fd1c9bd143cf768d808d2f9b3d10be3968f6d737489ca9918eba3f5d9f7663bc0a7c961d00caa79a4756900392f0f424654d760221533dfe8d35e80cc42c8a9accdbe8f644b83bca978834ef2e2961a99d34eca2f773e67d0c0b8dea1ba6944198a655ad995de4a43eb5baff410f15a6e802a3b249664d41f4a4701de63ca9b516907b02de6405ce966e6be15c3188fb8d6a52c68649a13f5cae29609ca12dd8c36a150bd4ac54845fc4f86c727dd94ae0758138d35011587735dc743927d32e755e9c0017290cd6478fff246312f323d1fdebc3c8e2e31ccf2796997b0442765d1e7bb15258c78b1d510d66185bd8250944c5afa0c787dc7c0b11a5dc53d0480eba9c5ef50f9537a99120268524897a817ad7b4b44b5ef6b2ba9bff873414139e8b6333df51c7ba8cf1abf7271fc5493c3fea35db787e61acc0f8664d46553db7a5035eb057cc621a8e4759780a308306de8239fff5f45c0be3d2441b6ceab19fdc0bae795944de629333cc7122e66f526865a1d61c2cc07c5c085a07cbe8a0f0d73833bb8f31896c1aa745599e20be4d870aa461199d3bd80d3a3756fdca25cfd624c317555a1dc31863b97ea50409e30216e73b0e34ff791518274a9c2b064f1cd5fb6b2089a31a0fa31934437c3ba04223d96cdc59642946d51e7cfbbc513664284130ce1ebaf4d19500a21c94b838c4b6fcd18251ffebcd39c52c6f4cc913ac54f596950b88031b971f458946ea9ab67dfeec62046fe80042d9eb2b2c8df52ca5ef07585948d394b5415517b471280880a5a1ca877608d199e75922f6435d64851087ebcc500b963f2c8776b8db5e77e6b208d941f122682bb496babcd4841c0ca8e2d9668fe44db86253c6490698713d4ef3e2f979393be9f4e51f5fc3faa1bff8a02bb3c354142cb52eca481b7cf50ad92b50716cf6fbbed00104dddb93e232b397442d9887b9f54d6150c45adbe460e39e03be0829ae53ad6424c11d3758ccb36c6d1714f6df916339b5bacdae02512796bcbbd688c2ad8288a08bdf0a181584af39a0ea53fdb5b0bd748684b6e105347b5cb1e1ad61bd24687f35f2d31cccef965e363ed7183b1a22f2851b6015675ce5f723fbb489f9b99e36a58568850a2fb8f05a8cabcfc19484f84c0799ea90e484267e17e33859cd4f0f448c84f128d8d71d82c5b97bd27c8995ef88946ddc106cf970e8d51fd9e9cea30c8716f5f9b85bc0b7947a68e402f3415215d6d466718be2fb6ae9612764ee4dbdc5fa07464c97e4a5e3e502f4b1e675f77511e970e80698fb7226982a7cf7858167c75bce0d22ff1df30f614993b5c4d13cf4972ce2277822546ee832f990b3e053b51b4bc124763e8d672d88b69fcbeb764ab9b57a31fb708553d39933138b06de580d00fe26c2f51ef89b15c8f37df205ac2306d748a23aad593f7893cf6e4347e821424a02c6a730fef1d63843f94ea62968e9348f6caa47b7d43080c39d9eea78bce9b933dc0ac0b7cb7937c652b414340c4bd777bbe4338360a26b01fe2944f3a41f1362b167865eca39858704e28f383fac433261dbf393bd7960918132f8157f674c538790df297c2ff6060a26c860a46495d05cbcde8421ec10ab8398dfccab1e5aa0963c588d8044ab053ed00d789bb97393d4fefa7570a0b4f8d2dd2c50c1455fd632f275385e53071d44166c028c6c0f876e294b3c6519d73150ee036ac366c09bafb16111fdb4c503a4f8c66bd69b84634b4d1b6294f7c8cb0d5f88a86d7ab5900429d2002b0467e0a0f74d83ae00bf7453917f01622ff83e2fde65add4c054a1d4bef216681b5d8e364a892cbf9d205ff4ffe5f1e0c44e935e4f5b50eb7bcda5742410bb1ffce28fe4b62aaebd5e463d7a2928c80b6e08f6efea02ac3cf02a74c9b95fca25a064d823a0ce5f5b4850793b1c957d593f23a9c09ed80cbb4b0ebe6e1813bc52edf2b3bb7c1f20458127162309c9bcd4fe3c213989029f73d3b7b92eff41d00860c89581e7abae4acb62dad21fe7c3bf1c1ad8bdbdfc86153ab8d25b8e3d96cd959cb1c629d8198a584e70e9c6e095e5a3a75ddaa022b951a689aa32cf5b7752b671f0ceee5e9b3b2eb0c4c19be3ca305d5ea3acc817baf90a9fc4bce739be4c54269587ca06e5a0870addf86834431bd5321eaf109228503c389ead999247d9952fe4d702c2e2baf7a0cc2b12d1c8acf2db5467a0b76fe9bcd8fa05e2cbc9047d8264b4d9396aeb921f0125d62aa16ee1470474a3d85c2b31f4b17f981673a6f8b81ec8da3c8a4a5db9fb584256e5cb5b9381a65d2d5a0698275606d5e8f8feafbb71f65868c3af9647f308baf665b7da62ca4d6bbd2ba30d9578fdbbe9f730326f5388ea72e25e86595d389dcecf33fd134dd0b4ece900bde8d08ca59235ab16a62ac080b9f9b5199a4a022bacfeac6f6ed5dd6961559e1eb815c552190e328cc777f9b82cf384c00ae39ee55d712b72cbb57a1a5710aa9f1a1679270cf23188fa4c4ea4389a0cf795ce3c33e8a975c48403eeeae84ca01f605b1f36d34c4b7bff9dc4fa5051b1fc86c44a9158630acc56418e51eb1b43d87d8fc6d69e7dee06a2a25347767fc3a8c947ab1255e8e51be05830cf54e2bc5a1517a826f066ceae09d1d4469c85145a5b64395bef52cd1c3588574a9c4706d47962712ab05c3a3628a04cdd6190f930fe4fd41594f48026f17514e4b12df5cdebeb4f1f934fe0d87f33e2b90448379ac4e36602eb4b8a563c3252ff30e3e735dfee03a66ea074e464ea2de3589dbcb3c93fb87f61253ccdb40434e551edd10da20b845920654004ef3775efa3afa877df9fb59b91a1e21a92328816843d45cece6d613cd63095919963e4542a1ad555eaee380efa9e7dc8c4c2bf8825b1dc2224fc7c0f3ea026668a853f2453597a5de07d7288b92233c1f01438b55724f828e454ecd742dc07b78141f619697fc3b8d6987b9b2bcaca9a58718738152881a481fbffaaafe8c03ac8e494a1c1719995bfee4be84931d3727aab409c2ea784eee124e91594496a12128e312e0f686d09ab111b9d8d58fb02c3b1aeb5bf288350c872ecc14c02406b2d3d089451f362dd91f5baece9893c5380703812326c0876c5e854efac0b4448c325ffe2ace304ea42ca1f8f30bf63cca6c52c475275bce0defbf7e23150f5db7cbd022cf4e02d869ce74e96bc694c107a4104c573e4f8a12dfcb0f0a428a37cbbdbe1540798f0eeeaea795d2b4417b464726ddb55fa7b3212fd022fb045bda9ba454a2ed59027a4c2e783a272e032612af820533c9c268fdfdcc4aa0e27cb176ded4255634c27ef57ad80ddef082668a3f1e2c60cab5ff997080fb5b1f750c7c06f259050d915193e891ebd8ea04b6cc993910d637e27ed8dbbc2262d89fbfc30405714f72e92bcf441c7d9cc5fc991cf176b6cb19600264c4119dd644f9596d44ecd322289717d33c13482297544138c56de8ff63357dc526a92facedac95af56023b0fbb7c403d5b551892b6f84f170a1c4b634762945c6dfb32bf815ede4fa0cf81cfe1b1bcf82d5440da1e26294580bf3585369bf0c6c335e20179741f96bea8f930b4cf531589c64ed2c660e569cf7906ce32bb66b1360dffb8f8e2b7bdea4231578de448eb2c50c305c3528c3b38bf27697c20dbf21df59dda2e9a7eacbad8201f3c9916aa402efefb75d4041a8dc8d2b729fba587c9b61565d8b142b221dd5b74be0930790d1d4ee9337140ce8d3cc23fe662462a3caa2b47146732886a9e40fe1a42155a6aa3fe1837330614310f0bcbfbed0ffeee799ff423309fa233982ebfe395eacbfb06cc48a3c4565831ba3651889eca51b95d741d4c70896a1635c2ca77d3c6110240ac6751fbc70516c9ab074225705be8ca5cf7205c88719117456dc8f2b911d49b4062b74cc6d3347cf5e6242891e37cfd09b99b850591c40120469a7fe69bc7cae7593fcf72826816b4065594c44b8c902170b55a1c6c7d8d1b1eef60faf680e488f8783d10ed9d8393b9007a07c60aaeabae99cab8f7b7ca8359065f84c1d4717f3bc75fc06df7fbb939d044b0faa845b769869c35925d516505c0a773e9671fadc32c53809c0e39bcada7d74f74fe821b28c4b8e24e7c307678212f7195fbd10e4ae6d751a582d330aba1241eb7fbb5f4db20730b8dbda0aaf31f286b25453ba1637c7eea85a4b24f4b4bf7e1040e097f3e64d5ba63032f63a5b5b7d1982d5c927cd2c7121d36771778f88d683f4982d5186469a7c626a666af3f22436f6f58a3f493641380adb81f92b618e53006766d70aa7908e0dde10be64809927e29ba498e9828cc9ed16b546e5f8a0cd6c89768b3b3219933fb07c1d9b630077bb54b0023b2081a7d507db7f1b28c550d74f43b4e04f233c28d091588e361b9ba3cbac56bb195b92068717fa191b9bbf217f211a3349f79f081a8af8eaa5fdf6c7d5b01fb13e66b19b81d01d7308e28fba4435555cb00d8888a12ce0899d0f6afd33cc7efcffc62a46602d9a77c990b9a6fbf20a3a63d0fa3e60716f2a82b838afc3e9c8ddd8d911f2aa939b12d09c3469cac9cbae8909dd382ddcffa74ae752c8f66e3658c92ca8d811206a940877936e6a601c8590020e77ce6450d4a9d084bf50b28de01bd66c7cfdd575ed8f51cca090152d00698e21125c65472fbe2c9b4f9419cbf71599a233420613e123b93fddc74f071c17f88a345e5cf371dcf9ef11e71cdfbb490d7f64668e05ccf4219668a87db5d37910656af8e896f70a57a231a59df131f33d4510b0ca2940c7ab482122fd95c5bb443e26c26459a2d7cac046c167acce8013456463fd8413d2ca1c48a6a86649e35ec398b6653f57dcc5ee493c35aacbdf37e868e5c31411de6058e2440f9ac72b102557a9323bdff24fdca888ed5cc484734dec217bb9ddf4cc20d13a8efd16cb93f68ce03c972ad1ca70de36a653e720cc3fa914588a5ca6d06b6905aa9065e4a1537385ac90c20707e7fcc6869228ad9e49f5de749c08c2ccec6172e89b2e71d8e0fc3c524c846f564170dd73a7f349eed998c5d041627abf623f1d80f8fe9ebb33b44070453831403c8aabb8acf46fb9400b29dc543a1f1be4da335715d90d05c2d87de59fce00bfb98b5e520b1fccfecc6e30c179cfe339a60ea31130bc06a5acfec90b48bc67ae131619eddd3a681d57f7e21f317080bcb46690b6e66e6d530819989c3a9269af4e6e1d519ef16bccaee4ac9e55af321e04a1396c8a347e0140f64e0fe5fe010b41f1f63b6c45f2876b41d93aefa92220df5cd58ff9649b0005348084d6701a956db2c1214225859108e6735a8acee9adb2096342a4ba04b5538a3ebef43a1a2fdf0f4e5a2b9fbefb7fbb35274d44adf1bc92eb7d94a3f920d0bc8346cf2ccfb4e3206af502efd65468bf1ae36551d9996bdc804624d3e6635916c0e46a1f60dc23064f6252706c6a9f7538f68a1fd6e74cd3f8d11cb32c878f2d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
