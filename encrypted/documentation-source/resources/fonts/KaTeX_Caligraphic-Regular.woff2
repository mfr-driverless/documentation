<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbb9024c627b99fca3e362219830b8e95255306147e656966871e9dfc6249650f7b51f262a6a52848433ac04b8df61df626684b9720268532e3bdab263841ffee8c48a381fc32698c28a1d8658b7e5f644bfcfb29510abb6ac05a836a24ac0541924152bf8e4359d4da00d151ac7bbc2b43e3cc074ec99c5e646e90ecc10f37cfd707fdbb5083191cd66ce0187cf0aa1ce8458f6c50070beaeedffcaf4d578ed1ae8b32d691c48c14771207ec5a62b1cf67a41fa582bf689e36997b46feeba9f85ecc49b814faac840eb89513006d95c913eae51d49438b5323ec2d56fea74f33cb8a79113ab349e041345b7e0c6526c16e31e01c4330610ef7734fbdb4b9c0dceee3420315f2b132f01c14c8d9c1fb492e4e2b3570d7db70c672edf076a16026a5a44bae41e2d0d90215bcf940f7cbb74fe7c89efd6a78dfca2eda6ead29307c79ae854dd4422595f88b54035efd62f91eb4b7f07f5466c5014b58e16f4d8281d22caefa3bf4b11970421d5076cf0c69741fa49b10910d429fc0212ffc1deb17f4694d766b83b69c88ed70f47747adbae94df554383189657da5feebc48e5345c051c65a8bf46098dbe8e56cf598d0fbc24a2db70e312454bfc2c364a1e4a55eba8ba441bbb753fad699e61e88e08a1dd5b6b45e162e27a3bdc54387501e9c61a7894e1176dff8f1ee92392f7c16c243ca9b2da04f0039648f048d644ead27a4d66cef333f5bb0c100ddd3c5c32daeed01d93cf65ac933d79152265e8e2498a8595e0929e246d79209c77871119b503f13c03cc60848d654150291c46456a9ffc3cde33be8dbc4bc945a90180735aeb7bbe3d3f9ad4e83f8541291bb3eb120907944b6c5dd8dac8479a76804cefa825668812c166657053fd2fb06cce5da8aa850ec3783e5b88b5e649fbde3637ed552dbd1f999dcd6e9c3c2d40f6e0d5a843852adc46006c90c0a2661f17bff728405637a6fd9e77de35d2882757d549319faa522aa0d9d91670e030ac863b55209d8d1b4008043dc88d3800854e15c4a9e0eeef6f1acc44e0d5970e4892109f58e3defb95786c727b270dda05ba326aec625731b0ab8dc70e9e6e30755bd8ffd68e0309048591b8ab73cee4203168d9ec5b67fc1f19ab85eccbf65816132b8fb0794e1642c57e556fcc65ed60ede5c731876c2b2e3cbf2ada9e29c1fd82dd9715b2a6e1d40841399e952c6ecb79c5cfc954f39738da78d47d3666078e9f3588f4ebfd8690ff7000990f3ebd55f11f2d90c5ba8e9492eee796b5b54dd5c6cf005c3617520489587fd028b58710bfb431376fcf71fe0947c7d2a3846ada7f08842f86de883332cfae98de8c323af6d1bf70c51b336d10bcd94d15cd9ee69a2a53a7a52e56efbe2cc715448b045f796773d251655b6628464d9fb116c18c24d6c3b0b82c2b3b3d60d4e66e9a1805a0d6f55e7f32ae2ec6f56ed6e49b31dafb5c03d8c45281d91980c4a7032d6982e229953bb5441b7955b0d9a8fb292c2e2cd0aee7c90392f07341b2e21088bea7d8752ea09fa63942086e7160d79e38fe87e9f195db5e1e97ca8cbb8327d12c13268771929c1e19f58f618c7b364f6ba20246cea9b20eebb35cdfe535f74dc5684711d529eb15c7a87b8918e325375fd5aa8c148b97a412af00cd593e94550e34d02a233922a8976145bbd6083bd702e6d486bb95d8d518f0396f494721e44cf572ca1577f70ebe13686be7caf6fde6a67c26c6e8049719d84bb46cd9b3444e48f77382e24e8acc051abc923fa5594a8c8898fc784d5f98ce36cc9d3613343ee82cd68dc48d9f0e45d298451841ff496a6c500fd5494ebc46343b597d9603a8fffd3abf97bb218f91c0a1b4f76845e56a98642b7d01ec7a489e11ce0a077bc25ab19f4f017fc72f63ab0ac30a00033aaab6c298e04af76c44e4220c5d075a20990ca1d288862efdad1f8a4f6ef7a713dbace572726cb33b4b87dc949ac488aeb4f4593c809bc15f50afa082792161baad80245cb4e68ac037e379a857265c5b31a7e9decbf9ebdc8d9d35cb9b396f4e9418735eab539bc55813cdbfd8924f6b9921cb65b5b30a4e10981571afe8e82a9e4558ab7f8fd3bd9e2a1d619982babc62afea8e95b140da65b351784c47c901a17f7de5ef99dd2a13318f0c54c5f3b81b744433cbafc1ec20ef9a7e24add62c27b7fa8ea907e72b0df3fa4351aa29aa81352327e8ece19c65d389311c27f0626c92ddd06397d3b0a3d6f37250973bb25736a6995948f8f8b1559da3bc76590d21960668f1091d4a095054aeb907b972c655038a84372e0f01b34918d8e29d965d0a202384d7a69f2b051c38e3b7a66d569fd39fac803ef5b6449a3bae27cba720b6ddabd1be01c4113cf2a3b7eeaec85ed675c68cf1113b2ecfbad766d43f62e2f3ce8a0ce88cb0731441b96c1e9de35d66a607ff0c32414b8ce7c6c81df437fd1977bf1795fcefc91d74e5530de28be47e70fd023e0c8df5edb3f5542db0803224c465a3353d199f39dd8bff501388d942c988b71b4e5953e1516634fe77d682eb32e0cf887192349bfbfb0437d2f46ab62514f66e5a0476dc25fcc640d64e14fcce573733aa45dffef9f1f32b731541650c4cd0e071cbc29b6f4706d1582e28baa65f97f4f60683b9098925ad1d07f1919c4d31d2d9711b8197428d8074c02a75d586afb88959c4142073a8367c7fed5ebb37ac74bb53e58ee1a48648f96f87878e0459ca49100715ad3b5af90fedd13c9ca6a3857c57149e1e9e5843aa729e5043c5bce69405f4f50d19ee76bda26fdb888d51329f911a4409893d43c94d1a643866e60d461b57e57a55764e5c1ea85acd651947620c3f792f6207ad3d76fafdc13b279f70fe3a952a56742c1b967abf145e4e62467a4f63250b09db9eab8f0bd0cd9c810b994f5d42cecc0ec43309d13c9b557251e97a19f012e261472d80de6c0832f2fa03eb14a2b4808270afc4fa55fce9c56cee18e00dd1c988173891cb7d2123b3b6287814b19ecb878c423acb2f81f7c2f3c317ffff2b4177dd33414819637b861a1c1f5d47e2bd60ae1445b34d248c44c92b23d06999e99a7e644332ec1f0491fefa2c382ff7875ca6070cd04097d01300503ceb73008dc2a968d1afd4d4526a0b183922b06add82dbde19fedce8ce3f95c43c6b0e3bed7340668420db6b552a434d2df2285a6cc65db015eef15b738665393299d1d6a5ce14a37d462b511bb7b70c8ed4d5a9599578a25e3b83a9c0c611fa846875c4c0deaf5da51acded5c0354d6db1355af2cbe55c86607304e78dbaa591f5b26475d9782adb4e3f4280a81e0e097f52bf0ab4bbb3b7221fa0de258effaa3787049a378a3eeb5250a38e832f12f65c97a572369ea73532d98b07daead6a96dbf3f7b1d4976a14f47d0e256939e86e6aa7a356486c74c88a6464129f9df06257160c1d8e9ca7c3cc3d5932deae4a2fd655e461a1d2ccaf954b3098201ac48c49b014d39f0d9c2869487315b8e3fb46755d5fe78eef30192fd847162282a5b2f041b6c6ff115e1d722b3aca2eb5c611771c61f2bcb3fbb61d2d280b81b808e8c6adef148cde63f4ef23bb072487ca96c2ecb1f9e3ba8a02d55765d5c6be4ee349d6d20b1f8a42364d0a07d5ee1be1528c3d0474b15aea9d1b71a8ab37c764551a8f3e454e18d7d3ce2bcc73d722c9b2fa6a3ee5609c5e2143d12588a7ee5856f303b97634a999e52a3983d8af9b363db584c4d749e3275fdbb7e024c3d1f224491d1a417a58c421f9dd1b73557ff1a2f355ef591ca49eb1e9e45884c2abba0abd52b11bae32412875284fc639734aed61f66b61ca5292e3b5682b51573a49f377b478c42c71350ddcd6e8f5d8ae171b1bdf94e716b1d2dd75730eca20cee208ad48573f4f18093222968e34fa9d05306f3c13436488a164cb142d639dac1c3aa924f644187801865f36ccb59531d909e62568b84dcc4f0c40ff6ed64412fe2336b842627aad8f499bcf644a7cdc699e7ad835f667e8791646145855f12bebf96d6645bc2db653f6effa252efd134bea5207846ab9750d908e2623be51cd33ea10e921a1f86567527d6a64751bade7005bd7f8e191c80eecd8291e4cc0ad48b198ec0cff5809544a97772f0cc14eb6f2ea57f9e4de9e8f1e14f45965c3c97e1007a81700fbc3cf888f7f1bc8e28377bdb107bef78939ccdd7b9d40447bf6d008c635a67f90f3833c4c8c8e7938709fd949c38a63617705ebc91ebc20b59bb78ebd4856eb4656382192702e008c869fdff000743c1d302e1fec77ebfc6827a6d6fc1e8025a4bc4966387072d5533ccd8cdc3b53c069f5045305f3e4a4b595cb295228b608341dc519ea41779bea71a70e8ea754f964bc2188644ef7d0ecf2b39bd769a18d803d97b7bce7ed502db1f422e695e81b0e102735768c587750327effa9a6374b43501b4fb9440399d332890d96d91aaa3b3b162fccaa35bef31e5258cd86cd69b34e3d8d04791b22da5c4b2551d842120525ef940ac4210fa11c93306e9fdff1aef84db4dc0f32427693fc44b601c66c72e47d9ebf7dee023c9a56fa8e3b4b72faf82ee33f3b677963a9458358ce19aa97f7fe2be4504c132bec9cda29b505e18ebb53e46733ecdb860ae9a35f19baa3004a07822ea3ae3cdfaed016968e3d2fc4ec9440396ead4907847eb836abdf5353df5c9371f0942ff3f72a52002157a0366bc2183bb4b9f3befc17dbed1cff3defe6ed43411a210d3942d0c5fefac62bbe184f7743da13fe4fc0b407f3692c790430e53da7c263ef4ab47a600450a811f28b1e0bdfefc9f2b7f705d3f8956494f12dcc2e40458c1196fc37a6b5fd798f14889b1e0772012a3f89e16a07cb92e511f8f25badd9990e7c53274ddc8515d9d30990b9053528089cd934c16410d8691e954deec2bf3b8c522ea59f3af9133b8759bfe2a475198d27bf7dae293ef38ede900e3e94a59af22443889efe944c05841a099c01967bf2b8633defdfbaf74b37f49ec767463b0079a37e829d2620ca81a914128537f9c9b651d1782780942eebaad0d3534169b678927ebbad95721db78a63835ac2564ecf564f4e1ff17e20e0ded58fc7d17eb1258880b1cec8030ef27ab436322e97779245c97624b6a9a43f553aa1f11aecd5ca9051ae3d238ad96ccbbdbafdd97ad657121bef4e30fc969a28cd17890190ee982c5264925085af2bc5ff1d6f25f0c724cabf2e512dcc98d76eb6f950b3c6c604eab35c501e8779844afaa793b7da53f52b5cad7d6882ec7e4fc4807b6f889a1aca76ae64116b15dc98b5861b9d9bbcee18b1ab0d28ac5d9cd174bf8f18b76ac1faa10b52cb8675c36fb8ea9c89667dd3e82468c7b7f89f9d988d05ae1012e79a2f28c5f601fb475f4c527f2dc56363542f310499e58ee0e3f0646f0ff5ea32acb102e4ca9005eed58be8aa777cb5a5f4be7135174b27b55212d128af5ce06a8809422b405fa56c719fdaee0373d953bb7a5b0eda17f9c750d8608ee725807f377990b961b5875cc77d70e9db7d84cb8c3539e6d312ea49bfbcf497ee31a5182c7c292a833f4a3da28da9190180573efb7e10903dcc9a5aecce239f9c187833b5ad3e32fb6e0ae982d5fb9c9e740b2a7b025342cc72b41380925382f91057398d83d9dd8abc67e42db44cf7a2bf69b745b5d83f6fd5fb00e2a1570c37e5390db20be145a18edd5ee00d4d8288b10997ea9495e27e08ef5d5f93d4cb6cbe34050960a4bbe034a3e57dc13aef58842e3ddb0f4a8fbab1f0018ad7dbf5b190553d1aeb6e77771798625c848f1aa784ea6dfc69a5aa4e60fd6bb081794d289e2c0f57292d06f1e0d9ecf9a3b459ffa34d35110974b50d57ff156d0002129192c487aa3b15913fe4c220100865808dc5ac7352e5e4461827791dc8150073ec69fabf91f6664bcd6794da546dfd967dbce6e561720c7bd7cd60027441c97c6ff19c33204c5baed64d5b14b500e3255e712d1ac5a8882b9e127ddc71718d4970c1d87ccef664c459c51a106ecfa0d7d9796c191f28e825642208c7178f86c89eaedf9139ebbf9065f1e81b1720ae6ed0a1558857ebf12982f3a2ada77a11194f0eb6a5d36407b0f58eb818d8b178cf0a878dd25a831ef8ef3c6f746d554bc95d5999d726248ca4c11e71ecf77e507e445888962102c644b54d2ac7440791d3617da5e3d30f8102a524b2202704da2e5e278c2d2f2ddbd64d9f9d702fe4a445abfd08753fa87550caad33d7d3822b31f4845996643d74e7725208e7e48332f883304751d2fbf6e4d95fc11b84d8ee30c9ca84efb0e88affaf1d296cf7ec85bdf35cb0afcb648c4a4e211976890f91a2cf67a4fda0a92f05d33db03306c5b33d5e543a647ac6be34a57288dcd7290b603b1d70db11dcfa38a5cf6fdf1060d187b46b89d6934d751f2e742835f33459c85f9cd133b78a4f2620e7e558f7a3c66e45f9b882991f391d75323159d10f94297c1633d42c39c97901d843534bdb97dd6435fe9eb4c5ce9397564897db29265a0bb8b1ed682c7be91b58cce91d86b1b390b889cb7ecdae459c4ec8ce84b124aa0f71eef72f94bc4d47cb8f0a2cd6152aeb86ae7530cd9960e39769bff50c830d2f08857e145290c0b959afeac6c259d055736bdb3784d200d68d6e536fc39d6d0cfa74a2a14aea78374a6b447bcb31ccd67c389906a85f8c322ba4a08012fefb7e9ad50cd956eadddec75fbf25d62823d39491306d18af43b8ac24f076d67cabd37732df16d2b1f8b769c435dffd6683c49ebcfc4c2b15d2aa562e0ca4adbcceb8d95ea60a5179254fb834cf89a234d262c806ef65806e59f3ec38cb2cbeff60ab9ed49b3a1e7cb9a5a7679f8baca7676cafc808699cf59825a6b8a2ae8e465a033f606622d8003c2f80b6656dc4a95e4b3a46cb52677a0821ba5dd4000736be4d9f46ea86a75a36880d3b0ff1c6f015b85bb69abdb0807bf6e17540e047ae6ab7300324cf83ba014f0f1390455a5129d7c834672ddb6018d15b1c194859f67e5f37873c8f58cfebfb2ee7c966b55d7c746db3222d720eeb5b852a7d7593b3d497ecdac0d76bf32b8f431470559e1328ab6208d2599dcaa79c8f9f9c5f2de8aeb9daed230b4c44f253fc8282b80966317d83fae913b30658320ec95e549922be55484014741260e08379d6a41342728a0a7a07d36462c22fb2d0e47a36cd60f31dffe2b7ef7712c098719ebab4c49c092ae7c6036299e565e4555be03af79816db5ea7d3babf92bd3ae79f5c4a837d6dbf3209108c1199c09412f2b644ede7c35a5b7ebb69e79c0a15428160c6d653ac335af7b1534c4db3593e88577ac8267ac336574c4e3b2b0a00b92645032b7febf414f028bb877d6774cd5d2f5a6e82f1936baa2bbe7df0ae33c7637e6142b86e38b49d9f933c2cb1ef510da203986d428c68996521c919b623eb0e014f5e438d2c5a071fdf87abcc7ccbf4d18b3ac09ce56325aabeece831f58b86dbb230d4c02d0a6b52ac7b75322a749b4bf2fd246727fc7f6618c11f7f2d6f5206fcfbe8d6071ed3c26fda2290fa3da3a513b535ebb64f4dfbc92cbb78df26e2a67f619da98c9b45984ee7e9cc11545e1eefd15f1baceea37b798d3a6440212f2505eb89977561ba8c83fbb030214890109097fb6d260706e4783d2f24f5490d86b68b5a88d597cae56026224e5b83c2e386cbd7f264385fb1d702524f98981487da4bffbd060b752b1518a9801340006a13d51694702567cfe39786afd884cd0c73ecac0dfa490e2a5827f6a88b092f77b99144527f4eff88fbddece103f04d0aaabf34ee0faec0e809d0e39d623b5aedfc5eddf9324602696bbb3ba689b9b0f9ca7dd6969faefd1084883892d061ffb8b9311ffb1f0fead6dc34eae98320a1925b351bebb2519cabb259d003be793f6184dc91a9dc95be006ddb3edb73f6d8abfd41b43370255ad957e49aff3bed368a6dfece5e66a5b98700ea71dd508aecc888d755e38474022c1d4a1723c0b72a78d45befa39fa7ad781860f86d5ba0e7702a0a7d61f70daacf74cb5873259dad195c1fd1f352cab125ab7008d67abd8a226cd0808afa11c6e6c8a5879d97d2dbe8662ff404f252dff055bc804122a2a2b9550e15252b293f56bbb654a26a2f86014d7915ce6fd370b4dd08750cd90293ac2f7092714258968c9964ac707ff279fbd3613bf74feb5fdabd245d9e550fe8d3650dd44c21910b0a4127972468a2a54f33fa0340501b89a558b5dbc75d2cd0387fe5678e28a895a87cb2163bdad77cd6921a3411c799a5ed318d993f73e83a4ed5c3d98a61c5fd6c88b76381afd74b5d66716b63d6545549f2fcff9de2e523580fb2d046c28a1984b979f77175b37d62f24d8e27e6131b13a397016c9098b44c7ef1e198e761d8dd5e25fcfff76669f6177ac28bae60fc1fdf203360cebfb9b1a3cc11a373d379564c04935f22997ff4193989aaf55fb8053b962c44c7471483b16a69fc2e4c0b63da2348881cc0ea4968b42e8a21813e8d7eff78889f13f2a884faf7eb8e905f7797d411e711bb9d531b1e8d3637d06e76ac9d5c2b52190a093ba1a440af834bdf359d510559d2f5e24b1d73088091c5dcbc8616004c4f4c0043dce0cd33285d0ddeaeee61d7d4bbedf5cf91d63239a833685513f0a48be562782527afdbb09a102088682265f5f5e5b65a254fba3ff562877ba7df028483247d6788faf0e2d0095b3f365d98162508ec54414754f4ec283d8bfd1af047c1bd9ad1e5f10a0a30354372c1b5374d2c7751dc5dbb21719d797b4d17448519228ced7b34693750639cd274a2f5d8b5579f4655dd71e941d1df7b20d762151d7efa3335dfae4021d08ec7556a8855ef1d2953aa402b48c58b122dd2121e247fc9a346d85d3fc80d8fc68471d0d8aa2a49daae56ef4975481d4be20595c348fa90f4c52271a1c7bd6ffb3a953c326971c9d878da728441b35f5a585f634c7ec4c1343e33221f0cb8370357c59183852ffecb92b8f22b09da2c324612e56373680dab725680e32d0e9c14c420d4418c1c80be2afef95e62509c27fc887f9af2093f2c395b94c3d61bfc82d249944bac377a65210b9ca6828f7cee8fbf256b4b64b7a7777c0957ac333c719b15487a903a58059061ebd2411bf1c67f7666cc4990896a043680045d2a315f4bbb694e075c4bc7f4ce8588c3b0795a0eb6b1be4f7be2d4e5069617ce2d4b4cab5581b4b72b4e8e6255e44c52375040c07a75cdad101d1f85cd8b8b8f624ad067f87670ed62bf9eccb12e2282cbda52c8ce4aadefb0d3b76a61a5e839dbc6cfc0db157e27131bdcb08857083df1c124a494ada14c637c648079388299fdd725a9d09889c8e6fa2e426ab75c7465a682bca6d642a47fb3a1e7fe767cead578b6031010cce0a67ee99bba1137163845eab3919092363640574ff8e27c4f744cbc573f3558b5c2442b0420dece61d93e72d86c4862af1027371a41ff2f5211f02138643fd316907b62ce1c24d9e6b6aa7477bef4ff0587aedde3e61721f66434ee8507c35344ac745f64199d2cda8736ee6f17abf006337c8fba650b25ec0da549b33b9a43a09cf009c6310fa9e9a46265344197a90ce2e099a489fd558aae5228abd9347fe62b2ef798c4cf0b4c4dfe4c2cff0e62818094241dddf10cd03958ecefe74645478115d0cbea63527492496d05f3d924bb68d8f65f0c622baa6cb48ff2db76977c1fd962b60968c7be4b4b35e14d752ea713435670e1b490d3bd8610fe31355d4c7b33de31e942c65cbab399f5d36a2001e2c8d9f568fd27eb9d2845f94891726c11c2e6842ae60309be6ec7673c69361adf1b902c94021b689567a301b3b1f6f93a4259c3b081de95f392f730c2bc523e17354f25d8200d54f9fa009c38e428f9d0069f63164cb2c2feee2646c4f647861c21e6f21479dfb1086fe573326fa14dfeacff66e080403c41f83573c2fb4fa9c6fe179d4d1da6dd529dfeb68bf976028b8b41089d4c95476de7d9546f18bdcfe3e1265a56826e316f71cceab0b0cafffa70a46134330a786b2770ee0ad75b69a3c504dfec889d6f2f3f1cdeeb6003afe2fe1aa196727af6056a32555e89eeb3d37321e976be38a4b2cce0cad1441f20690b8ae5f9462ef13eb8ea3fafcc4cb4cc4b0ddbd6ee3b35c8c0b4f26de6218bf4d149de0f117a207680e575f02ebc72e8f4b21d9152ed2cf7e56dc114ae2e471f1b15c13407ddc33167d4f897462ad49da25703dbbe4713c4854e91de5d1633426de10cf8766cb749743e35932357f5474f2faede9a31b73facb4e1dea46bdc6e692b1933aeda0aa565ae3cccb12910b6cb0b5b27c6e49579cca55db50406f20a483065261eee62336aab3bde2b9c7c22e89c1952056363f68d4b44c91a2c00b671301fc8ede3d18643dc654114270e3acc4acafbdd69f36ebb83af6b1aef97f21e76a08c5e5e2e6443a18bbba442f1d5afda96e4896ad0821fbb3da4455bac573dbff463dfcf5111f1683821152336acd175ace224ddb123c97e7eabc1bfd7227d66b372c05657b8065fc33682eece1b615f4ac82e4e24f76967b3b81c23cc8b3aa00c5d133744fc7065b66eaa2d043709e17bc0cd78061608187167997892c7feac5158bbcc4a35ea426fbcec54e7427a0b7236a03c64e60aabacfd61c3ee8d6a59334e08fbbb42680a5f3c888bc7ff734a3e4ed00c31dcf21f1f4be95eae2feef315ae04975f7c2572ec44dfa590ce453805a1757af71f431777d86cd4aff71291bd70fc48f7df5da7586b5f203379957384597a678bf14e494072a548e996a8dbf347ba1f32215447fd52d058e58af6859e7bddc267bd07dfe541c4bfe219f16277f2e13029cc9298a6cefcbfd53317cb711271f55d623077f70b5dfafb07a3e419f69049afe27efadbb68c25ed732a6a36e34e8c20810f5891b62ec0548366cf315194b1eecd24f4cc387a3bcdf10d98b945291597c85df030188b95d7eb7b62a2404bdb041a7d097fb3218ed61081c9d3de258b95325eac3beaf367d530992c5cf4164eac9b0170e70b58e8351b8387992efbdbc5be547b44bb553343d0dea021bd81cb9f1f8dfff6720d0d594af8a3e0aceeda186a4f306bfab37a70a0e9c0aa3fc83d64cf359b783d9676eb17a4165f3663e8502794885e03417b1fd35af1a91530718664606cb6f7d9e62c90ce6550081ddf7edfbf1c8f7bb0e6c06d6d2bebdd75f98102481dcf0981a462c4d2fe630ea9fa65b68b6cbb40c277b852107b585bd0254fe3f6611f5e4def91b22bbef1f437ad9ce44bd8adec37129033d74fdcf616bc7fd1912af0d925097ae7d991cecb8b48fe4e5f06341e953066ac549e774326ad932016c173bb6593f68277f3a63917a0ba67a31d86bad407f7dd469c96fc91e57ef6fd09cfe86e1fe93d80bfb972bb1da7f1252f8c358d30e5e12ce4bafab7d0f8cf6deed7b4660e24ebae59b04088ef75f535b480699e9d51ca4d5b450ae8532afe35421c945bdd223b81e73ea25f062f3d574ff8c2b1b55488e894259a93cd1b1e7661da85cbffb3fdec69a61d02e8fe7a5e32dd7e15a460793862ff38b4cfc193c3fbb7e17852f6b2f115458740a56a0f32ea19b677d94b4c4765cecff71143367b48f0295e939b6ba057c1a6ac0c12fd89f7de33dad4ca07baa02e12f6aabbd128f7a008f509e922deacf5645e2f922140989a29fb2bed9375c16a008953227a42eafe0068447eebaf0721e4de94d1d6dafed523a01ac4d3afcd4b8d8d78228e9413f8e460719218b459dd28d9007af5645f42106b368d8dcfc3d661be187a294328b6ce2a653ef58a9499abe04e1cfc8b044ea21af16b362b5439eee80e56e8e7441994ace1ff0bd6081e8e6824315319cfd7142094101ec6f337681269eb3cdb2e8a349e2112579cade6836e4395c83194850a4d3ae98b0318fa1d8a46efb197985c68590974d05260aec4336e28a5cb66c1156ad47e61d0cf693c3a2efc271f7641c9bf362f1647486282a5c33ed755a023df5ca262e7ba85bf20ca26060b54bf519f6f404b0eb644e937d00506df0d07d3524913c05966294ee56ce586d6a6fd486b3d04175e7c95fdea0770d504c305314ea1963eca20891d5abd86c24d97b2c1fae7b1430c53eb5c0c686631ec491197adc512f818f339d4c5925fcd6997bbe29008ec493fd01927e46b03b39b45374eac8e0ec00fadc823406f158373c7ae8282dcfe6717f3106d60645661c5755e9551d80412233b0d286c548d4201b4b6c52ac460490a981d3bf8f252130185de362c29fa28bc4c70d1f3ee5eaca8a8e3b6b170f9c178828134345b0b97c6fd64bc9b9276537bbef95fcab47ee87a8a5932bd67ca4e7b3211bace6970eb023f0f333f8d0a044abe50da160c22e43ec28418f87770b97d13484895f7ce18bebd7370001f6a681526e31a1db9ab5a8c087c92d83a50fef07b884489023610509279b72018cfb08564ce1d598e570d8843c7fe7f2065f5b19861f4384f14844bab8215c693bfc345c205ad353c3a0121a427505713d01a519dd20e05256b589ff413dda3de4400bb90a9ac62287c031d7f725f0c06844a0d66ea51e357c3ba37b98cf19ef1f8ad01e9ea6fdc6358ab7d11b323f391370bbeb0fe0125821a53ede9322616537f34a8979bd2834b4b4828674e1be63cfbcb9b2b9d994317a98745870d6a19b5884fba14c3f4de37362c9c1aa0a65511ee5d9aa362e39c8a5e030263c2e2001c1b70866b2929cf51fd4c5a518de3d3c74c85caa15d9f0d6fe317048d8b6fe232bf7b3208523ee58fe16d5f24154f32e9055ce0f31e41ab05c339d3c275a5fdec6e8e12f6008921be68b7462c014c7d00337a6a0dd0e5738b3ae5448d2da0a6e575cde7e4ae455ff0e2f445a5584cce61f19babba65873124f3d5324ffbf1799d43e17edf35470d0e71c9cb82657cc2522f93b0f7667af24da75c95fe7498b3ef29142f8a34c01c38b295f40b2f9ce0206cab7b22338167c27fb07e37e7616d76c92c395a3dd3f023df8202f5c096afe8013fc102e6eb618434379fcf055e8ecc87be30e71a06ff3086be9f3c63ce7cc4b2cc26c3ef9b0b2dd2db28aed642e62f61f91ee565a4e38e8973a33556152bb8d7f6af6991075692bb64105f94a0068d4e4bf103fde5f16c082612897b60716b910acd0751463e33daa367c5d20b53a17523d77be29cc7207b54009c125fd5a1f3e340317c8e25807fecf72e9cd2e01b552e26372c201146402b99f34defda953b18803478e9c38a16212e3745cf2cc9dd90d229861dda3d1b7cba645fb1e032ac95690545dcc74a1ae8c80bdf327144060282150e59fccee7844316970bac2d6ad498c59f9dd8edeb2131a6a7b1eb2375c5f6e86b4e602a2357c70bbcf254679553f323faea6abf21a18bdf1bb75e1c6de84d5f1c6ea7f9a476146991f6af65b32a79465f60deee5b30e24ea9fb08849960c18b7d59f82a0d819e28e5dbbe22499d553d98aa90d9270c0c328d5ecc4e9534b3a0455a5337b8dd559a9fc3b60853e8d89d53a50583847fc6abcf9a638658dc86b8ad2e4225c9fa8087bc8bee7849dd12b653c2e52c7ea214e263c7ffbe8f8ae6608f296a224482224dafc717df58658dd81f3e64915cde2ea23db0fe791a7714849e5e87723d2323aa897e69b157fa261c66721f604d86545ca280c7a706e5f0e2108d04ba80effaf49ce55f123b9d0d45a9ebb9e6a7f73dc0c3286a571ca83982484b9268e073fbbc916744784a9138bc77493d0a7591bfdae64503f4c25f5919ae7fe92899ad27d55a77c92273e0f5da6f444bc8a5b823e3cd82f2caee3da4893d1769bf9c2da1652bb2e43cf16ccdf25758b4e4b1df06c588d171b1cf5b47848b4ffd709a39d33d2fd4f6b1235fd79a8eb2229da05d124d99fc894737db2116ded7076dfc88992ecfe9f5cb9c99cb43fe82326563602a47befd78542b10186caf35f23965f939c1443ac320726607930ae1f989d7effdc86d69aca1a808a160f69aa9def6638756bdc07d1968d431ec9b1d71b1bc2b5107a6d3e882a8d34d32dde6ad4e192bf21c078965fb5692439777014c898bf0f645516c3c63195e734255a0672a008a0e1ef07a264aeab8393c6ff07f3ad2bff65c42f79ccce9ad062019486f86bdd27d6896d2edfb1c3bc01eb4eb53fca74c0004cd8488efd3c8066bee9086ca62045870c0f623bf11110ab0c4b514585add60b39f67342c8bd925cd6b15ada821e4316679dc506b47980145f8457903846c793b8b91b1bcb80cc5b6dcd18b0d7fca7ab8011e0da3272fd78e24c4d4ab95f367fc7ad095d247ea62bd708c57e057ca7921506d95fd204e6310e9c623f33ff07fca7172593abe9b8f05b3ee1f7aa0c98225a06c64d2e1664140dd4f7229b73b0ca74042affab62a4817fe1441bc629c564f0270923cef065618311f2b9652145cee9cc755e465e62d9bb27d37380488239e425fa67dab3c08214e7b8874e16f05b110344b212b6cd905909ce73a62716011bac62f4abeebb793a5759ffb4b7bd07dcfd2baa70af6c3abc8a9f543086f4dd3ba8cea3bb14b6136889d53068b635d490fd412e848d254bd60d333a378e993660c991da899497bc74dbc60dca68664ab143d07bf9e37bfdfb1c49131b4364b07485d12ce8eb6541770bf38b8319f85b5ae76d1f533d55f4b2748a94450167099ff39bb49e2f1e42cdea42d549d5f6c14d60c408af8beb8816ae6f026fd6f8935dc982e3093fd0a17716bf16be59c997e4ee5313c6f201c35529ccc2185c0ca9b101548aafd3b3eba8462e74b3fcf87d4a6613aa2234242a7e21a6852f49cecf527c45f523268e753495c0ede23487fc7fa0f8b6cc8af6c955cd998fde2d8d6d1e8d143bbe61890a8fa7a5981a591ef2e6848c6ab1a53d07da8e8906df9e6dc3f3b6feb7df5ff5a85e1fb0a7f744969f1e8f9e108725d0de42a1114143ed3fccfd9c146e788a59db4dcf39f9744d41364eed00467ef027fee2b64346923704ab0843e97215bee3598985d585988170ff02fc92da54ac6da6e03ea853a232a4c70685ad78397be29160cfac906d074616207f25efb2da0fc2c82904b36bf7318b8870000278df42adb3d9dcfa5ab283bfa99609eccdcf05b8f98b138ad32d2fc14c2d1443bede66a7b09e35062578bb387e82ee89e534fe781e86f22532d612ce258235fc5635e52049d4b88ac3de09a4ccce06ac81d50c8865004625919999d6dce242e8ea82157940499188801589cbfc51ddafd113480d08171a7ac8e614e7473fe7504e5aea8a8f72cd30f83518f5d6c209ee7683ec1218f54ddce9635ef2dbd1f81e93ddf7ce7ae9ebdf2a09c760249968f0a1847d8b0b260bb013925060a7d9d9ed763973acf557276f850526b7892a1c62466cad3a4f3900222bd098498e62e29d554f39471c5bed41157f51938d4b2ea1f920de2aec78465b29eb9bcf5d208b45d1f761ad0134d9ac43127de1f3a85a732fb5199efac5721898f7e1e488e59f1589928e6d39de7f78554341791df2a9fcbe9c7a906d61637a37d581d43f44357f0699a1d7ffab11caaa44c3b3fc8c4a99dcf854735ac61dfd1cb472a9d52c6fef5cbb14ae636bfd83ca617b78460156ca7741523108741df38b90bc9208f37acd508203d00d4380c32e514516cba0be0c51c6cad791ec25a305f215d30d2b6adefb4cb63bc4d75aedccca34b51f867ef110a5d2731db7274ca63fce196315ff822e6d2f7bf18cbe4fdec7934cc0dff7b39b5698b6c0586b0e3d75ea56a446c0ba337319bddecefff725e2e8b06e830f975bbcf4b5d2a4b380e80ae33d13fc6cfc337279df0b3a0117aa5c6725df971e1dd7d38dd8313aed312bf27b64641c20d8c9eec0fe370333179017cb183ae35dadc1775f091f0e8035e1bda6608c53e5dd8f1de2560d8e16c82064c18b7bb983e0a153d23a158377456d637bc44aa310084272ca67c5f866a7b0b1cfc8959d13485242fb5516c02a6cbfadf60e148a34cef2dea3cc724133c8df649ccc7dbc2ddfd46cb26347c7ab719ecdc0bdd0550e35c5055eca5679682ade89acce36f4f790bfd64b525d954f26a0e47ff28ebd9204251eca364f4c7910f45a266a2243c817ace83e4db5d8b1c0cacbf4f3601c930acf0e15bf55c3cea16ac0d768902b2d83f06f75bb3d49d5c9b04c6dbbf5487c979e9c0fa482c374de9702745c104710d88ee089570ed650eedc6e117b9b39c69853a4d4f3f62d9d6f6bad4e3f1cde9f102324b14de3a989742dce11431ae20b5733526d4e7a089f66250666ae3c330b92eccbe664c41f7087b6344b415de3f5019c4b0ecfcb6a86884f1688859803b400a008ee1bdcd30f63057c5c7e74bf44a17c5131c9fcf51b18f58037977f92950ea538c460c55a1c3ae20645f6ce8a0da906da2cbfcc773925a4033ed61f6032aceb56801c01fdce6517169d3a48131944901c7c8ab8804f2035c65b325f8ab2fc01abcab10dcacf292f1480783bea01ef38138dd2e088c0cbbcc019fa4156211614cd543fcce90ba7eda4202244fc18afa3de8d381d7016a01a46e656c2919360b1bab4ea6f6edae2b9dddaa6e9dcf6b2b8a6e0c2b73875777c4073d549d467f01d8cdd36799a066b00478357187b52d6b28c46129abd079b7ceecb490a68935ae6dce289a946cdec35af27e88abf0b1320cd1402200549951321d1ca8e7032015bb813537336a9115738c6267b3f7ac7662cc2a9f0f08b6e18a29541633c039689d4ec0ad5b2cf52a61b83fb6206744e28c2edb8d4c863e8981816bce105558d8552f9803f4cbf1c1259ac1062ec0ba2d0fc0612490e4c74ee855512295f7fba6be599e9b21b2bdc4c75d8dd20237bb92e1eeb4c3ce1f841539947f82982ab2523f230c338b97533ca0bce75fd974067a51e39035dd43bfcc1ff6d8c4c5d6d8ea23dd748038e71f646beca9fa0a77a3ef11f53926961e48d9c5c1634edd888aa13fa563b460a85af2801daee6f11f5c5c068e0473eb2666f15085c49203017c33bae4d4f59459db8a185777d218e89b95d6f852dcdae7e232721a35899ba7c0797ef1842cf1e1e6d5e991f534c9134e38050b73a89001c98ed03e0ea24d0a3b89d2e3c951ce816f08ee31bbae7f4688414d019b68e6f0bf63031b13ed6394fe42584219931ab45a51757a9a55a6aa24ebc6e84349ff08d3fc66b2fac1ae115c78bfc32ab258b5b8d8d684f3363239084c8ceeac84a486d3b535355693be66f57b536b9fa29aa488543231c66770211f4ba2514319d23446250350be9270b509e69b394831fcdd4558191d99ab545aa165a28c054bc81e2ec4303d5d8793fa8a1e2797fdc9e1c1f8592a0d999a12c90f8c2cb1594c0be4296ec90049a4b276c663a122a8ca21fb4b9ea92c43f93519ebb82be45798f961bdaa50505fdfbb7a5073f32189c4e24e152fd65a9a6eabc5496a1d2f5b46349c908bcb6704b2e162054e9b1e9a60509e6546801225bfb72159065668c0d081c29ea1823b3279934db5f0d0f72c4274ec6366c2c798e8eefd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
