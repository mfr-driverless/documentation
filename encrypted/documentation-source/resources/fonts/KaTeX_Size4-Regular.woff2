<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8a158c8327906e45c06eb06a7de0198c5f934717362553609fafd1c1a173e086b319b7deb32e37aaf3085a74768d90fc47848e67e0a1f42e444224754a2b896529e40b3cb019382b314d43958b3109d7e439b7068fe5c3071ba249505548f075f9ed44767a24568fa8fa692e744946a2266f6a159247711104c3faa8e1e9a49c40c1bd7fc1070c2c1dc26770cc4c135bb5e04c8689b474a642610575f72dc9aaef19ebf6f6cac9dbff9d4bb7ecd1ca1b9946e72753a5fa84f150a30c7c77e39d490819b3120e19a25cfc6504377ce6c19acc6f56321a57e52c483b641426c7ea51628c59b548904572dba59519b2ed0d6cfb1cf211344645fbccaf8a34c3f11276b8f2e8ef0675c94f4838e48db82e4d22e665b93b17446feed1d64649825b65ce6bbeb21c2d629ba9abb69ad2f5e5a38965eea62d9fd76cb25afaac8975a795f2fc1c85f7b881fedb772f7ee5879fe6f9cdb7be738f7e5997e1501d86751e675cdf5909de0eab3c6b1138b426b0e7385af1b8719d6bfd0070d510eb270b30aa5c14733701392b13f17091c9d608b3c8d88cdd9218e062311fe8585a6ee319bee2a0f0c15dec9ca1341f031717a2ad2600270ca9ea2c5ee3f3cc556c08fa5c56cb92a21264774e932556f1e1c078fdd0c65707042768420954a5ad8d0eacbcb4f665842fd698e28cc2250361e50b3da4c37123a1c1341e3179af22665c6901f60148562f370e9ecc9550cec50acfc7a747757ebc9957eed96ad94b453e8c2320f793f21611c2619a66601dbf63b671b4076609901ac427419553e07823d6dea1b802f7ccbffecfb629666ab6b0a426c11bf147fe31cb15552a8ed25966dd4c76c0bfd9df3110966cb5fe79683989639a88f655cd37a60ae34ec5d65c75aa94538e8f216aea191bfbc5796d2a1a1e3eddfa9c8467b598d45b9951dcd4f2ab5a9d054c2bdb8f94fa31cdcb6ab93b03438d5a5d40cab7021f6098a13be5aaf328dda0eac9e5ec74f93e51e0d86391dc194214095293c6b40210ea0fcab71324216e905db22d68a0a77639955f3ff6c88525a8ee6632beddfdb818726dfb631e01b4b2e1376238a431d314d2e757e9a083be032456c80128f9e9bd9b7f8720cc5d7de5a0ac8b712498d72960f2f15eb1a0481f00c27ddcb3ba7b4d01d77b9b16e0b34e7f9f11e8ed0c182951ce68e00a84afc2707df36b5dce1d74aca71bb0900f50a23447579e2cd3727a5e698f1fa5f4f15f903885aa963c1848bbefe0db8c6146fb8f6522103c1d2495b67b11cce8c111d5296205588a92c6856d218195fb831692e4820998d1df8ef0beab90d676da9fbab8e25bc12d6a6c464116aee41183733c151d9873027f680ef51f271e65e65a3fe0041ef9d85dcffe543b9757576c19a647c72986872baea39c96b0cfa828529d1e497700c93ce0aaa7068a4300f4e7d76b82b467e11c1168b63081a5a8c829bd3541c0396faaab734ad157306324c8ec60442845636bff1e0c5894279cae313270f0d3b4b1d52bc25fce8b67c3a6fb50d7fc88af6c2d5dfc721f5a7e836c1df25e73088a6fd0fa3df49edfbacc3451ab67925fbd80c1f742955327e58984f075545dd487f6880d53d8cd39893a8e724c7c5e582a9a20ca7de6acbe43a8e6c11704829dd6a2594584c97d633ded78a01e6fdc6670f4575c609dc0f421c529049e78ee3434d7d2264b277f4337d3351dbd2d7d5d2f4ef90a8998aa591ec81b4b02410eed38c83815b09b88268f269d28d1788ce42b9977ee0cf7f99770ae7ea1bde0f8220a8a856ede7ff1bd1453f5e182b9dd7f11408c2f419e165e831eb2b2aa6a60a0af96c901b98b882490ecb732a55079cf5714ceffd9a6366bbd5bd21c7c10439ba80411f8b717eb80ae91b5c793c77cd532233b18f57abd953204aa04457faf7a8d70b04c69607a279c242e9a5caba1d967a423931667ed9e6b540c095c80945da7da9b0987aebd280793ba0d38788b967429d1691325c96da3243c30d10766a9b92d749b7cadde925a0943a0a0b37f5060e65b86180efdd7978eca1054e4bddecd91b64690f51296bc04d123414668fc841b65c2911e49ad9ceee603b16f157bd3c09f4fe7efd1b477e138aaf23f0c4ed3c39f28588cc4061f0f4ca38e954323420c5fbb574060737bd00d4c350ebd08051865c9228c4bbd85d1ba3385d211b3ef35c6269c0313ad84616b6faaaf45d77dd0e850202637fcc11bf7329c6816a46c4bbd3a96e264f85701b58740e6340d767a263dddfb54ce6ca5e865e12d816b84c0270f293c07ae08f8eed4841bf65aac311946a08cbb46df704e3cc6de10e91ac399d5cc45d38c6a2ab827914bcb2096fedd7f426edc88c00c4499d5abdb50a94d54262a02706df6387bb86f8f49ec7c9de34f57daf8578b7fe6bcc47b6cb807b444b71757f2062b2f03f190b65f6916dfbf9339fa5a9744b556b44c030f36aa21d71a8d07d9cfa6d20052e327e17904e67be0e3666661f1996bc16a7c76e656eb59fa5c5741a7c0853dde39d2dd4b71956cff6778a57793887e4ffea97080e5bd914336036b4129e7658525e15a64b8b5c0dbaac51ed57abad448d5894503154ea7b9372050183c5e707e064e9e3600b81a353290d115d4b542c112dd6f06251649bbb1924141b77ca17b549d914c14894a29b55098275022c6e6ba46821162b0564568270b231d61d679374235d70ac55357cb3cc44d9573f4552aa7b0009effaf18c2da61f9421159dd86df9004a9bc307b052856134a11cff988450fe8e9b0421882a321564e39d0450555692281d05b9a431b7e52412ca1f162b78902b5e0505658bbfd24d2e5e88164808e3067fbfe97368b994a28ce4f0f4f37bad41be99549fa968bf5045596dfaae87bfa165bdddf6f84402844a04bfc7f8c5e5b3df576351192cff9e49cf36b332e954da1a94672c115b08d2ed44bedad2398e74493f227c8f5d6c8b5925a3514b3959f2d635564284b9ef21f31a6a458840a25692e843055bf0ebff971d288a01109eec26d68f0f97993cbc8602d0ec7f3b32239462817a442d430f982477cc01ddc2826a24897cebfccc1d19838196ed12a7d5db22c54cb0058104644131c737a059956980c1fd8c92e585ec3e6b3eb275a2337c1f515e6d0cc8ebeffc08f0802dcd81656678b8db4679f4a1b1edb3e2a5309971886028f5a8545c50720e2ad1c492bf189dae948bf23330f733e0bef7aa01ec18c7b57589c75f11071602335b1637ac2834e791c5d79e1e77081daf2819b285fd855a53bdeb0224c302e034900d403557db1ca89d86a481534a171e5c6742092805b7fd8a6580a5dd9c6b565cc3817e07bc6ff7596f1de361129ddb9d78a4aa5a4aeb2a7e64dc51944278ab199fbb92f4da5a8978dd570f86caf46116bffd248f6cc9bea630d95cc232cc4292a5209789996b493c9020c974395503dc6cac5d58799b945cf12502dfe79893958f3ea523292df5cbc2a7adfdc672f1c371d24fbe25690f407e99bb90d3e3bf7c5bef034064841b07e7ac2ba6d62702bcbab6da73e9aa57007c6149d756b01b724e62e42be03e7b73fde0ddd1e92e2e601b70da3d116621862f6928119aa844c1af3d126af9681e3e963d4e17a72ecb487af0e211bb1955fc2422c75690f07554c95891bc908b436cf56c863bff9c358954376b3a9b689b3118b316baa8f63e5f184e337e903b1012e2a82f5c7b10d2988aa7e98bb408157ad046b2700df053129f505b118fd8aba2e053253227e333e87de58938cbe77bbf8237d524ccd74a0b654e4759e6bb27b305bac145f07d6a30f7e7882d2ac88ac2dfa9225867c3f706eaee070c32043ae28349a5460f027554fcc73b7b1b185ad6db7e73c62311b58464fe627c5cc5e17ccb9dbba06d6c2ba7cf3a8122bed4878a7d9592dee9e622039087c7998f762bbdaef67877d6db7be1e831b4eda2986962e0f20c425da7569e00c7a84f3867b346855fcd7246b4269839f0f577f2e588befdbe922c9bfdc058f8e32edbab36e6566a03f3d36dca33ee2c06164575f34bd9243e0fb66d35336b36e1b04bc5052132afca3b10b83acf08bfef896d022277c99eeb51eb46f523958533291195e481047c024aa8345a03e08bceaf0e14cfe607cb9cf85f46fd1d0029c64385b09808779dbf57b5701c6a293dcbc99abbaf626018b93c0b66239f777293888bd5c68f21880f02b3946cad056b067a127765acc3e29a39b8e7f741289540e0053bec6c1fc05c3e4c2bd81551c4b8a41b21023f0068e4943b3a8fa1821750545821e3966d58d8906b9fb7c9afff67a7ffe04bd6b46b782ff1c77b486d1a68729c1af9b07b05f1990eef7f5ee80a38a38eb42629f5f7632fb1a9e316f75ff4616a9e034a95713e6bf20506a1efb7cb44ce7c5770cad6a8feb5e12d5ac76cb8646cba363c6c18cf522c9babf25f5788d18aa42f8719c5ae3188a8e3e8f66c806ef788a79db59d462942e5c3f0e239b007a6995dbb7d50f615e740d5dcbc656596a1e6b5fe63109fb3c493aae042320ab8b841a8bb0045f6533f25f14c953af13748a2f911e07ade26987df5b544ff4501993f2e7efc566a4fa60f7b11053ca9cb72ec47af2e89d982599c4532ba836365466ea541eb3d6422854e5f9bb3610e4961e3eb6a69b98c874a57959274c41665a321957373b4b47f7f40895ed751447f21e10fa4cff066a6b13122f5fc864a8e467777595cc45a51f0f7cbc159ab2375ff03f2fb56b73ba03478ba4ea62deeb78a8596015de3320fe0321abafefc275f15a7372c079cee282f2dcc906dd664e5f42b325cef4b7dfb78f479e2b239fb569911ebb6ebb437f51a8e4f27a3854baf94e86cad97f3708367558ac0b1467a0f56feb6a72eaaee822f56e00f7e23266563835491daf23942dd7e8f70cd24582deb1ea7b0440ab97c2b0ec1903cdd7dd48d3bc3eb408037f394b02b8dd5ebae0365d467c04ef1408cf8c9f93a5058e567faa9d161883f769993b1fd02001ad777cfdab65eb4c3aa9a75d41fd4b663bcae1a390aa074894e2241f88c2851984f23df0d40b870363e683818aa03f7dcbc0b4c83b99e663d910534a370a03fdd4ab7bc355ccd83fbaf3e581fcdb184d42b0297be0b1e27d6ef67ff928decfcc2a2c2f1ff0b7a6e27a7eb4d558a1bcf65e5a18cfb50d4853e6bfaa7bd385300fe4cd985069e75f609f6fa27f980a351d1be5ca30d9e4582277b464aa1a6500de3109b56b6c45359719701faf01ae42d3ea6fdc93d6b6d3b1a53240b3eba4c54589391c1950340b40ba410398751be06cda3c5f3e8ed95021c1a6d0beba27d771e8d93fac40da911b9f9f51de6cbebd43ad8c16ef5afa68fe74ebcae9a3275b0a463cca70dbe7da2de4bba6485ff645568ae4e8aa2343f90012844cd16684bfa19b8a95fa5c35aa70645a71cc7e37301ed2a0b6b35199db2885034959dd271133ce0d053f279d385a4d4044d22e0745596914ea9a4385ab1d726ed61e19cb8fd8145223ca9bf46462b5ac4571a6f15b4bcbe3c0d211af901aeb999d8eea45fe209bc96d402892068c65fb1a2ca48706e520387c8d573e88cf77896b689dd09749c2a0a3bde432055c7ac222a235f994722aa7132e7f0fe16b68fd4a1b579605d60537e61c99553ee9f8b6d6486f3e4cb9844f1494a8f06a28b60a18d47a48370c4b2d854e9ab16b745bf40c6e553c8b3b50f56d1ae483c566aefccfbfafe16762ce62abcd64c8c9f973d997b114b2cad99e9f74fa24be32c9bcb7ce3c20cf7794fb175a06c400b02276784e6cb726e890732bfca8d430a2d12f6f62f08b1d3dc4f8d1a0de66df2360304485293cb449ec343fe20aacacab85493cc035e87b5a7215962010feb5798d844af4aa65edcf847f90863da47df7a2ec426b7e2825946d2805764db2532c5d32d3c1e965c8d83fbe5f4bbad289747ccb71b5a0e2eb34747c756346a4ae8d0a520c2f7b68cdfb58bfa8ad84de07bff042d0ecc40047a837b456710b9c9d5ae06c177c8034ff07da8718946ab5c1d5f230719e656a101d511739f1c52563905e517ecf9654a34d95aa3ba775de105b6e77ca5d6b9cbc72ee3fe1da7471cd14665073bec69fe7af886f53e7eb35d73efaba0d23b3d6bf7ea51c3094d4465c9d7314c9fa5e2c002678460193f1b1fe28c5523d84be427e7be7c8b8dcfa70aad283172a87ec5e2e3c39997117e74da8ceb320b6595a47f8dbb43dc5e738d5d54bdf63ad72340acc3a3bec3987ef981d23c51d7aae12a34daad3f85200f3810d054b4db1e9bf17423e98eeabe179fa219540d3a99a1ab6404211e0052548c7704ec7485f4acf2c944a3d894d96a7891ef1727a7f7214708408f2e2b59f4e4c3d99646f592e61be109cd886308b008d55315077349717ce99c3f85b179a7909e837a78c3b0e5ddc292f023a4a3a26077b2f97e3b5c1bb8dd27da13fed02711eac7de7f02b0c06d573acf1893ce956a51597a5250e43741ee046ec725b663661e9c462386429dff47ee3e1bbbc9961c6bdebfd4bbd7ded74bc4f65e5a1080ba3731e506d7ca21934cca8ccb1a169724acc7a728e0d7f8ec9d38ea5d5d9d2183c5200d14af28d7cf662e7212ee7a8a72ac31066671bc878ae5d49dc842a244b2da344c6aa6ef39d5541a2ac9e2230df184cacaf13302f38a54a14c881031531331917e7a4c64c2ddfb875ff5f6f0e56534adb9be9a496c9755d0abe2bfead99db3f30ec16793a9a9bd503dd8a2318eb69d34b4ab9b43ec889d2d5fb0b9a07c73f847c8c1ac5c2cf0dd4cc3cb8c01f544f47fb6a607350e6abd9cea7cee5b71dcc273aaf7df8a30964a3744e2a45569cd7c58150eb15667dc6fae2c42ff20b089f9ae4be0c8cf191a434fb2dbe8c270ffc03e33df8e62d68e5d5060fdeccbad4f9ba3e166e46d9b78461abe6087178f1f6224deea402afe1d303a1f643ebfe11a5c0385070057e25f596112cdaac2d2da99281521ca8025a79575430b5e2329f0492abf42cba58e6f5d496cc9d5be9a222a7ac019f3ed1f0f1b1aca6c0bab9b9be2ef16a800cff4e33ddbf5902f6fa82e1c4d74a12675632823f6274414c8a98c05c499da1e2d8f9892532b1480e967e18fa454fb957e80588ec8c730949717f5156460dfeb57e3553a735fa066201814a846d4aa7c8a52a885b55e43e36882943d29edcaec7044e4a537c743908b5e0fadf10642f29b87fa79624deb263d51fe7dfab49d66b25ac6d5cb76b62fc1ff1c8b84483f4b38dd0f1a9968d07587cd8b4009da32d7077ec67ebfceb5915e7ea19f02f391cf5a1928408ae41c524e4044814ed43b29349aa523d22d8a7f97f873d3ea6830656c8c3bad35fed478110c5073f5db112d1bb73f3c1b053ac4b3c9d0f6b387ab03be24fc487b047acdebf5ae39a928b5ccf55449a2857fcc9422f65f758a06d940cee942ed87bf940302a575aa2c305fa3d7dcb7dce509eae690d4325467276c436d30d277a7b1799a003ed1816203cdaded0277491b16fdadf37bc2f4926c6a39847b13ab77b0a46b9156f5914fe52b35f65a72e0a9b8c9742c9836c58b76fd629c0969b9e514723f6abe27d3024b001e09c6a2c7d63b8f86f048f1a545e57af7e9d423c02c3474a9d86f95c971b9bae80980e2b667be62eb43362ee870586332979025c0e4f45a61c35b02f7089e952f5b2a946ae6f0fc22c93826e117fe00c721bb1520e1d878cfaafb56d05f09aa5301104b64421194ac67894ebf4c0ee6bd9388e5f55ecdf36d9678151587c5c57d89bd51a4b83c39a6ed9edb5d8e64639c7a4d0b00e861abf3224061d988a0c4d9507cf0febed071103e47a79b16e842eda4849fd83da529a6d2cad49d185e64528d63fc55a21826a5295e818248a61a9140ef8fa0b2f5c7367da6ddea8a082c3a048c1681245811009bd3005e56fd38bc5fa007f1d9c16d6e529f81b3cceeed02b895b3e76f0cc6772b00dd65666eff05070ac374cc6982cb0b14448e4c8f12e9bb669e316ddc5170053064cca4d94bcb11c6539694543389ed4837bb32206d1dd2e8932bce6ca2ff95f61a82ab3f6801ae353de8d3a5933f75d04326394f85c6b3b88e1a20f10d5763a7f6cdec58c629342f37d5e0e712401cb088067d22a86da790b60371748c6c45b445b2fe77edf5108ffa64b5c58a38c669a8b5abeaedeeaeed995881e527a9a3f2a2d04c1f9ba93e346dd51b438559456e826b2480aa9ba40e6b55df5d162da1a4d92233c8601634d5cef9c6f0af06a2e62e164430e68f946f28289c34d5db6724a4e7d211ca2cd90bfe2b91a0244ecfe45cd1d81af5f9b9da445f4b487b94ba5fa1c3dda23a9f96d5480e6c1a792f0efcd303ff129f54210eba216900374fd806f63d9c6a5e8358a1c2ab9339a8d317d2149e4fc0acf23e1b8f0b10c54cbc3e0a380ba8be3a9cfc7fcd0a66c2b58da64f0a498bdacb9aa3fd34e3ce3f8a836826f89352f4ad00d0d6335a2728f0ac47e1d07e2f8c398ee6025b8c26c471befc71637610918bbdfaf0e1162ec2c61fb0894d7192f390c8eccff0bf661569177e74fdd71962eff1868c3be8cc0ad4bf65efd47ef77f81bb590c852e50cd067255a450c7c4496026d6fee0efa75e826a788d8a903afd6a878b1e41a0f07e3f34620be7befc3ebd3822c4dc0396d5efdaea4401adfe72a2990c74ef607b9f5c07354c77f01ef4247c15103fc7ccb2034edc504f9193f7fde096005ef535f0ee298f832a3e1bd7c3434d584e2df9419089bf133eb281de928c79c2be03057a562220215fdd336fefc9c9ccf1bdf8c701de59a6d8d7e0ade6bbf0be72c3526d721af05c43a18e5e22d7c0ed035b623b00d5e2af02d8464a6a6e6ca2d4ad76aabbd993995387ad7e44a7cb4e40d9f8f5b7de98a1915fb13e48ffe8809dc9c645896f5c3dff310a1bbf1af683241b75ff8df40791aa3677cc2ef79c5d12ccb82ba49c3499937fa08d5cdf1c14e105de6315f63fcb18470b8d3c9274c652662f8928eef7f3f3ea14329480027c47ec30d3cff7bbe43c6bceaf8ed902dc92f247dd85b5dd23a548e40e9e696564c3860125f67bec1043f5361f6ddd183d723c30acf1c4a5fa28ab549b0f959b1da7abaa2a38703ce18ed723e8e869664d2b3fd3af37dc6c26c7a680cf9436fb84996355e2eabdfba94ab1ff9b625a54ba9321814535ff59b0fbfb0b1d0b2f32ec86c2f5edf1d7da744e8aeb9486dfa9363441f410b0546835e7ab470addf8606f50065c33bdce52bbfca4d2cf28affdb92e53faa2759a188bcad00c37dd48a1a30266f7c871131cebae203349aef276bc6f84302dbd99bde6b675d3a435426098171bf209b3bea87b637214863b9ceb1b15b12dda3ff64046dfe4a77ce7ffd1662741dd8821722ac0d61b8228f1b6035fe88f076e23b97c8f16ec88cc0f2355a458cd112760be64334ca4c6ee131f398176cefab3f273e287f9b8fb92f6360eb44ac78cfd37eb03074fe6fa56a1585c73ceb19364f5b7ad5879b51415394e12e9d8e53b4d075b5bcc481452f0c5ae73cb462203f28fecdad90c4ace34f8af24096f7958f898bf26d6f4e5046731f44d1f21f1a3329003aa3d6ccc58f00108fc4652b2d01658be200fafefd52b12a02fde3d1de491d51f72af55eff13cf0bdaffc56a96e4726b46e4ee1b74201ff33af54ac9b2dfca25e6beba3601c2d662e945fa7e014957beca398987987571eb1996c8c637ee6fd1b921f2a979b06ee0162d3f6e0c8e1d5e068133956a233b7467dc84186e8b4461c1c84982e3263635780024496d2a25a007dc6ce40330d4afaeb72468ed98904e37a4c35ec8335758de909aba6c18a5a0295ae69f23c93fbe288a514f20580f758793d87171aad0f6d883ac3d4cd3cffafeb008f0f77e8f5274da8cac0ebc2c3966bbce40241aad1011828a027b866c94bb4fce7b663aca3c95854658eaf140dcf4d7045c3f9670cf151f0531ddb2a3a6e6fc422c4a9314b513c10a41a8ad39116e40bab5af65383714ef0d36c13425fce92ff68179d5443a1c0cba59b9d23a2c78534a715fc198e75e27cee53d84b26fb90beb5128cb00ccdb2d8d41b9f2fa3f600ecaac2ff918d5db30bdaaff08a1a4ff98448947c31248620b26bb4d1fc8a96c45bbd3f21389ec02f926a7dff8f426ddd42d815411991eca09072f6bd19f9fff13e70bd93d5228bcd3f11321ca9ec354612653b021a16d42f4b3f869223905dbfb1a025f31fbcdbcba9ff7161064214692f0b9ba190f7f824da7b94d97e1e3c7a46690c4254442d4550d2d2ca00d6fcb5b5398adf13f9dc3b414fefa151c00686f1266cb8036262d5ab593fbed879e80c945b1eae054513c7e1263913846b6cc8ab6f23fe1d2a9d794f54029b30c67284ba4e3203e6b37ec66beebeaa17795cd187f37c88a9ab553708bbc936919b64e801551c01ccd380bc38197cc467034024d66063bdeddbeaadb78d631e4fa825208dbaca0c35f4572069eec6fec147d125f85c3e47c33ca3992822c94689eddb53f61b61c865ac64f671e3e2b0e93f36f13c40a9c0cd5c014cc621140190a0a6f39a239406f36fd125e86f758a9a8ceeb52bdcdc65ed1e22c7571e522dcde77c694cd85856d6e8f76e794a0adab6d65cbccc1453c0b515515a4424f848c00c516ad55e96bd05bee899bccc70314aefb3ae3c15e5c49ecd4b063e8f8860e4b08cfda74f9082eff37cf7bd5da94733869327f0c42a1289363c8eb84df506e026b38a8cc4733bab67d22911af9518e652f4263aaf3c694d122cfe5ceb6c14e636e3d8ae6efdca8481acdf4194071901fec8359da405739adbc67aa867be84a23359aec2ff6a4aec7d0be6a52af6c476456ec6ed60411619ecccf601d4300f2fb94d99553cdccd4583aa742280c463d00c87980f721d3a3e31e8d322df274a06e388bcc592dfebfe8147a5bb1484131af0c321f68ff5e36904c8b524d68f1c906b969787f266289cb0a6861e11bb163d196e6277a2869441789309aa15f8910e0a0e813b69eedc94c9a01c27652038774f5a456f2e505274307c0f00ee751c29ca44dfff7d30b380ca544da6d4f06d7b7937e9dec801170fc64ce55ac6d0653349c258dad1a415869cf989f58b45a0c8b61eb4d7b2dbd7a3fda636603f1247e4653cb0b5fb1c7d7dc828cb4c6f1f56ab25dfc750174bbac3de752dc2b99eddac8a6da06b2a4ddfc31c139de7731a571a29dc7eed54e17d33a3fdeee31eef4ebd21dacb3ad83b3b7d9fdaf6a6791bcacf49f1143559893d0de7d34ab388f8f2ed26c82e4c6b975a1b17e4c61d0f982bfc43555b054d1070a9c011e5880bfb3ae4ff40bf4b64cb6ecc8f440ee4c4304f1a29d613e44d840fc49db3c87511074774b7dbe377dc5cf08a8e2250158b1259b923790d0327064e07a6951c60cf7b1f50915ae79b574fad659d3232a163447e509fc58d1b30fc7c6f988ffd8d4bd61f55cb798245c6f93a6f347f3d8c914775f4fe9d182b2bad4aa7450df1b54ed06e7b195bdabbf656574632deeb4b475d283b837ed07d4a25c0d173ead93527d6e0d1cf6dbee484267bff3b9ce4aa63cfd09823ee639c4d890d667e7abc59f199d1cab6c9151442d61b3dac55277440a5c4a8f1211486555760423bc34d591a812e7fb9c2859caf9d9d27655daaf97f8f74c2e16144938032d85841245f015efd9fd0feb8f6dbb3f6f98da5b249b1e11c13ab3b57540c8bf444a3e798e9456f86f1eaf8ba78fe5591774022d5bf2321688a4ece9c80db2db2a2594d6d618e7d00a08be05461a2a623b5502a3c44d784a5c5913f99b450eeb6558b76120ee38de67fb6aec82f0c155caf52ae500d7233dc4c59f7c3468d72da76768d34106d56ee982f373a988da4af19d727b84b5c69b1f0f85f2aa74b5eb148b9f6368982c31f6670676a755463cf564fb8e0a65c860cfc23623517551d7428225d4d1acd4a3c33a3ff2ce083417849f0a1f30c69985fac3d602a88a27abbc16ff7465d005e1fa03a7ecf6e415d6065d8c13da37a345c180eae2ec5d441ce08067b33a77428e20563830c4bfb67cecf8ee964fb2a99b7cae2bb7d13a5044ad683bc7258c3330884129b4a912d4783a147dff808cd727999f6fe4c59a4356dd9744e4280ae814a7fdeb98dfe769407976432e2963caad3a3e3f722b50db32a25ac23fa70cf3f079b70b18b4d3a4243d4651f28794209d12d3607655bef9d2b9e12e22521aa1a2b2d9b35e34524b03db94c8332e441512aba7345df81b86ead8312f019c966f3e911c69d0ceb5cef75a9405eab6352668db4ea1f97a1efe25db3161bbc0f5f2e7ece56941835df39dae7380625985b9de8256f71e551ef8e444aee2942e784a138a0f693ff935a0163d393da16dc1c59216b34d07b14e9ed4a812c3c7e2d0d9bb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
