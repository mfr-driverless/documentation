<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3efcf62684987f2b22ec64319a2fd511943492969367b3af9a347b54794709e1a19aff98804d799f2e702caf0e19ef62b401ce8915fee594aee0388632927fdf56a5a1a42817217e804c2d3f8f1fedbf1f826d773bc019f9751baa2f13d1ec451aa0d7ded6de9786c63799de8e1e397809d2488692599479580e9ce0369a55998191978ee571ff42f98edc51bd1a9917d9789c1e485d5cb787c05962d1ada234876078645bcc3faeb7a298e3dceff4b7130cd97a98453491dd15f9ebd9c57ad6d184a60c457913761bac0a0f3e58387bd48c93cbdcc5679c9c55aa02cda64a280ddb0b3d1e49bf0a0b0b72c0f937cd32adbadcf5db54b37eecf614b661d64d1be86ec6a0e991b11f50e2a273e02a40bbc975d14b0fabb58043a407912ab29ea5159d36f25f442a8053a83421f5eda4d1d377da602d96b3a152a8156b3d539edffec4b51f324ac094cf3178c2a6de042664211a8ffe1673acfb8ea133f9029d2de6ea67d65ec41ccf48ef637913a8bf7298cb6cca5cf175d5020e16a21bd2ac7aa4d3e8f78fa91b575d563a4a17063869266b7b621023cd092de1cf0d854c68672df52b27145106c1d8dec64af871c256aa03aa350c534f00b110ca5eb3c67d53c6f635d2400f703d77fd15d3017b37293fc1c036a9636049f583472d7f3ac070c4fa5d51ea8ebdf6041815a7f344d3bc5f6d839c369a3e4e82a0e1738609ea5bb5f5222c9f2ce1c02a49a115583bd445af787e5c2df0d6442f5bc36841ac1948ba9c76f103729c787ba1a3696d5a3d6b99c582534893ed10187bd05640e19548154f06718a3c553256f553e6cde8849e9d42ec575e4d6fe88f333db17e250a4253f03447413f59b93cf193052b6b47c2997f886e698df5f1b12b246dcf1c36a890709ade3b1df13903cc585e678830a7b497e938825fa64be3b4a02ddec028878725befb466a256988426938f5578759e3148f5a4b4fd11b379a6d26c915741d3805b275befcedbc46b099960fbc9d4bd06b6982f07573bd499462222c9016bb2ac6e7cc9eb1fc4ecf4a5983175bc2d87a47ab234120a07fcdd8ef279c55955ad70cfa3764f95326ced9293f54ad2c2611e6c95b0de754d936ba727a0a15266cf69015529fd2235b76973418c8dba2dd6799f282bd0129749b25867dcc61094cb0bb55cac090df60658e61590428f50de9ff6bc65a611a70731df9c0898fac0b6796e61e96c93a95e6e25dd8973902dfb45fc17729e1c767f1c60b8f2921af665dcef3bf42e3100b8cae52046c3bdf801a6cf5ecf96bbb4c4480c886c0a1adfe7158b4d74bcf19d6ca16765f0d0ac9896b93a5045fb374fdd0fe74df58d5d1b10a647c36cad158a5884de47b74d52ee91a57a372a565dccd18a99bacb52ff8bfb7a00683e5bf3915e03c06701f164320e4f65ddab57ca88509de03ebc6c491fab31bc30a6d6729ea7b37fec05693fccbe5ddf79e3e894a4c05ae3d672a7ee9ea67191884e79d28a1dcbe642ba4cbbb034425901209b83c8210ab9b27d93212436028a2eb40caae441c4e437310510b0c977071a6f808945a382d705a53734bfdf6769bdaf7ab8aa56876c76e67e179c1e752c5431177d97237455543dc37cd55ea6bc11587804de335e68d99171fbbf13158dc0c208705d2420318694ce1c81d80f9bdb1e285a46a32f490828b41b3acf5eb0139759ba825df7f93b37d42f86d7f3cf5758fe97815a8c465fb509ea705c2696f14ee85b9376e6d4f97554879faa63bcaaf9ff46301ad49c70a9cf8f8c86c5deaae9e7813eb437d58ca54826c8f722d78fa4f83aedd1be2f9a087d6f17bc97912d1c8a4393c5c484e48b107985fab57a2934e372bb76e32678a2b70d55bdb126def1251c2ac250ba82710135809e74b14debb67ce1e958bf3038be42148f8f307ef4b722af73c64ede1d58ba6f8d237981d6c37a14dc3809505c10cbeec613be5ddf9fbb239279c9aa67a19da24168495111e86aff87541e01bfd53fa27090008749efcf8047ca95adcff220c701fabe91478730f83638cf66f87e7d3d8d31c7f398fac3c41acc5d458a4b84f82727c10d07a8c179124e736854be812a71e9fee78b0061b17e49ef2d4a47a702d848cdf60f8c55509c68fd7c5f16d8f81a7747bbd898c5e0d3639a386dd9a4104635835cbbccfb2f21bb941db5ad186932af15c8521d916accd0bc2212d0f8ea91face6c9ac28cc68205bfdc49052b6b633d03069ec11603b208f8f5efb174d876f99ded3509d5450621569372291689adc0f710c7ae940c065c1e8dc9fe50e9e4db164e258f1723d27df8fdfddb6a46cf12363579c07832fc099af024d76d6c8775250376f3a3d81c44ae64f823309b538c6cb7a93961d9e250f97447697dd0d1c64193c4de64984768d4ce00b1f2f84192e9e2ca54b3bf09634bf963cf873c6ec9f35492bf898871e0bc19b7ab4b1693c4bb037cad31ac2ef8d10f7b06f2b2afc774d687687a0f9acc1734337c7a9a37d7d14bfd1ba17bf4de7f75753cb22ec47ef051ba6ed136c737a368b1bb60a0a43c6a1aec26220f90d95f27194d9f2c5bfa917de62bf614a53726beb964a1613d8198d67a31bf9f3aa39a45b66d13109e8eefa75983f9c6e09cf62eef7fa161992dae55091aa32e53c940b9179e33918cad222dec0993fcd8ecf4a7c81a2ceb768e8071ec10113ff279c311b10739c9a4be9f8f4072f192523c4820ab3cc87c2693f5f8634b959b3a4667facd48d0c452d6ba3f1d7629c63797b53966e52741d753de145a37241e913a40653d280c35b7cd9e27039cf598d0f33b68f682fdf583e2315a10dfb50bafec66db9fa606367f0faa9fae52179a9db454b4c1389efdd362a9a3fdd069a9201a8c5be45c9ae7453504e03d9cde51c76cad5f579b5b5aee7d4050e232469c02ff07562e1a005e23a07b27ef06b56a70c7286b3adde462fb7db438a8fde11c553dc08e55f6926a0b6fe8edd7aeb8bcb25a36a1e2288be402869948883f8be68be8f826250ae44c2998fe0ba9a834d53d2814bdb99ad176f5838852bbc1bdc88bba07b5e3bc5bacf7c5df1d3ddd26fbdfd85e849bb8427b5a9749bbf15d39500732fb53c90ba77b63096b9bff37d121f7009232e8434f230c3ba7570a187422dde91d044d2a9593cfe8e0d502cbcb950664c8dc07a2b5e678dad89b2e77fdd115bb77073e98931caa4e4f43551a567a65d3f58ae662ce2b758e7c9e0efefb4753c98b3ef62bb3fb08562add0a63bad92992e10ce6e384173c024843ec80227f5c9e55bf9e50ca8361db4cae9d99727fb6b706cdffa52acab6a66661dea1a3210fbef97566b225d1c8c866cf941c25352b3b272e7e6bee1324fd77a2b2d6c841c4df095e5338bab45129c6b0ae267f1d66ea0b2a91d4a077cd83d926fa6c759bf6ef5631658d837337ba853ba13ff2993b6651733f5526416f1b63a2afb07086212f441320994a9f8f82ac2702a91faa3dec92ba0d8d66d257e0d3e7c4ff2c789ba9fd7ca4bd593e53b11ff97c57d7afb3663e8f32e194d3125971894f688fc0f67576d1e5ff7fef232920a22de4df0926c0a05a3788804cc6b8739f0b45e60dbfedc92f5861ae6990ece2282bc4a2184d9590b6660183d9e2994ddbdf423c4f05166697317f1d4d6dece075010f4401cb9b80ae998071242a1b4827a4cf2e4ed7e1f3348c18ff9bc25a340fb90b60543c9f526ea7966e83f9ac1a38e36d1e1b85f1978a032aa2930effca9afd49db7b6b813801bc4e8faa182cc1c4e3e0187747c4c046ed6ceaddb06fd31ee94dc8f9df14f9afc3e5b35919900c071bd7da2a831cd3197257237106d4b414504a22548960d46df6936708d78870d7ac58136cb90d15691afc502e2c1870e9e2a12adf7248147966a2118f67eac755c2c586668132443b31f559a3f80762d8149f0d1b55a84b30a0ad1e28aff7b0bdbc713bcbc876cb2171ef10fddeed770fc5047a6b9f2bcf5cb7933f46d1b6e7efc9845875a46dd96ed8cbd60d21782fd1e059e758300edc5530d10f0d958bfb18f756e95c9f797eab4e7d2169103028e91f8a2bddb7da424618604f3b8e4dbb805c09efde6b28f7f64f66f537a6f2328fa06dc46445903be941c2af15b03bb3e6a71eba809dc8db7fdc30698d93bc13d45495327e0ba465eabe548ee41a16f6b249a69deff95422bd257eba739d773905e59e03be31409400820b7d6cd2e6973da636fe3bc531136d34bb7d307067197a929d42d255c254d6db66e648ea17b64d581fa2ad196c0dad820f8a3dd0624310d32ede9799f7e3450b9b18cdb9cfd1b714f7ed6aaef774d289a8eebbc078cc2dde1e1034b6ceac6342824a20e86482583bd3fad5ad61e7f8c026097cf59c2be57404e1f648fa035c5c37be73cb10d44a1e155c6baff1a192259846037c5861f564cb3149c795811dbc3b8fe042aecd835f628cbcb739b2c56681e05e58df3883af33f4911dab76d1a16187213eaf36d0f8d0e5afb5c818af2de81470ab22685fa05dfe6314c15845fcb8ec14cc0521065477d5feb9b7d2ae80e2265ae0770d0f34afbb039ac332034b037220abf0efcdc27da62637dcab397068dd648db2e0085ae1e617d58245be2cede6e6c1228b921880b518b27f7da9d4981e486f111e90c611a8631ed279832af562224953090d37c8d1f4aa4158a8b33894c17a6324c7aa8b9b93865f43e90b79bb65b58d6d7c905ec16dae59f2f0b266b8c6ec14747d8eac2a2601c9aa03515ca145673ff369779365a5823cbbe80a9d3f7c01c4189007e3e1d02691f3bd3b080346797dba1721989727396c1d6713323c1d07f0984f86db71f6d181dace8eecbe17da52b5e637a1daf1ed5afa6a02494c56abddd236525018b105f01cd6a79f92ec99d19188088881b82ce696e05b78a3e54218744bbbd8728c623bf78c02b5967cf8f3f22145642e17b7bd60b3aca30484eb36a96bb32b56da031bf45294eb2d8596192a8a0716ec1e84b2d7a51dd2c686d48c01adbfd6c765bab0fddfc59b8349a339b1a7db90ce0873b5670ad515709472f186d4626e6e9d2935f190f63f23f91232d0e0d9b8eda0f82f2251a2c3d3dd1f03b114bdb23b322236223d834176a486ce4d0235837d4aac202caebd775568640ac48261883dc8dfbff64142c97244c426e433b08f01ef9fb6f993b7bf852c73cc5489cd0ded90505dc1a382931adc991cfdb9092664543edc03b48def03a0034cb0b9ed9fc25bfc3b92eeb4777b89b04ff017a6043c7b53a9ddd6de17866e2517d8c30e6330424cf1c356bf3ef6802f60a38022beaeff01c3a444fae58aa883ffc829c72c83c3c619c4ed7b54f0ffe59f3963dbd08200b185190c3522e24fbce23ee3597bcd45505da21e637fd062a21846a7d407e23868a53a30d7a57931daa99bebfbf466ad89be11fa1297e85ee179cc5b4ca0605c9e8bcde4ea33e6a02c3f0deb9d42616e6ff0bc91bb1e3b2409882c4d896a51fe1007184d11c895bc188a0a7a917625f26c99e76cde47fd1482aae4def8947c8c35b638a8b6cc037c57f31f079818b8d88831623f9a1d86b3ff19d1de5211853fdc2af7a3ff5addebc453470264d71036f5504d1b8d663a066f33c2ca307fd98ca3d44d7007b0e1e5c021181bb67b2813073d7cb654ae66ddf32648a781953c65720ac2f3069e514bd922b53ffad757b4b34d1426ba0fb168d135d5af3cfb7cf4047d80ee471a693e866d6c5011ac722d260eb56df58bd79b50a2df2b20973259dc99cd2582609b1689d487ae41521c10436559a45aab03b08eccdaf50249ee20e34ed5df580b54f6c63340a985f03092aa0d12f14b57139c2bb0b5cb857d20ba43cc69f7311fdfe7358d55673919c881cd34186c31eb7321599b9b6248e56be9732eb53ba0a2af664930763ca0ba008aed0220264a1f8b94851738a56ccadb7b44a9688767db307d06b00f49c9019fca943ffcd33b70fb2e86e676970b615ba8ba3a48b879b7f20363cd691e6a2b60acf4ae0b7475394aa10d4604d342ee12322e97cb39512d979f9f098b108ea9bb5b1bdd3bef6038d2ea2b4cc6b2e3a24ef2d05cdf68a317da1b44558e01ed37cb70e0a0139eb2b72fe901f044d16d032a4dcae7ff843c4b110a9906233f94449508302c6af95870595ef9337421aaf3f4cfa1031aafdc31cecf3acc4b2a6f0437f48e82b899b49045afb70dcad0d0e73e6798d81f9ea4b158a38c4c56f50e4a13fb8e4ba65dfaa290c4df7bbfe90586d28a6f6e82fb3907b2f905421e7599b0aaf9992a15d74b4b3773e498b27d7dfa0c08d2d1fd8781f6633384d29c714349c062bb9c38320787863cb89a3e17cdc7dc009fae2b37ed4dcc43657e314ae767edbced9085e08a5c61afa7b57a3dde5a4b8872550d444f420329acdda730b82c23f0edea3bc75a957b9273b4af958ffbbe9c96075fc4b5bdc4d6dd7aa3c57b6eaaaf16e634c52ed5cba57bc76c8a90e65b36d604aae96c035106daf5912b30ffa75a5c9720632fc8149fe62b63b2646d0f9ea9f0a8921293c2273fbcdf8e97743452f25d953fb86463225d147405cd755120452bb3db1e2dbd2ab37ac08d14c66f471c5a16f09fc3bef34621bd84150d60f4ab111549c49770880cfb586b2b956827466e1e920c52647ae9a0e6849a53e0480cc9207bd556c5832252e1dd4075182590f0ebd8b83fdbbe95eef46591180e0c124c10ac905f1ca837acee8b4c5502b8d84c46cc2bb695a050239025cb40e40041095d6913862345605f019380b51125853a9a2a1dddc5b0da3364bb40626cde6061e079804c81248a0515500206581f5f0398589a6206b36dbf768d4cfc3c1f97a1ae72dbb44bbd4938952afb6ac3d5331339f578a7c9e621b9a212be9922bc47549ea7d71389d9a3ef47fb1ba69a7c54e85227c303d9500bc6a958c53c93890270b614a56376b89754690ca2f4abb35015e9c7272ce0125e313b61f4c43bb0829e201dae9dc98f36428e40f9f2ea461b91e41e22f51bc56c19f71a910c360af69ea0c8851140d97b1b9af560343055e9cd89c896754d1845a7c5668fd75dc206b826dba757eba9b230959f535a60864e382577938de084c14e6e5156b7e554d6b6e4401d1c287ce898d664dcb2edd3320146d275393be7a97003c7e51e393dd9c94c4e44de397b0680fe1d00776ff347324f00e728e3f1245fec6a6c16d1ab65f911e3679deecc0174acdffc78006487897e73164c27f6cd65a764be0ec6b0efcc2bb44f9eba2f37e1eeede6fef6d216c4882598434109e3236b3c58b0394fcc7aeb634ae94dedd68d3f4a8d88fd2424f5d832f272b8a79df2b529a896d90332183b5bb48a469edbd27fd5d5017a1a295c1a7e53f9735fa173cb046aa3d20705d997c34a054131a992de6c41ec8b10404f5898a0bf0294cd16fbfc9b7df4bac639e2957dd49e83500682786924298512dee3926ef6286a8ba894f6a0922a3b1f2fca54aee682c6b15dad02bac745ebc3d12793a9c80a51576e33a3f9c5cd9c14388ae301e3315c1f18c86ae61c013df5a0162332729f5d6c9bb99ed38a53b5c5f5826ae28b5cc993d1d89e98073fcd177c5a81fe0adb980617d4329dcebe28e63d428097d3aebfbb50b87a40982af399128e33ef8a6db7385746e7a416fdd44d3cd85b59b461cef4d2417b3a62af9d5daf37bb9a2199a52c6bfa044ab8fc106f48371328081daca9a2014260b1365e5ad7d6487ae67f269c635297707d6341c8caed09c5f3d2011ab076fd27ef168b26078ffe36ec72caf264881be326e840c0f4a98b1643c400aa24e0dc0818355830bfa7c0eb301673e50c292b75bf6476c95615b7cc317a92c6dd1d72096004695d31b94eb9e69d2b9f06453954a7d295c706be6032fb8fe9719385b512bf07ccfcef9d514f25f59260b888cdbd9f43268f8fccba900f1fc9c89b41ef438c3f598cffb006c528400fe1d029adc3fa4a45b8bd85ba6e22557fdf1f1616a9082eb8c5e4b3cc75c4cf0cd00494e2fd2c74022c05c9558abc942b360044dac9436835212785dc7955d0495bdb3e8f2a57a9f6524fd3de3a8af78cf46603a9efab7cda8838e95fa7eaf78c478f4e6c76a8dcf45ce99fcc958e99a59db15a33cc4b0e8ed778b52abc4dc4044e1f2c8179d3b40c86fc83d8602a8fff74f530aa937e916ad29498b60da1e53d98e16ec6672912007222d037a723d68ddee3dabbc12bd4e33e105a2c47b30459fa9e070b820b8ef0b2329d9017e0e87969fba5d7f1eab8781eba0f6de88af0c76bcabe1307703d0aa12b73e4e01b72221b9708f622c4fa83893dbbe64e5b76a8ce8ccc9531b905aefed2148935caddd27ea98396326b5534366a2ab2ec5a24f272fb9a66ccf2f267ea2e51007af39dd76f7f490388b542ca0e4f7f74ace1166106f732f205a4b64ea874edeca8fafde199fb5d90aba3e4eff322cfe432e35b966c9913fcb190139c313c187ef9544e698aeaa8517f17724c4ff23830787c4f549d6f0704b2c7e6163c8df8dc447ab8d3a4f6cb01fb6b2bc09b565fb1a8f4ac90cc4714bab638d821ef7618a65a6cad9d28d4886f3916fd5b7575a71242ac2336e71df766b03f83028db13fd6ac87ee4b7b6c9204fe0bba99efaf25b223e02c465a824db50ab0e0722b9f9d468f73081fa83af7f76fe3ad662865dea82ec0b081c0ced222d202ac2bb14f71b5f56846c9eb28338e2b44cfd7959d639282f2c0de7301bc8dc3cc924987125f0c0b9dc1feb044b2a6b2c039443db4d7255f4a062d52cfc24479a9ecb7dac885b4a5a2d1c5480ac66244ebf3a323c3bbbc4d13584032b25c26eee5bf4bb0b6ded51f56f144a98c85331856f1e2689e4c240510b4b461bab39db27c2428f64ab1d3e74d402cef54ae7ddbbb1d9e3555cf2027061cdc265b52494f559f8c5fa54952887cc0aef00f9d6ca778b450c5f6e5c32422f023accfeb2857395bc1e68eff632e49e63367875b5bb3eb6b57a1aeb6a75c84a6ca47f8413faaf6bb71186ab2a0091ea3210706c7f518d0231dd8e399baf781992a4d2c155a3df98dce43f0ecb4c07ef8c1364607f91b0f38e95f946b62035ca91a5e1672fdb6bd4d5aa309cd7e32f5e07f1ca145e320deb7983d2ddd3dc44e77e2f1c0a3a47eeae1926aebb6b60c9db1c4a01ac86b10fecdb146e3541900c7e6166db70553113849821de7a87be454f29a74a883410f87834b29faa2797e9063db0bf64cea5f3737de0182c749bf50e9140f38e2d5f4ea5dd6f37b2eb7d52d1144701a39d64fa1d6628a0310a93e47f1e4b6307260fd08b1c823d3a7f25f6b1dd9e6f9d8cd5d84ef9c81adbf62b74ec72df977d00d02bf27aacfb4bc4482a63bc6430ffa5810b46964a36e29780e0dd1207aa9440450fc3a62b539dc2a334115fd9bc5ed460576133fc32d7edd47dbf55a9c7a361a3aa2be107baa08dce68e089756a3605c8c34196759f7987896555238b26f3f354fb68b71a9ffc9ace3e178a4c7375cace37a7742736c41758b8f1f8dec51f19654fbce6d979645afc139f23a1e5466763bd4f85b945913200947578c97f928d91c4d4790ab2e4917bea94df02c1e0d740dff142eb7e687de9cfac7b0afc28ec77ac410e436bca161e79b969b4fcb36fc8ce7b3f15b6b332721a668c7c7541f342dc08addb65cb90589a4fa258c93597a88747a5cd0332085335a2ba3d115af8d63165a58ebbb83f6507b81897f0254ca0d8a0490e39dca8558a575d222d082de1d7f40b5e3d3d7983a0032e999d02688c73c1f2f37d3d7a51ef99ed52ee2fbf1dbf49bee9a3060c547ba143e72003cf8b1e4486ce524b78a4771a4047f45d41e228d8ebfd19fb8a3f074a498dfe48de1af3cb988469d98f0f58c8321af82956076955bf8f31274c1866316d1290c3343d95c940a03ff4012c06a0d5dc20c28766b9d0dcdc0eeddcd378e04c52313b2e8791c8926e3b2baa0b14d93a9f37adf76a1de1bceb4c233a8f9708517848298307b06465ae0aea0f50594ebcb04d9786b4152f00d4516241c1b3f94db74633b166c3f10e25e6149f10d92685974d0e73ff095da569d2c122def8c673b75b9a91c726ac50983f97171bf95d481932d0684735c0e02caae89a1da4081fc05e535c6fb6cc6b86576b721f425908d16894daac5146d865aef1dbe7b83590381b886d451e3b2056d2dfc62d318ae58dd6ddeb176583335d92b9d557b8ac9a6dc4aadb3935affc4940f74087531fa27bfef033911b73825fcec66004938f3464a7fa120ee63e0f165c5d96eb7154d4add25a0019dcc53419ca137b80e717f944879cf9ed9ae6d24f4bee3a169bcc55276bcfc9c26c9d5429c848b9a9fb8e8d9b082f0be7c17601c7a3ff3d2f8167095cd37dba864c5633bd35f61b12777e8113bde2d1dfe114119d9b44ba5b7fb89580970dc9141af5f2ec20806f04adc25c095811143206b32467a02c5e4b6b3abdbb714889f4fa833042fbc45a47e15920dc31501f8969275d4e9354f8c6132ff08c0ae3172e8dc76fd0e5a9039f0143a9d4924c1af259a9eca473e0bf8ac03df38fecf173a49c1cb43fd746cdb7d1620ac7cc67bfa07e0496414d9292af7bdf36e24356efab7a6943b564a2d0c778cf3e88fa3be73e8358119230931147bc0088556e0cc185a2a46cf4c52fbf00b4b31869fc5a72b4b3e962d0d881e7f0544b5bddd56e75995b70f57f197210df4f98798461707ab363a6f84c5a814a7fd9f17bc60967b59e708d434da365e6b49ba8d79eca0712e3ff354912ed749a61c2fd943b010b6c58bc697912971d8e25507a141a4fc359518b8b42124eda74d58101e42a5c13fc9f18f2feda275061b7a22e3a40d77667f94ff2bfa93c6b46d98e51e4f13041416b8b0e58e9a577ffd72c2caaf44fffe209f989b91395926ff20fab413a53830f691dec5b38c623e4af4eafee6ea97fd58f99b158e5e7ae1768051d7eaf945098f2281cdf34f4f2e03842ba61fcf223e0a740aabd6c44aceecfc5cbbadd2edb955a4c7e6bc88e3e4eeddabde11e8fdd9a879b94262cd93ec58ed933fb4e62649ee3c45f8868a95e7d6531d22b9e0f9b870e29dc0af51ee122e21374696ddf060f594024c77fe2dda2726329f0309e1b2729c9fc4b54f563a200d34bd227ea59a0d8b4859cf6042d35895fd0d4068829f32a171467071d9b29f01df76ef550e6cd7587d33b67ee449173b35f460a9f309c6a42aad96dddb3a6fab85355ffa29d336af0a730aadcf8b56454412434852e5f8f8dca305065040dfbd92ebab89089db1e2a201cf98f3c35b34ca474e517c24e7ef0b1f21b632a1387ac2221fda3ee49da84f95347a2864deda9621c58e96462604ec61698091251785cb647213140efe189b0286686c4684aa7769e7194c5faf50b5978ba1753cbc2bb580af66d7bfea1f6b8f3b1ed71d4d4a6cf2cd051a2824a77fa2cc21724456d256df27c5153ea1e9e9f75ef428f268afccb6a72a889a5655c17048fff6c920a08c3eec6b9c25753cbe4da352414bb5c5dab25e29010b9ccffb77abfa7d1dd4d4af90bdd788d931691af735cb695128833982cc1e51512838d7526bc6c30e2320c7b1e842f7f16e35708043bb2cd57ecf5ef4b1d40d55d1ff82ca466796df7aa3a01f7867876e34412e1d3122cc5f655aa5f8849e3a45fb04d6e98a0144a8cab2437b1b9d7229f68e3903f7ac5cdee08ada79f18c914b8dce2f49869a89c708c39fb672e3e64f8464aa17f38738d1ef9a8ac0b8f2336e6b68a73ccf31aea8c63a6d108c13dde27bda82e0730ac0ccc849d910995d383ae057fc9f27d408cf3ceb7b71788bb0f5ce1f0f9e71cc043d14868f514ef75bf0969dd02a6aec212739090b8e8cf3b9aa564a0377598a43b39eb346ab92c2f0cd10c8af5f5a9e8220ca7e0c46ced0698d50c8745b9e5c8e83d4e2e40ee8421f89abd684623c6742a68f861f3725a9cc42ecf56ebca59661908f8cc222c0a3aeaf65addd961ea9d3edaa29a983690739f947fef6f19ec3e49c4b429c5f4eb141da25a8083aa254d64af4b61a010cbd341f9b4a9e5ad586f67e3e0712e663559ffe9a11d8afe3955f78a13125cf20436d28392765773274448dd6806f29e7cf932eb42f6f9bf735dd4af6ac4f73fd9649885eb9072bae97231c6d5923a4f025b150fab6b6835a795711518cc6b2f34aea17ac86c1dc18f5e48bf78cc3c7bfe23f825a1802de62aef6fbe9ac1bfc3a5ec8e89da510efc2f7b1b4eef33af9f00afb0ba7df628907981558800564a06a6b83856cf37a70b6085b08cedfa78da57f6dfee60b78d89b284d472dc4109896f6329d94c288b4dc9bc8466cd82baf9b35184062eaff7ada58c92d42aad999eab40f5e4a1040132057cc42a823f8a6b6c4055058f67b0218d9ff6bbb97edb578868b1c0abbe1ec9dddd24ccae72bb96f2daae3ea3907cc66943632b201f9d47262caeaf39ced46aa9acb1cab149f8e6892120ba4df50d2e1dbdd53fc975f946daa8209ea67bc4b6fb6ea22812ed6adea9ab2e8d36ca23cb3fe4cabc67229bddcddb79361eb0dc3131f76ff0b24603f168104d130392b90955dcc1299bf15c41a95dabb7727eefab14c26e4c8fcc1ea5df7723b74a16a6cf0347537b9cb190e15a8c9aa9140b123ee35c209a914b1442c4e54b30b6cd6d4822a2649065b631a3b8a937f6b61373ad2843261cb57601cd0693fcc4d37fc4fe16df6549a146a837f39e9d7c3e7dd33397534b2b52d45d7242fd0b9adb28b8ff26f6bd39775508b19af0579df27315efae9254453091859de5193a2f39f96290d79da88f87cf09afa655cd4b4d2f7f65e0f8355daff026f51f36f7f92ea9c86b46e143f0e80826de74d424c91aacb8930824e9755c85dea3aeef37bccaa15e6f42d380304a185809051efdccc94fb79e87d6b2f5229742120d9c93c37f8520da20dcb3d826edb6f67cd5c1756b3813095afa6813e6d0f37ec4a091bd3ba7513a4b226695011f6b81ca2a583e863c4ed61fe99a43ba9683ac198fe8bc857b11d338e061126640676c435cdebcb1e050e21fafaa684599e0a120afd8820f655bd264ce9e0104f073f60c02d3fd1453c7f860fadbbdcf426eb7587f6e4df80bf1c00eb03bca9e035c2768df99710b57335f3a3b0dec3e0852b13d3bbfc3f572760f668034889bfb637c2d8e5d538ca6fb6a9cb309cdc70f0b02791ccdd3f89b9c230cb981767da77434c8e99e109125708da0d27057811b41f6a82f32f0d56f1dc98a7a829f66ca5c5e13ac10cbec50582d52d0cd1e8e7c5c64c440d2a262f028c6f634e305f3bd356806ea223bf649d92acff03db6ca92b10f8dfbc03dca65da87a46294d186ddf56aee72edce203cb3c3fecfc03712779b643222f070917fe0b7f14a09ce221a9caba3c0ba7dc3c2dd757520bcbf945a9391c3728658347b3024aca3d37491c2a79207d7ae361c5f31b3370f53f74a473296e654845ac2b33a7a8045a70251b0fa50737e6f64f89b41ed3d9e18a010ee356b4a1524051ef2ae81db8cf12c15c4644df314bfaacf6aa175614430698ad4fb2c2170326150935e83de2494776302cff5e269136acbc679492eb0fa3897df1b70237ff46dd5edb7c868e1c737c9c1c18871c04dfbf7e3562088c08472e7e0040fd9d8dae530045638ab65d31e9a9aa1e01c9f0993cfdadc87533a315ff37bf04394e97eb85737da7df5272c60ab3abe8b90fb2d2f6dfa130591f52ed97f3374995c82b8a89b65a4aa31a87327eb78aa00f422f991d8b74e32866e7f9e32b3ebb74a66c634e219c61d52850633989d6b1a1a0775e832ecc49dd0eb032c24574b38093890d92c0477798317ea33d387d8e0681de428a5756d356b33be8d79297cfe0f8f2e80e15ff6d78534b6cca32365f9f44e690ed604d0a8b7c8dca54ce62d7da75e98c801cb8e9b9f9cbe5f3225eb179f002cffec104021e9d60186cf787afe8cfefd90b3fe44e8eebf08a715dc7b18ff55d4d73e6920dc1e5dc9f76130555d7fa52c7319842b5258323a72d59124a1454354522a6d229143de77b6ed8ae211aacef8814cc2d991001ff790712db80a4c90398073ccc8ecef1b09453766bf8f624c8e53a136e776f5f56c11f6129eab6caaf961bfb17d7c13a8171cd18490534f892d058c3eb56d7def18dbbc3fe193ff2bf588ab6e0af04d8f7d15ad5c22f8852890d9cd203d4f32b46d09713ea8d45377f97b841d2675746bbec7328e9115baf43612e6ab7412b64e82a6a6a45570568251acadc4e92d249a16e4715eac9ab3c99cbce3567180dac7263a94c936f41f1fab5eaa9e693e8fd1da3e1dc3762516e4e5e161167b85895de36a105345de27b78ab5f19e2ca5fa8424db5a933a547057210f57973a70d3b276b3149c220aeec6a5a3e7f4d364527e5e354021fc99dd06e51c82b5381f7c6262dcc269cf10e8e9e2dd084512ab5bc1bbd3296cd8086145f0de18d90c1420766ef4d3d3460df73ebfc3a558568fe2c70491a7c0e4bdc45d47b334f5a23813067a0468707daf417c6a8d9220562d97e6f61982522a451bc9c074ead852c4300c635878f273a52ac5e8685450748f54ff44b8c74e5102e256a8394bf5f8cf436d14f14fb9e98d63c4d0a0866378d78b32ff90366aca7a2324d998c439a54252deec00784dfba574d5d7875ba282242dec2a75549b138b1e15132defad6e8940cdd00b7cbaa6549ea5fa7ab7d27a89f10028a023ecf8e482e3ce49af5e94f47f51c22bd0e6136152b946a71aaf5467ef3bb517dfcd6f3a0db346af679bff49c0a5861e2b1825c56c8bdcde117f024c158ec83e643753087ef2f0083c6fe2fbde67dcb3759860582d6ece8bf0a3e379cc806d23cc939a320fdb4ff5f63e8137856053e67a8f1506ea96f3cb07062270ecd9a3b4f7294b83203e4195147f08e78f98d8b6363f38493772abc7d35e19ae69a4b0da1f8e4b429a84078e99a1caf8c7d88e1e8c6979cc059e3766c9e56d39e17dc764d659b488b165915a21a3abed88bf5fa1aa39672ff897e460f43e6efb696f52abc324490bff980fc21fb8184569c7cec5595d2c6092d87945d844f65bdcc2d6e3ba720a97b752999700e6bdeaf0eb0fd9e4effa62cd4c1f1cb4217eec41dae18618220feeafd50beaa90a38efa5f68ce0277d250ed991311ae8f25458c027bec0f31a0900e536b46143b004bccedf5d68cf24781f0d2b4e9c93fca2e253cabc2346b60df9e0c862ad548480a5aacbdaa3a7e1c4093f92c59e0403c87eaa65a412ec4caf8a9d95ee1b0bcccb9fae23a340b2ca53c516e3a76429a6a4d9f79c6dec4ea25d7dd96f7b8a9af99e1770abc79985f314860409e95de8d90d0d07690b497eef6ab3b96f3882e1a9c1ed3059ec20fc5f2b26759a549cedc972cd956c340112b2beedb2c86eb8709491631262f31edbcfe5127caf82ac08489c9b3a813a3966a5868c81f78e35ef0413c0540d188b392d3d71d7d7baed5363638b1eb49ff1aa7ac8cef0689d7f4fe1369cecd94cccf2c6e1da2f73a029c638a6ca936548120d3d6a449312aa1aade12f0f7a9ec9adb0f22dc4ed64c6ab4bbd2a4fc0c68fd2a43bc0fa8c904776380a15486df617f0aa09af24557bf89dc40b4140e9bf6e9d390d28c6af362431c076d3e4650dad76487ff967ccb4b3492a89b6be4ff16b457261b13e8d0587c81e28aeebe53c1b03a00dd81c9c5dde86419b59573a329e1e323d81f828adffc362fe77e3c5c42c708a594f0346f2c405bca60db9d126d4034fac0229ca6f5c5a23ae3c94eb6951543601d408353fa62a3825e1de5433ed611bf736bfe905f0bba8b1cbca116ece8c3ccb4c21d6fc237bac67cab46bf807e89ed42282ad49bdd303f1d7ef1e967034a3fca0a040a04a04dcdba95bfc3b5adadf7db7a3758b9465b2743079384f73f512aa9006f7328793dee0fbdc17ec48c2da6db15c6c71c76afbd252e19a27d0eaa42c9a7b82d01178d32a1f1abe5813fd03df21858a787ac346c95c9ed89d91fd6bd296d1de2be86d554f7db31dac62a7330b79220d71d709d001d10bfaa9f38dd53f4867177a82726958f4c2f0913a653aac9bbb76f289ea87edd9b5ca17bc77953c9ff48187bfb2431bade7c4d758a2205a30b602a83446e61d592823d87d05d5be42f2b9178a317a41bd762af1283ed1592d3a267b9733c11f5d6e3de31e2fca8b6dd8e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
