<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6f5105b77bf7aa7a1e9cd5f339905bdda6b41c687839423b7db43ef361ce3d823fdc116fe4eea962fc949b467065334c5110e8ed9e67b75fdfe491763895fd3b05e9f7dbe0db31312c638272b87206bc854c09add18f76aec8880d81ca80f72f5b0b4d035d89d216846810514e0967f50289dc5d8a3fedd651646390fb9922cdad6c3a3f167a6c10605a5d4702e6b0691194a1f958562122d54aa185e422af036cc3b7d79959154684b6dfccada22f3947ac83927cf8fa453d6e49ceaa39924812031515759b8fcd318a516734eef24d8e5e9519ea8a8f1345cf3b79a8d8cbc419091015987a39ad762ee6198d88f561a1039fad7206466cd0296f7767fa8ce247ab1e7c3c28a55b811fe2ba01d66f0ba345559a851f4232e22cc0773bfb8aa0f7e76950c2b312638e154832d229099fe56899be459bef8d738a35fe384e4c6ebbc0e593d2ae132318049f7c902cf9da10ecd63cfcded13601958cd412b612abbef006abf74c8359d121dc98e996726f374f3ed0e1cef46e4eeb0ecdd46872c6d7f36b78c20490e4839b986c15fe8b1d4b0fa6010ef170162b0f8377e4856b24153b84acf436c53af95b9f61ece6b21acc3578352c38b21a980f19c0af33c936867ae90d5e3bf16632945bc2f166909a647b50368b2532fd4eee9f4116b2f7f2bc7ef0f82f994286ed1e03cd474900ea194fb37f24a9d1d555f65c30d9b0a5eeb021074e156ae0df8f994a569430ce8986ee7efa3d8682fdc957af79a3e247b58632b30ddb79ede4f1e53c3fda1d4ffe86a99cef926569f6ec59b26d0099f78b10f8c99424f8169c5c59e153c2d6801917ba6250163b9bd412ec0f16f03db08bd3aacee39fbbeb90cdc316fb92ccf41c48eaeace1cdbebbf275ab9478b2a3d75d2a1bf2fedbcb24d267ad86686e3d595f45ab5a3ee976dca7a993b8a7915ef2dbd55a5f7cccb5c2afba204c3a5191df79913724d0d488b4a7bcb328fe7ae711ef97f44f4e52aa5696964559c699df14c87b7909fc6e3091a0f8b3ed81f90b3f377931cf81dbccd2a37c21c0183baee45ee790de8777b5b0e5a830a269a898d28d5e7faf36c5f6df313ecb90bf02ad6cf11d54743901c6624dd8ae86753d1e9b334e763121d4d6b4cf15edcc46c9aca11d8d39e4f3ebfa97e3f05edc40ba1b9ece8ac893dfb93d2060d0af8b9fe8e3c50ec3bbdbd4b28fdb2488a2e304d8455db1f06d9eda114e3bab026b5081ccc5b1fd9cd5f998f35cf6229ee36a1fd62b06064c2c06dea2589aba23285494c10292b6b84383a94725519e04c748f2b5a0a335b0a992e143638d809b27ec55b0fff02bb0a318874ab7589ca961d5b7b1eebf1dd79d611b602f33dcf4240895708e4d5dfb37736bf8c0ae9b49435f442aff4944be52d5cd3a0c6b3aea49a4af3c5d6ee2ba0b246379717453b20f8fde63235dbe004d0880025501dc4a3ec555ea4c39d14cfe5c7616dcac04674ae6f58c74998a0f967e1cf1ff6b53d347e6e5751c93a555c94d6979fb4e334cc0fe9aed018352317c8c375c8684379ba366d9c3d37839f01f8c89085cd2edc54ea6a10354500fc9cbb025c25cedf9878b1ca95bc0a9c53e165e4ef86af0e6dc3efb8e4248af6166535a1cbba6741c98a7695adad9de46125ad1bccce8b337e0cd66fbad6263107dae6b98b96bb5beef57cfe864281ce9134f235a5fa3079398f56d2f7ec3a60d31fbb4423197045b71204d84f3385ee7a897ba78c3724ff29e5449d89943c14a50b3269ad6ba85aa6fbeed248637af2d89c00fd79d259d5072ee070625ba648f09d46e144a59d2b612f2fdbaa2d1d961144ecf02306646a6b310f9e63b3f05ccc8f8dc85e838ff4562e6bf8de53e5b0ae3fc54dfca70c4fa7ff0d3698c3bdad1d846d35c6490d5c22d991c31e491af052c2279a048af2197df8c2716877bdf7a632ed27f7e0db66d6673af618d5f1886133ea3c25c52010488dcda9dd15ef0425d0820673f55c6065a5fd26dfd3e7884775fbf4c438b2ec351b86b2d498311f1e93e3f6690ac2cd946835219376782aee129ce93ae6cdc9c4495eeb207ad1f0785d1753602fb7a8fcac0f6d5bca8f8c053e3d37587aea83493ac0d19d1f9c19da3bd1cc9240c667b2ec0c6215b1a86ea97f6e4d3155952afb1155f27fd755502ca71bdf880f971fa4a6664947a987fed263a84996d74b7bb81702644331e07c361d315f974d4fb909a31c5f209a9750e076e0ed95625440d2f6928e9c564a72ad16184b6a3bb63439c9370600e727346f4a859bf8e62765d418c38cc0398ddd499cc744ee48fa1f5f0d1f430f3337ae324822b8f76d1e038d49c9b675251d0e565fcf5295b7ec8c51d22ba98ec8a0898d38c0c5955b0a18620b5c140b37142055b6d4bb842b7f1078c1c32eb71f45be08c99a92af29d2a0daad39ab625657d5ae7dcac600e05a38e7c84f4fce63e1bb8aede0d84abe95f368b8e27f90200202902cd7e38f15e33f064cc8f05eb5bad4c0d07a581bdeab3a21d149b2eee360442e6ac4760feebe787de18eebe90d2323b1a7dce6db3a40e860f7905aa2c2cccf6e89b715066cb5e41a36ff880c030405f5238668f75275d425bfd176750e84bc3c5374a9ce4c4f6d618a32a17f368e77772c5cce3fdaf584fe662d8901b5012512245039d2106918f87d94f22512106360c36f9ecca2968d2c29e0a0134fc99b0457db07bba462cbcd04cff646b564f2b422ef5fc722c150b4c71bd9eefa0cd9f27f1d74d6517d305d52e9ee334761d0b3c8e6a96ef3475aba4848c2587eb1d2065d5b1f3563c2eefd116a432bfab3d19be1a6a2a0884403ccc6b0cdf1c84d41c5fd47b0254abdb7e7602e1dd045ce94c5ab386cc5ca7b4506a4e86dedab5590a24134abcdcd741a2952a011dfce39316f3cf63f8df3b0ab8037c44a77110ed341b08e8455b55b2648574d681634d9f72a59c9ab939975cf3786e5b40a916cbd54c73c549ff8d6047da23d8d72ec2e0b5ebf6ba25e1ba2b1b0658d77b4b1b3f74c1bc84af8af1c4bb9a0bee675d7347840b2fd0264577c98d5a1f1a66e93cfcb6d71a61e6f7ff899e036d5e52c68e7f1e672dae20ba881344c605e5d5c8417a5e23b67ebdf1a22184cae4a2fea651e4f8986262d23432464be8dd84c31bbdd2356d2dae1d2399e8af989898595cf59b201ae885d3c6eceb2b4099b3aa21872b5cce657dda5b9a9498f3b426791776e6ba492642bb28e28b8d000657f9cc0d25fc989c702786d1135a37bf19f0ed8e8d86bef160032856d7aa2320ca8814969b9a4eed54cc48fcdc31a8434f92699f9619ef67e40b75fe129a36ff62157738d93f9f724a98bfa005b0c002ed04cefb80528100effaa717f33f3cfb73ada4d2192c98dcc65f002eb93371d0d495433eda13ab036b93bff93ffebd8881589d96f269063432e58c3de98b5380ad2e8838e2ab13541d620a327e26738bd31b0120772bcc4bc85c1a1f90b903e1089a88e0d37a37f50ad1e75335bfff013b2514708a51f63f9a2959581c2518e37bab9baa2e195063087eb7aad0b23392dd23c1c94b447c8f67b25cef104aa24c1a95da360488471674f7a9fae8eeb49324d426fb0955c61e9893e65369d2a0b0921c0db61e57363f145160028fdb44eb92c1eeee2f300f8d77bafa43d0e8b4ef7891120d47b6c629c1a8e33f56e41501cca58c2a3fe4809215664d6252f8a5cf8eb8d39b1476853178bd520cdb84f2acd73b4d092649795e07d6f43a7d383b1c0ab406e7c7702e7f190a8473cdf09887a5955c34bfb2d9702e91b3198d5b57aad354b2dafd52f356e8ebaa042526b952e3a364cd3919e40e158007f32118359297f48a4ba45ed0a9ae0aed5e9de4cb9816ce6d9a8a5e76c5804060acbd395dd35ea01fd42d2d04676d7e55193c7fd85086d7e966615d83463252186608411ed6a5146e48081be39a2a6e5bba0f341883d6d8f42ee5ad35a9d2b9b4eb2223ae8f567bfdae4d39da68cb4afc50f61350d2ff43dc1ab8ccc686a477d3256b1e742d8c5478d61b8fb0f8fb2a31f2b7d30e8f9c278043f0cba181434c459eb705b5c6b7b0a16848691983f6c573e9e46ad9941a6be209db58db1ff7856a8a4b89e48809cea44f152ac53f4d46d6cf770848634bd7276797f84137627636d8464d701015d218f95843b57d76dcc3c1bc5c7a4b190b1b442f85f24cc0e656fbfe4979da54d03764f93ef28626aa703fd1c7c2d00f03351ed68e593e4c5adb56c7a4f11fb1000c88b695b3dcffd22d2a341b511dae59e6c3a11848be1ad148254a075ad553dfdee4e669991f11fcdb41dc0cdac9b9f368f2be0628bceda487162d505ec5d9007d633244f178cdb5539d5bb1d7ec04802df74b1935a18e520ac60c8d69f6ab070bf47277bbe8f3a21d2ff0d0248741a576e032a71dafa51bd24ba2059fdeeadc12885eb72b2cb2801d73d8ca99326b415010f30c9b2dd37ef4ccac6e282ce15ac3606ca8bcdf06a642d7b292815f87da94a9d6d011362fdb4e82aa089b83dc7f0a465f7b67e1bf38abb7848d0049c089ebb64f76354722b16378e2807aa760e3e785f4c4b38ea78c494ca55663f004afb02cd8df64a0cd0e01c1c123a45b8c558ac0c90ebef41716c9c2c93a26d6764476024531ccf449f10a103a398e017b000e260d04c7810d02f4ebe62faefaa2230c37c9d7f54402d8fc1162c3f9909932a96e1436a6542b859235b7b0c013328d2df0b067d8d41f69406a0519d0239eb9b365019fc8220dc3f7ec14a5ca1390a8f344803b69b739f993c96731801f609cecd146b282162d546274d5071a887d81e60e3cb36d94897021b3bb79f1951c20259d033288889138eef82ac10c9605b1ae244e720ea0bdab46a445f910e2047a3ad2245ddc1c323a7e058c9aa8499920e4d00b9a54e2bfe12726bd807d4e9d90e00c4bf7959d561149444bbe13ca6e80cf305047680f290f3cbb80e6389a68fd1b3ccc6fd61b7b75580dcc9a8f235162fb6784b0aecbd492179ea67e98f4e36e80ca3efeee855215bf38b3e571d451e561dcca75caf0dc844f7595ef18ad9f7ec6504daf17ea2ea9527ade9ec1ddba44187856ecd425f3d906b4ef166a94ed82662ccc8b74c8010891a1bc8eeac7fef3433b32e3cb75bc80013be03fecf84594986c4aa447ebf7abc0a45b55e7b108517b6447c8811d68624e8ff98a42f991f965a41c77f722ba399f0562c68c882a038f9df33ad0b0ef8eddd51279c4561a9670c52bf8ba495aac30eeee858c061adfdfd76d4517d7ae463061667d8530a3cb0c33ba43d275a3e37503be68be2b4181af6e130ecc58eee9264988833e4ef4605f0b2c45cd5c29abcedee8db102e6f0ca7fe700363a8d2df8aeca7e1d4f7ecf9b9d9588e13fee1dea6fe52c698509ee2ee8534c771c29802ab6005cd307b7f3ae220c46af2194c106f724b940f6a3942af7fa295a5e64f94c99a724bf7ee92809618dd84de6eda0e5256b164de3ed7d6f197e05d3e8747dfae0b0ac29c30082fccb3473e25517f05beec2cadf3a2bb0703a27cb3c3036fe5526612fea25ee48a84215f39ec3e289e40bdffd6dd86752b529e04a4e23e9c6d9ad12d7f6b27c1943c67350fdd6a941e3edfd53b989769aaaf1c4fe8abf6e411c11f8626c5c42dd40aaba42c5cb8d987157bf7e9f066e12e2200d48bd287645c651bbbf5af5712aed7533799c60171d92b52af8f71524b260f96fb755cb022193d531a50c80d7b2a2d20d887a1e60ebe720eb9697ceea204616e711c7cb7f1f1a2c12b7ae4b4e36922f9b02b6d9eeb4ba357ccdc29c7f726e3d578d755539fe03f7ad64718a2f8989a4a7cca37f700c2d881534735d5763b3761995cfd49cc6c46eb9b8ec18a5d42e410bf9ea7f37fac1f27d47a0b8f0039780fb3af64217b5f1ef43cadc35ce1e118a2c0707b673fbe2d05bd7aef56828d2e2c6a7d600a022350b8161a537ee098381d9163b52e972b81417bf090519ccef20d4ce1d4798f8801698029d38ee28b7af255e6ddd10290ed6145bb7d9c5dd07bde9746f96914c13f158cad444c51dee33eec9a5609b7ea451e4256e35d230af62c25d3974978dfa4b4020eb71247234f15236f03c6e7b33556ccead3db2ac53729e7e039db6af241d20d59b1a8bc9ab7c0726cae6fa22c5536c49c8607b095aa9b938a208fa7cca033ddcf80880221d51ab0a4e5baa623f579529c2cae2176d1d70ba9a6dc6f7a83d325bf6564b46ce3a1b038c82d31a3dbd76419f5980d9d84670c465866890aa8aca7e49396c77381ebd3a33074aa695d9f6aa8ad09ed64a6b1b35f7e96ff7784d40a1ecb2b24e8027aaa9e78ec70db64a9e09ce20ca377e14462900288ce078e641e772fdcc1fbff7b9143015fa1bc8dbfe63f3a1f6c250fdd7454743281481d42be351384a81a61a783fe83081d8c826164bf34427b354d716cc52d11c9306e1cfa5cfa6a70fb78ad04929baaf0630ccca8a3954d2bcbd529b840edb71face588ab9b97ab3715135d2b8efdacd43dc4eea6b4503c8160203bad105b4f8ebc02bc3041af98991d9373db2c624520f97a4c5bd65e63ed256e0d66d6b1b0547d294685a3b4a89dd9fa088c3024bd2e21c020e97c397a66b2fafa977b6e7fafbbe2f3b80c6aea5bd8fac8b29ff4bfc2d3f5e9a3a28a99a2c70e529f914e8766ee31784460b95a116f3d89e67cd87cee91ffe56c51c1a66f81c17f9948ce6d5bae6dae317cee873f5d350a74942be5c496152febc71cc2060d298b8ebe43dd8c12bd1a0ac3645519df8b80fa42f1ba15e3e1eb904325ce57e87112dc63d0cb1fd6b70a702f3da8dcfa40495b596c3307f3b3b881dfd9e6b5d5bbffb6084d43a53900fe0066003820085925234a5b7549499be400acc3fa467a90616f8140403b6528213097a66e6a23de4246f1ecb25502ac441098e76e06cb9e0e7fb0f056cf9fa437423a2970349a0c6595d165f23e960bc3314e7100332a5774358212639e2a00546ba47eb7fc74602266062874571d28cf9130b405adc2ed718d106343d52d5b859de915edcaa4efbdd5207f4a3139b265920eb5d64d014f8cb4eaec2c16cb786237a088ab049802562617bb24eb0c99498c2237a9e578cd1a3d99acf0b0e57310f20031e087c42437ddeb734777545cb7838d297b1f7c6f60b5fcef3db3f045940459e4faba68ddce8e31f47a9814f491e52a6cf919078d83762699e65d8e366ee393d7fc5c0bc4015b306234aac2b437de7c537280fe2a8af251ee2575d92b149b231ebf15f7ef1ec4e4ee0ecc3cb72d268f338231446f5c550fad0e1d1c7a35a07f662194b186434d32ff78071d44eb296050e4513f5a03039d34963c0204e38186dcd57b54c8c9151849fedb1c933be84b1888758412073ba3c454318a7dc195ad89fa269ca2c30cd636b894f0a378c490d8f4096d0c4502407efbdbecec2df7c400f6bf22d0a0422d79c12c0fd97deb7d0fb72561f0abbeb91ff7ca4e8aa6de1ed671925ca3188f3128410748daccaa574f9bc4e6f2bdd121083bfc8adcbc476edf25ffc51801b24b4ca20bfb5ea4c4c92353d0ee11cfc1b01a76d4db18e92f724e99576299f3dd66144db214475bc7f6e18c2c8dc1af3ee4cdd06cc70f308769c92a46879de7ae104218b6a1c90713af834906514ebdf6633e36f49d11965d6eaa77ee1d50a626b5291413095f26b29c2f26fb7485be05be334975fc5732ff6943dbab337c4c10bd08aec1255712ebab822bb4e74d365024482c6c682d86c066d0e20e73696b4b318ab2bd20fae8f1761d48dd3e486db4640bcfc089438a594c974e1d7db136e2463d589e3a65af726729d248cd249f719eea2f599e62da5ed657352b84b42560154e36e335996cc0ab6b2659a8300b111f7f19a14263f8865ccc40503b10547ccee351f07112559c618aff2f53eebf5b81f7ca83c8e1a8b464018ad316be522c3ea2666ca565f3ef32ed1bda01959e2f90456ac3dbd3c45b761e3ebecd6fd938180a8c7013bc5725fe7b1a8cf1d292b6768302ae1447abc8caab4214f17dcfae01b7e4b88158f6025bb686ad56bfec0491194489f4ca9eb5e6a7e921427d4beae5cc3ab413ba9d1670a1478ef6afb42b0d394713bb645d60b1b82f0cd52eb0c7bad0a1780ab644847ac2c65b52b54f5ccaa538aca62e6eccfb89a13dd3b1911bf226234749d32ec9e6e5f69198c539e1bbd94822c4cbdda507df44d100b2fa950b9911d52f908cf4840ee52bd5b71c17576369f2085eba7f1eb0601f8f7cbf067196f14d97d3d2bd68cd171efccdeb1d7030ae0aaae0c08d67bc8df73b947967f29078ad47702ee267be501f30640b0bbcce717c6ae6fe4dd2e05fa501af0d1fb128b16c5611bffb81d57b8e66d6f16fbb8d034e259877fcb0c7000be19b78a64fbf18032c20b17229a7e225910a74f273cf2535142f90eae7c582989a9f5c610c5b977658b896ba07929ac4dbc52214686e3e91bdd27f58e2da024a21b508cc1472ab1fc50f2f761f233f15dbd4a4bc214b7ab91b0fdca1662c9dfa202356b193f027faef01080e3aa42b37c0e5a8658b85f6238719246e97dc4c8f326f458e21b6e6a658f3a99553ff522d134761d26064f49270a083e424fc17e08c156fd59dbae1360c2f5d2401ea306b70954151dc67ed37765d2651b044a6626ee4a1125c18346058ee589f61618da502a5ce9463d59f6806ffeee8211b53f2073ac681d5bfb5babb9a3e0d4746ac32e271ae1e858f969d7231868e8cd44d5a4d61f00b16ea8419552400d1712ea350f1eda6f903c9ab4ad3bd2455f077c9665ad10b655718ea459472232187fcdb2919dbb5ad0881a6357646be620a0c39a45e4115a8f7922dd4210eca54d5415d4c7dd234c8c070c458b713ed3510723fd536a40820ce5eb5f3a225527d4189ab6bc854d9af346e1f5133d9d140c2a338dde8b69caa5946f983af6e5e110c19c9100441f8206d38d9a317f13402a70de1bec8db0787a2eb2d6b3f8c05782bedb90d1a8872792eeb41007f13ce6ffba5463ca705f438836ef99e4e42e0365d2c5f5d2f82da00cdaefbbeef85b41cc485111b0c09a7a46188a6e11764f4526a600bfaf73be64311d26333ab4335c14c996d5e9412668364e2eb89c7d9c0f0aa20894dd0f9a9f9fc69d7b83f6bc1d5c2609ede4b356a01094f2edcd7fc0e2527e1ce223589c26e24c26f71b85e110a66dfb3475ab620596c08d82e3696c1ff1bb361d011549ddbc2f781bdf0942094880fb90510e27b47d5347c08c33b257cd211cec28b3c9f794614deec669bf5217d3c48a56a0ee7492d281cdec2b844f96aa23c678260e8ba50095ac2c6ce9b59cf878bdb0562b1a3ba1e8969824697ff942ef279c9f176a9cc720eaaa653a7c3777d90b66c395b62198c802d3c4c4f67fb3c9e690b19985fb54ff1bda75625de04301c7de32f35d96fe85aa4f6f0a7e4a5f39c81734837c9ff9a56b6e43bd28eb4d307a089c0d56de0eb7bd3f7d9f604e447e5b6041a20db6804298e4850f7bd5204c49bef70cf28e3c753f81d984ca591a1b4bb45f5d74295ea80e6a5844cf67c35371c3d5dae548762abc79caf03206a38542a9f466deefe42be72cb44756f2e6f06e4a1dbb21e5ea439f18a35ae95f11f49fc7c1ca89b3ef4d61b2c54a51d6178920bcdbb5c564c2592abe131d7fcee0a35ac5667300a38366fbed8424c4b3e1bf06e776756f2bcbe8e2b7fd6835d86331b1d5c6e87e97d77c3e6ed6eb9e7a2724004bba748be832e1c63b91816f86bb0bd84bb01a6f1804320e102f6d5dbacfc12f293576e18350094d35f7e1465f1bf74b55f7724c8817a31219c595b801fccaa08728e600a634c5ac6d3107a438766491faae01da864298f2cf99589e4affd63f4d88b385f2fb715a67ee62a219a1f89bfd049438755e260b2de177e1628f516a8d60676c9c7d1aae0f19c13c639f17fafec9b6f46827077429ed089d8c7357bfa1c6b988c8c5ffd3c45a8756869420f89483fe4249554eef4d57d5d9d8f70c1c3d051b0e29758c30fd90a267461cc868b12430622e1c77eba2f70a8197093bd023a9f39c98fa93e656e188db61c5d2f7567b7d2fd3a0ecf7e8b9f63aedf2e7a541691a5dff2ba94d8760bf0d4473c65acb973652c78b69fb3051caeee5f11d50a2df59814612ed3cdef12e652adf287a60b87749cdd985536313f26af317fae13590870d4418f1cf834c74b8a17abfaca812c63fd1dffb8d61da8a6110cc649123c23ade720508ed709829cd66b10c0e2c5cc5f0fdfbf780288528140f248da572bb0835eca8e25b35a6cdfb41767f0ec5c95e15e4178e9b6041a170a0d5bc6607ee1879ae436838914349a03cdf92a85e80b7f1a39e1670127cd00f3796ca18cd317b63467978c2e33ae9011a7c537ef3268a0bfbd4a6f06141caa1b7e03e1399abfeff17dc5b9dc2cd5e20e8a530c1ee7bc164c3b8423c6aeb888a00a389da2daf5f42cec490938579fc0983192f61d1ca673113817dae1cceee2ababebb0d145b8025bae75ad7c6ec0495cd386cfabf90a7b759f7406adfe76b29d6e6c3f7c2a411bfe276d060bf657a81a029c9c076d507248687b1317e34d73abc8b87b397ce2d0b0395bbb8500077b430c054c413647f8a721d7f4aae64712b2008d6ffd30e205a1aa79919308be8a555b1c7c0ee1412fd341b99346bca1435917e3db71b75da988cd226c5bc4dfb7f0e2976af772e1e90abb1045bf10c296fdec2a7857be31a15303926b478b72410a44dedacb7f4ae2ed797291b1f083f385a8e22a53454bfea741deb4a452a6548e8cbd43325da0c319c1f0f038d6ba349ff9f6507318e6743c7c72b28e32b4d5eb8fb598f17b1f9f6d8d8442448899e476814fd303d9c5598bd0e0ae7584ad1304aa6d29c695e499c35fc6a2d23dddfd6b54a3d1f833d997390e33ad3e147a4dfca69db588500cafe9bc131607e5db8c1e683ea9b1f5e3122dc301286599ab91be3e202b093beae8e2d9b99027425e193fcbb2ca4df45b1c9ae4bbdf5f45c773e09af13ba916c8894665c348b635f74fd49504cfac27d0d62dfd567f3152b999ca68a57b3e16e6aaf3463a4bd750250321adcbb51877a4e64730fca0dee62e17e16b9139f58ad056f0e11a33ec97c6a2d75ac2860c1f91c42c65e0c523eaf8bc69bfa0df3e2aadf30a1359a34071db718b27a905fd4b344c7edbd63af1976855dcaa0b26c07aa67fa435d3443115ec694561f3c5abb8d3b2342f2b8ab25106d62b64d0af51d8ec531a7e81ecfa5c24dd95153c658f000db84664b461c6f04ef39e2574905d02da1f6efdeafe396e15e80eb7fff4d1fa380fc8099b14333d411ccc54bbc702a17e3f4bc4f03452eca7012f57a3c77a54ac01ab3ec8ad9ae7490bc5814708956b6b95e2c917598c0ffb293be303f52c924fed684ad34dda814c9952cf5a1db1e2dcee3c386888478de05b7f4d3824fcd6067b254db73ee02f54af43752c556dc366ba9b156cd4e33eb8e8d8264a51de4b3b4425837a934501b7ec8ceeb0b36f6c87fb368dab3fba077087f907593af345e2c8cbafc38227ad8d553e3f00e6d20304e8cf35425f1f7360816e1d4ab9ccf31b3f8274c6859bc6e5c685f21afb6aed74a7b2b49e6238de1ad3ad9b5eba62c9eeabe0b5fa88d934a6ce6b77e41df04449cda7ca5a43bc6bf62093d2240ec474c04eb947bb9de2cdee8507f9a4c7f9e7abffe48226f8227f1cb2366234e62db7d6eed48dc3bd96a47cda7a0f90f3864d089e0f62e7ac6c506868f90c8fbc9fc33ca17a560fa3ded408694104e92fcbf80af06e81b12b84bd05dec6767c7815e4aa6fa6fba82f00a23b9b19e7ac4edd88c3935b75df0106ae0ed9c8f7bd04d8d0107fe6056771ae263ebe80860c8249c29981f27d42656b8082cb2b912e7e12c3758af71d7881f6cbe131267e1d759ef7f62bf38b6ec0501767e4305118337ebc69aa50b0e0d6f18958abd8f87f8edb29bcc0b45d4a37caeaaa318179a9749a48169e121ccc564f1cc90c29703a6c30507522bf253d956c7b59ca7477db4f62ee43fb99fbe1a57c9602da2a3caf641d397bc5d79b408a4dfe5575951dee52859b91ee295896d688cc4b6e97bcbc0bbaeaefbec935c959818637a2ab8bcdb934c4c856955ed2283e1f1d9cc562db9bd368134c0f6cf7d38d14ebc7ab21f90f375afcda538fee6133814700caca57f76ecbd9e5d279972db96d2c46bda8d59b25e1785a9d081fd71c7f1d7910953c210679f4c1f9a5efcaca1e0f72114eb0b4bfb0158ad56f359652dbe1841480c9d9c89a699534658100bb364ad2f063296d5ee95115509907c40695cd485e3073d80df8dede6daef944f9d53744700ef9bdd1ef172f2bef9cbf4dce8894739487f6be35ef00d10da1bc17ea4413b12791beaa1a0d389ef99c4ac8552e10dfd389eccd6c4aa59c2f5934905a8f73a665e10478cdb1a5431c811942baee198674717dabe10c49fe0e83829a504ef944b3f0524ac6df35167f874fb6c4f7fa854624f2236a6e88b1954bf422302ccc83cd0498cac0542fa1c903ed188d45df4c6679175b4b20baa83905add0463cf8f264f69648bcafc363d8b7820576bf9a5412bbef96fd2df527f02ab4b53de949349f43202c7c05d151265bf48790bcd22fa2d1e359ce86867d69a2e1dea91b0c7149f28e94f0d6243f86a78c5e384e069dc092e3d3799823ea4d1cd1951868f7327392b761f2d936772f0a8214e2fb37f62b1febaeb6c8a8284fb38c83f5cdd728b2dc9737be34f69c90b63bf6e2fb250ea66575ee72ba84053801bc418e6a13147d29d56bf7f3b2a7811850188aa7be6d40cb25880a390d9e15e48ec9b5b84988f11ee549a36748b96400caac6021e885e641359e9391a57e013447147d55949b04ed3b2d414cf360956dc133de548c6fcb3f098ed375a319070b02da92393d5ec17f6a0aabcf5199c391dbb6014060689ff72732d8ddb43423045fa1419709d028ce20df4d7a3b1244a1ea9604898a2a343fe7906692d000ce3cb7cab1e8a9966d8d247d1f75dd9b0434c28f12374e13aca86a50dbea1a8f9db4745f66a7440adc1747b773fddcfb85e1958484460f26d3aa60549e2eda7f4485ad4c98d62703558616e05eaa5cdf0883f98c173badf246c69f1ba29d6ac3973259707dfe28d1e2184d1bc2ec637fbbe199385800c47077844193df37e4cdc333a83ee8b6419b98eed0da9ddd51d2ecc9870cc9028152138283cdf4c2348b1e0848b26f1b027ec1a2c3f82863869ae727e5e83e2ee883a47493097fbf90d7f653ba116f02e98551953631cfc952bfe2354ff1da4bd19bf35b3308c8b740b25df3065aa2997fd2485f293ab4031744d05c62e0f7b342103f98406d384ddc56154457a26cfa8962323fa0ea37d85c338de3229e9487e9a91bd2df49ed5083c24562c8c7a6cb79e450b0072886307800c40b1e66eb340a6a54da48472fca7890090fcb664cffc627ff46e145fbff7099677ccbf5960afcf612b2bd1c9b9bb2dd3e620be65ab9792608398ae6f951d9131fc250a54410db07fb397a1f1c895a3fe8cbd6aff2d6b886a26812e51356ea0e0ab3ac46c49edb972e6c9e76a52b20734f562341c3173314e637d8c9256cb53dc096cb34f25bceb6616ea397d6d4595a62b6c30e8b1eb9f283db091a8f26be3148a6be4ac81159559926931504f32818ee834bf0930ac0c63537a167cd276515a9b25dcea398214536e53bd96d5fd0533727ae123defe90454a41a025ac44398e8468950e19426c038ed041195f1e1cff03fe99a5b9d13847ee2d5dc922c14c86a98c3a8a056ae6ef698da83bd00f14af9a6f94072d0cafcd1bfd908d5d71cca1e8696023f26ba7aeb050c3a8906d26ee931aaf8e064610de915b0b059b4ade94337bc81e25ed9663b7c35ecc16f3e76a6d75e26de8e7729b38815e1734813f3f402463134fb0fcd25313bf2094aeebc69bbaa3ea27cf394b2fe809be22df1a37c70a938ac2b907eef6eaf2c75940ec498163b367c384ed4341b84806276ebae9d7a77b7f0fcf876d8bb452e3d60ede4999f0b8734d417da3a361d30b80a7eb47cf22bad03ee6b2f0d948c1266ba1a03fa3acfbd2df88091208ae5f05865db4de3e4e4b1b6d6ee3339a496aacf55428166d897ca70ace05a44098e47026778d8a2b9ab556815fb2991dc4dec087ad1778cbdb8a7c038052402a1c85cfc7b237c6b3930dd1dc4d007f839386490346c9233cddb9bd10dd95b66249e4a2a32fb8d04068ff5e77679a19316a8c8956f85125d773138856902c570a0d031a77f90f261243f62a99dcb194f43c3c1330da8b4d29764d328ba6800a739ea2b62c66badc58f25f3e77e9eee176f0003f3cd2088059dd74ea80baddec2bc58c33f950ba728f88e91c987527cdaf163ad137870781b350199df4c9807060027fd25566980fd74b27d0861c984ac67b29085fa1ee920fa01fb15428bcffbacc2b29fa26061b9c2a2790fdd9182164b86bb0fa8b8e3fa283f8d53b564049eb149120aa916b7632095309ad212abb926a4e5c84157004d03fee35fa11cf1a31871f8ebb8bdb1f9a8fa781b40b64dfee2f4db188b22c6dae9e8199c8a66ace06d5ec5412962ece666285dc04251558cc738dc6c85d8e771f83902dcb4a8a5848db12c7bd380510df5f8fb427dc8e23d4fc5fd91f3402d1e95b2835b49db2ff0ee096996fc671de08514aedc4ca6a5d021696f90e88d69185d4a68704febe83be188dd9a61cb6fa1aa5cf4188c43e41c55330257bb093526faf4e81cec633bd3cf07357291a0164ac691d882ce2c08f083dd0f837dbf45b3626896271602f1f97f357a6ba84e1a3bbb761bbb2d9091f78b813f89af6ba36c92ddfdc793fd170b4557b7ceda43c266641d392ffc2e66ff67c5a7a54e6a089c8f2eb0b161e5da7fbd78bff8cb856d9624f0a2ac1b72e0e5c1c03ec93944cca154f4c09a4ede5d6138dedd0183118d44471a8ebac3d90738abf7025c8b220807470aa3d4d9aa679c78df10fc367d87843a7199db8b0f8f6bac7bb7c33f9f952324a060a4efa9d54a46452afa73329e4e0e846e2e09ce6aa38dc906fb1b1dd85e88e6070ca60ba19fc96cef9ecd4f7d79d52e3020147754d28a6890479c8178e7f2008f7181edd696ecd49f8c9872fa5449f0417ddb3d020e8948063131b525b1c85770fe0f5706e4a79af02bdfa622e12886a7543a250e5bd3accda442dcef0294213b61eb7ff3223bf2bed9b9c5affde15605c51d6bea7a3fc9b6400885d73cfe4eacc15fd6403e1f9170a0e05d3413196b334f7ef9158ad11b304f09aac876069b22f5803e33722a451d2203e99b4bf49a5b0c5655e51cbf1cfbb60fec3e23ff220dcce35621be9fdf1bee25f9c3707523046d9874090d10fd05a6a45451c5968971ae599cb54e20b450a05a7ee4c16ae856036e3839de414761f577a6f2119e1bab8295af436f6817a0cdfee85004afb56b7fd28ae94d3e3a03f285f64f02efa616564f1b9a10a9b150f5117e5aa7586ad6bb060eea38cf5318fec8470cb21fa9f0fdfc4bb8a8936b88583ee9356baab06300ba849809ef7a68b2288da5928e115627e89366f9e399b4cb3da3d626a589955f30802827e62af85c2f37bd3bf381063bcd5e6f643aea73ea8e36d42eff5a5f4057d95d3549418a06dc16603ad0bdab714abbbc183f03deff65d465078e9a3907f407ba30751ee76a01f082e5dacf7a37a8fc7653b11ba5fb6f26341e75902e2492c2365005072fd7d92a29dc452082d284c6701a871005e99af92bd2a8a946c84f17ec86d0fa3458279bf9dedad2a926fbb1ed4e5ded1e18192b629650d81f187924fea5abdb01a387405154415d83076c173e8f28ccbd4619c3023208e686bc3f73fdbeb7153ac0e38e0cbd51cce8c4e5f498b1e51dd61944ca07c84707889f94c04eca9f0cedd90b5dbb15926d53669c4d49cf2e9db286cb3d5378ec8f70c85dd0856339766e276d5028067010a1c181151b1086358dc841bf64d9ac861920345238865e2dfccc330097b4c3773dcadebc81e3c418d270b1e316f369ee1aec5a10af9bd03ec5dd2e89ac5b75a1b89ae66cbd2654c1a7b673e857c74ca9bc8e1b2f24df9ff31336486d1ecfb2a42547af3833f758c7e966ca74b07b744970590451d5725ec08338effb68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
