<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dca9252f113558eee68f0a054b48d66ceae70927b7a1f2fc448b7dd0f7bbf38737499937054ea7b3ad77fded5773d30fccb42dfb61c0f695ff1e18f4e32d840edf5e59e25cb658b4724531e1f824ba270cdf58b0e96566f5cf9158530b0f8b28eddc5507a9d62bd119cbb70403ca25870cefced1f113a93ceb3df7202319baf993454df74f67baedb84fed28814a77814f9a4c124811fb7c7c034b1309de61f7cd4875c1c262cc8942082ab5ca28170f9efd604c903a3a67cc0ca011778690e0edc5eb90c2bacb30d246e520b8e5c2da56efa2bcb8acaa52368af204b4b627b0de5074357a0003099e7a3c0de27664df1f04d596c3fcf1ea5e29dbaab93018bb885b9e2b35792925db09c7655e2806d5ccebef7f13ab4c13397624af08ffb03194213973bf1d6312f9a681fb31aa141c2d52916faa7321409ba68913456180457f14605ea32c29fea6c3f6b8141e46e4d385fef0da738cf77755cc5d087516f594cb6cdd6444173d09a02cd289670ab035866237e392d05b6fe8c4451c4466c8190e3f081ea42c0b03ad695e8dd4066be667070019f7c8259fb4fc90015681e3b0af4b43f07024c0b0e3d5db53fee2af41cf20178b2f4c35ea39c3c881f5e48d151a88462bc18705ff0507e18ca4221effa080eb88c565047919a2879bf95190058b2e116fa0affbb5d9a75a3efabcf68308d5db402829155df4cc9edab4176e5dc559736cdcb08172c2b8f0ebc7da373b7b41131d2274915dc2aa8113f43bfb8092a9fe310f6783af9993556bf6964e1c1e90949528295971a651b908b5b4fff1c62fe8224b319edec9c1cac3868deed7831ddc1a498604455160a57a74532f90148d28dfeea7d0a0b00a56b24f28c670a470cb5877c8261ef6fdbec0f71e0ca45ba3cc6a029d280e4a54caa0b8451bc75c4fbe4d13ab79c1b909523dae9de8059230e6974e6f122e9d1217195734226583384d470dffc610509757bc5d5f72f1464aa1ffefc3e28b90571b322edbdf656775c2af359a2bc49da21244bb7a56f8a51b5c3e30f8d4a4bd1e4272b3878d18d4689e9996108ce7332e8b00b5d04363966ea2e5d4113c8de6eb85ca7f868a93dc83042ac378dae9dcc7fe7f37e393e3e02cc54a1f46801cfc14ba68a43ac9d51bebd6a6d779e01651c3c7a9e46b2a96786e534c1696e27dc1b1b2b1fc5285ac07f181950f8cf6ac4b8cf03b8e6d6f57199d83757452679c0e3c54634b2c370da470baf9a7ad03d269f4be673cc8726cc5e504c3e1d12c73ef86a3af6afe3e4e501e242c24e2f92a1f45fc3a8b498c4c43b05c950e6efa838de0074f35c177dbf99a56820699e75a4bc740a2e90ce37c6bac97607e977ffd8cd54470924b8d26e149150c9b543afcb7232dec0bd8581afa1c55919685c5ee8ba3b3d07849610ac061eb1b9384134de98ead1b1ebd8203214c8a53f8dd80b75492d017d2ce2a22246cd5574e594b098afcc5d9239df6e83fd2960ccb67813103118169aeeca2e6eedd0eed7467601a55a28e9d69d770eec1feda2d98ce52b915f16f1bca47e3ae5d450ce9ed38f3b292c8b477ed1bc7f4d751bdea773d48672f82a2ef91bb86fe5741eaa65bbcc58b3680f23132117c77f777e214df47de05eafcbefc76edc846dc0e4911e2407c359007ecfd3aad89c61922d7147ee94cdb3d9938f523b4451bb2ccfeab064f03769ae5b53bc31d3f7540df109e099a26e521eb7a368c3b758d337157e5c943bf5553b1c68fa868537eac59c4782e47af4fad7902c8f16f5b13b5efe6dcec22207568bd341b04aaa533c3cf39563053691cd0c663ad35f8e38518086ca552384646a354f865ecb3ca77a2944ddfa8ebc66b64d7953a8e22cc3be0a3fe4259ab91394102c3a6c05948712f6b3d9e082ac1456ad0a96528016b7933b3b125eef62d28693cd864b93ab7a5963a381094d4e06cb6eebb02cc7e0723c211adadc2f7dfe22972c2433df6475fb21dbb5144581766d8945145bb30d68b730cf5861c71860acd83ad68a3c75d2bca5bb2bf993f144c3cfa05ea8ecc7907466daa176385f630c51f75a5b86d9f5f34dd0b5fe8f3e140a8d5f9c45a7d191eee48893eabe6f71669bd65ec98819143aa2dc944fe33002d94da15377e20745cfb17337d19dedfa22291c88d803cef6134f1a23eb236d860367bd3e64a852d39fd48be10e239ea681e4a0eaa913548c8c0d15335365c32e6ab58b9492e55601c22001ebf1b87cb17a8e8406846eacb916a119be52af7467a37ffdd10ba927aae8defb48cbaf0913b96694625284228c796a8f43977d480df1f15d6a928eb1032b4093a9e2c6c9302a9ca59564faaf0aaa3707666a594bf0c9aacb8755aa7d4ead4ec9ec0ba3edc1b8202559e19e052d3c220a72ecf336a27a5bfa259ba434b7e91469036bec9dbde625951ba35967c02136f3c7efe16ae05c652357fc70359706bb568a1f555130c92bcf4def4602352952d90ef1e279d29abf142f5cdaa65b66645b82ea12950ad518169ac73a6c2fb5f50dc84a8e53fc5f1d82007da4a26fa62cab939afe632fc1133bdb3fcd850096ee9c1e5f2579cf3555cf305f1c0ff091a426cc22fc5436e85aa216bb4efc75b518e21878c596932812538daa18d53d6e3b6403c0513299c83e6702d54d061ee46884927a908c4634b6dcaa5386679f38ba5bd7a2f64de34d7da098484f5427b4d92ff1bcc9fc47503f2f79fe4d620d4203d0e2f24cc7f0be337f6939b0176fef802872ffd6b01fbe1d3e8cb3eee92a04b8c896a0e92f1495c62febd61be56d3fa786fab5939db3d0528bc59ea9445d5333ef4da64ccc80824ca91898e6731a089f71443391a33be03417a92abf79830dce17233f8aed20ac982ec6530c745a8945ef8fa6b2bf0e56ae4da18f9d31b4e824b82d12b3488d596f45ac498480e9fe9555d6ccf18187d30669516257215c0f0879da6faa6c5e93fdddf32e51bc7bc61577f9c98057c67e999b99f65750003a5206ac3fa25d60372ccec22f710947db5a23d0be5ecd3d76d9c8876421838b778521f6e88bdcff411a33e68ac6c4554f2fcc25321180c4e5ca52832c4e63b3cd0e3ec9ddf5495c1c8d3180062aab770ffb684811c8eb631f237d4d6009797b2858374121f1499af76c6f769db8082190493ee690a46ad9f9f288e403ef65966a62ace7a0d5f9c2c0fe23b244df9932e54743b972e5857fafa413c382f55f0a92a69b8e0b49e55fe05888ce97bc3eeae5668718ba90fd32ba89ac8d0fd03c87aa23919450d2602204f88844e51f3f20fdb446b61a9e221a11931a52d534fb34245704fc59c2319e6ebfefb93b601966be50fff65aaaeabc5fbfa14b55e0c216558a51587ac7f5d29513d2fd7b192393b6b648af26d5d0fb69bf1e3716f04d25ccc9162e8cbbd233abe3567ad08942076f979ad4fa75e29827e52b960535b43d11aad9d9ffa55dd34aa96843cf1c8fe0f9b8923a1ff0bbbd4f36b6d96fe76e9ce6d8f90cc82702891540a67ae10ad0443a4c1767c3ad35d977d39d62447a092582d5716bd1662575df348d906b53badb2fb2bf112ca29b7ba65847cc82d4448ef4330bb7e525b916070766db7c4e34b94cb1ea45b69a0bb1a31c641c24ca738f7fa8514c337bb2657ad818e3fa649f3bf131a5a58a10bec2faf301585ae66c0f6c6261ba8ca1b2259be5eb6e415ac97b9ce86dbf94e89dcdbebd934af5e81ef5b4995440a612cbb7e98f1f2b8257402ae79b917e07e81f37aa6da6fbd1bcb9c87597cd8dede5d6812c3412f5fff992dab451b28c5f557f4c8ae95d7d92cf816bc94691c5642a2be3e37d8d66029fa6bc5fb9f5c42601ab19d9e4e74c093aa0f0cdb2f08ae6090540b6632668b0f81f531aeceb876e894b1ab13b468567299b928d7822538ad0bfb74e4a79fb01f0c792368abf7b880f5e00f28f069b580c25a93497b15ec20b949e9f97879491b6becdb119c7017950fd5ad1f99fbef9e21abef2c6a319f11e2961b7f4f60779b2677b2ec232b05c154d6200c6c0cf129aed2d6efefe5613f76e856f0417b9e9a0aa4ecffc982f80138e6f084e18da84380e88d6ca839e81a5adfb3abc510ae2344a1b0873765071e326334027cc1524629e383e0d2fcbd62eddc371fd6fe0921eb0f02319d1f084ac21860c3c004847471f268f661c2338eb7c26d3457aa93e0400d6f8bf08e33466a456a1f069e94cecc88d21e81765db2260a759277003841932bd4503e916a1055ec02e6515c8854c2598e30778c21bd8e30a548ed784b452a72552d7ba42bdccc0915331e23b3fb79e98e7611a3364c1d81268508230950f7a4b08edbd6c6797e7aacf8c40b76f50be3c1ac8c609f461c56297a90845abf49e7241b9dbdd4ebd827da10caa1d28cb84d8ee571b3023eab742ec3f022370c4633ace7aa4098182750d5edc3cfa71a6fdd31c90f854d4a6360fdcd56b9e15c7b459c4a5d83f586a3fcf3d6af948ad01661aaee17ea4889801195fec90e8284936e5a6bf02ace714b9a7cf34abc7ff3dede4866a7556a63ccba7b9c13aa87c28b42865233c2af3ee4aeaa07ee0688351d5471ded75699e6d3783691aa2dbae92efe95712523a9c38be0452f70307541fb70d50c3383eae4c02f5c6f6ab711e0dbd6de95c4f7764b7f1364e4db6a01e6981505e0700469fdfd800573217d6ef047e74fd796f20967772fa220da782bbe3b3270d7af11be9a55da6ede7844decf77f3ce9e91a83810077742ff4ed479d7e28e8e6983a05bd011f2a2ab080b7171490c030a22511d9c5a3b6a031a0815e31d57c4c9517917710af3bce8cfad35d4749da551bc09a781f9c358e08a85d51d52ed2338b03e54a592379a055113853650b4a78455f685869dd3b91eea0a2ff2b084ba4cc8c06c5f2838e581d7f86a70c1cf74cb089c4da64cbee42fc23d146570ba973ed495007998d501e6137d05778f3e7567c9078567d72fc679cf4084ca8fad97254f49d04ff84ee8e0e37edfe9d750ef6a887c35e62ff7948f4339246a8c792023e6d183b133e99e14d536dbafbecbdb31eb27308db6be524ea4f0872e2562215a26b8a5558c54651c147470e76baf3e56571c85445323614f5e30f4a541bf1eaa75b8560f91b18802ca39deadef3694f9f0d7ef3708fee1bf92338a5d5081f156eda394c174b55124c56998a2b48bc316183c11d85d6711da7f174dae71e59c20d9d769f3cccebd0f80f44e5a56b61aa0e7e5d31c601e61d3980ccdb68d9982335a6325bbb9128f35adcabc30ebe2119f7035552955158a06dcd129cc3fcabf89ade5c352e58da53e8c5673f1424797f82e5ebd97c7fe5049897105320161b0f04e338db95e2c09276aee1258e11f0be307eb5b470ba406c390c3cabe3e37b87c003c941028c4d63a251b1c5e11e6636dfbc9951265d05de6fcbfb16f93d224058f42ce51c64917bec168605dbbe87db7cef574a57186a880631b64a6d2399a1812c035fac3e43dc81d224b2948bf10faecd816455d5b56dabc57716188ddb2ecaac26f7dc06445dc9b3b9fde447a3c1386648f6f1d32c22e9a46b15680b7afa8cbd55a89a0977fc5d75d7fdae8872f6adee587853ff432e575ed6b4ddb46438f291b002ebaaba967767ef861a3c2e7da401dd6a9445d7b146611cf75f11fb31a0df32edb6ec0589bbe5615894396b0e0e877af4eb558fdbecdb7924b668cf8b3cd29e650d1bae44ee8fb21518043dbf68904bd4b17b1388345bc504c1f17c005a6236205664bc92d98333565ac2a426418547313ecb2d0da8998a575732872a9de6212f0418f9f3a7aaf057ba36e76ba139a8e8e704258a4bb96f7823ec1a60a5a67d632afd8883c42fa1cd824ed40575a9cd5ca8334a0dd563a5d56be13bd37879d801b7ac3830b2db1ce3033ad9ae29f1d3bc55e39faa6008d5690b3f74f332c250480a220a00327f3884f8e13099bcb37009ab9a835ead1f1460a94625fe96843c2b9e965cd6e75353cdbe5f55eadc8c32a8a35d0b66c44bf9059f300085c8429eb3e460afc23a9c900ae5e7ce68ccc2da0f8245aca3c78e44e23454e69f322e20305653980ae87e2dc5a0f47dacac249ee762a348e925fb88e1c0ef2cc08a23d154f7787bdfe36ab6fd4cabe38459a82034133aafb0f17f23a2cf5706721890b63608d9326fece660f1ebd8b304d45132444c395207f68ca5282852e573d7f685dd620481037e4dabbb3d2a43ea71af115aa062394f260f756885d84c195e7d534f9c57d290f9ae80a95ed762d200030a37ada479a728eafc7d4c16737bdfc82a5269b8c897508309368cf23269bff23bbc53d44339668260be82d46a1ea1e776eb3220e3e04de696bf707d25ca013023fbf41888e4c0c264a6a64e0d8e81d5cfaddd8c616f0196ebc3617659d98bb6083ce8bb40e96a8fe43fdc0478670329eb684e0fe9247962ff4ed61eafa9863a92cf6daf253b729968fbb29d716c2fcbd2a97080cc683d94e79b53c531cadba1c72918526a3a5b982ff1c8a1d58607ec983a728908192801fa7877be16be242fa415e3521db3165a0857454d016de7e9c06b45ebce0fcf82576876250e249f4a99e038300b757664ee9780a5adb68601737121917d737236424c8261d40789d43db9e0dae0754225861efcf97d6a6a06902f9a7af2c7a009c7947530255630aef4d62ba8cf44ff922f7c36d7e22ac53befa91d4a3f994a0f3453624d1f45e71f3c804b09fadd75e278be3eb65f5ba0f0bc37fcdd4bd4d0dca74ec6a71f3d6f26c8592ce1b29caa6d1c3e0de6d3b07819c38020afaf321d7f98a0ceb480d96903fbbeecd034588a6ca1246ecfdb8112e46a194783d17cf48db4bdebbcb0ca2bd7849b927dd025cb4468ec4babc5aa0f82cfaf5f1f517eecde0f9a85a6a7bfc42534fdecffd0df23803415312fecae0f2754eda0c4869bad3b61c57c4d872fd79c2c3cdc35f0be3ffb97ed500080aeaf241d225c0e8c6a6fe2a5162548c08d57b5a0aed2c1e6d8f1c0f4988ffcb0abc2550e73786e5972ef7e71fca19c5dd12a9302561295f6f73ed18abe661c3185d225b9d96b539a20c071986786a57bf80780ae8569e650dad882caf8f5fbb6035577553c5518584d699b2e0ac7db1f3e9af8f946a3991513d0db67c9c985bc12ba9e675b7a68cebbe5c9d042d3b7733b02bdd2fe2df0dd7781517c5a19c9dd7e3890b3ffd2fc1d57daebeb34f8e25a6625965c530cff2896c58d3af384fbeedd773a217279c7c5693f338097871d31e26db3362367130c721f55eb1004a565a94f23756d980d10f5ce260ecc3e0aa3bab974493ab12a392885bef1053a420e8cdbac92e9b8a8a3b898701204b12dc15f169930f32a8a508614ab5ba9d700e32bcfd96ca5867d0b256b83913dc76f54c9bc7be12156bcc3e8e3a8bb07fd826d69f3829cb4e1a7227fc11f451a990b940080b5900653ad7f2c57dda761a0411fcbcf399a4906f2af0f17e339bf2dda07dcdc2fcc1bd28c16406cc700b803c32bf7ef1671f121310271a274be6dc86e3d2dcb7593ee38fb3c48ea4c3391ff42de90acc2ad738d81810868591e36da0307e5c68af61afbf5256faa614b208efa9cf4f19873f7abc8c1729b229881aae2b462e8505fe346bbd16cf519f27fb6a355d24cac0094f26349e84eb6291be5a0e2705e70f32d4618f92da633522f91779e881d2da3a1c5be2610771ef21ce2a6a158cf6e2eddccd7da572522977c0105a013bb20d562e7fcd392eb81612c924ecfe961644e60361f310a78cf02399d4d6b1a174faae48913c24f449cb2c3ea92f8dbcde87cd4f8e3abf66dc1378d57da4e352b2c07cf32da0ac0c52cfbf5cab09ba9cef43b5556a0d3f92ea1df16172dcf48ab639ecbd751a37775db863c3d497686ec51d6a438932e223f48454f68f415f96400b0f0f951889d857f4883c54c92646ce947f6d4ebfae69372b70aa640a4b4e872c24a704dcdc90e20d2752de6c5cf3eb62117cedc6a6464c02846361a202079d7d9894fe0601185f1595a1b3baebaa9ca3b41b12f14ac073807136a2b04a098ccaa9484683f422fabbd8eef7107c4855cb1e8be3f31590f22f070cc7af38131738cec30ffcbffe2636a0d8476bddf612788a4ab404aff40f54fc7f835026203b051476ea426fbf590b2b1060a8d868b1155509ff7762362fff4ff31536a32c3e2becfa05f7f3ef13e8d7609689995292c0763e9ce4d2e9e876233383962a043479a30d2d7a1d1e694f00e948103e4dd7a0810dec4a84ed2fd5208f514ec5b4fca17b2c09cd124b228316235b70e3f961021d791e287a7d9125e848bb38b17645c32fc03770a7444d720d3d77d92e282a55cf3cc372cb18cfa683b9d38b3b02fc18d4b8093d10131e1d4f0315284f322d6ae6134434e0e2a564f484be1a97b7a4cfb36dd0789e5dfe582d3c4c8b5bb3935b405631816394a5371f90cd965c9673ed92ccc3ec123a3659661367cae007dd1ae183250b8946454d59f1723d7800c19c49ff0688d454a0652693965c306e6e2cd0146c4c2278ab8d6979e6e674c0be16a97d50cbc390934992ffce893c4c09aab0992e678ad4daf553df72ade5194e532ac577e5881af3b67735aa55712db3f7a3eecb7e5709866ac7859d3d3b433258588d104eaa1a7035902e2b19a94e64174cd311505ad708cb202c97c03fb164f6a7e1cf5328d1f362efa6e259c6374a35999fb0d324a988bbfe7ffed7681150f71f7d80bb1e0d2c06a28cff997d3946ee8b4ba89805c82c2854a149897210957caabfe1719544ba48ae566b6913d1b525e53e000690f38edfe731ff6c80360d6e7660a0946a27b7f068aefce75e4da78e2971d7f7bb081b70105ab8ec8344373c77668d75d6a763f45234bb6a9d526351e886bc65903c039acdb83ac5ab323bfcf36fe0ca71731dcbfccc858c6be37fc864970edb871439719b3237abf070bd83f6f04f3c39d19e82ef26da37aa28b31437c25263f2e4410f3d716a5246341b5083069e759864ad7020b233d167cefc2881a57a86fafb9b29c7e62fb07db78adb93ad909e8cfed8953274f43317323feb7c5b3517d4d64037f8442ff2121c527698b23d22f5bb5e76f5b5bda8b285e3aa7436a26fc31cdea08472b8374ce43143c9b6f1c27a2c141af75e4f354728f002e2046ad5cf3ffcf2ab9ae6e7e76e31c738fada89b17ca200d99b6482ec218ee6743f3cc94b5c6c52b24bfdaa18e12a63261fb32482eb863aec687ef648c5229c748d9dee73d6f60eafa3d8d573bbcfb66f9a424bc6b30ca4788b0a65b3a274b1619e0f1bbc6ebc85b748524c60b140e42358eec9b2c4159d412cc68ff812b9eba2c3159f22fe93ab0574e679c1860695d2bab8fcf83242c646401a54d763770e7c3397f4e15a8a3f76a4db4e1a73178f466ca70a27bb6d8e78cd698611dca06d5fc690ecd4dc7a4b6c804fe9e160e9861d88ed1dac9699ec0d4c8a5a1c8af3a242ec287bde150cde91f2c4a4ee9f208ad78e5c4804df12c7892adef11c61a68bc7941a29fa3973de54f819b42eda76200c1af2d84aadea16a4620f2d207659eb032105a02a5ea0c157146357bba0f49d048382aad8e8cb0173652656801b645f2a6d0f189f7c23c254c945e00015ff2e5fdb39193a7ace32e1dc4ece94727eda440d88cde491c19f7d5aff8ad4aa9b0ce2fa8044076abe99eb49ccddac940a2a9949a5ef657222db56a7b97365d0d9a8f88b9654426a836a1e2600e8232795297f65bf37ac27e712a9671d3948eef5cdf3ab23a028fb192b810c1960915570339390cfb4ca0162f8c03b8e69594a841acf7fac061a3b0b9e2598b47c103d58f0de6640d33945f9d07c68af62f099f2254a9b93099102869ec1266aa686c422faf6359d15de94c30daf9a811b26e16348a89ff9f217eb8c99706fda11080165d5a4dbe248130b3884ef66aae98224f42d17c70698b9230e4fcad95ea4beecc2b87130b040cf4a9f8ba652bab1f2078d7571fb80d352ac0a333dee4445b3f940c72559602e2186d5ea21bc0b231bf517e1ee4981302992ec3c32c34e1c9d9f823571ee07f5843623f2013ce6831e5a69b3f6396b61d99a8bc7390a4d281182359bb7bc2262cc772199499fe076da079a5059da3373622abf540fb68376f85aec336b702558a596539ce526bdb8e8345fdb6c88a84dd7112fb2d23b5f75227b589b80eef68fc6b2da61696142aafccfb21a47f09c38c590edd7f475627d7b21041e7dbcc4eaca868cae4cc9871a3faa180f1f4d660f8170f8eeaafc29a399f80e924f283a9c30489dfe6e290f3996e19cd096db6d713c8b3eb73508b46c63bb767f38346df34541c8ab4b294fea501d5f39d1d81c97470bac70e190eb933587ef296c104008eaa6642d32f369db357e977983bbc578bf2bf9e8d4675ddd9a783c7be07f2ec454e6e5e2e5175b6d7243fcefc01f38a9f87cb6d39960950ec78ed37c6546a7389623050d17c7ce38991c0d5b048e9cba928b46a0475140c2cb0764e34067001c75fe66ee4ae931dcd413b4e56904d49bc751ae22d1f6d7f872178fee97e029d339d77028b774ce770f5549ede8671e3b219f3e1ac42fdcea750238f42d64ddd554a1eec6af053982b2679d5253aa93b23301b1c7086f31e29e2b06908c89078b55263469d160808a58b7124965f00da55e9ab8e2725fde1312a05a7297b73462856f147ff64ec9e0bd1bad18d13c14c0fc0a495a93d2ae101d45f7f5054f84d1ac195f2b6fcc47996d1412c86dddd02502d1fafe668bb7be471c96115ee47889c0712572fe4b33abf9859bad9dfb34021eef65ea425a1a4a266f9c09ae64cd47dd90dd84e2d98faaefcdbed8caeda7dc394b53a838f2beb49b113d4cabcf61b3e899aaf7deabeb39f5cc7d16edfcb8c26681b71594cdf1b7b0277f8dc6ce054730b3fa1b91da0fa1ad8baecfc3998e8fa08d6928c9e9d74c35602f7c99c77b30c520a80ada698ceee91a0136371c549de0c555f15a4ed819a198e921630ef5ea212fc5012b4e88665c38594e7476b4efa19319d165d66ae0f57b83e302faedb817ca6244b53b159b8d38e50d32af3dc16609ffb1f0e8676a8ebb675947e35a680b92cb33660e5789431526f764b1f64ed9941d82819d0cb28fc516a94d4ff6e6ae3b9175fe83dc65206ba733d3ed35b4837e15ba4059c9121b4ee75f466caa9d2608d2444659db837d8b86030c679aa8778bf6b54bcc5386cb004579df8a0fe1d5f7b557f69f25a045d76835d203dc1a600aa9670f55acd4f96c1d54022636e8e8d24396cf8d1024e7aaf62386aecbf594ffb675722774e0372495e6d585b62c190f1d68f511993e6fe8b603cad8d8c39487cd5349543d888943b9dffe293e70d75bfdf0c506db3e6639ffcec10af9d9c4f768c797b1e28af49771562ff2b6d40780f04d24327774b50a35be1890174b3b816c52edb35b45d4e4dbfe501dbf2c8e45be66476c2e04169c6a9b796fd8f267e0b6e98600aa003533185889d4faf268bfb15367ffc6599373d5109f57d1eee6a189f278651bd2c3e69ab2ba56c091b82d451ac2d43f73589cf8dc6347d7b4f26521e7c96a91d4ee6536042f86a6c968de8a7318ed9084ee7d3b57806a47de5a046c3d5883131b6d371fc7bf8ad60d2e5ba569eed1666f7540a27d8860c97899ce353c289e870e252036329bbda31d5901af7d2856df39e93da231b5b65dcfc1ce10eac0e006b4adc5de3ad94bae416de678ad8c436bf137dff3c2c7e6a8a7d23479eab124d1236fbef30154380c163ab8c7056d5f06ee0b0cd6ff791fc3c5e6a650790f10185229179f27c2a3e175289ebbb82f1d8ebbdf3c94053f9aafe34385b48d25c8838c161a8d64b46098b883f6d100baa32166d8398715d419b84cb4a291b249b0b4ae178b28537c69af66d3cb744c7659a65ee78efc60b1b26ae57d5aa36efd618ba5bfe357c48b1012b8be2035e918b123fc3a9663162c94ad2f0c83ff435b1384ae60b5c332b4dc3cf8ea3880ab967be8299eb6a2069a8d7417d29f4339e2139d70df69f54ab6c22a5609f301b1a3019640426abdb58dd56ed0d637260c61636fa0259734b47bfb624fc14caa7ded606f57247697e9dee3415b8f3a0d4c88648ca2ba9e7597a926e80c31aefe71293ac5c5ffba9a9368676b8056e9cfd224a853ce27f56e7133f81b2c5f08c810f76ed68634b2d408f76e9b5cf980b4d3c234c529d0e161bd6cb7a11d6de14856be550d5cb82eb9907950753751ddde7244087feeccc38a2bbd628493decaba23d7f51b123063e93b28585475ea780d14f2330d6b64bea68e5a8fd728489b57c2354ebe6ad0c411c31353db05a62e2c5811d5245272d3f4912acde44fe8fc87de0346203004e5270a72d51d1861aae492dec9b5b521197cca55ca45e8b06f354f625bf3d94dd2f44143c474b909fbbb2466d6e6f3abf83f08b6654b68f5d6e5ed690e508acbd1143b338879ccaacd04a6dfc9c54097ba141cb988c0853fa7768b9fc025b2f6a4262dfda832f45165b10013c894c521c0264b1dfbc2e717805e1603daf499923708b060e7954ccb3a976d7c4502a438389b3399058d4483ccd02d42d3c08eb52f0f4150067ea73e21a9e21788eab64dbd050ab9796e8ce9b1646838d2b9574e13c34b9aa3b3e562ffa7a2410e9565483c5003199c94f0a77479bcce44377deae1aeb7358bbf96da46a5c93b54ba8a3245d657df6621f1b2af587d73664f8ca6c08129402266a451f063ef873a1b9a5779cf1642c94e36049b7dc62dfff842e6f5dca02849a3dd881f63421ad37fbb7b46b8c0b524615f66d11bfbb45cbceb2e97af69802d0f86ba4a02ffc7f437d19a8a0bc90d410c03b4e117145d58606823ab97cff185a5fbed23dcc33ecc53666bd42f448262a0fe1ac10b5edd0a044ad6f268357615759773773c8b6a49cd32e96e882955a76abe3e0d09999dce97ec430c1e2df5521ee6df113796ade096feeabdf4fb51e5d129f2f0f0f287eaa88825109e8b63721818f744e557543160cb20eff3ecb2e0af83053e35598caba44bc66e655fdadc9b3ce2bd9769b336ce33cc830a326d01a11a98b4ff8560fa669ac028b9ad3821895c1d54f870cea8bf23cb6f92779efdf2a7cfc5f5b7507446f89143063b50ea219ce24f0ea3d5cb4175ef204fe1dfd749e2863c438ba0f1b9c9c765d0f465ee65ec6b8b021a0328b935c83c0ccc74a67bde85cf92b8fcf26b0dbbf7d60c1ea2ffd93cb371ce9c32aff69d9e0ebdbf7011d790b2f6e8aad6b206c99b6074741b17f8931b955bb2ce4c35ad611967a0f5fe5e07ac9989cd5ad591d2d7fb267bc6a3577476b77a1f60fbcd3956814c3a35b06757d4f28c82ffda55f8d948bf1933b7eb17aaa5e56c67f95a4a52b8b3c77d6027bbe29d91b1fb639cfe865936020f320726a8bde2757f2b307b5eab85743218081abf18c27c09d26cd036081a4f85adeb45c6eefcfcce9d8820a08f316b63c54ce172b6579ec77afe095477042deef9b01c6b222d6f25c205ddc841f7bab6a634f7d4acfe9aff2027b17b15dce561f10c9e12e5ebc0c8c0d2b78cc63f15e0f1a64c241f14fb79a7c7f8b265b0d5a38ae9ff0299f1a8d6cb9879590521277301d498999aa50219d9e45d5e88a15e02686eb1d0bb4afbbccdf05f481536d3954923f9a4aab2de687254ee78728452e5009228af08e2af26b72357396fe24205640fdc18a9cb1b9943dd3cd7d49bf10e829052f5f05e541276d8584a98351dd47b6d41a63eb6cdc4719ff43a0f1b1facc1f653776a6326006a010c6ea5d0351a856b2e56121258b8ccd02a58dedd2a0644954a5c08e93a56997f69e538afd18c4efa6f967cfbdddb948e44d8ff99a3ed79055ad52c5ed92093bb4cc72dc6d5fc2eee9ca717266ff49be35d4b31eaf79d4e954ade70a1d53377d6e823f2082dcf54e9c31e90fbf273ef20dd8a1a30414c6a12516079b7b3644e3686e2fa05de8d2002c8626e722d3d9fece952086d278850b340f3a66dbf2bc53d9a7c3e9542e3a432a4111dbb4db7ddec02baaa5da51610ea13adb7779e155d796b8b8ef2bebf155c710d4b1e58f220e71dd0b0f70d10bccf50b377c547f9daefd24efc31f6f851fe9292cc926f796dedf4a2edf77a63e43ffb37feb62dcbc35b4952cce1113eda83424d127875cb85fc5f2251e5d3577e355f7a9fe08cabf0968238a35705330672892cbfc8950b1f82003a84e3706d191d71d0a322979d49aaea2c97db551b9aab318c89ac3d037d45797c1d508a608ae9ae0102aa8d9c3c5df214fcd5e8a029c8a98dab9b4c766a65c1644d3299925af291ce8d2404ce1f7c793fd1972775cfc277ec1dac847f38162a26a2dce4716ec3bab30bc8ea0d01e76e7d6f69377a0c605616dca1f6bc989968dd8cdd300014d935d104f1766dc4a1e1d53f522eee85c3db4e278076e96551516171c07ca6f84fb4a5952552bc0ae69267eac1748592a7f2e9b979e8aeb6181157f56e8055802b008be66027e44b245ca8c69d865eb769333abf623cdbea0934dd9117bf6e1120fd8dc582008b541ab07f8c721d082185f212b588169a5c6e03711da85eda9fa7e611ceac19a91e668cf1006c9324f732888419090e5ff1f75bd1644880b7530cdfbac935fa193cf713724e333b483e2e6386b30a34ebff0822d43f9a2580286318d186693ce808877e9662cafdd5ea9998091e8a443ed76f82bdf51a1d766386f283fba4de191938f8d23d6b084eca05a94a9bf344731bb447d8965db4ef70ba3d2a332a518540df36d08ade2f5c7c2e282b656b4ce7227ecdb948da03b92d394a5940075e2f16b67924ae9398f30239496c2927b69fd383411f0561fa416f03692dc66a5876a28150b3d78813a65413b0da46ac4ff7e34a2537bdd15e589e038f7ea91cb81e6ebeb9a898a27bb8068b4e247272bcdf05192c5f627bc4dcbd3103870231961f94e94a02d580efc2febd64b76aa2cb0aad11bf8ff41f7dc4f9a8122001075fe3f3fd5f795cd00dac91c18539a88316073228231e237929872a965d95d61cddb3cc0b36329fc0519be72bb3d3933a73dd0699fe8f51ac6ba20fa5953187db0384b5c746f57d1a2a571432f294ebfd4cd3fb7a8321ae5c7dae7826f760fe16907f0bd869651f463632d45d50ddb31a5f863a33d644245c73fb6fad6ad9faa5098ebe3325c977ddd7b9b912ed75613895b97f8a4420ddefa2caace8fe9993cdd94126f8f161c970fa70e9a76ac388463dae151272e46546e489694da56bc6e82a174dec455ae2f17ab5899972984e9013e3079f2d26fe01eb8cb6f64de5f28050699ef280bc1495169baa419fecb734e1d4dbeec9a547227f4c610c26ed98b7d479bb6c9617db2170a27e4b2a6dc88c79c8d852f6ea4944c0c3917bd9618d5bd43ac31cf98b1aa20ca4e3f718df606479a2c44380c5ea9d53f4e9ed2e1e3b33fef528634a177295dc6798741ef23cfcee6b032ffd289f0ff65db5e12bd21cd3454e0628f670685057e979faca2d38bfb2847474a1a0e9554451908639f86d23e1d61d8664afd4e12bbca234b8395560bead3408934bd8de346477f0b9625a9efcf10224a159e2c158bae9917954db73c791ad38d7419ff5db662ccc0c61a224919f7e59a72394a8c745eb30ee1cf5c88fce683b14b748807fb07be59643b475762388a279b13dc2ca38833f7585c6b6958e8202bbd83d21fdafcdd5cee7233e5365df10a4874740b1c7669977432f2c09b9f5f9fc5bce6ffc2d7474c0a042f031b1914b2ce88ae5e1cb22f573c03327270de2748d19f721039f8456af06edfb2d5a6c53ea4e027a9db08feaa98933f005b39e493d1dabbe7075ab6a160940461fd79141390ba05b5930fe5b9260bf79bf363555063f9f4dae1b608ce9f1e103bc4a21db0ebc488487f4f598988b01b692d3acd9a68a3efa75fe04dc6ed64e26360af25111f562e13c99cc425f852f27d392239a281f42929265aac6082aa7e125b070b283f2158c848014a9ec9f5cd8b9e87da6d959f2840a03b40d2e8379f170e54b715a5689e948c65375f527ab742cf0db7bf35e2c40897f1e12bdbed7266af48b9226f26ec6dca16c9521754220088fa3f6231f95ddd038f77326ba43ed17541f055a6a34185ca7d833091f4831d0d6ba3ae8a6875afd1b08cd3a31c9a8680580a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
