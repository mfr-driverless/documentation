<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1485fcbfc9c82be05781542ffeefca012d05164b1c6189ba625f7f1a6bf7277af33780996d9be5656833aeb2edc5b68ce72721f839e1f2956c94e40a90c76c772140a5ad7bf3ee87912e1b86d6b4cf4e80048efa78cbf220d386b762b13cd2c13df645b039098f9ad4e79b4e2444dfbcb959f4027c768d635ed750af82a46b245a1073d3e522b4e722fec0abbf87eab59534a3572b6df786ac4dbbfc37eb9d134cafe6ecd567879f3418dfd88164c901b0ca17bb5acc2794d2cd8c9711ec73f82978f9da9982dccfc7d87fa578f0daeda6bfe85a197f9dc01d8506f49c502bf3f2dd69200fef37216a7e0ac8776db170ec4cd0acf042ff3db89fe21626747fd961cc1aacbbeb4bcb4d3f788fae5933849f5a1a9bcc25c0f9891527b733ff89b5897dee5b37889ab8cf23d08ec9fc60e85acdda2bd8967760d6f3e3495e50b6a5e22eeba49ed20f5b7abc79be05e0aa8815120ffba6a13073baf41fef0056e9c42977a57cf51b8643f95755745031b9afadee00e85dd4bc53dad42772316c5ad64622aebbfada127c876cf6c86cfcf9230ff5db608417e7db588de4a2adfacf210d3e84091cba0abc0357ccd16556f9a784a8ed62c56778dad7764f31ed66f2d11c345618c46b18f016c9be4903a26abebb5e133671caa8ad68821a1a946b2bc22f262d76146877f2ea164e0734df0a0d1130bea9016f679126954d0394468846c34a7035ffb06940c50c4a8f8d0546aab8c52671d466a2bf455a3190ec48eab9013665fa70f297f94558a1dbafc42c47a531c89f7d4b1b592c657ad1dd6a108958c4d3a0c50efd59b4803bd58363ced449210164bed79e6ed9677668b49cf5edb3861d20cd37b3addd7b399af700a1851bfcfc5860f439088db3dc622e827d5d741afdd9b5d3473173ec2eab0dc66af331232bf6e4db1eb665941a4a005052f7fbb8ca845d5c2de26783ad36c1adfadde23401714bc9cb91dfb178d02bdaef0052735e0f8aec18139c41fa4d404b7f54c81385f7dbef404a6ed82fe4ec87e1b401b58d7763f017149d1dc79ba8672be126992dcb477f4c64d5bea1568629eee529935c6786eab3978bafd20eb9ec2bb856894b4385d1ec814c9976dc9e54d3bbf509d7fa8831b3e903c2b40b1791ca6ed165b88d5591c52a6c6205ec1f3426e34e71c3a5dae9a79a0061cd5dd5cfab003d010add7359e7172a946171bc26e365407842e89a29f499c3cd0f09507e69a2f200c4ee834e4fe721661d247c5ceb40240581461d8ece0cf37e20270aa4917a316d167f7c9956ff3c13e71db2c3ba6fd5feb79798ca5959ea01fe6b1c607aaa59cb7a9aae45c5d8851a6f03a12dc3341db46eb6e62ba38ae4960657702c16f67bf8ad7b88f11bda8635318c1d10f7248008c05405f955e7f9c296d3ef812432294e11f71f26f3a8efa118350aea3db2fd64bc109862fb823931116f6ab2c9bc46c103dc1b8d7a701daa47cceb83a6d2dccd016ea256adba7f766868ef2f5d04aa67e772b2acbdb36ae66844618f9f60baa63eb9f5cadb3c48d9bbc59ff72847844c6ed8ab101f34bf3c71c7af4f8481f18e95dc1597b02c4983c7cee25695d4d632e369c47050c5c5e88ec7c9a2e521e5384e968352fdfd7512cbaeb797e5cace9daccca15cb4728eb50bee7c876d1f010eccdcaafb7c13019c7fcf98c01540d30ad55a9b400d2a5814c817a32f9099b9480b5a9f9aea31486a947ee17dcfc33d5f57712c3fee01fd399c3a4fb6255d1e6a0751d53216708b82f225840f7d50a42e16221282656dce2b5bea498ebd8cc013b365ed24b31c984881b1e799b93cfd7e1b1265f45042a1e1705d110b56b642d6eea92f58f1ef31fbbf4b2860b031a97514f4e73a9f9f93bf3959c52e1172d19debf3cf369a828ead673eb691292422e522445c5085a165171e44fe9eb2c14c476978d1a87ab065f2ed97e0b20d12193e6dfc86cb1952f0636b21c5be51795fe7a5c70fc55aab99b18cfcfa63f65d7a98e32153454c542f747a395db6ad9915402897e247789b9ac568ce67910f21b96d9e93f8435ee42225b3dcde260e58fc82c1a9f9fa5adba1030644cfa75767bc3342a5402a4ec39bed74d110065e146bc8142f98d4adbf813981a5b20e4dc88c29e2326dfcf74c1e83e91adbd530bd836702b823d4ab95c5caf2eeaa7faedd79412b2e4422a9af079290ea9cb624d8efc82808474114ccbdba1cb775c8a508ffc79041b64d14999a1257f2f5034b43f883370997789195efb7b65b216b023fd5caa5e5f263e126c77dbbae452dec08ebf1c230b27240421fe3023dd8dc2eff0bcd8c7ce1798c36448f6f2ec5a1dc50f4273366bb3ce4a8f85ee1cb33fa7934db3751aa42604b42122af26141cd37486a2eb4a0af1c9caa24143f2d1be48d1f8834b3f97ec330bae5c783e2eecacf2bc30583478026ddda1e148d2f4a557d01540740ca456aeb50009d36e9fc2cffdc08241f14552e9be63b1f34b5dc0371ef29e55477677fecd28c78acda0132e295322ab3dc398b2dbd4c0d42ccb9825b868aec4ac0c5e8b1b16e203f49a102656c881bcf8182988a0a2880787fbab130ed37c2c9bb12342e763333deb00244a6e12d8148f3d7f5c8373babfc815f750a8132953a75314787519eedc622b7c619d60506922b9a553d8ce347618a0d1c2ba645c9543934a4ec122cf51ec899f16035d4c23e790c1e59a7021c5e55132d8fac87c85a401484ae879fa60c7e8f5a92ae3f23ef782d2384b83f10c642460de471a1396585104f8930d23ff0edc835c0ca3d8880b340d6c42208fb0703e0a62568c4d848ee29626c0df101ae33df03087a4ea9e59e85d8fd06476ce5865a25d0c75402f8d9b5b0f032e70a8ad347fb6ee0b4b5787b51e538ec3aa6b278e1dc353d73e566ff27219cd242dbcb6cb7aa053478ff66d1eb6b1698899ae68cb173cf0e23fda8254f3a163dd79650c0012682779aa080146fbe46e0795afd9b802b86cb016214efb21c72ee394c961a02db2fc97663bb79b8aa6e50c6d59d28bcc18a19202887da62f7fe4b031c14dc37635868a61bff0cf2a4b71cbc9f3504bbf2d2f4c28e276ef5e0647dfbf4f0ce5541c4f5c07d50642b57669099d5cdee46d00eab053b608fd786e2bff8054ef2d32bc857a397cf8bdf608a1d7deffc331b216ed98f15e2cf42ea8caab1d23323615dd057ef23b3da0501361d37a595c506b96f13008e22921faf4aa5d5b2a115d3e398255babbfc749b08402f481c3651f02d45eba38e62f850cd75a82a74488c5d736dc4934f33314c7f0f90df10d7ba7318855f1c993e5c4525806dfa8de5658e50940d0e98fbe090eaba6ac3a95d74b2b59db025c0c914d31e9ed19161ba5db94b52600c8ae0277f2a4041fec7be4f3c27ef04aa90c7ea96e94b85b1b58c5b03642fafe3e72fc6bbf0f31f7cd8c2ef9dbaf5348951c6dca572df68381619460cd0e3a368a79e6605eae74da661f12310c9aee2eda9aec512284355ea646fae7d505726638c46ac0fd64e888559c47887bd2dc879185a607ba0457ac792cc7c511d5015155293322bc5168259e95393a3f605cd8d27d344cda70b6667f953929ddd9e5ebbbe123bc07a55cf7d5db057ec0cb2e581ed20f3f3cc0e604818ddd699bf7264cceb56b1038e519c2bff7901c37985e72009b706ec292c6ddfdb078f9eb122d43bf49a5faef958a4a3aa297155c829fef3683b26d165fd425a12c27fd4d3a79096f747b4aaad2c8150d7cf3582e4c3589a68bf59a2846110eda61c15168c9d06adc745f2d5385648898ef881db09a6a119f13ec06e90c2d363c31cac454e64280b8428b2e3511c7191982881fcd5711e92d55b65a13312a79d932a141a024e9b0c27a398593170454d63a6882a2c44987ff9a7e6761505fa2d8fd9803810b7faf093f205d8083e78f39b0647e4b874c183e2c2a6407c2f3352061aa3bd4582b28bf395e215c57a8c46f2cbbb98cad326042f37de037cd0560a623ae81404970a7375b295a21bf8a28c27f6b921dbb90d8f1370d876ee3399fb4a8ad61d51fbae20c4510a1f01064b3b62626a0653a7b0781aaebf6766b5f23b6e76723eb8b5868567724dbe7c62367f259b053c0d0ba3210822d7be4855a2b19a50f144d59a1068c41d61057c8956d14ea2d0b09320c752d10c70f8fcaf0266bf2f7b55718fe76bcc3e4c77b6351bd49b1ff296381c348aefec0df7cb4f5da5e9b9c055d25e20a2a654b07a84e0136a09c46a11a3d7eace05fc6bb82a7ca6466b12e774e6c7bef04b6023ec04fd21148a82461ee858aad4565287d04b36d44cb7c50cc9858449ca80e5c995fd75368b68d9265ecfd17f3b4388fd89922fe2cfae88ebeaf270d2a34f855c930698784434e80b5d891bde1a48f5cf2f82d8fda87727b39cbf07ba256159910114e6d75ec0fba18367b3b749d8afbfdbbeaa4b5214a4ced00a6cac3365f0383c7ab4d36a3c1a57ddd2279773c77365349a11c47998e65d5e872a6250d56a851f62ac4e0289c4f875d711802caab9249fe9048c3a657b6d5d5cd77921c848f4efbd3c817c995f16dba53428ec420cd4398acd274e8c458d18448c4bbdb358bef1b3d5249a8ed8810bfbeb14773a3249047caf6b75d875d92f0bff8f54943e6de8ce924e624f01cc3536641b104afe075af9350d9359e4e76987707a8693d348b2640c7d3141fab1c1feb197fe756a0bb350cae17802df7fe3227b9b7f69626d86e2f3bf3da0eb986a649875d2cc2f249b080cb479428037066108bb9d527622a55dca4144eec72cb3c425f541e9639c9a021c36e93c6ffb5c880c7c0b846bda8bc77d89ad8322bdb74a5feebe98c196a9b9975f0e30e59ce6fbbd52bb1efb40bd5b525afa6762b65a46421c58ea9b1424a8c3ce6654051bebc1a65248f8c022e383885c8af70d9b9f29bd4a9f73036c688c709a0950d1e812183a4245c2860fb256e91bd6f217f6b23ea6003783d07cc4b3ed576fe61fe62f7120d7ea53c621743bdb7b302f934cf6bbf45c6b7fd54d4557cdcbab751406ed1138293013271406faf0351cf99634f02e9041cd85cd5b27475aae678a429bedcdda40b1bf81a1c0cc137c387fc9d483247d200e6d8f2a8554af3f1cab52c18cc42581fc9835b0079680420ca870599192a5f6a1b4148fd6dd626e9d8ab8bf3c52e3283201e6da8b8482b9d84dbb5b7e9a2be68f4ba831eeec879fc11ce06f4e711c1c7d44bfdec6c5df343a98e1a717fe1919c0e26e623a4f1ecb436963ed80a7477c3a52f1aa3fc0975d9ded37701eebc40423ac8f01f9a0fcb1f2bf373ac1de1908de3459200a0e15b87fbaaf43f5b99bb9f74b726914cd2e2341ad0804f8f28b0779acef474a785f8b11a2e4803a35826af69d8c73762541b4ad4e751697c15a9c46269c50d129d54d9a4efe4629543242523602987d806e7461af2280252ae0b0c40d87005bb27f62c3ed8c191a830e5df0ce98a73a4e3a283d82ac7b3c4dec27a01de78e2c96c807db147526c6e871f7e3fcdbcc2e15f9b4dbda5a4bcd1a1e67d6c6c5b1e3d7bf74d1b8bf9c497963fbec0a2a0dea059314b724c644a834b3e65ea70236c26c79bbc5d995ea8b5ddb15c057f39462678913a048a535c2dbfc9c91ee3673fd61afbfc26aefe6584217f3079d36da738e5736a88e28a6f7b100fb8096668f07294b45203a6c62282b067dc75f5f648c15138ad77737df30b8178baf6c47da0fc5364f55bbbd20514004f16de90f829d6f3194e17e6bc49b7550d268307b1de5f1dde64c52886182ad9436d2540bb4c2383a79ad67f2b90e2e01080230e5f89eebc94c059147665d525b451bf2df20003d34efec0b00b76039a4379a1c191baa6ee46d110fd8e5146d5e0c933943dd364de92f34d63bb3f62af5950634a9c6b0065a88b7e8b169995f1b16377f8a604fd54c4d19f7be9a5f2821b1d900bee08232b814e2a4f791726edb93d416bfed68eedc07ea75859f3760fa2e65b71f62ae3a82366b7634d62d8db0956c3819f680bfa76305cf17f383ce340218d4836932438d9632be9d02a4ae82892163fdc37e1624fba68c4cebc46156e64ccf136a708b5105a6108e46fd7933b35c49cd0ea9a58c548696a3205b4c632b1d034da7da4f5a2327a3855d95058a74324dfa868bfd628b162b02d3a043694e8d2e7c2296d124fc3f28152a36c14eac04f5adb1aae7b2081284ef25e4a570d3900fc1944055ef7fdb623ef6f13f32471e0755462f6c9e54eae56b859ac7e0aaf7752e7b10fb06ee0bab325eb38e7a365007ea8ddbc07ffb4b00457b1270e1c9e0efe3aa574c494ad72b2304574ac0d21cb3a93e753365ad14f128a5de7d14096ae30cfa1b8a534c73bdb208e0217175bd7972684bc08e3baeb295992ddf5bf36e360609898032054886d991e51d5d0a54e2721a8aa974a82e7bf35ef353ded22e119e720e172d98a5bbda19ffbab23646a6d1e19c2f8438fcbdce3a23f3993895d76e15b24eed736d7d788576ea3ecd9679bf741a2f4e5454123ddd59d59f2ddefc7bcfd1f8b88e64544b6670e7f11784a1d47ef058ee465300137de2fbe521b040fcd7cdc74da62038e32ba66b46105de2d4d818404bf947ba3e87041c99f964d462e05c544ba780b9dbcadeb819378ad5445147ecdc2d0b0cfe9681f7f1297ced4214ea7ceeeb614ee81ba6a42d3c1ba695dea6824dfeb4c3b2b248482292d4ccf8ab973212a89a5b85b44ba71772c37cdc9d7d52db01c6824dfd167a000ceb127e6e27e6143b77ade7354198b4971d450fe3c44b40e387a7ff2f0ef5459d77b25a5a28bea9accdeedb91753109c811145efacfb413acd797f3b2ae4985118b098f8e08e6270e784cfbaef60cd36528045b5da5dd924856a86e5ccc996f22c9c2c43ece395dcace193f24967c39e178ca98798ec298d7fb0d62b2799d9d379ba3cfc2feab7b954c76e66ed58f2d38a7c2fa81ec536d7fd743f78878b2ddc08e7c4cb8435779422f0ec8085f73d1948137777a3c22cbcc243f33eeea787e266607c9b05f05fb33eab714b74d1a8e888436d9e3d32bc6b389ca647316909895244ac42850ab5c0bd906fad0ade479b31c2288baf5e71e00d5e7cb5732265b5b23c138eeaecc76eb3a8340b55c225399b84b167916a844464d5a069a0f79b9f9c88191e3de6ba4626a29968f0ed726eeed0118727390e4a5db1587992efab19a818c35f4cb910813197dfb73197e6f145f6f9d45ee391b867e48621eb94847842d3d239fe0f8f5d9a6275bb36d5787e9dace84235c052f4f30fde8e620bad68ac5d04f6b00cb10f77c1d0fd0116b745582362dd26613a4ce766421ced96e1d034418cd5f96b02d4219743214a14d32f0d5fed569bc69ca3046bf74ad2f119745b45e4f4a0d48761efe7aaaa518c30d9674a92af05dbdcdc4453bd3a114aebd2648c714497c0d52471df7bcf0f7f248eb31b4d51837b2ef6fad574a78c48d9f41843ffac65cf580057c0a6d4d0721c938c4b625631980834ece99a0a13ebbbf6ebf2e79e52629df2a438b489b4a25b06a1932310bb5461b7f716b597cddc8bff218db8e34dd0970663d82dfbd2ae87213bc86dc2420c18b6883226e212726a9a88f8443d85c48e4bf673fb218552873fe38b8fff608b7464a4f927313e2d59fe0d3bb6e07c10ef134f2f1cee0f12b2e57b916ae49f654a3f495b5061bdd4ac5ef6514cd9d331997f76da63ac8a5c68ca08119af0c678794123be34c44467074ba5a6d7b6b1a5453fd29937042bf0abc20246a9647f894554157d0118a6a57423f91da24b7843f911e64b5e111505170da62ccf40e1863510885d3efb02a8d8aefb39f06fcb8bc16c9bdccb22d7c53b20222cccddeec4016e0701738661222aa3525daf424930b9568dd91ebf31ad59293b7dda3bf5a3f15863ee479d260caa15e581e71fdcec48404884ba6b7dd966b88f89c3fa62da28248bb35115197c3b6cb9ae81fb17d17864b547c72c04d50f73f0c9caeadd4e8bcf8ff6fc010c9ec91c683f50dfcde1d988596147a2db48062dd12eba3f2c47e344b37316f59ddcfadbd024255b0c716b1a251b9b612d99e4deaa37fd244371e0220e383a3c4166cd00928d49e29188cf2c93c6049b128d78b2cc23f3b1fcc05e7097879b996b03bbc0384f1adafe14420f2979e05c755fd4b6aa2ec545753d0899d3398fb831fdac486d6d93d7785dab5592e62e2f2ae4a74ea601ec0298b728555411104f26d739a973364784122bdebeb7fc5af3ff164c0861dcd981c854ba560825f64431391d3711b171401f4d0cd5acf67575b6070ba8145eda118f589eb72ca540a8c715aaf55adf91d39b21a66cd8b587ae4cec2f17c76b399d3e7de63fc07ea11e3351b61f28f6196664443d5226a7c16b9180ec2ee61b23209291c725378accce59e3657fbe36b2be68c7855a39c152ed1339d5046e955434df23c66e14e847c90e28436265e20389bea3e72bef95696e24d76158260ed1710239996616640b42840f2914fd449582ee4b4bed772baa93323ee0486f92734cbe9fd688620849b019ccc94e3bc89c4270eb335e930c716d323e26f538987d2782e27ee6fc9a97768bba9f8fa374423ed0b0e00ad1c2139f2f69e25e09a2b38f742c72b438f3b503ecf9aead086e10487c53c89e37a807fa1b40f372b4d24bd8033c1b98eb465c6c64f32356ab0b398ed77979c72696d25784f51ca6a402b81e662770b792b5cf4292a344fb5ab78e028c1a4fcb9971a9bf31ddf0e0c195ac280ecbf5842b4ffd7376e34eed63af9bc0ab006305e4bf8824b834434470c54579fdb9f083230781939ec4b9500092892e2dea3d615c0e67934ec4dd02169c161c08148acd53f1321a38a3899eaf6a9428910c3fceab3301b4025d32dad9cf552d2bfabea5793241b9784007f5b91560c11865b1f4cd25324a5ac1804cb0be9a6ebf696301450f6ffe112e8d3336030b3368a2fb17302696bea794654fe482149a23613f7c3c4b81e76e010f9225ce81fb8d4e111587b62124836ddeebb5868db75769b89a6a471a3d0d6d66167a97bb30f3f2313126a190916f1abbc35420f3400783dffd98f182c8a173c974d55a238657bcbf2063443c49b8337170774a63c8df1ef705eee94dcc7c4eeba6368a6cde9d959f68d74af7333acdcba5b7b32b64115362b0b8256846e0e140b5641d0eeed1b397c1d05ac6c0ffc6c2faaec3157d069a2d3652b9e288b061a6462f998a9445e8bb587d41bc2b569ef2560ceb4d4060cb902f90ad7d31098e37b595ea9180de6fd9e2dcc6a8000cadf8d8297a5d15fb610f1db25f148d2061e64fd83adfcce60649bd80e9126b6622f06819df43c2d4a13010b01b6d3131600c725e0d1b116b86662180eb019be90c201385501d96eb8e5a648b64cbfa10e26235839e3cc0bac1a3b2f0f0952ad6fab56f3eda460757d62ded4f82770566ffc17f39dfa401e95dae1127a87308c1c587070490da88db6a4626c0a00de45d23e9b2a9c2bd203e5591599dc331580149766a8033e44a05b2d7bf043ff829010b230da10dee7832be4ceac467440acb0067d8516d54b6cfe836c1a57432ef02c6152bce7a1c4f32aabed5940acec23225795cf1cc505594f270b1f7d9b6cfb2fc3055bf7da467ba351b7ac49094822a9fb3d8476bd365807ce1c8d9509e50b6ec7e8d34acca799b2ab510e09d2f8d03b6a0a79d97aa51a6c33ec38f103b0ee76c509a051ff5cbcc8b28053625af1474ef1b638174002e73393ed0d16d81384a89eea18de299689b0052acf3d5d3221b495928b6db6bd922494e027f845ba784c3c6b77a16efc18b6e603363c6ce22a544b86fbeb027c7153b1571304f3be67bd87c6642afaef2a38c50af0d1755f7a45a4ee6ed2366ea217994d49c40150cf12d7ac107d0ad4482f3943e1c62fd248561ad5ffc41db6cbce92adefd4e06022854678154eaaf3b052a5056d17071be7d4f1f65a3c5949878a08a4654fde8004face2af550f3d60aa57112345eae4327cf8f98a383df5b3f78dde67310b2b7ca9b5a38bfbeb2557e2c3cde555045f53cb90749a084659d797df06394d211c4bb00cabf2f5878b4ac66443629f66b713511c340d14204689e06a11e30bb7071b668fdb0fe2c7295af966c1264090026f9029576cb99507c74c9fa88e1dafcdd95106d9c60e32524f1e84ad2577954e8dbe3ed1e3c318fcb13683d2cd9db030716281b0a5ebb58ebee82ca5a89a4c953d0cda1a40bbb22287d1d73bcd47bad3b5aa19c8dd70d8354f20b8766ec805cb5e2882fa6750af71a51d841a760d1c8c5ef518e6934f6882b6d172efb53e5744887a79d3a8b00243514a0d37d7114692b1efe627b93ec50ab0d941e7c9c4675e17b7bf97f37affc6f39ee67bf4677c73e30a7864cc6e96f09c0320ffc6de542c224ec4cb1addd8061b4a4286dd45d48c239c1b880f4c8d00df7a921341a57c7fa93e3cd984e88bfaf85f8e2bb024f9da71853f7a73e950e228dfc2de4e6a8b6cc5bb170986c1cadf12ed3f59d386d4ac64868fe354f4c00aa56721cf2bb8d7e4a602ea5af6fc614064b20f7c8ca6777c7aaee6b54ec3e0e2f91cfc915ed34e0f7c6277b98e63290d662adc78a19365b156544147364730b3e6ac28e70e3e384c032c521f40ff83db3c4dedb243fdfbacd22f8318348c508dc08ad357c46ef376395ca4674909e48518ccc77fd0e9756d09861b69b842109ee1fb59ed6f84da19d97f0d662d1640aa8a1ccda86dcfd25ca81f311b10663bc26eb0196574977481b203c017d4bd65ea759ec9e79f7176f1c48ca2b9093fdc29badf7e892981bed230395b2e6b883d53a5182dd7dd20908a8d0265e3c1e879f0ca5a0594f4522309b3ae5c2e3dd96f194e7191412e5bdff8f5395dcf8cfe688ef5c116854ae41510964f5e7ac868b4ee5a048b0f18c459bb3ce2dd2ca7813d161ae1a36f222ad52974301ee8e3b32d5f3ad698e63243ca94aa2ef68fd87bab0ee64a553e34aecbd15c1b926aa987c9d6b996deef68b46f3658061996dea22fb4c7ddbbbf3a12bc9bae643c2c8d3e97aded0a897e70c7489ffcd7d99a16f536328fe95aaea52c1071373704f89cb1ceea9c1367eca16c99c2a5541f4e7f869d669f2c88d5e12c250ca3c4192e0ad2bc5f39ab68c1edaa89fbdb7a069edf93857f63cc4ec38cd2473f20bac13981c3a21782467214a4922553e983468b5355ff0010a8e9920893ecf79eb0420de8c72500606b1a97de5e5392a578d039e6bb2dfcfca2c0393a7c10f490aa3ebf5a0af8e758e01bbbb05d129a49091f59f50fe6a05a5cf282d5c6d553b5aa9db8832cb99046762a38b42b7432b6d9b5550cec7a60c5154316e06e333b694e220fb2cb7f91624b6438fd3ea89a8bf275385241f3a08da63784989b226a5e392c70497169b8244bd7b036cc45f6a52cd5b2858bf5e004deb222c4b26370311751b8075a2214d1020fc4be86312eff1a83f3af1edba89c829a7c61272c2cf54f664724a23d520daa2a9d5a71fdefbcc037d76960d5169e245691a0a18c58efdf2c9a032eb77aef4e9a8b65972cc75464dc654e88cac66d2a9a67695e979fe3b0750c5bd0d8562c60ab206c465ae41c903690259fd8745a6f9f54ac4b44425c1f60720d8047281a27015c4762720a160a8d555e588f74611aa31dc5aeddb5b80b8b2a27c40314b30366a93652cc6d0a1cc40f25279b795524d799ddd4a8bc96f032ea943fd5dfad26b89e4ec55f87fe34e8bdc4bbebe5cd289e2659933b1bc9426d758c4d21a5e44a22775a6720e091ae8eb5765bf3baa7bbccbc2d014471222d98c2f61f43b51c35dd5e5b1eb4fdc4894ec899bdecf927b234841691bb15ef02cf2b5b9ab463a017b9fa5da352f48ec660721008bb19dd321e179bb5deb9f1c37fd5885a1c9207bc3b339331b32ed7ab8f9ce06173635e38b23b6147626ae480a58a0f60935bbd27acb9c9054e528d4924eda17d65238331eda8645079cb37e0cab5ccbee2597126800aeba036f06a10129afddc348b8e70289e61d201f4e848b3e3c5610d93aa1927065213ebbb03a034a12238f1bfa40251bdb1346fb25e1d1628271db981299f0caaa49fc8754a7e9576ca75bfcab29c6b9048f391e773089babb7882047e5f79f0cb309b96ec97918506265e5cc04f90bc925c51b17f586d593d356e08b6d5fc943d1afe7258ea8b8174ff6e3d2d54c76bb4cb4f48f0c423521b728d3e2b7961908236d45abeef4d86e72966bf03edc641c196e2ecd101177d6af27b6a0d1d5ac2fcb2b6b657d851fef43c341e7a2e0ab1a5935c59010b42ce69b7a49ef8ac8a29b28fa1ce8694e53ecf9f6a07ae7633e8ce440baf5d782f5db8bb7a460872c11972ccfc46949217d840bf2d505718e667f090d459992268b1ab1f621eeb95772e27dc95355d12584bc1ef04d500f1feb6b07b42874648f6e703a7ffc83f407af6a50270d8ccbc46005ffa05153b9fa3944091357f0892089d94287883e2c661b917d139a9f584f1de1130b17812ff3369d0f030dbc8e6533883a3879f53af73675cbc1cf6b54d553d3fd620b118cba6ad5e36e048be1a266e9217a9bcb93cbf6163644bbde0f476a9e4f72c349350888dbb7c86dbce45c0ea05327f8b4cbd19741c9a64969db2fa8242084a99dbd7f5514e45c562ee536e3514073b64d9f0704cc141047e343d07a6762801893130ccfec632c20b341b6e659689f0997a804cb1ac7573753b37ea6a292fc114b52dd70c3aa7a85b6139acfaf1a7f66ea16dcfc0affe573247d9c5018b32a02885aa86d70a30f78bc86ffc9851865862703741e37ae7fc0be6d2831b58ea6788d49e8b72ebf507cfbb17db0509ea4e5374363e10c402b88edcf3018f53c674c730e551cf358de23d1263fbf3e3e442c88b1dc78152f538ccab53d1afe02a94b96f08eb079ce2d6e38e25e9b18a450ed9d97500c9b6438a06b6293ae2fd6ba54b2bf01dd522db6d34981409107707a0b16bfe2e942a131d92d39c8fd95b1ba94eb01d636c91e388a06e54d30019d64adec84f6ef7c97cd5193def3506151cf7e1fbd215099db0362318ee086347cc0db102e75d1be9ef27afd9b162d2b40d3762374679fdbaee9d28f20f2474720be6a19c4aae3e8a23878340e53a40fd54a7d509ea7df4853767e858f0ab97c315cf0efa39a056af841b71b71bb84954ea900a9f21948a508ebaa84d681d133c31c42aecc960edc8157c417bdb391a40ca3adae15c85b0564038f19de6ee42710bddf890f5e8f774bd5dd89553b1729860e6c48a693c08399f65afffc7ccd71c973d3afb0824f9d4300b7c9b45d7023ca6e6a72b2b28dc4ebb9cc62b901d0e797050a93dfffdc60f24ed1c5539acf96e0fa790abd91e5c8ba421d85466e434d61818c310af922bc2b46051a3bef350648339d98ed3930b9f119601fcd7d11d55e650c366f1d36deeab9e77b6aba35a0c97343d667b2af4525e7ee042d1774a003e6f730efb34db70523e95778bbc802ccb4b2e7e95fc3a371fa0bc7810c270c150c9d565c0e1e2d0942aa171f60adb23af5d6d808bb118f515ba75667183e05c70fb25cc57a1a89f2f9bd45877ac557893d381cd9d5f22d3b0dbe6b4d393549574596603ec7cad3df3e432731e93be6860206dbfc708b154f4aba03b94af8e12cf9cc7ff359b299bcb39982c8ecb7ab5086b939c48b28f2d1ba3bb24bd4e7bdc9786508b88b6f5ad21345e7caf482ea9c003d31790345f827b7b26cc6c514cc6642eff401da817f268d5569fefb95d700ba62ca710a0a08bebce5b161ecde3e6f65e8bf6ba17b569c2cd87be0f9ef0602c49655c5c4faf9ab6f1c4bac5e454c070c6cc65c069a3d67c289ea9f4737ffbcbc544f6230433b87089d5899f88939e9b639af40e1dbecce357a9610b64a3cb6dca87dcee0b59d43c1892e65f0f94847ac7ae0bc9025ec782f59e42230ec1159915879a7e93244ad3599b999f21f83873df8763658365b034bd34a8f02d30e02d2de939591a1d60e905bf770762a37abd338bc88c579c1cbbbe1c60ca76d3efff129bd70cbd22fd7e3e2965ebe6ccd4e899459f7e9815c86088470160b5c1260d8005448e4d4b14e791a825498ca50063590986a467a1fdf83f18fb7268b6a447cf65a6d108c4f288daccedc34135cbeda5600173afa16b530a3b1103dfb6e153c141d136030ee82b3abee6dad08957ad3cb17d77317ef5d0a207aec15fdc06fcd5be7b51b6eb85fc462083cc4eea24a426f5cc510c2524758e7c847c521b3473e784f6fc626017d6b8279190b094702e893fc8afa6ec458b4ade75adae3b0fcb31f1802df499067afc78d586203c22bd29e4a87640a80a777be9c6aa2670be7e8111aa7d458a012ce9288f557cdfa460a3b83b7ed6af2a1cc95cd449bf736512db94e2f4e8caff53fba952abea9f4cfaff66f49c92974f7fd34ad7f1ff7c4ffe6356e56060c5b9a0ad44a4a9d0e0f97cb3532cedbada2f31af700a7cf844b54de4e11a5a25a8564a2b876b908fd448868406db606168efea253f56bbe1e6bc27048b8809305f79f03eec180e9a98671936bf8c8f8fdf3a1a400ca59d8b0082fd232999dd789ecece28a2acb3974362bdef74817a8cce37d0f3e3640e845a3f60c7a2b538089519a0b80e7c896124cea7c5bd409448d66d4773446410e18a896f944328bf0ea0ca4b53b37bf3e129c0290ffb320a99c05f2747919ace1db7bb2ad751a862bec7b1a982c316a84c4992fe512f41a8fc98371fab28f0ed757ed4ed3aa44c5364c59ed963459368abf365b4ba9fcecc3d56a903aefa22f345caeb58933eb0018e3e716dfee3e9c6c10c966545239f436a11ccaec50b4d81a30925ae530255089c854238ab9362a0c74e3d8ca575a1a159e152392b2fca5d11bbc79473d36102d92df6e08daaa3840c58ef06501542fce239b0dce85f939b9a2643212a63a0cd400674e90c56a44a0f84595b7c0a3f94b9835860f723d0bd5baedf7763fe78c356d7cc35cb1bfae792677e9be79a326134adf1f3642a4723b362a24bc470b1707f5f3fc96013ac4ed88bea440c479676cd9a800aa48686ca543f549e3eb5566868aa88ecc8ed512162b8be8095e78e4b827e897aa7ee1c310fb03c4efef927d8f036a09c45505ae61f6a70c75a5b8f414d199845896c85742822332bbf5d0dc09577003edb39a3ae0671cf703511e0e9b81c7357e7b8e091239739d8a123bbed480f233c52250c361dd37db5df44b77998789279a49c224a2334fc0d79df195aa0cfbd8399c003c53f4cb8b47b248752b0b200145db7a0fd06b8e7e7b450149c7af8684e69bf76068a2ccdc14d60a928f48cf8017960967231dff8e25df592d9ff18211588000ab1aaecce4d7cdace31988a5954f91dba6de471f48421419f5829da330d904dec0739745367992574c4a182704da7a8e1c4f2f0583fb92ac4d0ae99019ce05d233ddd3bccbae4c18686a7924561dc8241d8272d44d24d65ff7b866842de78bfa5b09a7ca8b5916c057c1f129b294fba080149e8b98a1e519ec39e0469d133d6799a6f4966c36cebf53b435db2404e0fbf133b1357a2c4f1ae8d169f51bcc67a827559336ee69867c3872086f0de245ffcd3570e0fd5a7030547fb9188318c0c31a105715f8313504beb040aae533184ea05d4e0fdf92fb9f753d331300d004b3e630ebd34cb69ce620762b286cf3615cd340f7b05b5dcadd06736635986e2a6ec6ad5fdb3079c814a73bb9e3459f660f27fa3da0720b22298d88122c0e9e2e473e1047b5f814380029c5760172f654c1d2f277b506cb46a2bae9cb32b629cf591c31b25491a80e0a74c80aa6c2f8def38719ee1bfba28be570b0a9adea568167001698b1a2d62e36b3d1e6d0576ed9708dba4331fbfff0d55606612503446790364d36a66146307fa238132fba837a876f33b12a1f17151f4b9f78a5ff17770ce910aecf18d812521b0bcb7c78eb960d523cd363d8a2f28964ca5bc92fea0d3f5409e385af982e41cc466d7ce0337d0811f8151ddff25bf4cf80741ecaf5567db446641816af3723227c0c2e1060e44ca56694a4fcf2b14e780a3d08b6c0411f98d3796fd01b017cd98d68bf37fdd3b28de158dd152bb838bf5454590b4ad4eb2ae0567c7e7bae7889e8901de0ff0de80cc2f4549deecc19689018bbe5e07920cf4a83e7bf99317cf33e9d45f2184ee0f3df2822cbf175719c3eec370fca8c4af04f37667403f3814c5ebef9974051605738cc22b9516b9f7f31145d597965778eb1ae31ead490410b29ab824fc71f9fef8852ffdde045e3fe24dbf6068368f8dc1f567b39c218a805cc5553cd9c37336d7cb164bed4617d4c0d83e6997e90c48e9de67b426cdd2aeab1a38cac7bfdcbad50fa2857f9e376d19643796b8b11292390d2428f502163ba557654d66bbed80953cd9e2659338c5e0476c9d43407d605390c8ec48ae307a0c7ef7ee037112e0e0b2deb93243e5e50af9c880021516b731952976c1a400a50d596bcf2af53a11319d943d4985acc7bc39e22a965f06c3c07fdeed3b62d2e8fabd431f73dca8bc0117a8cac903c814be448592990115807c6c3a3c15e51fbf9ea2daa866d5cf1b2070221a574c9f78a3bfba3dcac9722804e899234c1feda21abc63c3573d3148c2b9ffbb33fdacf006f293c4addef7850e420921b1658c5c997fb0720ee1694df72f8316fa623a85c07b4f3e84295f092a6bb9adb240b87869f58c1af968955d02cb8e3b0da3432e203f8216a0502d866b8ac7334c5b392a8a828849b0f55336f11a614a479cfe3f8df27c09523920fe93e75c44a1f4b972f147efc7693aa942975af76906891ccec3c2a99754394005ac9c5cbb8d4ab929a2c419c66ceb797d3ab3d93abf4058c52d0260d16c5f7933e3efbead64f9e3a01e7285c89d56dc3e4ecd0a67407a76ba30ebea97596701dc45c84d8b936c4bae3e36b4ce0de19534dcd5f54bbf9745b2ee10b1e54392bc0832e3160fe9e8ce0daa903d1c046740fd20474c5fc9286900ee5eeee320cf2fb577ebc0250029e6f47d8faea79afe5ff7fa8dbdef187c5f7fa04af16f4d55d987b1e330108e1379c9758ecffc9d4c973cc7c69b816eef16a91643383d78a1e0abb4209c3feef58d238166e4ec9eec514e876551d534bf45c46fe7108cdf04c88c0f76a76338236d0588c5f1fa6e1d4a7d510162eaea41454eb1e1f3eb10e81b625517a19a530e8fcc1f3397fbbdb6afb74b9727fc69f8164ead035275f32d476ed91abb3fd4070b64ef9005bf7eb11d22a71c519f62d2aca2aab0601d646e0dc9f30e0ef3620a11870e51c825918df7e7f235ba5dfa3418086d00cc19e84d2588bc623f33d56469411604dbd8160de3e5ac31e5f2ce082343614a41654a6efef7c0314070e1cfa142a4c5cb3199711b88d3359e538f1fdfc8a758de8f1177571d2f93f0508d91cc8134215f4b156ae23ff2be7100d0e55349a6e62b6d1103cabe690bde64a2196f7becb5b904736d28501af448fecc41e2764ffaa83678c306df259838c648fbc83dcf2c95fea2431c42bcda9b981ded38edf2ecff459038157edc87f132de594eadbe1ccea581e6e75141d12118a475a8b6c18143ada36948001831940eae2b62c36c39e4b5d120acab5805dcc65fa5463b212e91984532b5a766e42fc7024df6fa6d9c4b8204862e98e197504e7f4b6c5c9b7a63a482f7c70467a6a3d93bb31db0cc297ac7dbe9415bf2110e16b8e81212303927dd0e8fe74555f0c901e964c7130bba177b55a247f6ba2239d27c455b10287811d229aa062c6be3e09318a9422414889da64bb1de67c36840de0c1c972e461213c5b3e92e67946da93e77127cb11936aefbf018d71d34c4ed6bab90eda27ebaeb30ea78f0e734512ab5c55517c2c7f819c63f51c12179e211cd0d5202b84e67a97213fc8c632bd503dce129225c2739ede309a24e251d58e4406027f0f485e89109f3b73c3cb7b3d540555c1ba982185acf192ec9fc0438bd158cba784decc6abd6a54204f4cd70a13dd4ed9ce76b681e42358284a242f3241a41df245bb17e8b09a9513c0357cc2203aa24fd2201ef1e99c161eda3745dc5d01cbac195303727ca50fec88aedc42a295a264536268b0524023b48fe814e3f378ba75b85ddfd97462226b635b83de0ca3c7bafda04e9eb31b429912d43a6e5245b99c37d094d27680855313fde4298a220dd497ee329a6f2f3e5133279a09f099c06340375eb4f38d8254fa9246caa15ca0653382164e354969fd33217f64bbbb01fcb6cbf9c79038df3bf78f9b5f40d67b5ded8d6a6d662683823c03066731bb4cea81dc4a1777f51965483ebadd7181b29c4d7c5ef147fbabf0d4d7ab18ea2058dee5568616d49c97278483081d68f85faf00e7815912039096a046af8eec4745af0efbd13a2301b6ca03b4340985ce2a6db17875c9fbee0880dd0ff60abffce8a26bf8b77d86a5ed1b239e507d5777057689ed71bf31f7dc033108d68cb3df3fa2aa7c295b88ac80200a6e0f7944804441d35ee7e6a6528b90f73ca91098ee1ee262cb94dfd8a8c154edd959de7c4083586433d51335cd8dc461999ae89586ab1a72e3095ebf64dd352dd911fb6796421b2863622c376be8f083ebf520e9f3dcd1ab9a8a30006c037c2399a27aa48282b090262047c9bf588cc06f518887da06a69c9e9666fdb666acad36b8583064d7b857672d6a47562afe2b0965e48f23b4bb4ee037a2002e09492c859c53ce1777ccbe7dad472a4a0f9177d76934c8ecadf86b8e59dffa35c2597328890c4900f463ff253f7425f3578b7cfed14db037162b592c8f129d2812ec5eed2e6a7caad5c6fada03d55abed1865df3ded00b0672265e077e9548740f57641155faad9879a98c5bb2d53122c701a6e50ecc4e8676eb9d3b76ee5eb21e4c68c3ab58f7a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
