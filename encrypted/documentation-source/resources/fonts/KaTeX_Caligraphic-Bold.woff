<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60b081ade57a9b7ddbb63d367c2599525bac829f19fc3a8191b2988643226b1f5cc283684f5ba85cda82496c57aa326384112774c229a6ac614052df209e93601dcf213c6bddf315ae736d66cb8e724872c4c2d417f671e3b588392a5fd73a8212c56f0747739a214f73cb62435aee24ebfed04712bd4a3435afc151df5d7aff049689865f49db631144d657373e3c51f9627d87382800a3f3dd077a896a5994f52706d41f890c20ee989b1a3d0cf28ac48f55c50152382f0ed03082c78084361cec67c1ee8a0e73527862411aca09a76e93fdfcfd2efb09cda3dd1b93e8314360180815c94dbdd745711a5176ce695b9e1725db1f173a91e8022235c6e91dee04f196bbded3c15c8f8d4523e3064d2d8d2cd69fdcf9ec328361ce074030602d98c222ef9c6f38b79c95092d651d4cd133180d8521561f11391f976fe7ce554f31729626832797da6a03880293fa904e5ae848667966ec33085b18f220dba67dc2091717c5f5f55d24f54714d756855aae31bff1821e820d00c30c40f511c3f6d7800287ab93e2f7f0150d06b33b54bc4bddc42412d809a1a337908df066594c0e404a591b93590c1b2f24010239a82ed6363ef94b43b333cbbf67933c1e2fe5aaeeed667c7792e3127155914077fade3fc727785a105374d88aeb69435b2d5bd485915160075c5c696155d814bcdf9e3d60b8799b874248ab503f301b093b869e3cf1ef5217338e4908a5fb3f2e71369e3735f84a7576e2bf95837889a8432b096096b553786837c798b873d9328fb4bf560365ea2cd20462267905f0ea7aaf1de4b6e7b0cb2228940981738ee8aeb0ee0e0e95653ab6a7cf42e52dc953e24dc991f9c9e17427ca938bc71eae2abb3a02f93aa4a01e6405044a2714592a4ba4628787a6deadd51d96c9e2d3a0c0cba643807ac45ae227f8304e70c8c739d61ff8013766b2d9d1ff4927501d369fd1945efa72555aa8fae968663f0035dd67f0d390399c047ba5a981d2b907a7c1be208eac19c8433987dc42563a1363ce03b1a5b46bf31ff600c1639966ceba9c80dc5da5f058e050fdb29bfd91bcb018daeac1aeb2990805207f6d24af3908a62796ad56a3d130a19c03cc848f5645ea5b4450a9e80e4d34c2af74aac6a161f57f3fece92c995f25806d3d682af9b822eb1d49d1b03cfa5bc5e2e0211a381a88f81c311a62e82985c28df73791e6a6271bc3fa56a5ce8e579fbf2e1b3d685b8c79c1e3633fd1fca7a72de4ac57e91295b6cb2951e2092e0fe9bcd3b7a89adc7e8c0f4482d23e5952e42a913daea75519514bf98cebab827d743c3e575c149f97cf5c2434437fab6245627ec2bcddc89998784d8af0d56933b3dda3285c1810eb459ee6c8bfb79907824455b991b7eb59f4e80823226496a31acf57747398fffa92feaf1364a808775f81dbfebb6d711bd341400f2963ac4398a51a8609c1db50e88e15c56eefdbca98bfa77701fe5a03c1ee6dc3212597a115d0cdd2c2b44f687cd1204cffd0b6951f590e96abb4b3d093cb54c13e8d5f374e9ed6969e972c82d2ebe12d602b50777f4d1d9a253a9cf7634158b8b4f2ebbbe10305232620c5a26de2d1ca5ca97d3d5ac57157117b9147c2629fec6a5bfb402cd49f6f91334a946571caa8dd433e2d8d3d83071619fa2cf4acb9de30c2fe65f84e9fddb18b34cd8c838cbc578c52c714b2ca720bbc9ff90eff3b34ca10ae7469cbead38b9023c6297767c5263caec8f2c665aa3d32a9b232bb33ee6f12e20c53e3ad100b09e8a125e33045771dcfc4d557bbe66c69af09c142839869819bbb208991811ee4bcbd1d0f0e935a8d93cbd6dcee073174f88946413fec0ced2fe4bfe41c42dfb5c232ab21181025c6b9be550ede5ffad0c7dd207f62982d84e81f313cc22e2cabb626b240e801beed7c91ade760c5a64ba2c59d2395b7a790063732f758213803aaee986b320079eba8d88552fd2c58d6db1666062b143b3b4c3326073d4096cf384a1f7e87ef23653011a8cc000af9f96af8a06830598e0fe13a86be24fe5e5f45383eb3caa36bec4294195c7fc82b368770c590fdf1bd9c46ba9d7962a1a9ac7c12162a109011631a127d88d1aaa346e39a068b1ec212285cc559a77034947ff8a2aa95258b3d2664b4b17312603584a196d37293b70c996c22fb5e0faf06953a28c43066f7035841ff1f5d4cb27d86aacb73ec6a72371a1388a649e40f68a69be73947268cb388758f238685958268d3f0c37cfdc9eaf178f6bace9636d864e17e71134606304a98c9d05b7bc74a9f895d40255eb02964868bae00acd063541636f7ceb30060db2d15a2096e86104d34ab341122816fa78e49e1b56b20d96676ae9f3bb258d043da61c0123754427f6195f2a103d026ac9df3639aaccda8dad1750803f876da8f4206f8cc373f859f66bbf3a17d21fe9ece8954c8840ae556f6ece55ae4b1d35e61165828be5e1ae5528bbbb14f2aa642fc3925640cea210920871dbbecb17f2cc3a5a9c1ef79b25bebb32c0d1ab1f2d4337248ccb98a4d71063615b5c96126200d82b67434208f3d583b758ee427d332e4212628092620c7d6d0b07bc3f5767e0537fc9a3a52bb3f7dbfcf920159ab72419b978548df6f2f61da25be0356efd02a985d7c47e7c480bd019fb21240bc2a27758dfeb97a27f6873723d54a86730e757af426ebe0a139717ba80820863963349d1dd1671ba4b06657efd6fd7acfcc4af6d9a04316ae2e944e4fa00de816ddc980fcad87c1ef3f099d5c0dccc2724f633a7f6e0e20d2c6041dd5a9d61cac2432401dabefa4249bc5e339dc21742ef81ab8d96e823dab8198ec279672a218af00140b2bf359cd96d4d3ebb13c514f9a7f730e868a3b6b0056bc55de337955f0703a56c1dcb19121b1a0459cdb50cb51cdba8bd97c35b0de332688184e7bb5e8508ad73bca49f4831036e442a2c7987a8a724e095c00af5167eec37f9e49f69a099d3edef22c12416a9904d101f73de3488588c94c5529c2289ba73ec68abef8d9b4ed9e990bab8e57e82a5abcaf9151ee6e6a8d573826ce5157e4445886e0a6f3c1332d56262743fd00b6c992b8fd2dc848c6f30fc28ed84499b3e3cb511ebc5847fa829054fc645327f5848e9ac53763219a07c7a83f9757e22415de0869eeda5c36f336a42cb2eec73461e4d21c368141e9b43e9caab7011ec412176a646126ecc80b05294738f57cc1ec3d041916e5ae7802a48e5cfbfef919afbb4e1a80f55d8ad646c6964f546b615a1e8bc7492fba26c049cb48c127d481ce26a42db119f9cf49d3502d878efd1b180e384ab4453df085607a22c194b5cdd92a96384e5710e7d7859be866ab102d71f323d3fcdd3cf13f68313bbae1d878c9cf84f06b07638ff8b8e288acc7c91ee0ac743d7ec8523c0f1ce44df6e4963fa3f1d59df608949b284a52098eb34c17f4123185e7bc3f66b84cb7b7dffb719adf3cc0b3d458a405032288ff91ee8820435e60f177f3504790cdfc3d1876e76cb215a7592a559888408ca79926890f7143dd1b14217a77d510c93324c92b81a88eb7ff1db2c293aae4463689fa26a1803a9b8674fb9c241ca75356f64b48c17c63842ae4ce44719bd12cee3b8db178c006e94ba51ddf17fe7418a8ef2c9752eac3c111dec30c532f22ac0e65c8d34d8346ebec285692b0a3e3d16e8242684e83ab02f6fa28ae0cc8b335c15c12f56088acb122c02212ce6789fc45c863f23cf14a8622edf7083814d1301c343aa717001b6571cfafeee5890db37d69a2a555ff09060e0e02fa5f6e1bf7986c56217494d90e25b706ca991a0f61928d71b77a7bc09ce413177cf28b5d5e12d402fc78babb263189220430cb18b02e294bcb42af4df389bb486c11e0608d0db906f385d09b348b217bc770bb027415c6b8a57b4da429517ef619ddff0148d4481f6a0d49ce265fa0b74e7343393a5ca973f3918b7421f47cfa61e894ae46938d3ab2095eee0bbce869c4cf23365eec12d620eba87f3ead7009e7b287e37542bfb1dbbeac02516342205cb57f55facc0500dd52f537a9ef961a1a2e8cac2de99ce9c007bbbd448c97efbc218fd31172c8f46a0268ba2309d199ef9c3cade6b2179c4c06c1be40a929bea86194c64f4b39efab241941d6c68b38a6dcedb8e1df0dc67d71406b62d363160e33a24a1b1ff9a439b0fec307e2b5da755f96561619086affd403870f90805c4ac768d9b435c83b4b5d8ba645132b5d4c3020746abbbeeee8f13308efe5c81a2e0da2c34382e4897a38804b3720c911c713532a0076338e6fada2ab059359aeeb313f3316b98f7723d8d256f558a36193aa494047c263655adb7dc83c95674c9b9c433fdf89ba4367f17460e8c1f1c9e24180abe6db0e3e44ba1ebaed7ba6846abd1fcc1f9e560aecb5990359729cc1e01ef36f9475324cbd492548928feb89bcc9319f6a38e1b37a923669c1d2081c51d45350c945fd53fcb32c9d8bc32ae37d5748d351bf71c271bb4d70b9f75c6fd997ca4741ea79cf0680dd9f0710a93b59ad4935b32d165f103414a7ad58d4562a904ce4c9acd8127cac2c2c19e359c63868a2b6bb76a6196d5dcae5d349cf8ec005182b5b532f81ab00d679894d862ea4e17a6d55f03adccaf5c96b201649cae5e553b332ff37e601040ba81bc902f40b8a0e97ad0eb18a08eb62c779584ccf06ec7f30faaaa1b601a1854411660937bfe14f3c6e7dfbc38b6a1f69c2f70619dd76a3a373ef3841088a6aa5d5626d760cbb098b2d786858d463f9b0dc0d2dc07ab27f5980a2c81054cab58150e3e57fbe897a70094e79211d65d48205d46bb2cb48dbf48f7d3b59884e041886bb60fb9f19624895fcca176f14f012724bf46974d5483e5d950005666fc8897265f68375dd04e61cd0a067559d6f9f8304b8422a6cff45d912d385bf1a4fb013f118bf04a5da1e81de1ce198dfdd4e460c0674f865649a0bc1a9db596da33f858286a78c0902691c83380f80dfcf55cdbec15b2f60155d3fd525090487a459b6bcb4979feae9c6ca61a4932237648b05b5e6741e0cbdf7005bc39c5f8944a50a5cc1d7775acd7b5077b951e8c38e99a79e47bada51e4b30332302710392a53f160ac495b92e02d1d03cc2b29329218088c368c399b68915e695bcb2b1f2c30dd8e53cee0412d2e29172d6651dc5a5635ef2465efe52608df2b4b2ef5b0b5141c42cdcc3de55da25b2b65e42b9f2c5d282647350f2f0dc3102044624745ddd5c336624dd2d5737a1397b6ba435fa01ffe2c26f2fbf9d3da3dbd8be30fc3d06dbe87fa6764c0b4929ab5f5b3bca4263332b175775abd61ae040ec0424a0bc45442d0abf49f5f23d7461d3720f8d1518e3a273d871211b2a54a3a7a4bea2662b82f0edb3d9c548a31a88b197ed831470e8142c882711a094f572329bf5e4bbcadd87c9a7bf8eb94689c57c450ea7251b40467453a5d9c92bb9efa908dc5df3c8eb4a79ee52bd5a1d8915b4cd8d399f6b2fd784e9f365d46383ad8b3e5a7892eb85fefb022d7aa54bc30c4d58dbbf3d30e223f8e5c84a1efff08b6ac76d874dd2470922f54d905b8e1f97c867acaeac54961f97b1fb3a98cf63bfde37dd5938380f72e5d95804a3d233816435aae88f5f736aa730f967d45fb7e0fe0e6f789a2a2749f98dfcf265257b9fd2a872abbe1b3b7d47072eb05ffb2293e4e006d8ea85151cbe72c9203cbbb5439b816ed8a874ded5bf6062c78767e16958e0e0883f0a0262308d6c2e793bbc6685f0acfbd56d2332cc4b6ead0352e8920739fc61324dadd9edadd39e3a36b06531ab6784faa822ade67d65da04f85dcd2681a1a9ed7e3180d78cee27ce2fa9f6bac237e5c8e55df7023cbe544cec83592cd5d815133ec1e4e7b206b2fb74a9c920a6023ddf13bf36a3a035cf2b1699a9ef383c4440eebf432150ba28268c0a3cd94467a2dcbbab735313fb0de189af3ef30b92e5e94adcfc62585e1e672f8307767aa70bad4c44499b61efd43f4fb7aa5f522b79fcfa3cebd94a60393e1415389580e7a838d656421f043b0cd3245d39206c1fedbc69264cc2458a9e50ed290b7b01b3271f5c2f1468c0af30a922ca82d727bcce1826779768596269a30daa0e166a68f5f8c5db420a17d1a2514f0a573af86f1ddf1cfd874bc754ff43e1efe7dcfa2f7255d80e8156ec05eb382afa71561a0be4a7fc161e12f789dd96e2d8113dd04e8817867a57d2950f047bc9c0ef99c7ae4568909d546df2df6473b26a0dcc379c06cbd4ec37bebb0820784a83b001f3248718693f3f94074aedbe66191071cb16b2035d400dc09a7af696bd069134506e9647f3012cf32710b40353a1c18775cae61ba800a54da2a1d9efc2a89d236039da8f35e2b03e3a5309a5dfe40595fcc5fa4bc1c3916f8c0da1c0d969af0eaf6252221ede55941d3c561d04641d921cc3e48819355391c71c8ff25bbd6b6f1cb12a12baca064ccc6b6cf8fe865012b899fa2fe0a45d95e8af0866c684ec9b2cfc0a6e5c4db6ce160ff08af3523469e47bf39b349a8842fb7e6fa95a4966f3b24bd3bf7cf11c3c68f8405e139671fbd2651229e3915ed31a14c71c371b24cf82991f0e899fa2ed1e753e0e3f06de0ffe34ca7548660d12cc6fe1cb943e9d60023ebe9345446ae6ea24e0219be19fe55cf72f0bba8fd1cf28d21d0980324709528b2143ec0c81315226b123638c8731ac4cc9d61c5d6f54592eafe7d64cb5c4e1eedc2fdb1c0da363377ad079b26d6493d4352bcbf5a9b5cae3b078d67c58a4837c9dd8166bf9ab118617e3ba2ec4ee9010312b682c3aeb4c98b63f21e1fd33ce3e4b7a5c0a3ab1ce0b1f107a669e27bcbb9966c387d4a7fc6b76c927d98b12f66ac6c08a9a050480397ea61da689a6ddb1a348528bd3fe4d9576b2503ee0ed92fb8e7b2f91ccd63c00e29e59d5aa4d9940698a495a1eb4e0a763e1f5aac1a5f8dc4a514cac3858b988e7709c3fb5ea82953c502eea85df382f17af96b08b03d977a5c6b182c31fcce5e81fcdcdf709a67b6c91a996e0caf45eb48ac4e1529cfe380faa36a42b601784d4f3dabe0a7b4ed0c01b1197205c851af95bf9942d797085115894b3495a649fe4d72b06c1e3bd8e196b6f78e6c984b1f7a10bb929c2c9706afc29925920b55d03fdaad9fbad6aad465c1403ba3183b992bd93145e87d54471c84c0b4861bcc6a71ae12f1ac11214ece4130152a6d4e50b561b484d0928b80ad27b39eb815c4d914b7ce448ddb3c3277ee758c15fbb21f33fd5c019779a020dcb381c91ed63be33bdff397093f4ecb8cb6c3b2635d1cac347b78ab5e3a125fffc37ef280de8cbfec96f3594869b73b56fe8fba0d8f93ddc8391dddc9ccdd7c673ee2ec3dadb5bdb2b6cf9c231f9ffd2101a94a3cef6e0484cc925ecb55501c77339d8771b294f704ccd8460dd84c89db6281a09f3ed47aacc5019acf0b89b6aba6ca9ccd39500a83cb7dd010ef920a83a44ec39ec4d6141a1965c28ad14a055993e0b91068aee8eea516d17366ee42edd6311770a152e040e34b65b143b015347b12d6c9e2c279884b17a12233129530776ecb0276e2d3771dd0f7bd8e2a794a7e7dbeb960460be656525a5153f6fe4a2ca87741b545d50014806658a7fc62212d3e12d160751e89ffa3aaa9bda61693e1c9fcc265eaf2d3f70f40d95774e8c4f49790bad7549e3c35758e40a57c392be77d7660e80be3346f3143c19cbc83d829024c6c2d5cf18cb1dfa625b1093c1949143d7b088607a357814e6c13009063dde3a06f84083a37edfda277451675f454ecdd5bd9a0bd27857ca225576cf8e39d273217c9697ae0d2209e5ccf07e56d77277f4bdd7f0afc431d8a3c5eb8577d25a496a30db4fcc459feac32d5d8888a61994b84abef977ddbfabcbccc695791bb178607cb8a9b8669bf2ad00ab9c5d7a602cf847fa024b47b9991f8cab6a1ad1dca7587b46e77b55f71bc53b30dfa2355ea6468a493039f620e7b051ac984c1f79033c68d3901008218cdc095eb6902e38cdc1135e6312c85d69706f3c172262376785b8b4d73eb33a57e49e7c06c74f536a817b22cc7070015db419565596cd473d717f4f28e2fbbf75085f7787c46465086cfb12c37d0fd8998c529ec9e2c0873b3eb7b91e307bbdcc5f46986b392d7a73fa2b66652b3305396e64a02a037fe941313a35e43eb0723b4c17f656efb56c0145873b595883f4699e05d3fc616c60449a6a0ec68c87fe336a374f9d089d6b25df84e93ab4b6388570b152ad0350993e4325342c13ef6b42ff268aed9aa75900027b3abc623ed6dbb9ab32c379ac26988006b3a15c98ec7ba65e15d086627167ed85bc42b656d6a1358c70676aaca4bff91c874951c84bf888340d200e6f152512b8060d5a4933af915be64f3533b28d03271cf915c5e89990f64da682a31fa4c990d0d8d777f640c218c5ccffd7ebbd137e98084afb60f1daba4a328cd8768d03eb62163318e24bc36ee9459f9b14586227dd1f2e02d844d003c9ded059453cf757209e60abef227c61e189b97702f05b4db116790e55ecc8c5f89f898f73791f5a96c97b90e7e76cad2f39ed630992d0c289914c97345273b56a790ac90cdf43b4600890acba724f7ecbce64cade5deb5ea318c11ff7d6416cdc92a6a003d2360141b7ee724d606c6c424bfe20036e159abcdd851a035c1fe0fb854e4115cf699661e7130ef968985ad1bbb8f4a8248a21ead2a599cbb8bf58bb1488edb1e0159c5ec64e7bcb8512bd475aaddb2aebd8d3abb74aeacb71c8ac1ef36582baf57b8e256eb0ccc2f8a40a0c4449dac6bbf383aea6269bd95d4b931ad5af0c9d76d18a32ee3ded92bc53bf0d14cc2b3a413fa81f184d2df6d84609c742e27ef9641fa7f20112325a0f731551c2dc7c4cdb8af2ee32e034e8627a1bd6d2f6447cf07553c8c90d4fb2e8ee5f50e5c223d3b39f2839b63abd95d157bf7ab0893babdcd41e722a9ceabed62c8fcc32aa33a8eef011f3dc9d579cf539cd17b2b109227a5ed57f0fa822ebfa71f1d6760a0f9f135e18493ba29d43d68f4aca75ffa73f3be838fbfd0a1efacc1b18e529a2eb09dfe5a1735cb3d1c8dc79f9c76eed20f0df9b0aa6f38a8b9a5d9e616b1f0f1d1ad79eb8e62b8c5fb656978cf245e4def79c2c2d673c9d672b07561f92d0e6b5cbdeacf7cad926268806f48b02b1ee24ae93feb444cacb8f981ce87b2678871ded7da31d304b2f5427176037bd64e5fd41ab8bff3e084040b26cf1c760c2c8ded9cf82ee5489eba8c3b7df47041e139c3ac4eee8a5877f53f7d8ff576a98fe320cb8c397f7f9eccd9ce4dc1a7364763d71854315a8999a66f2406700c1bc89253f4a80f91fb58038240613f54eec718423cc4c1aece32f3b9ab418410c8c07a4082cb1e5011494f9556fb36c9614ae38961b38ff98edecd91f79a582a83cf18b13455fab24c2fe5b06a717b9c626c8032b0e0f6d41a875b7153518a8591ff2e706246c88846e239ef0b67fd201ff48b9cbe362b033418e2ff341860018480f22e890b17afd86f56674d43b66f9f9533dd76b8a683386153c209f4d3c5a59e33d24ab8dbbd3e6fe8f6d0c70c5bd262c80ce64bdba7d016b16f8abf1303ab2c829da0544d9db547ba72faa1ab4cf7bf01b271186a4125f5b81bbd5d17c920697de498b319397ac18b6d52458ccb7f197f1b603ecc726c43e85ac587a02aa62a9017bb289b194bcc4d4fd0c5ef3fef7d277fca4f71e2ecda1b9213428ad75427ee15f1db0b7559e9dd67473a4f107e939107c02cf8d10e6f832f7d958908971098b74f9c8385fdc7fb9a421986f72cf72a6a44a05ebd265989ca99ce28acbc840cdbddcc133cd40f240e61158801ce02caf51be0b90e64c733de0bbc74c88d69c1e1e393bb3477a54d2a379ef8a02e051e3e5c77050ffed7bf746425f97ff1ed7bc29978cf3e7379a6aaeb9d25ee21546cac4f5da1957cdd40899ee96ceafa409dff183180a4f2faa7c11de1c67980a7a90200e38869fdc0e83a08b219dcc5c3b82c9ff24ad9ee55ff2d8e3c6a985103b4a5110c547bffffa7a2ff847814e8721971e9266b7f09ebbe256dd11ca13f0f4162eb52a8c40a187a5c61226eaadb6064fcd65f65825e1a9edb6686824b7975e48ab2c6b7e6841053df8532bfca1e6fd72dd6f41d3948d67d2308d6e50c422645d93cf46cb57107276f823df7d40928e09fc5b71bbae9ff58ca32230493e53984862d592448bc333abff526d1b3530b918c0e9001d877925fef992856bd5769b2c10be05c33fc2e39152f8d2d599f89b5e0db9623f9900a995171c03681989c39cb21b90268657360efd5fc28c5f70a7a29a1e5a5b515057e50ca17f4cee8de26dcadb419f586a19aa1a103403da25ce988453fc605a9bb1bb26ecbc0f7b56ac9a5573bcf06affd0e1051d1612d5ea34cbb17780ca18497eb3da2ec8824cdce12e6f714f3153bdb2e2b82cc11baa25b9da66c979e7160a0970eb7360d2268460d230261c7c101b5d2842340ab6047ce25718dd2b42e2157b416489fbb346d4b3df08999834ca553ca6c07998763a2e9ac6762c49a672c2f5e418f36a67f8afc403760ffa34825da876668ca7d45093a14439cf055b08c97cd05595f6bd09eff15817ed0a0b133145172010956bbce56c5e8b946a346f911e550db4693168bf91dd53772b532ba6894f7f7d482c6e95521a1fa7d4b966e8ffb32d539180d9bee9528d32fc5bae923c42b0f1417c63d3dd92aa83f5e13b134369d3c8517eac64d1b32f736f5575b5f790339e23398bb790373fff8fd9c4b16cff52103f6655a640d2bd80c594154e33181c360e3a9bd6cb45544b16c2c22560dc32d3d5160d55f0aca43af4ef3da8bc07401607252c8ce8207c21528efe8e760f0f9d022949d1a2185d138802dcadcc2e2cb57f2613bf9c54b3386fc04582e895f1076c1242f6ffd1470113e96a3e47f80f8fc15e0c703e4d908afaa98b10420e425deffda1ced0aeb4160bf13bed1d36e94382a2d0f8f430d40fb5f224df6c5509edd8094261f157a780276c6f31893655d67e030ba89e92a2e8a7c7520fa40c5f8955b32453d7b953012b1775de6bab0fff50e257434fb3c5eb93dd0f47bad3c60108f39f19f47d6f767590399c0a141490dd54d67f95e252ff8955c0342b3b03490104a239d6b1806e59d0e0846cbb6ec40dd236d47bd34f4b09b6df255eb95c28f56114ace304ceff0fa582d44b2a3c46b3ae8e75f1e43fce2ce164a5f3288c883e959ad847d6773cbbd84f1a78b843e10580e19f70478cac5f417a737e8722df2541a1346e501edddc3c6a54a21b449ac36140214ee31df5977d954e4705c74c29ed496b32e87bc27767785fa4c79ba5dc51f33534aa2eb575291e1840db0ee03a24e3895955c44d41e69f2b995f0f46e4314f7c2af2f4c90045734fd49a7c531c4d797206ee17b641a1ebf97e239f98e274cd712cdc1855cd6b63b30a1665da28fc7b94aeab50bb9c6fdad96cfd20f9e71b748983e5bcd101dde5eda9160cfb9b2bb5a291dd69dd6ed14187dd4e8343a30e9e9703ae864d301a41a3325e02df5296613e309beccca31634100d4f994ed2bc021d467e0097a1913217205bf235573d76509ddc4d60dd4f10745adfcdad8ab1aeaca6844731e19dce4da799ee5fb8f40d1975e0a74c9dd7390cb759c845b027662b52ac2f66bfa50ae299131a65c5ec9cb97b0d31a6cdd1ec5a29b63a957d437efc3f0eb739bcead3165b66c31d4cf466942b66c61f5b2c71f5daa1a50e2623d4191e60fb4a1ee9029693e5ebfe28b8be2c23a3fbb2f8ae32a74f2d42192b642d4a573b830a2a357e32b7169b65000efa3198d4a388b2220f5144c25cbd6cc6b5eccd3b812c4a46ece1d9641997c3551b2e17e6cfd17e1f306d35e85dfd11adba57a3f62c1772d16501bd475a3cc02e940ab6465e772ceb025b274981d88df4a1e78bb511ae01be75bf4f9f360ab2ca5b8eba25c1cf1bda313ff495f63f1c8a77f05f2169da026b42ef6550fd5de3766a1cab2b5d1b5e07d703e1b610ffe469d897b70c2755dd43f4784ff41a4e7114e1b731ef1aedc7dc6210c4bd7c0503d80c16b2ac8767c7e2ff8f073698bb07b52616c0d35ee22717c220ad33963b0673c294ddd2774d72876edfb342e50aad851d7ca1c356c5489c72b5251b8b749fd44c1bf9b36e8ec046898c429b0b177b138539c6d170d24358130d8c939c656fe7a978b69832f5ca2e46871587b45bad0c812baaabbb54d8760e18dd6b44721097082f2c60bec932384df80c0cd7bdc3317cdeabf86a36bbc215786d587d775308ea0b091062dc9a011881f510f219d98087abcea4dbd422bc709f8027f3113b4f09d24da6804bf596b19448ddcf128eb5fd38c62c81d2684fc100c975b2d5f3571d37e307576fb4f4e8df879eddc40c63c553b2ab938c324636d56cbc6e2688c34c73b38d7756852fe60b5de1c29d09767917e2384134f456372c6b33591bfefd105707a5ea7aa2d9cf1f0ee3bd70d11e95819a339d7eaa20abb79649d07ea587279f9cb119430eb0565e2a234bb707b58efba8738f36a5d7ea517af0afffc1f2dd0db0da33f772fdc89b32e7a9674598c79e66859dc234114692f63dd7bf96ac985c300fbea502392ed21bc07439fa83a312666cb39fb9945a3da37727abb81ac48bf49735ff326b7ad1af6b45a2827379b0ab880126474d99ec99ecfd4689e854e5aca9dcea6888f27a761bc509912e477a9ee8c2660e3d12ae83ad7b8def7370e9fb0f66b926f7f1bbd89b2215ce92cdb4c94451af392d1a43de4d75538193547f62a2efe5cc4df03c8deb869fc97951776d55860b625779822cfc9997baae20ed323d06e32cdc71d08f3ccc535f4a2a77f2a42f26866a4375bdc6bff2a595531bc2130014e2a422ad84c92cff51a1defc8949af5cd1d1296e303ecfb0c710c02418e809d00493acac14ce80c457660fad2cfe4b90dab16bb3df5aaab2aa8c37fd8b9015632642cc61c302522d5118ea9a57cd41c4b4e41208a72693a29d14f2f7f03ae29e0691c40cf949aa0cc4aa4a1fd29bb3556ee35aa05e284aa2d1a54699b0199f34aba6eacfb0fadc4ac4d78b5934d53d87746857348bca3bc65ce876bc24c975ea854d2ee6d8f3754dc76cd2f7c41d2e6f6da941e2260c196656f630afb263deb68bb2505417fbf5000771f3d014d86302022665758271f2a466e964baf0d2681cec11c1f800c61f332968ecb34c97d656dbe930310dd9a39e82076fe0eeed72c408fdbdf3de157845faa656c243cb433fbe4e7f58caf96ea334e9dfc59ee1ff3aba2a135ec315ce1f1ffd86df98ee44a6efa65992059f97a081c33cccfa74ab7cf9290a7fb91112df95acf0f580bb47bf4576808cccfa24f8d128b40ae5072161b95e4e94dc0a211a913536373438fc7f17fe891af2c080d2df5964943604689d2000598f0c4e9c33d340ecaf8f6a72cc94d247b857144fdaa684163c00240ccb1a98af6b0396687b1995ca799d4557f22045f30e487599e990c12605678790ffc985c837268f68ed518eef4960bb332a50c255a812e153dd1505a8dc84d9b38256e543826aac2987a79cc266f5d6cbc3f1b1203d565d7e8fc1409e1aa99a200900bbd9470767df2007e3e6ec6cf01083842ec94a4937c7991906a04db6010c34023aecfdede568e81abbce38da6e47e1a109594583dc369701d5f2120396eee3266cb4796ae27912c8c1de21b85f90e9f6445121633161ff40699c022ed18aeb75569087a54cb863e0c807c48660950b4c019e9de0df912a53e71bf85c599d6047b55cc30fa422a415d17471160090b971983eedd06a23f14602f8aa182f43c5d41fc98aac4d7378a400948eca549cf0c1fca74a908c43e4f2dcd58b81eb141a9bf3fea50437f6e4cc75097616d45b5b4fe954e8902ab0e78d6c64e5666449357e6f48563bf0f25805b8bdcf3e44712eeb430e1c22cb88b56125fa555fff25603b45e8760ff09ae14ed4d6b00786add24ec2e85278063c0fca6e0e7ce9448fbc80d93fa3715dc442af65c5881fa0dd6379ac8e3855dc27d70547caa29a208b6572ea0e98fe0ca996cbb8e0bbbc057b7fb25e5d091f392f7c9898650986b79738e98fcd1b4ceb2f242ef03bbb79d5136878f8fce4972ffbae3805f3baf525aff797f7156df90ae08029b38f92e7b081b0391e50e9cd48d36f656b30f6be32ee2e8f6239ba5aef8192f37aad653ddc6b194ff4b115f76c23361db9553803fae20cb72f08fa936ab01cf902758097f7335bbfe47c1cb7dc8b1b12e0fd43baafbd7442ae88093dd6a5ad61e80b2edfd122b0e15a92b89f86251aebdde63f0f1fa029fd16f488830011652b5188c23089a98331210340439a98fb32b334d77096eac9d1eeb65822990b31e2eae37a7e43768af6832116c9a7ab750a548fdef0a8c5f664c88b6c42988478aa3133b2b75207f6b8068121caf03a42dbb714796c15e0ad8cc054671972be3e01f7a7829ac3b369168302ac675df42b895d559ac87b07fb0395e57c49f74d29ae00b289d39dbcf9d354fc8826e336242e0cf53e2274392e4c1fe1ea397f712557da339ae920b67fb0696b58ae181896a2d2d9e23aa0c854fa5172f23fcc158510d4d311c7e75951ba4a9680620f675f1f1d7c7bafe6782b8d4929c7ddd4fb70bf9a909e949a3717e77e24614ea39f4461ed633e20dd34cb1b1b699a7de1f5c53849381acead1b442d4ea025acbebca249a5451a909eb9ff9fcb5d9a72b5ffe58d1ae239f59092f5a26de36c7dd0ff0c21375cf1320368859b170d62c099b2d7e9127679e7602191683c03f40345549e9290a78a1b3b48d42d0893ea9924c14c9ae65be7bcee18e5fe44aeb87ccc0c0337969c3e0bc2745fb6835ecdd1f27482456435c0aeb1b1780ebcfcbfafdf9ad32f2c04f2b4a5f76a50fe27b8bebf7c92215557b43711bf819f420f90e362e8579009f7f12ca55d73f607e8be61ebd2f134d3a562ed6d1b0048d597819716886c56f1971e6072e3f5652e28f6b2158661e6e84437a0c7bf2ae79d042532ec89703f5021174b1030a289a4b244d31859a633f0105a9eccfbe17b7e0855090caddf322b564d856f1e06c0385cefb144efb6c7c4f270e283a792cdabf9b2c0782719078a6f306f7987689f3b75fa624d62cd6f8af27f5052c7a507586f9d8ee620801bbc410bb1f54e26cced1f4642a88ee68d0c4b0b42a3495cc59fd22e70d8db89cec857696dae9374c34747d93e8480608931923f544de030074cd23aad6914891a4999449e12060bfe66f6bcc9cf023d6707a5011d6cb43650988a4fabac5955df2a81536d375015595aad37eeb78ed70679ddf6c2b319d4229a8f1fb0b73d9c5221ada6c44cdf96584d8df0ff79a6cde6153c0d2b6f6d4491a6193b6e09da8357e72467fbcef1264c69fd090f744404dc0d0fcf18660c828f3d642a055426d4e0f4dc466d245bb6e709d2066f3714a066a3c2d455c2c7ea3462dd6022457b961aa1abdd1a0a9b314c26f6bc099f9336df525936f2b834091ffa5e088eff14c9a874314929f9f1467496fb582df041b876b29e4353aa0730e861f7231e2e959b5d61d1a47cc50bc7d0ffd681c1bc44b659ac4f951544038b119f7c47f2a67745e5e2bcfdc0f203f67757e8e8b12c6c0b86ba4db04565e16a5dfa49e21c5f7d08f3b387dde6939203fa399a8e3347416583244dd7e87b6eb026c71144d352b45cc2bf98583beebf192b63062444ff751ddf603feb3f56f31e532ac114353d687d9bd66cf78a17657cda3993d4b3d03234a306e3ca3e2a5a657788589a73a564bf470ae6a2b8644d5bcb284542e4b7b41e48dbc3c4531eb554444ef832bef4f88dc0c5684b3ece0e2a6b583ca65084088bfc2a0a7c5de6fd5d170f457baf4cfd763eb7d580e8cd21d3bf4c985afe898c4e13b73e85bcae391c3ce2b62c2304b343f76aaa84e1d06143a9f8258f17a0c097f8876d8d75d016adb8dcfebe4e3507e03d8fb66e7d6511e47eec3d7681c15715caefd37c93ae8f0240eee7ae0c68a434505f6e4f7447351510a2d4255e209a965ca88b9953100808bca956e50a9e9e5c8b5a918b87f150d9c12eef473ae232a9d52f47cc8affb1df0f2e07ab5b5a732ce8c3761fb604344cf6680d57f0309ff014cbb1d0e3c625afd666b0dbe37cf5936219628802ed601aecbaf3f41ff20843dc9a6f6df2bc32033c8f6c4d95f0a6c37a5b3261e0c3bc9f6e8957d4ef97aeb4a4bc703f0732bd843c0ff291bc878105984b37f07e2aabad325af6387fc4969b97ddebc6fe9f4fc98a4979a64342145609eb04eec5905b4efafef51041491db8537b6eab4d53af5b5e9f2c170941a18635e601341245b0c7feb837e9d391a7a209d8ab704c33e6ca07a8b3c8313bcbe742af2a08727a53bc8c9a376dd5859b65a81be402bfeee7644afad2da66f7c4f2bbc3c077e6f4b563170fca24d57867a613a914a9ded149e524ad30254cc3c995825ccb253df628699895fb4c125be2f451690957c5991c6796fa198826d418bbf6980af3f98fc9948f1d8f35ef7b38a7a973c364e0c9f6dcf98b934682cc619ea7259ff1535a162497b659e19e929ff8ca207d1eb06f3f58551326b877e12c86cc4ff7bea39b5af36f499e54f0ebf7c113d3af781e292f4bb1cc2e2b631e51c1f1b304f4e1c76c3d72b1d3d827d8df07cc9c62c40853b4ff1f715bebbf35cb2b477d570e41ef996a47edaca67ab901e0fd8aa77d1795770f6359c33b807fdb292ad1a0cc75bfdb7ba3ceb96160d909b93c1a33bb0b2b2fd18a1ee0d2fc8eb53705268f81e9699c93f02e24da0ac622bb98ad82e150d8a04cfa1e6bc24cb3d86cb6216460d4c3f74bdf24382620ce6d5ad9b2f5464abe2c71dda10358635cd990ea1321431b6ecc73c4eeecbbb6ae3c7e5e0834183b9538304781e8607c92508be8d89dea2edd73781724b9a229443fba346d07d2267e2796301caad6421d9e22941fc8a7e157167eb01ec494769dab7a21f5f9d91aea8cd4b3dda73b8c5de6dc31c38c877b526fcaefe4258a37bd67ffd943e26e05c397d824f4192d6b99520a4875d1cfab46aa18c3bdfa7ebda486ca37dc1f243be7b5ac936ec0218a8e84ef4963b706e7f81d60b7f21de818ecbf77baf9ed1b69dbd301412a34b6b59db45ae75ba960aca7b63c655bce48db337e3ce7769c82cf1cee1ffb76488359c938e23bd519c982cea508fd6ffc1f970f0db280dfb55e4d659a8d58f5b66d122d33dffd296426757c3c176ab841d2fc89921ebd4d9b41bd608e4452cf5cd4bd6d873c9b978b69f8de9982376a3ccad67e643f15a8e7a844639848701775c38f334e396972922ef4323a13a9ce8062d592f3dbd2a7d01551d7443b3b3b995d9573440ced18db4c51b4a80d7a3590a670d4924f9ba3af0b7777c27f234e4fb49320e60766aa644027f1f7e19be0981a70594e64016bca2b228fc94cbc607bc643236ada5d931e5405a5933c87521470b940f95af2a4a405345e19f9ad63b737886196b71a6b91a98cce53520a12a05adcd77658160c319dafa0e06692b4ca12769c423358c9b7b13774a7e82158db078686930fba53de0cab00838e90d0e4c998ef0d84d9ae6cb432e5435344031859940b005fdd08dd550e02a2561d874801c167d9761ecb142983aeb07d3fe097a3df1f54a2aad6d62ccf8472012c4e67dd6599348c3eaa837eb304f0482970f54cd1b0e028ccc405fb2001cb53382a243a985c166642a5f088b006119c5dcfc95e2c5e3c282371fb1ad4b75eaebda5e0c385d0bb5342d7ae7d6573340e3434abb93d4c53d713cb41efa13abcfca3d80a289f4de4a8815fd7af7db5f9f0472d6630afb0b86054831d1cbabb00b30cd552b460821f7bb83b1ae589caaaf19bae06499d261bc4a65dbf557f53a51b1f7f85cdaa20c8e5e12b57d2ebe072043fd2166e364e5f7163dcbd9e8467ac76a6ba620df4e3230a13856d08609d0233629fe3b037dc3fe690c15883d29e6cd330b60ab50823370d1faff9adfcc2c9f9d7e678aaba6af37b19aef1dd724e351ab212c6218cd8044c2c62e87faeebf07e13c47056f9252362714efa503fee93ff705733052f43ed9e02787c522b47da78048a349bebf994d8011fdb4a786d3042cf5b125d4781ff91eccc4192c39648eb15686777b88bd5b4bd125aa20dd1ce01b6ef47d847824d247e1ef44a4b16ab2ceb0eb52b86da382b7a07d567d7457353e77c84c86c46c1e72baa106e8d8052d29e80bda2d7b662a4cf2cbbbeacf4d04b2299a791ce0c082e877b711c2f826e30374a30c52727b91f33e129e2988bff67aafe7d336f43a90dd58d8c165f9f37a1cbec953623559cf0cc101f47954f6f26343f739873926b779587be34a34516eefcc0e71e6ae1cf1085f2c26113385e2c3fd311efa748d99656e3c2133ae75008b2ef7735e35c9f50f506ef03dc97074f77fe4444000eb02b6f9730ccaf2eb3f15438089bf7ddef3c47a586cfd49767fc2fee7faab700f59d72ca4019f74c9222959cbe232e7a134bcd51d60bd5f4d2d9d309c845f2ae2f29d782b37be190039c1bfe6e7e31dae34864e386bca2778bc1a4aef280501151edf7f2860de30fd31189c405e9128c321e009dcaeb58cdb1d71fdd3ad9b31b67662d5c71068fa8b920747a9de3362db0628531c3089e158b3f315c096ea746f89295c83852a333a7434e9e944aabdb134944cadaef28a06fc4a927c3c274442fd233acdbeb64997c4a23129c089ac9317c8d8dddce7e35dcd49764a47dde324c83a6e155837c28f3a2448f9d9ab9626a256283d00120668e034c65b0a9dd671d2ae106f3b4be46ccbc0d4107345ed587dd18517b871b12060f4940cf08491b0fb87a3c26fccdc75bcb557d7ed12afb55d6f3e9ef42b6c5a6597862f0c4697fe2bffaefd9f2b37a0ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
