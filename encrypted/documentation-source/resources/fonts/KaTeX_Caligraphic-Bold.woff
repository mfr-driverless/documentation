<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89192f5d8344f63ed680496b527983ce5845631ee0112d9b2ac16897c45bec058aac524921d73bc4b1a0cef2ac5b14fde2931f7fba6a04321db22f6f474f38e748d80b37fd3aab5e802978646a5d46e8baafcff1292054a4eeb5063920ffd774aec25c4d998e9d79048a75f23a8a3180f47e97a8ccd3cb1f02d6b2e1fe00be4d2f7e358021a9aa06c317ff9cec8d3b699f6bf3ea298645ba5e283fd41d2d889290539faf33c133cebde57c9fbe3f37b7647db9c5a65b526edbbf6d57704f1fce32a92373808a0264355283f7a3ad3870755d3f4025af8340344c95d46a2a9542d00fedfc3831bd22fea93036486eb8c8581c4f37faa808330f2642f6ad62312898665d8f17be26d30b1108c15862ca627e96c8b594dcbb2a8ba30c60d23226ebcb5c7ee8160a4416fbf21a467222a510268d01fd234db0fc5287aa0b5cd92178501d6fa0e7c17617ac8d111a5bb42f6a19d1e218e2f72a300fab0faa3de562c30f127d6b4d7170297ba0bb142813d2bfea2b22518b26e6cb46ace3d66d0332b328f919744e40bd541d03a931d2c41406438a097912e486c2d8fb3916e5e7bf5eaef8c17a7f13ab565460a337c5d07ea49534c0bad871bb1882c233e763ca2c04b8a491a6b2582c6f3738c09e78da08a10929e1638ab621ee133505e3e83ca413000e079cbd2e98177ede3e39a0666bf955116fcb61458a60bac1935962f16c5084388bb65bb90ea535742272aee6f7169343eac75c9f44932f791a86cf8ef49957637457c4eeaa211c7eeec7ab1fd9a81f998e680933907b573776ffa474747925227e49f3431b06ef233158656da0c024dbfd6baee7bf7494e8e3cff2306427f6d84aee731f983f4659bcef295f4908ee433a6c10d8252456ec2882be4958c209ba0c22f84cdb7d2a2c796f000f6055577680d60c76d9d210a6c81e611eeb8da15a48736e7942af49878b29667a5b17bc54671b035267a44ffb9ead22ef39c372043f985abcf42e089444820936e7c7c10caea7870c5c74bcab02283d76f1b10b9eb3f477fc6abbbabdfa6d3164f3d06009b5834abd6522c025cf62bc5ed02ec6dea7442d5bc1069e361072b466abb4bbeb8ab596568bd87dfeb7bf095d1ded43c34fbf994e7c3c112071d62a3930923ad749548c2c7d1bfc904420b0198eb2458067d2ba1ed15076380b715663d8d06c4f8c87511d014fec01fa3572ef6de29404d084822dde9f32ff643c55fa4b8a0866eef6f3c9db03e40cf95d270febd21663f41013d09d2522f5b3be31ab295b9075509b7a10f2573783cad732ab782bec0a22bbec683cc2bb0dfddd02b5f3f696070dac8a88e28dec2d61df6e11c519dae50a056d8db72fc53e6296b2ee9701f89b5cc132ce30059176519f1e8f6b522524b738df078cf366d4e323d4e8a944aab7049dbec6e6f930b085ed1404ff257c89e4b77733a3230b412626f085a559c65c785a5c628cfd3fba203f05210a9d7967229fba2f0b5f3d06bf27002da8b7c7a514df87cbe07d2843f196e279b555f9cc996c654f4277610552b416ae4323f8e98f0c0d49060f6a8487c57ea8bb5a614845f74e97862c802950a123b42851a1e62c95f29871a4cfc4a652e90d29366cf8626a05c2aed67950eb53222fd8ec1a28ce74b9a048b87a59618e89e541c82e2ebe37f876b41797f9e7b58eca89675462f02ed4b036216e6d1a396d5dd3def35e7b3ae908da978d36eb3decf5ccbd010770a121cc05e330505941e2dae6cc150f5d1667f44f42d60aa8e4d7e386a71d6ff20e64dc7d977774fe07f32e1db0dc1d8e1d5865acd2b77965bd7d7ee8ac875bf31e11f65092803aeb320fa7fd70a04c4592c2b4984350a7fd14c37f05bb43bdb538ff88f0d38be4bed2c5eb892a46ad2df016a377a0796adfeb2e79efe5370c4f9e339304a13d0400b5a8f7e38e13bca2e5065fef2a13e55d94c1c7c854b0d582a94ae04fc441f466200c0c6e30ba81cc20f55715f92c01ec656c808c1d6d7102eb6bb879126ea2f7f0afe9e8ab2993470050878bb78cd6d92d74100f4eb2171f5d205162de5d21e820d5828e56b6ef44110bff218b4606aaf5c20686feaa662d58611463e7e40c2331f6434b90b4e606ef3513b56935b4fb0aef8bd57b9a42ae7695a8f08ba4c08da808aa759dec3a30441a38ca4ec1c79b2081c3d2a68fcd1368ed75effc2287a71d95a2a6e162b4cb6204cb322ffab2481a0673a606d3693f837dbecd28e34d0664eb4d190caff5d6d87ea94a01eff0d1d36c5c96fc668c5f497d053be2a77d3ccb8f71c559114d97f3969e872230d37798bca7faacccc577596b6298f463ac6fdb639b785dd7c445c6745d4df69f056764e073aabe3e92b870e1a1f77f1ab62371b6c77d68784db766a57d7d1269a7450eff13e0cc431db33f44970d24ee0440e06ddbe813bd9f9dc7476fce701c9796620ada39f2928ba938a2f13f5c3eeabf6a62dddb288afe54e63990167fba62d859f26ae96c6d342a52a87acf57947a4040aab58cde2916bfa96d4e02870fd598f9f8350e6baf91bb10e7729cdd3964f78f0dd0046b1f29f5ab6320580890f71971e13bf4675381621562d018dd4b35f58c39008794aa5fba293081848bfebc91cab81995fe80938f614070e4904138bedeb3128bbf3463c7199e1721fd5641ae5c9bdf527dfe910c3115067ba0eb5f1dfc24a4abbf80a4946a44a74add1d13e50a45d3d8cf003abb1f26ccc880d49691ce208045ada9aa68d380dd94ba8ba217017c8c9e8c9849151375ceebc96d4d9fc209651c31e636409864d503b5ff5e2f5a29a82303e2861e03d2084e43c499a3065e07d20aa1da345bdd5ca637674688693c7f572c3f5d740862392545769cc3047383605f9464d92a845c53561f5d072c177a498d8bbe0f83dc2bc61938367f1700a92aa7b1bef7844c50c71d69cbb639d7f0eb825f89b2f25a5a5ef64cc1fd1ff3ffd556582c99b7eaca34be596b1a2da3e0c954e800788a5bb3f439ba579f74c2098ee99e7f1b36147962ccb944b253d4dd1b4fe2aa30922cfcdf9e45cb06f3a8d2c586a30fb44dc417def5b9fd08c272273f8d4d043de09be6b0d38641dadac33594a457e61074e765485aa64efeb7982814f11c6361106807abdc1778d053e953034a38d959fb381ba3641b608bccbe211b4741a33158071f04ac3e813ac340f05de9d17d09a05ae230502892ca76acc5cec5c524bbdc0b78ba105fefdc96341c1d6689e0adfb962184c809ec8215db8800f2b0b228dee1f13b39993d2887af13de0365ef7f2899e4bb1011486bc3f8c0c43c59d73b9677a8563634b1c28778a2169b43d0a835109db950ce4561daa78a87b6d844cf7d85376f66fbc02ef05a44c552fc9af52829b2f33959e9c53577698e0e37292ed0f40669fdab46c1a6bcd0ea70730e537649815662c3f4620ac0f9b852c6ee88f3fe8c04ac708538011ae1c954a8c8e05e66637a3c168f86bec77b93faf71a8ae16e6d11243d7a27bba80ee4c5767aa168c1774b68e790ddbabb095fb6b570ec711630056336d2a52cb3fae6710c2ab1672409eaa94d32aa2ba489378000ca58340a588438295f1e52780853db3f0c3a56f487b86460e047f3ac6ab544885553287da105d0c13c840bad7602c724a65807c5420d66dcad31a1cf6a5e0fa2aeecc5e68743975b205251c8d9fa3f63f30e87e40b1427307f1daadb7e4fd5c6ae303e380e28c8c6cf6a5b9bc288d50263ea8bd56630c90b5900570e66d656161fd37c49dc07b1e59350a5c2e51fd8f5c24433207b6a462af8979005b2e37559ae752ebe5d98adabebbd6b1deb4577d693b7d7c486a7a00b779ef49b5c53c27c916e6559400bdc217eb8befcbc997fe45c20c747eb6a3b98dd7a324d3c64d2aef05fe7c6af6846ec0284277856f564d726744000bda914ae31901a45dcca95831f204d9d7a3280ac83d7f22f17f7f9aa7d8eaea07c3998a2423012f9a2c25d3a4ed04c12283e74e4a3ef158efebcaa3a6b02c0348aa2c83e0b9329069b34475f930c279102e44ee7f42e1a24b2c5d6c69cf9c59fd287225909ecce1b4fb07aacb1efe2eda288074575da21cde1b980702f0b8e9b44033d33da9326b2ab035af7d3b0939c26ccd38fadcf0ff9d81831827252ddb647e916dda9125476fb19fb6a529611d62fac35d9e6a62d4a938fb6658d208b80e0ad6d0572bd5fd7c30e5c370ad6ccd259b0c9535875f7bc595fbc05a0ad040dfec9bbef618bea77c9e4d87f0aa53955447b0937f1077d1cb41c670c8ca0b5966abb87f76bc49a9cf336fbebfc4b1639ca0a7c5d2b64c52739be2372cb1679c4b8db1fad21663889f21e9d9d1db46b61c133d312d4696d11085569026266e1a5e77c13b8ad196040471d397fe022838773782422b326ea0e71959a8d255b32901a0cbce180a0e6b2a4b85135a591478fcc4b5a8b8e2b061f418929dca883af39815a12f078d7f076333a04f3d2fb37344005640eae587e61ee558348887188f15d274aa23efe13fd0bc816132dc05c2bf8121b5488ec7a30213c8c2e612621e07c8dc38969565bce0200fb06a83881350cd6b02be001f354aaa4cea0f532ec0fc4ecc5c2998f3d6c939f954edeb93a8b8213394cb6af1c15810c1d188c9ac998de088f8f37de5b33d4ea131da8b6f92d3829a41760f1dccca6ed099848e3202dc9eaf197dfe4a761a9d36e51c9f5d0ba0933a7fb8fc3972c260d0a49ca6b341c205a86c70fb60541ca7078e73a9389c84a5b023b9666d541a781f5f3598ce7eb496873ac3101a1bc8e6e24740c99bf3f33f0bd48c09f71db68637f9d71c60a68f9fe5cbdbeb7845bf8548d5a479ec8cb6fc2e636cb43ac484ade9452f7a02236a98dfa88100dd0fe35f76007c24545541bb3c8a81f07f841eff744e5c095404127b33c0a2d63252e9ce0fed4f94a5698aa0525a64d6ceb6c41a67e3f2f5c0f161eea02e8def37c38a7e4610eb34d0525c157aa2dfc6eac57ddb1abb57635cd67af359298805038e106da36193c9d227a678de1ffe561e3fcb3f9f7664c3e91e3ed6425e6b519a698e8bb576b5c5d1e790adfd0e1ef9a493c310d61bef11e7c67ca7b2a29789908413e1300d39aec4045006ecd29252f004b8ec14b26f7d257660ce3b083c140d5f036ce8ad5fbaeee296913907078071507a0ed5d07cc015f1ce4398a3c4c2676ea6993b805f492cd4268f5afb7b95a4a97125057aca1e74d994d6b4f4aaddeb1da36521f4fd3978f9d07d8362fc968e94bb0d37c884b35ab67766b7cbd4599f4a01da177331028a60729fd31b753eed69d68d42aa242de146e9a8621287c97f6b070b8797c8fac6bd8736f0dc2430d82ed5744681818a5eeaa14370520a2c23ab04ab772894405033ef7c142801adf65af1cff0c31d1e0c9388f4d2a6f1ac23487d518c124bf4c3d00796a26af5ce99b5e4fec74a28ce31a7c43eab9d35f5d3bfc22e1c4849f6bacd6cf26200cb8e5d8f9716b8a1bc7d013448bbd724a64c50eace78cc6ba525a8abea75c5c9fb8696d5d092af9c07b5d62512d441efc01ea6db36ff282fb6d729a1b6dad7cf1152893574cedf889a1e5fd2fc2d796cdda0595785a1dc0a737a4e8d5a02b2ef5f51a062b05e1d746a61aa570522b53fc1d19ba4d021721e51c57ad1cd526f7fa00319aa3580f514b1942f3cb0378cc97dc6d1709fcd8fd12c36e0221c46e78df9a8aba7cdf91e592e52cc3c8cdd631e2d16a9b000850b80467e8390866d3ad407288f6a809ee81c093c2330ef37d8145cd8ef7d199ac7c0108b25b10faa56a1c5b35c267efcbab7e7b8c12ca5bd2037b8b3a4904f8883e73578f4760c06ae3e2761bae3bd9b93e76b985a046c821ddf70dceed6bc66c34c622cbfe66c1a4fb9f8ab8fc246a2871a67bab39237bbfe59e627ba07d728ceea624a6efe62e7a47234a35d54e91110797d8e23d69b58ebb9a464aa4804cf65b6c8ccdb94ebf470a025fcdd50b246c0dae74cb8cc08145001ba5236f91396c41dba6efc0523a5ef24b4a009f42263a0de5d22bd7e9d1e1032cae8982926f4cb90e9c6ee97a3464b871abf98191aaf286cc13c71a37523fc05642719625542f9e1e26f46c957e5554e67729a3bc9c90c939fb46c969d3c7673e2008542b054fb4de045e8359ab0d59e641a1261740a03483d591934f50958d45da7276919d4374cd7bcac8f9d6aec0a9f496fb472273752e07b8ca04a9bc464bfb8924fd50e9aae8fde94042fd57041dd72c9babe2bf68851fc129d08b4731595affdf92911454334b29a06ebd02eb1a0b1145dc8f156dced73957ee1c4c775aa30f6f5acf8b70adb8820d8b31f8fd30ad7205d98724772486884f520267f44bc204122b6f3f460b6056d27459c7023fa01cf8f7e9f0a44eee9ee4b5540cadfc2f0499e38bbf9530df2beb786bbb38eac8d75c83c27c91d337bf1af4f957ab52843e45e7bdb5f6d929b5ed2527d3c219172d3ff732c12f2bb3e9094c1b207ffc33d92f26e1617b4b8a057a79435c7d7800c5d0046a70def302c10bd1cd8e9869ba30b50f0d3db8d9eb99573d8f03b01e29140447862fe1f8d10ee755ad84077b73e92141cdfb49255d5613091ca02f8c2e1060973c2f2f8289ef923da25ea2967a2ea076bdcc0fb9cbe1eb91c8410bd51493588cffc2da3974466e7cc5143a5241069e22ab8087ed9a31690d34934e484458fa59d81bf2b0a3d71c1bd129cb19448c55d09e80d6fbeed3bc40728fdadcb1558d2df8737b54c6c96fa2b2e689a8d13e437fac3279decfd2084b227121c9474d48a28eb67e1dddb5864142f3353a2b5a93569c6149d3e2ba883afd9cb2622f0df9f3df93057e5f7535321c1720846171b74642a0e4b823e75d3245a0497ed0fbc7e13427c31a81e4de1c1af7b0a5de2539ddcecc5e6ddbcf24a42cb931928ea63432ea3699df263b1ae064cfe37d6df21710c5b27e5f7bc7c9409c28f1fb67cf1a3865357cd449db511861a54956d8b7805aad801b5665bd5afb0567d6bd0ef09fdb05e76ab0646e4a6a07dab5fc2d46b7017509cc53636896dd978c429e84c7ed5af32b82354671e485967d204ce99d789d56ebd8e66e6a613418d903f23b4052709aab651a7fad229e1a70d9672f65833ac4d20b18e1790502129c15d5e086f756422d0925d4bb3985ba71b947859e6e5f5fa08f22a00df39d203ea4b736eed6a1f27f5638f6d9e2c3d5a9beda3249b7a5c5fbb710d3e5206d3fea03d4da3a799f2d11476872a957102eed33cbed65193bc500075a2142973d25f2448fc81b3c856bf4a28ef91ba44d27dda95d947eaab29617e763b0bd51e977285fb2a1f4c4cbfde391449e25129e073d4235ffdf5033fcc5ed4efb942e91f09859203635b7fb3aa39b3f5c8426cb52d456bf3b9221bef11445d4b75c4c3811e47c1e175eedc5cbda45ff24497b90f9d8f02dd8439fb9b3da0b17d52ced1fd6aa391070927d014a080421d4c59b84bef9b93e36d5e2e0ad38c84c82bf0724a99db34836d375c112255dc41896e115c4ddc6f73c397c6e5e7acec3aace5c548cecb6c7afac48b157c7d85a6531e43ae56ba94e30af70d767a32ab199064b26f0ea861e484f14ca9d16c34c8cf1c9602ee330cb5e5d10a689544748f9fd19119762086fd752b4dd3bde409b64347ab1c140a0fb0ec45204ce734630a28b2b142dfecf98d6a18242331e0658b1cb73206545249d7bc2d46237a36312ba176a549827892790f72aad1b3383c8fde904f931fa8ef5109ba89e458303fba8c2ad2be41a760bf5d40fb358033f073b85a31bb703189510001e3d0a4fbc44748e9ef804233392fcecabc85d1b9d3001bdd9ebe611851b7f59eec6cda80b4befd4c4ecd4c4b0bbce872e4e1b7ea06cddc7c8df5834b445bc4f36e45c623594566fdec9b403cd18401ac4af795ce0ee4467b4c46ba6fceceaf443fc8d5e43632333118ad3103a14abe64f748ec18bfbe13e8a9bc5e832b9019a0f53a14280473da21a2e0df15ccd65c93a899c0788e1e9584deb1fa87fa80caa3e8a2c7dbbb97998dc8adc3a4b97ebbb11791806899e99fb0048efa6a8de4ea6cf5677df2b8dc8d07667c01363778ea287a0a77c8ea93fa817f52039668b97962447107c29c84b86d3939c638361a9e7b9d8bc9d98bbf9a41ad9296fefe92dbc448ce21a6003aea1889f3d1a5791bb24fb491069951cb634e3d3658b1d1ba3ccafe5edf2e6f73f7c96c113d3719ba610e8f692cbac58395db3770dcdfea2a719fb3aca970471556db6d349d3d0512770c5414957b8a58992cef671164c31a649e6097596b0f3fe78ba1f89c7bce8be51c5be85f8b53d901bc38ddfe3eb2d176bac0552734f0c05c46b0c9140b5c5e1c4474fbf2324b3a92b43144188c87298b029ef477b05836f92df3a63ef0f973bcc06ebe716663953d52456032b16b0b62b8e0f7332a7412590d2b1725ddc68aab7221cf5a7f30484f8e0cfcf49b26667517bff5dfb8edf405a2d28460882702b207915c5aa0950f1ab8517011ed1f5ad32e7c2503459518910ce7e43c560a16b6d8a3fc8297e08e0770461ee2304d46aaf641ad27cf86b29eb693e50efcf87c5a3576d2fbf8ea72e875805add0486c566e9e4e6baf88e51072fc19868c0af7f52835f566b343b50c6c48bc234c4e338f169f88698a7186cac6598f021ce6fd6edadfcf117316ef72b6fe473607ae24e71254e082d5f1353747b0bde3e1b2a59caff0cfc74e0fc9d15c32168be340d739e2c19e5f3a5f880eb4f3159cd1b4a614757f11b1b470b68176e7bbb77cb76fbe18bb7aa09de0b21e92f8e71972dd7e1dbeb0d2b8354e15c72bd2b84dbb0707930ec4eb31c130808968e13251ba70547373aa0acab5727c73490fdd34be2ba66c2e95c3f52534648e95ad0cd46ff6d438b4158707f8c994fb79d789f54e79193befa019b62dbfc73981ed6537fffbdd1e1872b5fb5b56a9618e4e737ec76870adc4789d9fff93726aa94a1bd84e5e195449d9ca65178445a2fe83539a251a9bc1c797b336f71baec6244b9e5dccab96e4a3325451d7a664a64d4044a2bc96ea6de615adecd93c4ba83ba11768b0bb848f6713ca57a3a2d39d2b727e857564cd2ec23e33cea4c580ee3f6f35539eadb2b5caac79947bc01333acd4d87d8af5ad4fd2618b6e3d5db8947080146f5111bed9f2a4a127fc93975bdc3d3d1e7f80e53c7496a6ba5266f89622e191c6b3d7a2e42c8e97be42e07c55fb6902c017fc980e0e6f4855937dafec396f1acc19f341abe75b61a95bf9271637acf0e9fbd8be7dc9fc627309048049bc76597f45ea13e331ca9630fade86f8cb340904f46af6f0e5d7c21b8e2a3c7407bb6f0b7acb408b25c053fe8609487aff59d495072755b39ba9cdc04694bab3992e40339bbc72c68e7dd7d37f0b67799d104ddd53772bdf3af4f44a2fd65e2252231c3353a37c7d784e07d50e28a1cdc4813ab046069c6cec5908a2f598043bbf9cb1a1ec9919df63c66e2aa41a5bdc9b3033f95cf163e16bdecebcce567a1b37bf877053f43970f16a00563d44075b9a020e61d1cddfb9d13a7ff55b1d10968ee358c5e57d7fc57bc709de749860d734d5353a590487c56461b1f43f4d83690cea2107649c5a2ec490e52d8c4200b01626625d0f268f1d7eb4397795e85e5ddfccfb84fbbd582fb4b80c4b1531281ce1b9fafa135873a9cbf3a52f198228fb8914c9ed564ef5feac935dcc1cc51d83a1b1cb1b7b58fcbc24831ea89e77e6959b660ed0503962ec907459f5a73d4bdd581629b23de5a1498cf83b1ad20624736dca8f2fe08de24a986e5aff22d97bc5a06f049723c4c6d6e4a6361217d910d25870227431bf0a611ee6c5c8ce67fa03f396c5cfea301894f30525354b06bd0b86ae3d3c972aaaa9bd3a935e2ac17448e365707925e18efebef5a9c5eaccc0dcb49dead998f2f0a3f4ccac9625e5010ed04e407f31295f3bd335ebc2752622c54e8581236403083b79ffed2bdf25e88b1eecfc06845669b06affabed0b085b0adc6290661196ba15b63ebce403efeee8df9ddd948a935ce1b9cfa9976dd022ee8cdbdaafad50d90f17664009a60e2723e88c1f451627bd0d847bb68e4cf893463598b379157a152339592da76e4b4afa5e3e6a69217b03b8ffceebc98488abd655b02c254ecd399cd32345a1413b4a780d58c07f9e5a6748091b5f31d5401fbe89d542b252a767443e8df1c607014ca7553476e462856eb39625325e3bd0018558facd25a16615ac3cd8abe2201694723fd12a13b7bea140226a7972ac078064727f4177c75f78ec980fa37d165440b683bd03429d8c24316bf59cbd2bb491ff6a0de76903b381828ad8f2824e6e5d1aa28cb95f37f80f8680b55fb01b3eabaa6b5eff6c0d29453b0e3b78d9732fe3c82c23d245379b5399a6a868b8633c9e8be9436e2d77f9b640c2e235f5a02a31e98717d2acbc04f44757e9d91b0dfd6999f2597646cfb02c9e61f34fe029f962ffd6a8397ff83526e46e00350fe6e49b935abbf5672679f7b71fa40568802e9ae0bece64156a01a268c3f07b6d1a19578fb456e47d3da308420e3a6786c353e916f82a14b6408bffa41240341fe3606d95629e282530183b0bc2d003c214ab32f0f448fbeee6477b4c2e3b4bd1c08a28a8ca6f7f612746711a33f96de5d052846fa1146472c1ab7fcbb602d086ad7030989ecf73f07052f9436c4682450f880ca36f21271356dcc58a2cb094c61bd68d1de9b5c938232e53e318ffddf80d465c2f16711f284f7fb9af94fc0a4a9b9ff6cda818ad7cb22caa1f3151eb744401b1ee00fe22bb43f2a42463485138883b8aee97713063345b774c729f691010cae4760205fefed2184a7d2991271b4aa7a20d0fb7a096db4171b9d5f429b705657d557890c4262e1707632905e3f8a916d38992d9136175c2ccf7f662a96fff14e24320b07135ae312b88f09b18a68c7694ddc985b8039ff1a68ea77162f1cf84a6e2a177974e5370834615d9f605e73993d1604f09efc7ecfbf3f153d5c1caaa8e23bbe5e405c1df17dfbcf6f810cbd678bc8a102f0916f360583d612a769c6ed5f01bd94c67772deee38686a0abf3df1d641f21fc2efe0c601c7c1d4961676b1f02a3e6df140ee4f39d1fcf1bc6a29908cd1e255dc800fbdbb96abb182c519eec050d931aae03e07c13ced9dcc07056087cc4a9efe80a952e22060d1419b9aeeca57ef886b391c9109d1a9979760a11e302e446e8aca3249cc7c22a52ba8fdd7a1f05bff51bcfe20485f217da67a35a70258d50523bf98c3e3b403461487cfb53303d0b9ead447fb8dca199932ddb11867284ca328bbd1acb3f42a61b4c1b6114dca526c16923aa7d65827bd74db82b7c1b8f1b5fe3add12b888a4ad44ea9b1dd8d61a9aa247b3d281149c44d3cc7458984e07348c9a88b86b2475393aac5a01ba9b8ac1770d5ff0bc3f8e8199ae0dab3b76237467ee63558e0bec9d181233247fa824a252dd986d2a46a0702639f6546b720ed8c96d09a450c4a72ce29d5ccfaf9f98aa110f7656a80963a7b97701c5c5b9a534410edcab58bec5a2ebb62be46d58db571097800dfb34d427da7f7473f12a5c536d3aa2bdf21b3bb0baa9f858ed2dd1b98b0641d8a6dc96d522c28f7d6ebf693d4f74dc96d257cd76446ef56b9018d07644ef5970c9c6baefd41bd3408157d99b3c3a7065fd5db2b6f4437e6d760bc31127377169fcce87c8d8d8022ca686aa24c005c9e333856c66186d1cddc4455824b27c6a495f74b3e5d26bc2a12eb3249e7f3a86ecd7df3306d44e55fbd454dbe5e288f382f6fe70f5c557287a04213e48fa7b0494f10a036c81c4727aa9be4252c9f8dd3ef408d5c42589122b28c9cba12c7b7551083ce4f87f3488ca212f0e6c21a114144b2cfc82f41bc43fe93dac684dc0091e4293911fbb0599fb9d12f1838a1c84c59f76740d60ba103aec9d36c4e1b50670e75113b15c93e95c025150e57e64af41cfd98025a09aaef60c5942951dd5d5181199cd92fa8004cca2e43a27c57e0bb5c11554154dee9ac68d0b2806b79857e4861052f3a79bbd30f098308e874082ceaeb2a3bae55be40fe28c1217a9cf5d7fb22ad286a8197593a4183fa34a5702baf0e6d79ec732a225375e9ba2f559f98007c20ec06d893a7b9f483315e1d142d3c6d806ad1efeb4f04c435158295a189071a78511486353b9c7f5e4d2fd28a7369d520d741d4555cb4d4a62f4cf957f1d5715335d2f942e5166f23eadecd6ba98f8023e62fd2ff62a22efbd60adc16b8d0ebb657131184c4679eb75b35f6978020bbc2447b68885ed613c63e6fa629cb76f337e147a461a33207b8fb0284f71e1d99b644b2fffe8e31c4fda82cf0af5e383bff2ac10697ab7292effb10ec5a33c37b5e929dac8a063daee1e8993c054d2415ef7533c023dfea22f3998c9576cafc37e666b5952ddbe9b042b1f59d624839c2c4e30509ad689ad0fc8e615d409852b49501899fbc09b97f15e129b4209c65380721d4875374963511f1fd002c31cdc496334b754bdb0dc41c2c3aab0314c296c941f12bf3e1ed82c999f356de7254a5961ede53788bbf239a4793292db7d7d950c755e36de72d9858ac769217407b0a1788cd7ec11eae3dc93357a981b9fa3b77672cbed7db6fbd0ba0c9eb5708a56f59cd9ba913c0c9a9654a962c70077637f2def0aa2676a377d9064b0926c08ff7a7a75272cdda991b410847953c6a3cd6487d806409a453c4a82757dbf5863ec7f83500658dbcbed8bb59e3871ba2a8b619e092c31aa91fa2dcb4d3fe7a02a70ba2656d4255d8685d627d5f6ed0bfe22e54ad3a8350998beb166288d99dc2586232d7b12db90ffe5c9b3956cdb0219f8817b84fa9894bbfe3d8f9a0b593c172c53484cb5ce322cb2b2e13f3f001dd39169ef89dd18eca52c8d302ce69fb6cc540384f25776b1cf871e874b7a945157042e2af9efe06a78e1f942db3c20bc8814099fd88d87228ca146bc68318d40f80964cebc5448481e694e3e4b8b2cd590c7e11ca002fe803899fcd6f4133d47ecb9440b497b4faff45dfbcf1a608e623bc4af0d4efd5c39b873f28e546c93e600bf2165d3b735d8a30d21cbad750fc1e07abb83128a1356ecd5f4d8f8fcb138ae61d5505d74f9e32f46ab1ffd5c799412a7dee575fff96fdda05394fc9e3e5df27590082393e84efa2f2115ee0136f3ece813131753e5cbde160c0d0c97f26ae997f8287d62641b79607b7aa6424ed2e0610ebd3f0b3e0b6595b57b764e4644f5dfa67107b75ca61d63f14d9c11cc03494ea7496d6b9130d702046c4fb0966ac6aefb78490a6c085bd1aa2b2248b2fd47cd2a6cb79f5a98925a05d05e6ff58fc88d8743f00f450689c7f4b9907c52774163b3a152c9db60516eab75df8d23adff6c9df187313f918c3abc1b66e38803daa0bee4a0b4bb3ac6efcc7450c40767fa1b6f95904fd78ed26a649c68809a17bdfb4986cf0e914677fc665151ae2c9af890f0f55cee4c95f4e9d1a26ee21f265b827f5586074779b24541e74fca622f87616d5cecabecaaeeaafe7debb10f199caf4bfba1c36341603eefb81f596ca67df355bad36ccc3f6c2c7d1c6442f33ae1549283f14aa733086825bfcd4adeaf61bb0306062b212d1ee1388fd3804c39cb100c7f4c393777695722102bc0ef427004763e5245c6e1c53c4d128c2f063860d9a9b34ec14ec5e9d6e1035456ec9e167f4bb29a97460aa766b4bb284a78df6d6e21ae218dd157734d755a0424d6e7fca4b099060f803a8d361322b7d7fca4a9ba2a2e619123b2414a2716a081870ecdb99dcd4ef2937b3e11666c089e107af87848d627ed66171b0cdefb4e1dd76e1bfc7a9ed9788ca6fec16e53d32d37b17cd2fdaa25cf262a87176e6a3626077195f56d34961dc195e34b3c5f2efa5ae8506dfb30491a169d451d1e6b3ed5d116f88df01ebffa86b5ab7236661bef15747be58a5c8895becba952ca8b20e1c638aca60b1209ceb9cb76465506465abf912e6d82133a645261f4b0ab40259dce37b825bfacbf399c5aad8c10648e4e23520cdacc281edd15cafe82845cfedf7a582ccdb794631c8e9d815622acf0bab3a921ee9dbd967f9a20c07f030f03ba51bd16cb2faa0deba19a8bb2409ce92103ca721ab1bacdc4feb53e55a334989312bf021eceb4904600563aa45d672399f73cd14baa9ef34c7e41bd202fa15c9146767c186eba02b5e73e0492a3e4a18f0bedfc085c5cf440f3c964bc3152b866a6c9c6751c0ba1a7145e763170a4addba8e8e3e390386ae4b4128639211697ec6c2207425021ff0a535def098155af3178cb40d661de12794bb3f5c7c2bb49ba2927115f815f8da07fcfebbaf620fe1e629464016ad53a834ebe4bf4bc96626bb0f187a3eaf90ae15a493f0df8684782f3d6d9f1fd9507f009f61513b58491a67cd85170af960e6a6a10988387db2d126a932a3a202532ec4409cd5bfb45e80e9edbc14a2e1a1bd45bb3f4d0582caefd4e33d9de6c7a7dd9f4890d362f7fe57ab9d41ed8c99d88203bb17c9f79209879f891c5b02ec3da330d86f7ebe36ccc515593f67191a01dad5ff32fe5d1f250db1bd8ff21f967992b46cff2fc475151c90974225dd77e5c5a96b374f1ad2ae5f6bfead58c1c4f5d9066e1ddf9380e54b2aabc88b00057efc69597069521281564ffab5ebaee79eaa3317e05c6f657e531cb1c266267a7ab3ace861b6612cf98c5d7a9441b2750546064c5971fffebbab71336fc4f37e714328d5443b00c8cc96bcf206cf48e994288617b070c1defc23c38d33df8e7ae149f64c672d242535fab7f4fc0090aae78dae1f4b5eafa7e9a1b7a23b49e77437c4d82572b0bd3a2add9d17047ea27bcba06e4ef3e760c2162f52dbec99f69e79d18d626f92b4b37aeb3fc3e0391ddee8d2d4d9d93a251bfa3edc677ff52bd1bc3f9757c40586fe46c13cd591c94b6d92b4d45720912764c5c8ff84f3867b151164e122869a176b1a5a7a40e2d16648316d82b750090ddc48741ad38318ccdc38f8f4ec3b7e61375e9f192ae6b8abf9305c33a1f9e4a639f88f5aea989ad793bb99bd86cc7e0b9f107170aef039f0ee5699114350ab8f0a3bf85b77af442ec81107f1428944f7e886fec78aa448656a8be2d244f63202b854fa36342d83707cc4d82d092de13639d6d96a1992fa135efc3a6f9574da39242973241deff0838dbca27c043277edba707719d09209cf8504e5ca379d0a57cee6c0fbf9ab6d51de53849247adba334fdfd461e883658d888e78faba3af535075e81c5b790560cb6ee1b3d8f832467535901f2d4a6efdefa40257581fae89f6ffabc7121fd142af93f845ee614ccd180501897c66be183905804b0ca8faae281cbcec55ef21f428eb28eb9b2eb31c2b40d9bcc0632900513c5783343d1f53334cc88ed869a1936f37e2b6e6578d7727b6bae8f44301b6d3020a2e092687950653403e4c46fc534cf0523fea3e1b461661b9a8c791aa9e920fd4fcc2b38fd1afac1045d77910d35127d58d4dbcbd61b2921d4911224c0d395af9e413006722b45aaa2a0e9a8e8b8a27163caaf5cce72995d0676665be2ca4706e5a669f162cb580424b9d243cbb243c5f64727ae821565af182e9ab9c12452fdacad27856046cfe353a0c227106b693aef517d7bfcbb21bfafee972b6ca0f05a397caf32410022c2660f3c21ad6855b36e16d8692418e2f440bcab5d45fd649dec464b9a5dec272ac0f1708a04ee4b9eb56cbe82cfe5f811b5660e7e0ef7d8fba45c3b60480bf02e039d543c3c9d0c1f408df40e7689eb6652cfe4387c26a29c73f7980b9ac456ce2c30ba06b709b2a0183b0c86a277595116142cd767da45c517c7625df81d6d86216c357704b5ded7e4d2bc6317eb7221dc07dc22fc62cf6ba7f23a1adc2ef4d23cdc350893ee9b1a83e470a6e132faaf03faeb3cf07a11a1dabbdd651da5b0df1a8f4f466f91054e8e3eba88658afb181fc0a1e2024aab9d153af55bb7bb7ade6720f78b7a04b1d9639c3d671fc6ec60e4fce4d0c81bb7459b5c72608bb27bbabfabc92b1e885d0d3ccbd9b02cbc1ca6036530db5975523a855be2b6b620c165ef25a3013cc00b39338d6504669a23d8dd74a28ed2bf04df17371bb2b015a059394838fe160450b58e0fae9c2b61ac38a9f09f63cf2417027bece0a3bc52d5064110ef515cc56a2fa8b0bf5fd526fb118aa4be87928f97b17857240cf12588e932a497fd3b2fd5d2fa0cbaaf53954178449d3fdcb29f4981b5ed42929bdd39c278238b80e1e8a947e9c3234dc7dcb632f804e9db809da4a064fb07fa06d052cab987812e1210a6a3556f29667f1a15501de6a94f5684641d22d8fae6ce2cbdc918128d17c6df08fd49465036385cff78dd344c5b36b032e1c12bd550a48507c730879d3a272484bedf9da395beae74c6561a60a9e86def046ca39b71764bacef9c98d1c34664f062b67b14e7baa3dbf34f75812d0ff3a6c22cd8ac970986e9014b5e191c20267af5d4078219907ce191f2d0421b37055a05bf2f55e59ef077218391e885c091ec736d914ec1a6622d860b0fc753a1b3c846a9649b086f7198f32b3dec145cc18298963fd3ed0ff125534dce65d00faa10df4c74afcca604834cac97a4df700e57d199a8a8b46137f9bba2fd0e5204ee7e2d242495f259416fa40579f02e18acdc77e37bfe96dc04a5b1bb9581f841ebf50f5f6125f6d039d4115923d1fa6dc0839f90591dd4b77236e1aa23b90deb26a97fea04ebb67bde69eec3421e241f7de6c0b1d1093f73b7f40ff46f798501fcffc36445d9407cdee0e8978f21dceedae013db908acde24bb5fa493efa1dffb0731e2328aea5b65263bd2d31693156c080ebe54f574ea24b1fbdfc174c544cb98665279fee3b7114a35d863330ab0815eaadf40582f2e2341d6c1a32ef6c2e7664c27d3f44dbc5e2c3c89156eee86d4f8c64322b192860ff44c7efabf559c49e44dd10a87466e6864d6746463bf58143757a4eaf7c56b0eb2f23afed30cf7ac1253c77bfb820cebb00299a185d2be3a5be509b4ea8ad0a91d3a05e1eecfcc09a3bfb51d324fcc8fa87b48f317a58bcba9a0b4c26b3ec3f6d7ffd5c31981fc34fd0e443c86cdbc82826bc6a8e0b25bda44df81b36da0add602e47f4f3a372f4a3c9a2d85c99282d226773fdd6a3d62f21e5eece3fb6b5980056e7b7e061758905cd61f83b296db446c0040eb9cb793915f6ab240179b595598daf339b97582c147c3e7588e40ea6e042da5ea20a40b9b219ba0d5925856c237d742e28803bc2b4bfbc329880be3db06ec3ab5596705928e3115eba9c8afa7d9f0db552b71678c020f7fde514949f623ba6bb309b8693dfe86efce8c3e2688b0a116afcd556007fb69f2167b503ef9afe1ed0b85f916ea3f37233a1d39cf7f6df0b32febd4d1e71bc83583efd8d438c86da7192b269febace6a2c0bccffea262becc527b6282dd31465fe129e789ae2005ffc0309fbd43e15d51ad491e7637678af1d7b4d2e7b3eeeb1877e22794323737104f321f6572023add69097621e4a12f054f21715333b2330d660206451a1a4ccea79a7bd9bf2e458f07cd397d0d0087512fef0361e8a8cf2fd190238283789c2433970cd931a49928a4074b08a48dc944a444270a29bf557c2d3d11b00a20f505cd92b480533114f85a48eb75ce3b3431a33cc8f52d034b9cac74b442c27daff9eb9325cf3c1eed488f40d1b88da3ddde6c2158e5d5b68b0ac7da014c4c0a10eea17232db85218614cccfb7a28d48bd9250e3cadfec6b39dc6afd3f8af5a8ef218fc2cce5ee71d5b74daac81898171dbbeaccc49708aeeb1ebcd28e0e25fb948aea6a19c25106ad63cce63acfdb1bcc12160c679af509daf37766586496847553c887ae1bb56f0070195fad8db00cb854ed6217fe3457b841d6ee73b6eef28903990c03c487054846bfd8a5b56db2cf34dae1f7dbe01440a456a7aa38246425d30434a9c4750a86259cbb6e84233cf25454e881b361abcf1fb96b0baeb828c9c2c259b162c315bd387a8895825460cbb216e3979356254284e30ae93b9c71626bae87857248ccc53453e7c591e32b8c5e866e50a580cf41c8fc1badbb1c7dc81c46f3c93f2a49165442186ccc6d8c84f97e6e23ed9e88c15cba0806fba8ea4159a5fd5029e70f7a2ad4faa87af2c7ac10e02ca6758eed63f9e12c0afbe6eb50b9c07a3bdc7a4142bda6048a54440dfe3aedd10e5d23b3436e43b254e58b2ba57232e370c277c59b5e30a3c12911fcd0cb846585d38b24c81a27fce1706b88afc930764046f29aa95fd9b648e67bb7d9850a4dacad4c43fbad07c88002d788e3b52e848a887ee21fb783cf145616712b9679a4a975ce639dc301b0c6ca800cedb226573899312a1df20b2d0209c5a8580cfc2e8857ebdac5b88d997b480bc5372a4f7b048d438176b9e44b14a9aa02a384ecc8bb0682a8e748292215ea3a08f38cffac93e193bebc8c21a39ac8615567748749640a834b63bdf8abc4604f95112efb5a6a111bd470d208f9ef236bc4efda836c81a808e8bbf66d39f0bf2bb13d782500af5a9673ab25e02f0d84762a33045e36451ce6fb5a11d5bb9f1c034b2befcb4d9e6e4dfd44d8e89ca5018b8017b67237c2abd60be3a242addf6c38872c65df2c728d5ca2a5505ac6d530dc8c727d7dcabea4c7e5526f9723b1ed5c3eef02707b2c1c1836773f3e7db28ded053ed9b8c00cdfb3c8559cc76d21737ecc2b2e58c001b483b79e83eeeff4d7960ae6f381aeb91031bfe34466b67b8c2aa3f7c160026cd8a6aa34311dc49216970abbea50557e7a36fc69cfa06090c449fc91570aa9e7caf0072c4e83cf941dccd98671a8ce2676f80a7b88a377e5768d27f856063923a3d68b77bdfb23a50b9c1be85bd53d78d552a380b78d4c250","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
