<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23b4cda426d184dea302a0cf07c23ae98cf4c38590a5fd8d26436a460e1d625cea6f0b5057eba2d6ced23f30cae3fa756942c2bd2439884c0d62ae90a8846452a9ec0a83a55d61f6553a00a0c76bdd7336b7a1eaf772176b1b45c1fa4596f7f954059a1a534cbbac0897f66ff3523415dd45fcf1ff7bcd82d54653c766119ae9a78975efa9763fa95e05a94e6f760b51d65fdec7707c07a46f2f1e6ac939815184dad96dd54fbd16725ed899a9079a0538927ee7ca395ff40d3d6390b4c89788e11b7592b881949d5a856b7d3c75233d310a11d5f9d3fe779976b1627c6edb0f3d7f6f74537da0e24ef20363f9ef236f2f39daded8c32443f11a1000e3e75d35776c5f915e7ee2e615a757fff0f29156f13bbe217ae90ff00fa3e4168d9a759edf4f948cbe5d77515ccbf5930a95f59328e51f77e1901aea454483aff205a5e0c320eb7b30fbce0b6db7cb05d79bf13d1fedc15aee0098cbff35c8538b9a4573aea59a0c87ef6db7b21815a96588d11d182730d041a6c977541355a05da4dbf3a801dbccf44705b3f0c25c6bad242969e9e95f6b5906a71e09eaf6703f47038c1a0b50034522e795d39185fb587a691e589265b50a7c427585fb792f71000b83a61eaa8315f472f806bcb54c1114f75424d8cb84d8e670613e4d7b2a5146307607e369605372aa6d7edfb45ba1d566ccb71e26b1737a7f3a0e710b141de603f8974b505e1e03492683c2831e24a43ff393e15cfdb61ee712d0f2198895f8c5d555e67ee0fe3d1df491f742dcc249a2f0067fcac711a05dbcbb49967bf516dfaf01b7adfe586d64d6433dad6946b0257f9bd974ed959d130681eac91a4b4e17a8c55fae22f7e1bd5404ab02a122fc71b236c831ad8cd8105bf4d1384028b2dbc331bc906da568e9a08f992cf81b77ada142f281c6f88e2d1c68c5ac6c655018952080a4e45af9d49b4d472da4fe88734d7a3a56e8aa0ac16a1aadd2f1f7fdc18df75aa2e78370bda4bef88b8e2388c1d3f87bddbe8148ba055132de39b146d4fb8a15c414bec6420a9ded59714055bb752a8f810e9ee131a23b4ab14d953e391dd6a1b08cfd403681fd628d069d334d359072867481adc3b3013c7bc242bfefcf3203ca7d3c3c93e699b2eb4180d92808838c86e213dcc36c4843d6f89d4695541b752872faab741a49d0c338319605ed4287a11280dbfb7e3f6b8e33ab04ee8a4a7c4a1e8fc8662ec6cb1b88b4d4d77325f825b5343c5f72594989df66ce50d7eb916c6899a9bf75bb3bf914786489b42aa9430aef11d231f5ca2709263aa098f34bc8c9fa76224fb416d250acce259153388a972255c9381514900f9a97b8e24e06bcd8cc84b79d2f4a0cacaa9eb939c92ceb68a24548604e408e4e7aa0f1e0a9b7fd2d4d1d33e6cb12fdb86da29d8710690df721f75979e294ba7c9244e1caab33af1c368318bca7f510557060d9e649956a6e8eaff8d5d6c4a33423eb917ad57b47ffb017c9ee50137d32d7bbf2237a47628deae6fbf21da57f8afa4bcdbe28715c61f6627fa8d8f98cb3e436c1c576c48119df49825d14f09a93f4a787a88aad3278055d3204ea7035b52b5407db6fd7749a78d1b576a9f4288020a2a365ade662d2d7ddf3fc5e11542f57cd19451834831217c52364bd47ff457dccb4fe3c17c822de6fde61952364db5646f80c4065737f931db622c3a24ecaa4ad0c73ab4bba0fb975ecc1497ae2fbef17a35a317fffe47b38fd5e8171cfb2d94cc8fb64d90111605eb812f6547dee2c75dec2c469bf16a923198d76ce7c1ab8909651253833f2163d2799a269e149812f1fd3502bb680bc72f83825d3f88d2897f0130182a4d90abaa52f9d1bdd75e83285041a21a6c2787fedf1b79b7060888c85712154ae7d709d0bba61b3b590acc19169fc22cc5997945a023e4d4757b520ddcab8bb84d48366133fc9b565cf79b6f44e24c3889636952fa571a58e0eff0da3bd7f811fbe7c5f157475140760bae4581e128a4569c6e0b4a5e8e8a61c1cb18098e44231fa90be4cb0c3f57587baa68d934efda1be021bb63facca03ee60701de2b176bafb27ca0cd2cc2b81b5fbea64100de155243a9e14518cf305a01d7443b1a830fc1d9fefd3c286e46d781357bf660f78497dd597a74ff54f4e1d63158d4423e35470d3b132a9de8fc06ec1f6c2c009f33a45bf1afc3108dca1c0b21bc711e0ae604ba5c977a784ffaf0d9760f124415fb635881df1a85086d4dda9e68a4f3351418f74404b6817a10bbaaf7bb89ac16b32a4f4f73a27a41697bbb476e54719e03ed852236764157158acb029543215b71f7962f90748cc2c192fbb68699452eda42ab582798e1f2c74bf6cb92c82830a00a59090424df5a33b52fafbf7193cdc02989e8e5575e815bbfdcae76e04e82f73644ec6c69be96d28fb168b65398aaf8a7b559d7f50cfe8607f67d0cf9285fb525673136bb917e8ee7170fffdda09ad9d966bf0703335a81901372ecba6af0c1c0aa6e74b127b78ec4f78b8afacbaa6b756f6c273dc53d777c25636eabaf36fecd515c1535ff595379ba00695a2691b75768a53800941b5488984da985f8c23275a0ece632595d5a397e6838d88ee5cde805234fd4a991514bed70a36de37fb7329f3793da0e661e9569e1f86a1d0a34b8b41de5c2a5ccdea875b411337a33a0e37976cb690f756247cb880ca7f1ba4fae57a095773a51d41f45361e388d9c4b7bcffca0e8d01c9fbf3e10681dcb16102f4d331cb0e521d42a62856550ac1d0ea3fa4961fab1ab5e8c484be63e64ca0ec91f99615210419275a33ea1534d248d6b019f3d0996021767740dd9a154d81c60c16b2e62a5f61b8b5dd417b7f9daebb2b1d727df77dfc64df161be5d024a3da496219e1c7dc38a74cb6acc4068c52d74634e20941dbd7410aba93e5787ecf65d092918893f6059457c8c64c15c69b6d11fd041c1933fdbcf36840856e4b5212adf3dd45c6fa9298380b7b7058ab870b53ce2f60c77c8b61a0ad8bcf2432766a20d69b67149ed6225ae6b2c6fef401d6821efca12a8d2ef1fad8f4234a14e039a44a8844294888ac556f7603fe5a03605cda5ee1f95f0a03263079e12beb0651b61415c5c5851b8d2d47d5ccd2976684ed52d5a63471bcaf040f07bc6ee929f5604e2e7bcfbec13475cb6fca348fe8e6a0e8c7f24ee242be98cc920cf2d86e6bcda419aca52ca78598277e7d4c1c8d39b76d3cf93eb7725ca2b434be52a8c8704a4c650e06e24635b9c6e865b18f545c17c78eabbeeff7fd41264549626b475a84150af70d9706fd68af96a487f8ccac623a24ba0ad713b00a61d40b03008646a5f283536af91f3cde0438d80b6087e8efd446fdb14dba305e51a8960cbe33f50fb035f84fb9e92a491e579e74f7ffb7a771cf5871752196907ae36dcdf655e0d5d3e5f09d2843f951dcd321fca81a3e6ecf1038006bf3a86dc5f23c327864f64fea4c2a8a132f25a06738789df816f09be88abac0a07b02789cbef1a498d93e924625222554a6c35b42ddf827e47187b5b7b4fb59850dddfaf206085ff00c28fc8a113e0bcd1e30640715916595c814b47f357f30d3bd3251d458eaae8bca601b653178906762ec050df98f29d968748ddcbb31b92a4d72752fb1d3844ad144653e54a000cf09fdb3932c09e8eaf671ccfc68215870c2150184e8b646e69d30e0bcca60e92cc4b3a68869c9418d8f3a4edbea43e4fa8b7e0a7475a63485aecda89d70230782a359b99750ac0967a584df511832ec37246f9d64ae0edc8052c9539dc855d633d5b41bfc1d9885e94a59b0d677d7ed263edc17a114677709a5cc4e6b6c9c575a6d2e6e00a0e8e1fa1c51f5bb1482562b02874be81ab72d09dd5a605340f3d6e792cc25de11ccfe283bdf880315fba19381e9164294f230c91e63b4fb76659141548ab1788af363f67ae19c61b471da5634ff44dc2e5bcfb4a151e020add775187c903b5abc89eeba96969896908fe045d1558188034c49e2f73a4cf653e8a4925c0c7237fb3023bd6f2256269c0f4f096e209ceb5c18a10181bacb54795fddf77a0f6b8173da8dd088de6528d18f296b05c1dcf3025fcf988538bf0c7386208d899511b59f87939971ad719088f4146b5d29f741ca9d995c015c3155d0e4c89ec14425d66ec3dbc61d8b13fad61ea835017e714d3817c028edb4da28ae0d2302af2bd5613f46aa4954714f97219167517fb29f8155ac525a95040af11474c493496a8c431297fb848b9cf89b17d61677fea4e63b769d1dfd771e57795a9067ade1f1fc08f12fcbd12ac26f981f01022d9adcd6f4da82a4c7aa2765012ffaeda43ed7253c4e70e86cef2cd3ba6010b14fcc4e39ec815107c788f12712440847738cde490f34fd77c3032ffe95a6f14dfee7ead25b25032f6bdef1fce8dc536c78f39f720a0320fd287da98dbdc62214a17c2b21db57a6dfac7925b3b9d6fa827b8fb29ded8ca76e495cd44fff8f3a37b357d5cf73f626d1a466b6ec2bb61a9f67906e697f6beb25bf8d726ad730b10df9d732c3f747adb9eb800cdeabbde46194d7ac041ac583c9490ee3104e3f359e72eaa1ec72883a3505a436f6937433abc276dc85febe1775a4a6e19858468fb5033a1b891a9dc93731eb5606d2ab664d343b19340cca34d1f413574aec319256244f55b9abea935a85d6aae3f8775a7397faa1df11373b6459059ac376518d8b5f427cc4013fcb5ad344269f5c00524133975e04fc01fa00e89e342d999f62618662ecd1590b78f1fb198db2b9a70a20ce2db45290e5b48162e2c54c6696ffb27e50a9edc65b4d4dfad88c93d6ee71fdc49df1842b4044468d95e40a58b54dea1a81899c75dc10a5b768ed780a3f30d2fecfebc2d22273efa1ee424ddc1bb02f96e65e9877a4e5d7bb6bbdf116432cec95b73bbffd8aba18ab0b30dfc3b38c34fa95689e06c5de6241053e950e1c2c726857d4772213ce93c02292a2e33b41676da6fbfbb622e97e97e5ea3b06dcafef5c0b3e7a2156830c4fa3753361965b1c0db7210164d7bd7d17c21608e8a45546aebc7efb8a936f8e0a116673471d9258327c82e23ee7467ece2d3c0abf2abc296232618c25725dd8e9b28e1e9a69f2916e59078720e7fa259d0ffca2fb27b96212032f1798895e18e30db05a3bbb9c30a7beb36d4f43caf3ec653cc18baba3bac3b845c76a9c733a6228c83fe0d077f80656126181b28525641b94ed363e5e7c3d049abd11ecb0b7aed6ae7929add8b0b2676a03de02154cde18bfef4feb282c045dba1f300dfe964965798a2af9fa5f5c6ca543d42deba70cc4e1333f0e0872efa6adf437b76c2547a2379e9d66f1fe9affacf108ba35b28069e57b70ffad623b88b037f9bc5266e63d4f052ad253efaa95adea1e9d0e7db160532787f2c2bc4f3e0c7ae5a15d9f5181294fc9a95a87fa70d46f17fe64218e696b586cad93152a1e2d49c240f9a51162ef1f28f9c576da2348357ffc244e53097788c447bc7586edf06f6f4a46036e80dd38b8e034f16fc4fccb8c9a61b110774914e0cd6cfb80e88ea1d2176f8604e780249d22dc48d622c8251a6068283b745e743bcbeb4979b4b70aef0afa6917305b6a1408af77bead3596fefa8f81be72062b6c30ad48490d8f7e9bac7c4d3aa30c55330abc583cb8d844dba97be44f5b0e344745bca1db69402e24363bd470ad51956414cad666dba740934835a832785028712b912a56fe8f54ffb1dd4d7a5a0492d7cb5b3c3ccd6cae00ec5353899a28763a40115623dc43884ebe0442d9e10add2e91fb5f75ad05f5b18fa8f52e4e56d2ef77ee0d325c2a9b85b09e9825d0d5c6ce4f494cfa9c482120bea7d34548fa48bca648958f548d150cc2b32ae40da3981a1b5a9dc450365283c4e521d23ee76dd74b2e17a5f005a8e26f35588e4a2d19194f4cbf7852b782766ee5e7c5e5894a624b299e937ba1de62762121dd11013f764fe5c8ed8fe06a3b983be40979b509ce75c698c7b554ee88b84a90ea342b37a27b8e22462663411dab85af088ace689186a91379bae38833c989062e894364192f579447b49d06294ee06c2b44a6d21d3929efd066a9d272600cb665b6c2576571b0203e823f368e3bb5d9659150117a4291f6a0fb581c0fee517316cf8979f691cdd76ccf474525ecffc9b4c467e95bf4497d12f4e9f11f2152a9738378eb471d564712059ad45490eddc42e99f5c967dcb0ff699b04f0883a411d32c473ad3eac27841bc19d8306db8e137a5864b8bd08c05940918949ccb82872c9d5c4e2c19d026d4e096d2e6da26cd64b6c19bfd25d747bcfaab6b194eae081cb5a9973979d525c2c404f46c38b375beb81bd0724b8aa6c59224c75f587d5823e8b8c8c51e4f94a848e59f70b28605d0dbc1133c9cbe463fa0a777052c0175b36c923247b16ea0e2effa4dc78a75a635de63c6d122705852cab1be96f9c0d3745502d4ab8897a75725f3c89f955bd9cb33751f0daac3dc1974166d23a8dca69577abdb592f1d08c5fdd1a7b17e484dba6f84d668b12154641e80b51a3b2f6e71b16dae437f0dd90fb16a014469e9d8a12ccfea589bcb6ae70ac177642aa952877bee39633c3f90838fcee1feec8ebd426500b4fcc3ba19a54014dc6f33b90a141b4410a356e256e209b9707ae6bce4dc6300f86ddefcfd25684cf9c6c81e1aee63e96eab25023f8dd54fc982e289e6f6b931547b15c72cc446d7dfd5a3496f8b3709d2ce9b8d3a1b9dfbedc5f9fe4eaa4d13ce9a4e118b123f5adc7d2bbf3254055edac61db02af97f05597911869d7255818e9e083a4ab448117742ea3e4778551d5f45dab24748f7123f72f0bc497078b34a38bff1149358a309d00b659223dc49336ef42dfff424ed4868e364dea000daa787a32b7b9fa256f2e55048c437313d9e185043d36816c1284797cf2623de363af8b396cc8aad13266b3e1a521656d0ae709c8bb0a22239cc41d67af0183ff3e496613e8d9d4c2b8dce076d3a17ede9aae94d35c33a258a86cc7c1b432e454e9b0e1b33e71f7d5cd8b703c1068195744e1ae192a8cc3b67882a8aa1b3190ac2c3dd13cc4e530c51e44f5c8591b5ae45f72f3a9e77077631892ecc4c219f592b355199efd850ab184ab1179a8d6e2c741ab713a4e641000751c0a3d1596f37cbc4648569fc8c0d04a74e5cd1c6410e5d083c65bdaf958f1209f91e65d1e3971ab30d395081992a1c3ee3ddb4692cbfcb9996cb9858712e680a6c9360a26562e186af2dbfdbad956a6cd1c516e0582b479c508e5a97ded3fce1d27e300d7f3c65f389e5a03d5dad7ce420e2e8108979580b9381f9085fab0ef75e48e90920e481f427135dd6a65aadb133a7c9d4168f3aa014cd60e625ddf497d171515c8ab69b8651499306891ff423ceb9f245ab8c8fb0035404365e7a9d804268c4387f6d9736c55c125e04ca7b34516e38ad7f2c318502d63cf2a2d760e1b070552d03bf0f96f7540700da479b2f00e2ea22a17c7637da3125416ef7614b60eb1e9305aec053c232edb086a46d4f4cb922ec710b0cb72194e0270730e5c24b60d1980878d16f74765c09243a8ac8268cc5bf273f1e4cedafa0350c81977d8b7fee91cb64484ce7a0c33cb3180babf945eaaa2b4e65b827eeb1f72b89e2bb9a9c0771e330a9c8762cc98d19e0ed342aaa9785c425c98a085832497ba2186c340a8694291013985fbbdedf2830e73d2771213ad9c19c31c7fb7a136c2e13d86f994334e6f22edf2b00bba71fb1cdba7663c3e5bf4c4dbc7a75a3ddf7422e51ae9bb01c0199af177c888074b98aba41054b18ccbef3b9a375d2ec66548c152b3db1ab2aa27de0301e9b9750b00d373ee2b4e266b3631d8a4db5ea51713750425718284631a43535761440d148d16d869f314e81355e74fe089b35bb73e6539ebbb7403bd75945fdfb52e73dbe25e3baf0cc595a05a173bff1d3c85bee7a07a184b50f9a255aecf9d358ffda161f30ae6681045ef7bfb696ea8a46dff145ad792c33f7e61dd16941217d901d3ede8005c4beb448c86019f1a1c8c6b7c67582501b4ec1fef91c21ddbe0c392958cc93250129adf98ec4f6595c27ea812726c549fc3e7ffc16daf2cf9e1de9b3b6fa17a453cfed46bc1f26358d2cd9901fb02dcb7e03db4a4daed33fcd753cdd3797771103acbd8abd920304ec6580a2fa153f612b035f0fbc480f8470970ca2417d37d9803b8639829b7bd55f21fd231e9e7ef1716978ecb2e23346ca059def523908cf7f8d142fa8d2eb0570987a4ae1dc6ccf7a2bc69eb2da38f5fd02394959c5dd0d4f6319ed908db535e2bd92ae6fdbd64e2b35a928cb67b8ac8616ccf6611fec66e2b319ae9518bdd4e719de25b56711a92663cccbe8753808f9a8276f533d1bbaada6845c3fac575de593a08629e605c01ccfdef5b5c48395ac3384be41688dde4e7657e0519b60d71e5e3b6f1ba6582de29ecd86e44aab5d73e95923a42c4f5e1c6f19716c08b39be4b8749655848d6ef012942af7cda8128e3788b2a0d0d35a5fdd4baddcfe679976ee62b6c0b7e5dc3ddb4ccd74b98cd9049edc84fb8b68345f1ffae0837ca0dc9700a3ec6bd843c3b8db8b53534993da4245c4eba845a248e56baec19f3b64c25666ff7de9da03ad072814509199645924aa69f8ab10fa3632d50eb1ba9830ef39e14e332813ef8cc7b345daeaae0153579e20b8f0d9cf53113164aabc44c195c911d6b3ce4692205922894c37506ff67233d81eb1d3e45f1024ea799f05bb587076dc360d90c819301a1744ce9557a0efcb822167ab9578546b7b4fe21d930ad93892f92bac39bc6db9554c3cb2440bf0cd90edb56f8860a98ac71cba10f70b50c6f3c913f91a72b6d875ef8d7a7bff4e9fb5eb82f3e89d84f03c0007ba338c182e63985e02fd338fea678b98fe73903e231efaf476c413ff565d06df93c8a79ff51c74b7ccabe259028f046427cc303ec1e277f92e3a050339f9585fe8b59f0229c8d1f1c0d6b2358fef6e99df2f875ddccddf949159ba8f6934f98f0599040ed804422a37fb81d36d6e0a2ff0ff1cfeb619c7d80765ea8603c5abd1d39e2b92dc68fd611d5da61149a0a01c540021bf1062de9bb4d4283c7a3813339dbe75a5d34a88e6a0702fc153459200d109a8c405df7caafe1a39f53d65b9d566e5c39c28cf46883094e2ea940579739dcbb30bb737e165906b7e399c09f2936e5b88e2ab8b17cc6b5ee32b72126509656a3f6b187eece409c26c37752b74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
