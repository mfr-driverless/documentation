<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e17a4dce3611b2f8ecaa628cfbd1f4673f462c3987a07375f74068d41ee17029c5116d7f9b6471e20fc452cba60a4447732fefd2f6787978a9f99c3b7aa1778f98949a5cb81e988309285db95e98a518f1c13e1099add711c84d2008c95148cf9cbaf0624dea471b8bbadb3d258754c9944369d673985406f900ff5f123e26c12a2071c7e098d91e46612a2961caf4036c1f7e11fa8ccf99b1088f644499ad561ea6820cc7afd78b70bb06c874783dabb835dfb39ae2ad0cf45bef137296ed65e0fd4c4def8a1b17182dd760e60303cf22a412ea7007b6bc69413e230556c8ff4ddf1d4a5f5c9b71bbe6208ac9b0ba3cc53668c5d2066dcc8e64e060659b50aa65a6b02a5e5734146da56b58093b6c7dd03b78de0fca7363f3bef9b02bdfdffbb60ba95be3937429d64ed55a23a4da881789a1f71146a4124af37b98cda609f52977b62540dbf0c99f7ceab3c88ea51525443e3b7a98d0acae26f70dd602ee204a06399beacbfc79625a01bf44e343e805411f9d1c38af23d46d2bce93d59d6b338a9942db4127ca14ac259f6b1b8f7d56451caf1fa75d90cb4b152d3860e6fd1cf6f17e712fa79085e12c1a13e7acd523970d40f4be8dff6792ee54ec229d107864c3a946b285328e7a923c6a880d626f308d5e36bcfcfb28a6c80e43b997ec6f596606decb160a1d99dda1e117670208c213d7531754dc7778a672a4d0fd8047199f286a1948225171cbee17e9655e6f649a3a421acb55f703410a0b3d83fad928f110b48b5ba342d280d96adcde9f1b7fa420482ffb6a3ca23276bf74f6dd9ef0a82900f9c34c0c71b7e23fb58d3786d985e86113f905689ab63756b579de12c6b63f7706b5d044196ac2577ff166e4bca60c607325238472d9ac9ab7ce50875da0d3afe6a8e7116f43671292eda9f94b2276969dd6fca219a3c4d97ef31beeb7d5a05f002735d46858490504c6bdfb585ec173897959cf41e6dd9d3d27c9cac87d57925dd890585250afa60677af7fe8da856d56ee148d21163ffe7165ab32c578127feed6ff012f25e11209549f680ad12136c707be12e919caa9d4c43b506405e6918c45d3cf9201f86402810ae0569b07d66a5a90879bfd663a7084f32c817a25d5cce1a47ceaeb67411217ce92215019c2e5920e58516b7131f0c8610f6a3370151b115b2ba2de595ffeb3c2894ff34a3cc098cb3cbf8b496ee7fa4a9d1ed6ea9168f3586fd235dab19b2093841f60853fabee914aaf4c15c4c289ea0abe0d0abaa14a99fa4c14a49eea72809128ea729344f8b8d48059f85a19edfda6cfed0a6a80c804bbd690127e12b4403113ab3c8d1a083153322591c23295cd93f4cbc771f8545229ca0cd38f36d3c985774fe57502b208809ac8577985974ec30a84c991644b577510dfe725d9bf1bec8e4ed31a076213860cbbe4a56fb61fcc466027346d214f7b73a20cf28bfb1dec3e7dccd20e2c7a5171b1dfc77aa813b983b471f2ce479f08fe042e1a55b58f06932c612fe4a2937d399977ab86060c82bc467411ff16729e3212bae9c41bee93210502e1241929fda12b01fb00328739f3b858b38d84cb77b8999769d644c3d180b4bdb71fd8393a60036b129a4c0fdbfb2f49fda892b48701f82f3495feece45f4e281efa1df7dc3ab24c87471627ff4707ee80344bb54cbaad23dd5383c1346b14fcecb77b8bd0f1a4b71c0f7b0696bbbfbff008a6d9c59792e0f0c507bad63affe1dfcf88bf5e41ccba70a19d15751a708f07b72db1a71b7e9112502d65ae119c09e087a0d743345b53e64fd4799af9166db2f63f9191d4c3a7917750bc887ccbcd3206d0cabdb59807556da0ccdc535ed5203c0dbfbf40c3d4a4605341deaedf1a5cbd81c00b4ac1638cadab25abafdb74b5554023c04e893a35c4c23d001d1baec485a05853aabec480af5f32c6f5c1dbb9fc2612cc928c3a4b9d1f2b045bd9477394846ffc6435e4670726f04565b56021b7e22cb6a677267eeada3f7f2ef599053388d85dc39ba2a051f0318c5ded1bb1baea9e39c09478bb8ae0de72351e36880dc265853419dbed735a557781a58c0069c30479183fad923e7a77b4645f15c21581eed0822ae284b5d399b835fd8bb1257e25f762f9bfa508afb7abaf886c80b68167c0d0995a4ba9f8b5737b7422432f59f4edbf0e7a6f4c0a4876d025a7544cbe40695d3ca28791a1351e91be0251185dc26b9719b068cb7bcef5c5004ac61bdd31599b037023dbe9216240d707ae5b7c6c68c0a847f6e529cf48fd9dbd5d6733b42f76ccde26df5ce92a73267007f96fa93324be329697a42eac6a7ece8892f9fa73fa893928b407af701f8101c8720f76c948e4586d31718361ffb4d41bacf728acc603f09bdefb8726a5a74fb81bc372dc14dfbd8b1bdb916086c9cdd2dc3dbde1e5992c16e4d48e0e637554982e628ab512ce40c7c097119e9d6c744a234b54908d9741108cdb264453388f92c7e8fbbe58114d57a3f517a7b988c166a38e74cfc6a35bea19bcbef284a7b873c80d91bcfbd885436b6f0ab76ba16841c91689156c8492bda516ddd269900a136da3a9ad8dec17f9af8e183f760d3aa40684832e54ffd178ec9c0466e4730fa1111cad6fc2e8d406336d4b64dc30e3edce119b0f789e623b9879ec0ff3c1cc64bae5521875ca417515964cfac76b52ec5788da069de5463cab6fed7bd65da85e82fb19daa4f17854846ae17adf3ac43e4f572147ff571689bd936c18cb7d025f04cbb4d97934c3acea1ce63671fae28b651dfe5e6d659ac4fcc7d4b376cb56251b4bdacfe72ce3676db3d52ddfefde704e2c6b05a1fdd8820a5ee8fe501df472c725fac3f88fcf2795fda2009e890f1bbbaa44e6804d1662b5003015e0b7d72527421a4161437c4908b24b16a1b42d7692ab0135777d9c98fd3c315a39526d11a1022c99fb19dc895df3eb6e9fb9e431b6be46b5c057a3fc3520935862efcb48713b6534195b1e9fb6c57cb98e81897df07dd674a122c9ab6257027b4cb5a76e54618b635bd5dff423e73a90048fecd8f0224f1f56d7253b6eecd884cc0bc8f93312646cea74fd2424f8db4c6ecbfe6412991d58b5cb768e17654ed211c4df43827fd5439c3485c6fab701a0ed4a8e869ca8bcf1d1c64e2de6e2148edaf7f16aa0f420bdaa382ef18268c2c711d0b81681b2346df184c575231fe1b882b80211c2852ba1ee2cd802becd0502a7f49a0ca7001e67363a71f4072212f7692266938dbef40df089254c726aaf8010a6ad98fbcfd1709979f51a96f2a2ca184a113dcd85bf4d7fa9520220850b97d2fd1571a5aa49f93e73c53d583c1febc8c306d332ef3b61acf803fe751d6e5bb95201bdaf58f6a741d51182e02d471584cd10039d5f89d66bb848cfeb1b64f097c2affabe2b8c50234722ed1a506f4e9a7ffe0f297bef1eacf1da5d154dc2f8783d88ce763a99eee386695549a2addd80c1799b3350f9f6166ad55673fce260adf32bffcb88e6b161a91b24afdb9f094ace24653a7133ebf63efa42d6c64e7b6be58d0abe5f37534981392f37ecaf326f906052daf0633fd40651602dae8730869b5b6a41cb5d5d45c5164045141589286b0f0f110b1f7ec5b245c55a56a6c1109311cfa9f2d3c61818c90babdc39586e147ba74e60a6fabb45303f9669a42408580a7db6200c262147011f99b7704a173c0051827fffe51dfe0acbdd544f165555d34644dc3fe7f14dfa3108c74bec26c97ab36e2b0ca5a5e397021ceacae59c4f3df21ffb1efed438d6e72b39540782bdfc4b42498214651fa814f43ee6f42ddd1c7b439b2c869e1aa4f6c3b475c325f7c2e63f1600cfac3daccad8504ec11b9667eea5504b6ee72b57aa2e30939191ee298cabadb9724bfda9ca75fabf4c3a8f663736cdd04c862b6e24bb0ce8a1beaf036043a40eb4a786142dc949485274bda5c0a0728af84824cf8480c7b27a2d310baef37e9a3ddede6def390311a95b2978292a7c99b15f74b287c97dfdafe85210edd95d2f910fcfd83e4a9e9c55059c0c67d124db958972c0e85d38d91e8f83dbae8f69512c71f96f84209951cc0e5900637a186b8a2591ec9250908ee290c740c3b59d10d6e8d18c2f881c9e20039868f4915ebda6e9248c7edb4681fe15b113baade4622a897b5cb882a28bfad542ba6f0643345a58fa83745d999b6fd00c9fa49532863f159b3b4d3538e4e3a6f172985aebd73e8e7fe400c1e1e5908dd8311de3ccace77b668c271eacd66ce17c2f2093e9454f9cc9da00ae4d003ec4dfd1282bdfe9c7bc4da19e4c269704b94d7266c10e06c135ba23d0ebcd15952d663560ec6eb16eaed4958f396a8cb530ac230101a62ea81dc171f6895e4563fc0ebd0fb51a88a81bb77bcc2ae557ec561fa55c13b61040c883d39b41b822919a62ef9bc50b3064d2fdc80af49b0498b310df3f3c14bd75ead5b29308af993a285a9f767894d09a41a96669787261b09dcde9b3ba2434e09987fe1c4cb944c083f7e9841f7736e7f412e973982111306e8202e1f9fed5fdb92b3ba569796eb71aabebcc7bd140c09cd528d395b510a363ab392614dec1c2a838201928c46e4cf39eb296ee66934e2a640cb42d7f0cba9d2b1f7430bd2d6a95fb18edbf0be10e6872eb924380d99bc6a94f1a83ea1c61e4832d4e4e3a331658b1a96af402ee3fd0d1329d8b869d9638ce5a4a79943cf110ec837629c399de9566aa0a9ec510b92ffaa7f6dbe3bab33125ede39b2bba60c713843bba14d2c21f3ef7d9a8e78a3c89f2c1466582d9366cbe27ab77ff6408f562e432a45f825696883f908522be75f1af67f452d76bf9a1ab86bc0246c0967cc485be6c4154d14d21d8316db20715079b67e523eb626b64e3bc84a3f394a3cd2efcd29a558ab9bc3aa747d61034d9b893da335570abea8cb8702500452c77b542aa278916ed7162234bb2b8eaa07a5dd1d4fd9a0dc53697953adab89285bd55156133dca8c0ec2bc6f7c76dca4a2c196ae2037b055cb34011acfb191571db5cfa533c331e3513d5fe7890e75197e4cfd67bf04e12dabc4eadff4aae9218f3386b28cfba3f1e4375b4e0ceea37b0591dc8990c2425d4645ca1659a61111609414004ae24167cb2c2042d0ea0ab6bd3532a1ad93774ec36ecca417a26803a8405ff8104199d2f9f02dd89fe360c37e812560d99d1816651fe2b2cad8a944f948eadb4f07325792dd135b29b9e38f538cc77437ab55427957383a0e7d5da4c32246423c078445a5d558b3ee31cca50d96f1144be7b97c95ff9effc74aa377f494fd98030f4ae71a896c4d7121cf1080bd77c24825e3a61146acd7e965da10d9cb9673740c0913f33dff3ecaee2230f5b7fe3672dc9eed2df979edaa890f48ab6d2bb9baf7054d235de08e457faa70f1100c2a535b7aabeba44bfe51364fae0e27570e438d1fbd9af8c415acaa5e96b9077eee5561ffbef3f24b35a07d3df20f7ad4d1374f4a3e748d6a3e297442fc65a60b0336d0a42d7830fc4ab946465a6f26f6dd9775cd1aa9582e20729e74519dfeae985966239099d7decd1985183a52929ec23d2b2d68d2884e243c480011d71f1de0ecab1115af7b366b0f5ecd7174c103f8d021b9784db4fda41abe7294737842e9c9b22b880a5d23374e60e59f73231119a0bd9b07d9aa6f562a6031bc0d4fc14b8548334f40f189293e8b8c02773b884ca55436e1d516942e1673bb40f815a37c3d64c7c1e5b88ea7eae5358b68a9d64241f04de89cb3ffb7c2f4f0e58ea48a958e11ba0eab85e3c1815f818d98bf393d2b5623d164608ecb4c20c44090079d3f8be2771c545c244b1bf1606857a2c4fa892352d9b77449afe9b525c0e4d7e46080f8b6b08482111996ac9f7a6b1944a96255ab9fd9361e5e9e8ca08e359868442669ea9cf41ec1cb879c776e8d764efdf687a8e42e9c34316488dd2e47daf00e567d7f9eb39491d70c7050940de5e96559426de64222dd57ed60f0096847cc94962c3e5d93dfc1f4536ce75b36c2ff6c22e4dbc1e1f537a800b91763e9ed1ef961c47d8041251c3794286c294011e48e8bcee500bc3fe129b1f29bdf39ef55864cceafc7e3d7d19e60d39c915ce8aea13bac8a6caf4528edbdb1e116514ebe16039bd111a41eca3e85e99f643abf841039298d1c36c36541e9af1630642ee6734f4878f21259ac699f53d876aa52be5d1dbb755439f7a36fc54d46123806b1875a8d4e2a22df0e4e7ec44c76c515bbe563fb1ce51dacb5d9fa7c20b959376f0ec87d1d4b600e90aa7f9a29067b2c7f042510c9637f722686c9beed7be0a8d9a1e0936109821d153521fb6a780b6d181dd9ea68ded1d0d2854a4a0c9068c13a10a0bc75207e78cdb9aaeaa5d9ebbb8c861547545c3d1d223c856dee61ea2c98f1b9af72512ba7c17518773e10a03a7641c181d6056011033449f3dac333dfc064a58ba71a646e284a3a04ea68f09151e71a99a3607c435a81f7e6d9b645a3e8e85b83ab8703d1efe1363cdcae5c72bc5a8f10f2b3e84ff74b71f8a3c35fe81c3ec3ef666dac9f53843129f65a76fe51c5a47570b3c61d8b37344d1dd771c4cd4efc360132dc9f595e30f6d434b377c27a2d1419ed68da0cfc9a65c811d8af5ada27d0d110b6161f88321e30b785794ae9855bca4ad3701fbcd5d484faf4b0381295a086860c23d4d388d00d37dcfe924f96f4790bd1ded07e6b321e193cc9b37c3e78de072a1b54f661a864ff96d6f97282495623f3944d1ff6dffd2039bc94bc6232761f011a4f09e1352c4a906a2d7431a8f51d84e8df4dd684cd87b8a268d9dc2e04a3caea03e0039e8b1745db414006eaaf9c7c2e7f50b7a21839752ddd931aa7e6d6481e26de4c4b9e8a5ad3d7a61edbe346575d5e6235faf910a8ba2c278c561c96b6f76c87f0e1ad37bfb6ad7290993ca5278f6e00cf0dbb56e9b43a1b3b15036f01ecca0955cc798539d5b0e4bd1c1d36b0708c7e1aceb2725eccef5dc0dc5e6c3c1d7cd92a02aa862351a28eeaeeef7d7154e13a5eb13952c924d944f67dbdd6a23fb0304bdbefd169dd4a3a1b284d2b93141ec8bec13d41392d659bfba602f5f77e58581ba82cadb91eb3136962186f223374075efb66d511ed7dd325cc497b5dd17e496cbfb00923f77413aa98b76604b7009f74b8ee7a554e1174dbb0c7ba9ed362ea1d80baa96d08f4cd148d670598493574489af1a98b166cebecbf1988f59ed2e1b5678b5ea2f5120206bcf98c1ab73cccdd8b1e005d9da4b67cbda26b226fcc00bb7257f45875d8535f94f85db9bb52156673cf6ba67913e834db3f81c429a87a78c9a49bffea060dbb25e29c4d25d5168baf208ef2b966a6c5bc2e3935aab76f9dde0d7271e00a1d2a151feff8d240da02bf0f617bb73b3b6644b67a60331af1b5709ebe75369ed47382c2325b663974acdf6360e822e2f7f166c28404846d6c94a2b33b5a84a1e58bfe867a3997152788c9ae531df56896d3bec280cdf8cb5508f0419acf020878a52b855269c8ea488e9b769d6c0ca46eada568b66a12b2f24400a05c5ea916fe61ee04a07d2364b7aae526e46ed90efb802ef9ebb83335a2e0c2a34b0fe35313563eb075bbaf742570516c610a6eb90ab053321aa5db787da1730031192c0b5a02e7c587f05b2c701fb46f034619d92ea8d7e58d79b6f68fc83a2cc193b7306a8e879cf302e3655e00692c0db796c2cd6ebe53fa5b4696c8c9b82c316a2f7c85f8784527a65681d428dbe9a3914d42341fe50a9713edfc6e3c9d153e03831da7a9f5079a03db8818be916c587d596054d0f1e1ed85f902e4fd676cdd20ffd3cc2692a1a6796db6b02be9bde2ccc8e6a0ad1d4e65a99721c51029e74ce519fa84e965bdd9705c581336d5e1b1eff16d77833b38d53fc77d6e204d474c2af14e4a264a7c6904313ba95bd5871ccde1314b44339de03d1f13aec3b198abab1e2b40c9b9753b95ec2438b5e51f9f806589391795747c5e017e39f9165b0cc44d03f6354ec4da6901e758d1a21871ba418d5544cf3ad6c99ca4393007270395ba4f80130ca9f41c730a2d0df61fb08c21d8a720a44bcfdd8492735581a94ed5441c164a2ae3b4465dd17dc046466a7110dff1435d5148603cf17cbc610bcd2903414a25415f672c8d7f62ac01284c22dbd04d003af16f9b114568b579859edd475adf75f2b7701797d9805826e61c4af546ab5f3a59be8e3e0a5bf9a94e4c87f62e9d5b7f3993dbb571f2ce1630976dd05bbc075220f839f1542127d808e25a4064a4ed93dee21d66434b35e6864fa2c59cd228be68e02653d705723a6f04af0cabdf7e46b8d53be192ae083dd9746f9df48abb564990d95f90167594af2104687b3a11ca02e489add63584622af2da9fc87e9c57d38e85dc60ce28aaacd5a5ddcebaea468c7cf2cfefb16df739c5e17b771e2a7f9f2072822c733892eeb1adb0ce7d86357c4f1f09c3624325921424c96b51889e92f1533b96148dce1fdfb1f14b0899d3a1c8ec17e112b4e55ec4cc50e7bddde986399651ddb4155160fe498249d7a0438d348fac416f7bdf9d5ed705726c2fc684bd38f620578212049a8b98a1a71581e9726cde261848e133e2605397063248916bd3842178de43fd0225b9dba1196110df94b5d256a8a140e9f1ac2e2fe287ac8633afd1cea25f83e29a83128587267a219f057d2b43788c53ff49130d518b6cd4765d67462f5be1f5248d94e0dbe77810d32dac33adbcdeb2d5a0f8cdab30445196718b4c0a457ed64cce216b53e90e1b5a03641868020c6a839315082b71b9d27b734b05878ebe562e82f10e13999272135fc7f6b1910b19a14daaa8c783a4cccc028b2c71e8166b74632f84f3050ce0593ff2b53aa3ac8ff5cc54fb95154453c9567471708b01277803f500fa33a71a3ae5aa8fe67433ea381b8b6ad017fb2073f1f55bcafb4e809b6a4e174381c7f055a0939bb422e153db84bd4d8475259660334bad482f5e759d9ea7ac38c608de9a67e34ff14d863b18c638db60d2e08c919e49631e873f25e0c62cc902e30e50a6948a651a3f1387755ec860292f3b39c46b4728dec711c444ceaf597d003d90e3e55e38028be97ef6ed07ae0e53c149297aa106837c59981c9815aef219d9715d1f5b4ba1a0f1c684eda2a4c035c41c21cb0d7a2d03b35521781a268589bef75c13b9cfe6ad97bf793c1d97a9fe3cf49e7113cd4be42eff729e7205ebe3af89a216fa8e29183be9a96012f0b264fe2ba63b54a3b854bfd98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
