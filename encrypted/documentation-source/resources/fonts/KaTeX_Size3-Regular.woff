<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3716bf6cc3256d8ce7e7770be3a3ad4727ee3f9baf122336f6efd8dae39d137cd34e40ba9c73cbf322d25d770cdc337cac74484a6546725cdb9330637b7cb1f7101c75be1f3e933d3885bcdb84ec546b6eda588e10449408c8747f367e4096f8fcc961e95171f229a4462b0ac4cc3722693029e3a6fc63dff5f002de3ddffb95bd8b282863783c84db3ed5da4db81fc254a6c6a2bab00aefd974374a556a15c26b99ce22c40ca2093dabfb1aecf7feaf0954d915aa2d1a111e1e0cc3c9169eaec28cfefbe4387d315f4ef5e8b38e533e5a48017a718df2f1865fb398864c842db2520020b917dacc54513a613d2699be138409f7a7b90a39b56ada5f3b1c0c118cf196a76cf6115db006d73500f7e744025e2f5ce86ee5468f082e0a3df2c5fdc035ed4136eeec37956527911996a36f6168292bcb8502e7b908473f232a3b71bb5f1a609b583db1f687fc8c46680a58a3a620564de321ae523533c70d6520a0a3410f21511ca8c2cb3f1119f871190ba42962f919f32e7ea859fea55ca455220158062000832cf1afbdd8b50dbc4ce5afeff81012cb1b95449d6af76419482bb76e9810ba7e5ebed33b66f7614c7242df233d5fd5f19eee050caaa5cca418ff7d33cba95e3664483542be27e8850cea1786fbebc4ccfc4a27d1ec8b9b8ee0d415e0c93fdf452345c94de9cdd3b346689ca0e016602101d6511ef1736b564c22eae8c89fd348c3a7388f5bfcfc9acbdf1b7c0384ba3a827474f53169197c83c02e9e268009b78a9180fc107bf60ce88af5fcd1154160d3a9f75d0d4b1d567f1332c1c7144b60cd802a5eef2b20da8b4cfe35962a50940ef9b7acabe7c5e62a86001f27723a7bd6eb31d8861d8c90ae6cc07d303cc0e3b1070972fe3809efb2b10f7840c279f74b1cadcf7b12013dcc18e714246165f45cdd650aedb5816256ac7d73830fdd0c45d1bb66e9644c73cac230d69ac2a3f8d49cad8ae2b770f5525a079ec39e91b78fe81d8fabf9f6b922fdeed34cfd8dea990668b7b2a0a15320f499abd85071c4a7f0b4de1243bd9fef30eac375a96d081be5fb107841d2b30f4b16a8debde06ffb90236a6af0a816f5ef165560e5cb5b71af44d44b4d492456de202adc6bec58f09a90499c7f8e8e956ee5ea844689db5ab1d32a8ea6afd436d14fb13ccb29506b786e2892665d8faefc9702a82f750ba689a2fdbe7112d8a0ab753e4adec3e9007dc38e346a0533caef009e3300776a72b3988823e6be4ebc77447a95d18f0b5dc88c8b9a667846d22887de4cc0e127803081cf4d74e46fa2f4ae3e547d41c31b97dc685980bac0054e2f9b4060398b70b01409003d88819990e45ac9997f368902bfc3ece00fa6a6f47da2b6f5e7e1a4886051d747c7aeec90ffcf81354b0951fac7084f092a56e35eb924e4ae9058fdb2dd1f37dfc46625c7f19ff9bc4d757d7e86200304cb4f1a1db68f94464c1d16cc5b721ca8b61132d170e64c202cafa90ae9fda063fc605e7d9eccd3f8021e0bc6e2620ba48227e1136b72fb650fdda541ca6cb36ebd903a35c52272bdc286c213fe87096dd105d73e82274e7872305db650c7297aa944acad5cad1dc32e9defa65c45461345d2ee60b2f112640118eddfb8a8cf7b5253c8502b554ad1a583e773da8941db2821bfba9f50a34681a23d7a7d6971818721f15972b0156036d8e693846a5860b4ba99ec9c5e1cf639cb435f9929aebed64e17414cb36719c48b722dd72f823794aa548d7a65271731bfa382620529f3d0af08005056dfef604a181140fbcd90a0b8438415dad07bd2502d7f7106cf66a8e824706df89fc33bf0b834c7de64080813ddc6a26f0435d180b8b869275e49de840f09c236f13bdfe0bbaf9c9f922b84283cbf567ff57a5e501c08eafb6503855efe8a13719403a84677bf3822a5b05918c919501ae9dc38b13a1e8205a67b2ce0610c96233b21102e8da088c644b5639b9cd827721f863b528ab91026b74926ca6f08634b91755fa2989f3142fd9420841350bb6bc834596f55e01d06d5d0b12eab69683c63b36255254e359f54636f62488ac4a3b406d5be61f251998df075fdcc81d2cce645ea47316059b77938c0f0c638218a4570642ba6bd1e8e9bb743f174bfed5b3f23369488031bce29efa2cf6e508a0ee0ce7eb31b54efe65eca3923f04191d7cd148c25a1b11ba517cb981f6a93d6dff73cbd9f194e6327faae40cb4bc547f217fbab71e696c7e0e3c075fc8b70403e44eb9bdc61bfb5f8cb092414274fbf6456c9f5559c7c907b3fb3e49fd554ef4d74147a50abe7a36969dd0170d651bb3678a6c3a7fe46eec53c4478a2f9ee8ba1fabeebd7b93c46e2a4376e5ece31747245996a344e6237ab2f35ec67d644d6cd243ea86f7da35da62c680f91966d190d81bfae04112fdc9554986956083f1e68ccf66bca790d216871867dd9dd2bdcfc3397d0b92ab1150004623cb13e20cf271644fde6d90f3560bfcbe6801b769d6cb37a584a5596a443a9cbebeaad8ae7e96539b7226d34b93f6094d185211ea00672b2f9ed6a86382053b3511579369bafc14299c939218696fb96a85385b025ec700ae400a8ea43da42b67394dc4dba704d7339db530f5ea8fd04e8d9e8b7e5a463d4fa98b1baa7cf0c89c3e5e8208cc72c13b5bf599f741ceea66e0ae5a7d4e6baa270d672d52dbe2c69f22b01512f1d36077d134d1d1df1fcf23f7f6032bb281d0db063766186d92fed1b73a3c8f08202f886022bfc80d3089f59903cff5a017fad46767a31768480b4ebbc5de654a1e67a35b761fd56bf256757fdebb22387bbe2967d31fde4bb1398c94ecf122689faab42bb16b6b62d77daf57133e63484da00a63a526465e064950d877e63e1c314ddafb54c12cf6801b00ab616fabcce8911844ae0ab5c20d7d97a3d36652e956b972d8fe562d8af5e93df6c6adfde1fc5e91a9d9ed4526b6faba930d96fdfce332b2dd85511cb28ed4d094a5b15c168e69a4a9ec72551da8d71267eb2316b2a2bf4b16be1e558ee26248c32e138a782c8a2b1cd30d9bc6b263879500578c832aa888d11925ff79fe3276f90875fe9b8a9bad9f17881824722b18690422f12965f7198ceed3fd4b91d300c6f3a5fc6485107fa32a8f4d9b22f1358fd640863ada10e284224c0b9e80c4f2d9e1838158fb048739f042d4bbbae212e6c1adeeed968745d54da2c498cfeb1d407ad21fa0a705497d2951e9a78b554aa2c14d675a2b4c6b2752d9866e864f24f63dde369f2ba728082abef6af9dde7a045a5eb2fef808237e017cb7241c062f151c20e28e1019f672f7d21c87018bdd2a8dff68cac8c5a41978b9cee81f0b068372616cd9975edcdf5a4e4f1c542680b3229108fca08635da5bb4a8926180f60bfc16bb7209833afa8a906ac73c33defe74d76404e80909e84af3993e6d7ed5fc5388f15a556ea385a7f17accfd1998da457b2780e0ba16b9d1095615624922803ea485a2b4816844161876b4b5f2ca38dc024c87f031718bf8fcc3f6a231a0502e67fa35c124480ec257406e9f47c4a2a54ccbc1ad2c1d881f117a919eef55e8a215552b26bd577ffd9eeea5228875c1415564d59f02a57a720950589c2ee24841132375108a4c0615cbf466a94f256961a522e7140ae1e4c594d09b399b4731cdf01bec01a52b2993384d70dd7a8096c1caeb669c903bd136dd22db49d65db44973372927ddcfc65452faa7e9dacf1d0830e51d37d9248680089f331a3e02287e2560005c1bb226b47ab6273b1add6cdd54bcdcdd13bffc8cd57d7b43db45594aa21dd0ff5c33af72bd411490167eef6de7d26d30f16ecc8ace37f9568ff0b568522ae1bba6daa2fe7870c5d35e1514ced15250954537ef0ad68beeb7e26742c89acf174b673137c0e273fe4c44cedb700a7f1b7bf5994c1ac5fb21af9d3f8fb5bad2abfeb7b73cc7c17b8b535699edb461605fe2f7723a4a0239b7ce3e981d19e4c5038633d875141de13e6bb6a703eb6c6815e8922ed51b09c4a699cd509522d404b680714c608a557dab39f700c945a85cf302da7cc1a8ec851b6067b32343e208e8b34e90d5339d656009ecb3d37d34688636dbf0e38048b697ce0f7bb3dd1d9aa7d911b681be43ac4cfa4d7b05bf4876ebc3c670c7dbcc7a09adac7d0ba1a844df2f6a1466036a95b929293f1d6dc9111c29d0a09d551b9b79491e0546ba791ad1a9482e81188aa9f38aa8954c9db0fbf366a32f416ce5cb12461234f3e27c421224ae1ef4da36f0dcaa4f9d1600032cf2c648d70cea3952d52c29daaac1d8e30c95a89346523bef85022d5945462f573584529e39fd01ced0a0a65a5ef6e8defa972f60edfd56e222f65cf54eef8b7797266d5f78ac4ef55cf1061f3f5b5352782b633fae6f194c49912956e3a46385372b91285c6335cc6be1b92977c63b10686f96eebd54264c814cb9b4decb41f40c7630b35d6d654611ee8fb5994846c3f806babe32fb3b98401d06394c795400e27d1977da6027aad5f1effe89efa7a2c47b5227454dba1b0b91c690dd04ac5459f6cd9a795afd633f747ce52b272de3f8ce82cd304de81e93f88c480d4f84f23a6765025ec77c671009fe2505a338789e231dd5c15e175cd1fad515d3af25bf900d1d52f2e2f83da0301b121c48f8098b489150326be3b0fe7bdacd5da7e10ac2c5fbc1c132976c260c12ab2bf86414dbcc551eb87aa9b98e7507a6f2ffe4d2f0c962c266d4729262e3e5ebde3703e413ec829d4dbee5e87350351a06416906e507315945bb12fd7784f47e23811847535fd623043e09b37f11ae1f9f21cb942e6ad591345087a85a66b7e1cf5da0102112165470117d83b5995c072949680a8efe5dc2d91b918e49d5ab6781b88f053f96eee5c5ffd5900bc6faf909b05fd12585f7d0f4e997c2c836959d44ebb6aa9ef1384a6da8910cea09d96c52c37ce7c57695df0bc838e41910e7c9a9ee053b254742d2d9e11014f7b285d9009e95b3710cdfbe4b08f03f88ca37c7485bfa415cabfde224a02308a1eafcc456778a6a552eb761d0817079e78e3ff545f0ddc18cfad2b0e06ea35bca829c073987945ba39ef63cfa2c3b0001e1bae4d3c07cb8693865509003db3113328f45d612cb105ad62a5ba273fd79c4311a2ae38b2260f1fea244984fecacbdc613796a5953ab1ee436a17d01b818f21b4e67542032b6398b39d2a12789e40e9c0bb8cb8c2d5dc6ecae597c8563fd3f3309c0fc860f6c2a214e0ea320e25b310725b691d1ba1bd48731a8a7fc8fccf9637679c6f5439f6307fa4d896779baf9c77703e727b5e5e2ed4c4ad18f329f84bd6d592c7c876caa83fdb7bd9b280fd469baaa960171f2b296606d899690941604e9ec365fe89d31255788aaf6699e31a4370319db3bb4f1194b540ffde3eed00413328a89e1249db94c91feb0a9ed4c0da82f0aaa848193287212710db8a9cf8456751ef6c45ccbe319d21ce19415286bb00bfe2e37a61af6f58b413bf0fe65b75b403691d93883e5191c71d6756b02514d7ea25dff9a5301db0db209b46f854c9e8de56ff21c21e358a8f764c8a0f385fd6584753478135e994a8cf0951e90faa74a3399017c8c7ed9ad67bb548d5f68b84c5f7f94781da3c01b13eed70ec189fc008a1e418ed1db5954ce4bddeb260e58ca4fb03434d55f7e59a970948b8bdae472a6137cb2a1eb38ae1855a02367d523912c5fc2d04233713dc3be97db9fe1fe4ad4227dbbe469fdfc5575fc3397d4da26bed5c6b9afa40815e6e1e45ac7cddf98566d649ef3d180bc0eb9e988c343de2e0a109b1efa35b2a41c2dc4b6a2a83cf8080ff1c13bded1f10d50f303009e246564e23ebe26ab7e692a949a28b63442495961f862ae4a70877da7183e2318cc718cc72b30dbbaa554452e645c676b9fd15f517ac40bccb9d2fa6732bd7f9fefee094b9aa22155285580f57a26e2a1c00fc3fac9387f5c6826325e7deda67a8530dd86990897a1ffca5be875cfefcd56d8f409bdb03318f0583e33b2b374ae613558b05ec622cb63040b2e2313279e4bbf08e35dcb1ddbabef4e903452c25c97b34fea6718b29a754365a5206be06731483d0fddb56effff1656bb8bd54b9c50e2245d6a0068f0705f424ea3bbc8a6d4bda98bcc2321409c86f5851002bb6f18a1403721f4546b25e3be5670832e7c86596c24a776a34907a390b0c681b1513ef9fa4a0137fc1ef28139e27f370897b0e8856c610dc8671eeb001fbb013372263a93d3e1ae47b8845e116061b018db2089ae97e1cd6a84cb7e00054e8cfbdc9b3a0a6852fa82c2a2ff90f9ca50657d5dc1902afd8576c9febbcd188f576ee509535d300391087af1c39cdeb038f6a1296cbb17f07ed0bb6c3747098b6747f54134f330aa6615e402643d01c9ce9ccc53a3b4e8d182ab05cfb715c122cba08dcd4db32e5820eba99abe8c40a03eeaaf35d11bdfc75602c66de91154e37767d6da67819a2eb632947f091e37e4690d51241c8159a2a1150a8ba7f0e7b89d63a4bd1253350e39299af6e69f30fcfa100e0f5d412cf36509013316e7e65731b82f6bbedecc190bcfaf682084e8062dfdd9e6be1e0976a50ab599d53f1ea26863eca41d0ab01ba57be6335fe446bbee4ffc5618eb1692b183d6d4f964879bdf43f81c7ca1196097b9e4d612a05634c342b487f9354cd59da3819cd44f94479062a845acb168fd28450511cf437c68ee4ab68c6210ef6ca1cda3845fabda3c4a35c4db9408cb29b8c0d522de9908e36737a24dffbdd551ae6ae56738313888f3e50d3c5f64d680056515de202b73d0d15b5657534c3af60a9f9d53264c607fa1eae8a1e1fc30a019500f8dd0274f371250592162d87674f13c4618a27149726b4f8b4574a4f565c187a1d844d37d4d8ae90d457bca0df30fccbb09f0bcc07aa9cd68677c70840b04118981888fc4e92d947caf0f8aea48bc20cc4d38d71c8209cd3459257cad8133f3c51de8845c70c5336764c67998d30cba0685b6cbdfcee6e874eb540c7711a50e6ddf07a8a052b8b8ddb8680e802b2b6d91ac50cce0260d7b0c2b09f5f72d73673197b311de54a06ff499325bf9b0b0b2a2104f1c42b3a0f1e86f1415f9f3f3e21b57d1fcf456cbe454dd27691ad6a1fae0fe06a5d1bb1a8a7eddd86879f7c6eda419be75003bf05ec8784a751b16f0f7638706b6986647db6d05f79e08fcf7c8c15d54783e6d6f86045c79358228a87bd2ee62a0720a711d38c8738c0005401caea449aab1ca14cf2f62b48adb7ef78bd97a5c3e7e0f496c2f42fce5594d882645f6105e13f6e5c5ff880739ae5dd24bbdf3f7cf5e0f9211b59f3f2bbc3f9b4966b5bda27cbd0e9f4c214afdd8512505189b857120e3d305a201d7e0aca5897ac9e3e77f0da07ccf9fc97c553ea9ef16a97ab15e309434d8133342f824989fb121a0dc3429d9f25dd3936bf52fa654b7ba428c572becf6f7a7094d0faea7ad2f6a3d7e1410e7a33e52cad884ec3ac46f24f416c55493c75acf6d45f67e3c52a74dd765b1b3dcb8c8cb24f2cfa8d6d74f8a29d857599e50c8be2ac343cd49f70551ff25f1df55de404267cad518a8a8356cf4e9682f80b28edf567f363b7c53cc0f72702b2b18478c74f6e517f301922ac3a772a5cb5f3b34d876ff6afb1cf9e0290faec4c74cf4179db65fa6689848e28d18808d07c3b0cb66db726bf76e434172c99f6ab0c2791d49ce9097de8754f555cbfc92e71b0bf93fa08fca17b28a82e14e378e3a7abd5c39a5da2d18c0b965cff37ce76fd3964269300305c7104d4224110a7c0207fcd1b9f2c3348128e9eb8171d9249c1876c5a31b1e9029520f790f658cdde2e2427c82e8bdeef583d6be5022c8cfa54b1cd0aad5900112f474593c4999b49d4aaa6e75c567e8ee4180b1ef18fcf861ed5e375fbbbe15dcc583d6ca3cf646bf8c571898b84f634af5f8b439ba3bd18222c45711dc64fce0f9f085b36edeb71cce8e773a9797bd6bee21016267373c89f4855527934d411994ad53a2ebab149a2d380d195e47ec38b571adaf263f090cd0290ca6f41ee9cbf3708d98d80007287edfccad7911ebe17882d3c1fe5dd862e7953bf069b34a2ff81dd0efab41e13729fc727b9ada2213f0189655facaeafa02c17430f98f389cb7fab84846263f2f8e4da7e2a61063088cff91b7dfdf0686e43e7276f2a32ec279405fccf6ca76fa134a96e1b4863d58113a06798ad85a3cb9a40c12b65d707766d2007f4478be18f074d1aa5786fad9d78f670a3e787c361c68403c0da0f2a78c6eff0f173d4f75f8ebdfce37414efa588467b39121120a34ac74223a4ad5067bd28cd92b9510c65d6abb16dfbd01dde1642f36b9b8830579012170a98de03f19375b7be196d34eec1244298abe3e048ff77848edaaa60984fa067e8d24bfd630df040f7f1e42aef06b5749c3586452c03b94f80e62ef3c02b58a8a60477c615cc0c716cfbe1cf9ccfe4ec07e76912c4605f5ddf01104308a24b88da7209995dcb5d296bf84a044ec0f7410e49a0f0cd208559e49de19ce97c089228aee8bb7bb78ad592dd7f9f2a5f89f523927f11cfc969c9f148778bdf850333132829660979124a9d60cdd97cd57da2ea68b6a3d99890cb93cc8b27d028c3064253e7805c3f5a5c3b469b3dc76dc35e543200d2b41d5ec43b6b2dae68f0df20e48c975384ee728bfedfc1644ed8ed39d8490e0a73f6796ddff66d80734f49926b93d842270035c1b9d3de19821663d057a4581adcd9f5773965618e8b29049ba757a5a28eb304431a78e3c4c854efa66d7a1df12b9225ab985972d01ef0007e705e2ad651f427e57fc62b9b0dace053b943672346448be03685b896d46f9322144e24a043c4124a96de9ddaf382dd522221cff9e80925536ca9450de1ef599ec62084ce0b9571930bb4a042daabc557b334809fab0c5d344600a75f7275e9ee1636fdf585cc4925c844eb94f2a5b0b84b1c1cb7bb27ba4332068f47522422119b5380ad99c76162621dadd339d683c3f779b487a8527620ed135d628e0b6a1aceefe69db4ac746903ee2bc9688e21316bac97ede302f40440da29345d80d9e7481668c06e8118db9357cca93ce5d21493a40c1795df6eee15b5f053c68f9ab10578e7a55a6f6ce015b86c30b045e6e3a254e849eade7f2037b901a17468fc66791b55257f9989c3ff1fbf4e68a80a50d5e73958075c5e606c033d758013c4f56bae90e872ff5955d05ba046b79936edf4f55e774fa3d8bcc87e88317015db4d7d264d4669e5354ec0ae52932fe1bf1d6ac851c12e5b10a2615dfbebb7cc8817166c76ac553329f75a46e7bd8b27a09611c122016f4647606d24a02d2f799edd5f1eb6fd1ffc1dc0e5de488eb30f204aaddacde72cb87193b19e0f0cad4adec317800496dd7c1512a89ed0afcaa4d5e89b5ff9e3dd4565f9c7e10beb9dcc18ce32fc7bd8f9f5038cb2667c8651dc17e41fd56c56ea682fbd20958dd8405093da109e39d3c010041600b4d2b15562023564b42dc06295c566d222a0bd38d9275f7322946cc0b43934a4a53243f968bb8b0bb4f4f1667de0a3a0962c46b1a4efc5f2fc894c83b43e75ab1785e279b330dff7ea54e09bc611ecc293a6e31936aeacf5e66e4a61f555bc1362d46bf205906b10ab60dbebb36050a79fc7298b8015f9aef6a196558fdcb67466b0f679a71bc63acc486cd7076d42b3d8831a8319133785924973a198ada9e761dd99fb2f98f3a42de5bfa8166afe13df93e3026e9e2ba167a52e6c06203e27a9650cc1cc1cd3266546ed1055bd57b81e8a381a389b2a0c8309d6720256b153c1872957f5f0d1c8f24dca674e15710f925e6a0f620212310e7a8aa6d234cbc348f6fc3b7fa93245d915f10fb6a3780cafd1ad37c476c8c2f25fe98519ddc1f01a06e743418e0ec5d60a42e56409e0505837315c1d6b484dc643fa3f65ae511805fecc085aaf8f1d1ccb2ec36d9147c08863f314af05476d6592c3554a35647e2fd28834b9930c1583cd96915716177a3b5b2ef16ea3c7c3058334b81cb0b25e2e57911035071e9f7ba5af85adf0a4b9d2ff5d38093ef3be70ea81c377184cb775d37c57417bb7e6ac6eac52c03219f65076aaca84c306adf17a0ea60b383715059be34bf1b66417056934b943f7c6125c862cfe4d200011bbd77f38bee81aa5a5b81aa5a4ec25ed5c9b6092d71f333b2c650957a7d7a602ef1fdd94dc7771ec6c0c1baa340fa3f19d75dd4f801467e3f908f57be85aa35ea203641ad632830a4f0e37fd6c19a3584df65b878653d772ae6b242b358d95c92859c88654a7f53bf843c18b26709c5849e6d5a8faa83309350158602bcf866e65e6a158512f860eca3b8099185ee83bef5edc2dbe3071cd3fabfb22e4b80994148b493edea165ef94ee21d5e4b737244242d92f11677ed63900f80b0ea6cac3a5f601a11f13e80375e61565398f4d1a31fe5ef425fe3e2dc07449962c0c886d70984e159b710a38326033bc8b400b092edd57d52eb2077fbfa83b6976bcc20b38424820a9f81be8094f3963bc6fa4620e0e9f0bf4ae70bce41fa013afd3c8af46c69013ad6406f4c6e9560c123c5af0a0ff8422d6eed9a7597cf5830f9357ba9fbe92367bd4bdcc95b1bf6a00f49e2327f2077695faba9a59a777360a8a32e03f17ef4f8b124d096f9175e9da0fc8cb3245c43b497f7f0c7415497d282bcfac3153b944a263b50385ba591db24860a83e25a65f40bb9b68546562bb1feea35cb9c92b77aa6c1cf1268a3ce4a3cdd03b4a07f8607cd30144f82f64bacb7888aa4df71d4063df913b5fb4a34fe33e9052abfc01fb5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
