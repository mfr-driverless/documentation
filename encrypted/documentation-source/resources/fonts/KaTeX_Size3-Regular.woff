<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c4260d3f140b297387fa271a6ab1eee1e8ce02a684cb39cc4a34e2c4a226cf1e546eb4a02f5e797083c4cd5c8ffbaf92b2c4be5cd2b7525695aa672ef7def5dee703db9bc88fe56e763aaca3a826dfe17570e6ebeac63203b0ab94794b0a8226d5fa895419619645fb5043a400f05e8aa9e9005ec358e690bba91a30ed840940137a158afe71a5cff39a634d42c0e47c2f896b2d8b1ac630c4fe062e508ac8e5670870b6fba663951f66b3679bf46b12266db9affa5e99510359d148ccabd04b46e52d1f137c903c420cdff80eeec64d650d4389dd22c774117962678d84af7f3ef1a0c41464afcb0a8aaf6a3301ac383a9a4c47ffd834a7fb57b154bd29cce896656a54ce2c0e16adb0dbaeddaa1cf9849e2ae5235f641af7fbfd5d41c6f3b4551c2483d3984c2f1734b940fb9af43180f85a06c2b879180220622e6362d2403929851cbf3c99850dd35b64a06b78773dc2ccdaf70989afcd20bca8053a1958c13991fdb20e3828ddda5612d16551a6d78f9f19473594d3a3b8e509eb1f6d8f8845c26c1a549bf3ae7308f33b33956624a7894a02cff6fffec756a3453d4aeb8f6279a610494b715f89b60da16e1b37642f36f305ac5a63b4f08cab4b02559407c33942ba6bda57ab64924b657dd57e7e2631ef683b5b8d7502e5565e55d7d750f98093eb576a1db5768066f3be3ac6a9b336e10849b8e36190509bb3c0d806d9abfde07cfd164e1a7f31e49647966fecd3ae049f9939a3111fa6d8ded20c8446ddcaf532a49b3f768f67609cf580169d4f7a29ad4e5767d896a58200af2a98b113a11a7f4eb98af05975740d622d77cef1ad4e0c6e6af6d1258421cd3ba9656ff3410b51245ae824a591fef769625fa759177b54eaf7eb57b5d8aa3f0078c8562f254bce45b34cfa6b43f2be8b2c8d3a143a5ec40be7bf13f9f5377322be36237b9aa21aa7d9ca7927d88a446aa461038e034004ea3c536970f4bcd77ded69efac387ae31a744c38ef6ec7ebe89bcadba5cda6923d21a2d092509224b8976ef45f464bcc7c19585b55f1396899cd2f11d1d46bd038117aa2cc5d0254c8ac0627470bdc8ca13c95fa24cc6718c3b2262b2ce13ea019dd78b0378d28577da47a77b7b784e50eb97ae070a2ab0d161a18a22e1623cd688d030e52e0db1003ac885c449263a631f4c97248d5fb65aa39808ab722cc5f77eee717cdfc459547ee3eac20b8cb4a2e6da18ada6fe070a7ab50061c0bc78efccde34eb116a78c8cff3a076b12f2fceb83978f41f794dfd98cb34f2baa724e8f52d847c91423a8bd5de3c71afb34dd84d1b6fb20a18b441715af30a51a05515063c05581d946e6a2cefbdfd97542d3de0164e48d67bee31c3ad914014ce8d1645aa5a5ce8f2265bcb881f611d407105015a6039878459de17612b5866766f2fc1747e0c87cb6bd43cc48690d951f34bc4895ece919058f977c0d3878b06c720197d3d7d77dab578685630eb9c9fd0b415650ed56b80002a6fcaea8ae04ca6e730aa1feb42c595f0554c0bd071bf0c7e61b1e96ad42935a7b3b03fa15f34d1e738eabb7f0dd424ce28ab0416c90e5c4f22d8f1192a6ec7b4de4572bdcf1c0a7491ad4b3c5d70a9f5deb740db68be247a213aabf53199ddfca73a591f3b8c9288597467c2988a90c8b5a4b11dd1d1856ded745e76328a5f99ac4417d7973604b034c547b40d2c28b331da0b3cc2d71f37dccd56d09862c16e35bf0e41cd5b44375c59d5072815e798a0a500c7d3838eb395315aa980117a511056b092b607bf3d568c9b00f407c4f4fded49cf23a75506dc4e70e55bae5295137fb5497f963e3dc8829dd6505c79f0a7abb0565bebd0658001252f32da383f5c2b8d5c9e631466e931535a60cef726cf1c4d6007ca61b63ff071fb7eb0d80807f3b47a5a734ff72e7c0ddc6544f41065bdc9e53c8ad5bc3a02009e529d406314a15a16ff9ca393ffc68e38feed8eb0c3fcb5296c693e50e8de2519be49e540c841a4c3442f899451b3e31e8329b62c7031c4bf03ff4cf8b737987f68e04e54630829f771e32f8979ae2514897d26be702ca9db172aa9dc9bce20777caa91702c56a22a5c5917b157c7ee6329e036e72215483f5dc86dc03dcdf075b3f4745b8875f826207ebae9b8824953290a117baa0f56d638285d361a968eea2ce448f3f24408c0c62f880528cc45ce41d8f8a664734f2d5f9072981e2876d1a310cca0da3a9016db6ad94a73d187b95681323002bf1b533de6dff45acf61c5e35cdb6d28ba1aba608f585a700ffbcdb0fed76eba5898e77673f9eef21123a89eeeb63e7bc7bb618baefc9c447a28670747149a6ac37b496cb06bc8899b9165eb3ca0612db52e86144e6566aabb6a6ebb91de4576e98613dc6662afc4427bff4c61c23ed813a9d6d16acda6657d0f484387ead106ce0ebacc1e3c297ca3bb7e8f471b5c1a2cb11ba72b59ab44cea23d691ba711b8027fcf31e11652db5a53a88f2d92bac441f55ec24e3fb74eb5d53bf0f13aee1d4ae9ec10ed8426c19fd828c4f0c68835b7145e3c7302e6c4fe08b35eb48b6be85db05c9decd4eb37a2cb4153e1cdfe9fcef739357cc4bd5bd80f1204e043797718c56d165c29e928debb64dece8eb11f9387d3222147ef50f182c519a3e436badc3cb7aba30c74e84fcffdc1cf20474542418332006139c3bc085d8d7131c7a8d5485e9aa21b3dcaea27ebcafe953f6d80341c752bdf34d4dc4b41c941b5b3a8d667223c508a0aefe50eb281b298452c04218184f42b4f30e3ff8e0a069c10ebcdcf16ce9bd50c3e2f31ac867d2a8ed390d1e987a7216041b406dbbe6513bf37b69a733860848864add986df6e066d47f8771861c7f5d9eb62633038e33efd03c5ebfd0829f6d470dc4c5a9138d4a1b163d2ee5454055a01c8eca56efc6a1d6369add4f8aac03f4a21b51abd390ae04d8608ef32d3dfb3dd50fa20389367e9245414514ad0675404f97a77e611bd212ceb838a11928ac59f8511d475aef9b709308a2711a76ee6ceee270e5fcbd5326e91083c8755aeab40b5e3dfa61b086fe77572403d3691c5e4b89cf36951c508b7e473e22f1ac781a256ea964cf002a8fb46c91cb6607e56170a032d7abd5c2a9eed29618805758f111f67d722fff5ad09118e30f94773ea2ec416fea1184a7f77ff954293db750b99fbb54023b2cf8def8695f0877305a3aa25373fd4605d0d997d97d9adea5638482b1459202d999b5d8306caabfa2eea97e51c5747c81c9abd80a19e9ed87f8ca2ea4451988445846de340562b40db99677051eca68b0d1390c8c70ab251e80213e0c797324938a7404fa90bc8729b91cd80fedaf0b702846a88656b4dd7b6586fff2f8dc44f2b747e4f314fb76b1eb88ff15a6460caa882ac93ebb733e9611fb0054b776796b1c8efc3e83c05def0b1b272843920de7b39d85b1136bbd4afdd6e45d401f1985a7e4f99d391059b9d2f95cbe12686cff2e332bd273a0fafec0c8b73cf63c694e36ced5f6a642d85f2aaad2cbb1b033eab606a994216a6c01e177748ec84f031e1a93d33f225edfc2c20914c8c3dd75d8b931aacab2b6f307fa323a403b9254c7e47cd78100a9561986adca97a432723b8245ed6dbd67676950aee14d9021e9bde6f3bffc8b291363d3dc4a871fbfdce18f22b0e5a35afa9a92ec622a51f8106c43e3f7331a49f830d408b9be381a7c9e416eb2cb7cec2f3b899ca700defb0ea23f5b2acbecf0fd353e5a7f2de579e200f82600fbe3b965a33471d5f274d9cf61ddde84dfb964d45bdd4ebe5d3445546d6a1e20ff5419ec446e7f463392f17d5ba8429cb7c759010ef9e2a5de3805f62f35db945426dd1e28ff85204867d84a1bcba2107a07f45b06985b87c5bd2feb5cccdea834f23eadb1bcb8e8d19a45e68a521f89ec962ca84640bdc722d2210543e43491e165a4812987ff68c4160b61ceac2fa7115e995ac81d90f8130add410e7f9e7eb18b45b9a5038e7f6b77e25d762fc38d976c97572bfba857d8ac481025060515cbdb6fbdb216aaea58f280753843ac822586db3b295932d1e2bef62fb878d4067d8088e8f6ab2dd2670aa8b02436d3cbcc9baf6f29ce8707395f3c3bb87d89338b13d4ecd711dbd148b0714b546abd0ab2dbcea41bde7f56fed51deb15f17a72d1b8b2493f048464cb2dfc773b2c7d4b34b91c49ca18421c0d2fe227ca2794deefa0cbda14d739215e2e6ca856d1f9fcc0603594eca6e7ca43b4b8a73466da516c9e0e09cf5ed50637f7e953302a63227ebdaa9ddaf059a3fd42203d278df3585a6815ff3c637ffd36e2d0d5b757345ad86fef2bdbb29dc9ee5019e71d786e1c85ff3b3b4b067b398a0e0977f520a0f0a8f127758e8d69749e8265a6f19ace9e9d7504f4a167a46099700d2ac7eef6e956f364f37d2821a5cc6a178d6748f5d6b7f9f7534f7b7df1d0828db76e9fbc6fa8b6c39fe5d265c8820d35f58292c605ee4b0e3647957cbba7bcaf9f5528356ebe58b28cbdbbe91cb7b519d27f6e39832445a68ea6ca26c444db1882e05964ebc9a9a117679d4d287479495bb7de73a6803d5da5d02a55be20a7232a52c9c34be7ce8b6a278336a2d35496b75cfecd0b1e7f06b8dadae8f05e4bee76bf71f5e20551b9630769d1109b21d9e7fb06d0ca4c517ba1a8da2a386e635745a77db12b7307a74a3ca38a2047617aab78f1a366e66a302c51b46624776f29000806789eae4ac273f02678b7ac7bf8a95448bc578dba9b77e4ceb7d160f64190c5e29c708c394bd811b91d5a48d00fbdabf8dea8cb2666ee94a4356d2eec532ba9c3fc566f04e8ca82ba492186f050b0e48ff11d1c3fbee86818fd18e7a690c3dd4023dd455a6f5823b41c4588ed010849ad29a9f90e193c9a5068ba888dddd57001145ba61d77f1141843259c3275a07823bbfaf60501a633645bf6fb105b6896296b38b34f8eca832a5cdfca06b3ab8671158e374e8350ff4342b589acc6bb359d5b5edcb172e07830abb4a24580fc4c7396ce33c70324e891627d3100e5f7e9c69ebf18675210886feb198242fbdaf8ba87215b15462d6efc82856f3f2e428e4aa82c3e7b2f16f8a17ed1c5f6dfe11c18bc90d00b3520eabe6f1e98c5456b05aa91a244e04e9b32dc7b835362fa115f10bf1d405619a125ebeffc6eebae25b7c794862ea6b6c0ac583efa328e0c7f27bc1fc2ffe2539f2c1ccf20811d722c837f01ac14fa5173afc3d5fd59806ac1e17048881c2db0e06c566ef932d5210bd9c36864682b07e104f1419f8b061c883b63d00aee4dbc7c56f2572ad4a2f485d5de241781e9e9d06ddb3564d69f41fda27fc7a059eea3a7445eec922e7c61d06b2060a9c764f6ca00479a921934cda161f86e31c00f7f1f0e517db65ae99ef1dcab33dceaa9af8c53abc6dc9b5b2e1bde510ad62119671b7f0c17541a1760d530679e926aab896c070d6bfcc65b059eb9e84ff741b6656d154db34052948d047e69b58cbef0dc38dfcaddedf35b757641bde265fef8e86ab7149a122164b0d3327c86c09e3f40481a431aaec5fc4f361808c50486ac164de6c12d33603c2d665b55b36afba70f246674f4aa0692639f349a98042d35a3dbea4438d4fd6f7d37f485c6053b66c3657703c019b04bee96dc12aa57b378cdd98428741d79e3f82ef6a5b3bb55f35f964b8d01afe318d2f60e3b652add2d25ab120f1ec0cbdb1d28fe3de19e6a53b1f436ec831155b4597ebff9ea94a4701f5ab8377a68db208af082431fab01f110b5f17cafb30635770500b61b1b9e8015ed6a462cb24743edad850d483d77e8a3bf896a03ef0130acdbbd129bd596d2d1c58019823ab31c04f2aac8cf0539fcbd358e33258b5116c98d62ee9bd3d7922ca042f40c41cda11302e437b59f5c7661087fe1f89cc357aa59b40c37fc47b1690d2dd5007df041554b80c34d441162cde75cf5bbd6064166bf8b4326e838b788031171f166fbe28cf96f684b6dac89fef87bdacabf076bbde4ac36cae23489282deefe9f82ce7d51fea8f27c5ffd9c7b098d9911654ffeccf4032e9502194ed0f5d1aedf2d40f4f0a20bdb302d7357a513159e021c7b16d1c2cbd9baa68aad96b4b33277a683596b1a55d7d79d958bda972e279ab197b6047f7cf5ec88ba7abc4c0a87d8c1cb61f33cc738874468ea5c71deaa318d47ef54b96d7b4006f61666bbf76535261fd893d5fee0a6ad610e428d13d0ebb74b1afe11c1debe22da44bd6dc594e7897267766cf49e32b32af29bd25ba8db7340ebd6fdea5dd06357c7e99e29bc0b473e0c507bcf79bcf95c8199f9b632699efd9880f3b477fb0b79013ff39587fe78ba284608e794a15c84072c9c49d4a80dcc414bc6074c16166e98bc4e85ceee6c537ed40347c507e3becd6f44f8415bacdd92e5469311b60243d338da8c6bafbeec59035ab58d8e5e240e4088668ad55f3ba2cb21ade8ad079d435422de53c1bb4be799c1ef17bb37dae6f9779da1368f49dcfdfce199a2fbb2024d2acec783c89ee39127ec440946d18cf91992ba1964a1b55cee47edadf9c61a8551d59e926acd122971edbace4238f1918761c3663ce8cd6ae9b30e1f963ef62bb2f4b40bcd50f266620f2032dd7cb522ccff72b9db3b3bb609ce05520d4202ce803b22744d8bd36aadf8da5c56949e3f02406df56763243326d32d2f16d1a4e83b2daf2ac21922a01a4509b7bd0f4da9ba3e54cb862ecd84929ef8a12da63e44cb4c68e28a7054e9cac4a6704b6412370d516e6e110949145330d5ca9b43ee9502a6fe36711ca030436f9aa651b928b72edf8a0d825f124c45b8e948c0171711f4db3b76a2b221a9ea9742d004b9a622b254cd5c01fccb4bb7b8d70387f3b32829f44f463691dd885f4ef0398fc4e0d4bf50db9f9fe5f1cc61edc024c7485a75787b0567bd71de9aed87a200af8e80a72d12a63472c15a86baf2e380581d62542c96276036d497d1ec8a482011f4f15cf17e4d9ac02016b5c223270472ca50f9b768a08f88f7a808d0c49414e5159ff30b33c0105c6ecd8c483f5d07e8bd74de6fdfbeecb444edb2b2e3de58b4fc36707861d49b6e3b2ba32cd88b1afa04fda51f5dab74ab793998eec797a12c5c0b0b287d154288afaaa4f6c991ca857ce1a8f43a4a4f7dd6b6027ce96c041d2d2aa325d020275fb80d7ce679439cb0258cf6182b9c7e1f169a4531b57f9d069be6ba371fb04ecf6824b48e60ea244a8fe2a54702a003f5936673904c2b55654223cb7517d43fb85eafa5a7b636eb457169c4548443f94ac4427deb1b42055f06ac51ecfba29a789d52f9424d6a614e21a0f5d36b06b6490fcb01065f81f14041db7ab9bc19c3ec7b85f6922b80d3aff7ce01ee42d2febf8d12c5e4cf07ebf6430b84bda5d9f74bf77c6e334dc416e740cc800aa9b2eae368721b75f63a3e90f13f3c70aee27e782023ca5f96649c8e69c2083d375ec23127f46b9eceab17240a0da3dd45018465a16ed0dd79a2876116300208a4a903cb722dd8551e8a45119378d19cc6670d0ca0ee365db31358befa37de921f0d7e3f5a52446cf09cfbbff0d17bec0a3bc7136e99cc83f13477e98ebe54a06ea376b8dc70d9d5c2586f802e9bb1a1c93699f262f0c545b18f82f6d01d897899202083345c8d9690e10be7c69534dad0ac83603a4a190be441819feff244309085b387af9796cafa0ca99150f825a43008ae289cb2dc0f84ed2e1b4da830031c8d79ec80b3bb463c6390fa0b12d628b00ac12f9f292540b4c0d17997e9686b6568482f1e9bdb854f324f4946278c06d51102e4702b4b39da054b69fe0b9b8af092e1daf85763b8e0c943789e85036d669fc6a46bd027008360e6d2a02adc81610b189c999f77c0ba1f465ad6a570bcb580e6ab46506ae6d64cc384792ca4e297cb7a9d475af149de7e5582a8ede62f446a5321db4797859fdab395d227e8cfa88036b036527dbd83474554e730f71c129c1e4f337d52ea01d0f3138ec16660e84187ad7549557eb87b416561e9b64c7d93231db4971cb36ea76f63681f5d31c6e720a9826809d9c63563172795301b514bef398795cd132b23bbc4450e996711381cdfac56674c44a7613da85bae854389c7a93b397cf3e6f494e31badf362cca14b253eccc488bcda46f173ea9d712de92b7984dd375db263efeac37cdacc46094d69a0c3cd191c58ba22c2f84c7e4a1c31d0fc909307f9d0273735a1fc0fb821b92e6cde6c03dffec6899bc54e63891d926e1b1632bfd82c4df387511675ddc18a54e620d9c5241a9c86ec21428a76778765a035f51bfcb54584d96c65c4885dc55d58a638ad827141fedc673b6f07aa98abbd1421f61b1a2fc1cbad9ee66eedcca3318328281219a243ddffc4cb5be153d276b2768e82cff64cbec717225f675e8e7f9c7d9be18fb61b5a7159cbff031d6dbeb6b4d125a1b437fb3a827ee9b5cef0b9d0e6833a0de1af8f31d0ee29a9f9cbceed96dacd56b6cf361d9ae14accf210dae39f4025af35bacc81c80f7dcddd53e18755cd00408ebcc090dca239a59c69491ac7b57b8ec98a969b85fa271b73f4ef40034497f7997c0c455a4c6379cf62066bae38e3cbcd8c06bceea0defd7b16752e189632552b2325fb6b62e12bda98a11c5175ba893ef49d9c000c6404d0ab253be239100db5041bf69dd815a68e8be1fa4d9c997244bc6d1d3fbec2a1d680d20107dde8ab00899f6c83668c8b1ca431113a0bcaaeb631f446fea634f5eb12d9ba9967191f428c2ed472a8aeb315e4db461a6b9e7b9f2fe1f47ca0dad903f8f3dc0e5eb0169c4f695365ea6fb26cec5712ab56e697f0c3c59647711dd2c946eaa3ed2d1c0f825feaef7ceeee44e526ad8d5f3c6f8d8d97c8eeef48e6725a85a87fc671e74f9d9b6441b17961910cd97c20d6a418b33296a0ecbc4a55bd5cdea83f3e4ea3c7f72d8e6063027195b7f453f9fb497856eb0fcb2575ce54fe086198d4be65c6dc20962d7ca5514969411f9f1c0b535d69cdf2976d0274ca8e2670fbe1492aa170b6de176923e829adf93b1538d6897cb1464eb063cba5389738e0c757e2466f3fcd71f46d8a2d970414b1d0795a6475236df0c584a7fb5a752621de9607cba277872aefa64bff21111c704ad6c6de7e000ae6067b4063b208a9fa79a777fd3c2950533aaa3dd07270ca2de7de614cbe17ea3ff9ee9952846fbbd130804292b20f99ee4d034ee37f67b85c37e0af2f813299117c89fd077504ea4cb9ca9e75dee5ca2a8c20377ee617ab6c6232c19be16ceee31d8cb851293735a52266dd641bd5590878743b953440b8d8a6ff43636d9ad406e769a88bd87d47da656726d6dd03c71ce39f6e8d7332fbbd29378228effc17e86417d7dddb11f77cd201532213c8db97dc038ca795e9ef4cf6cfe2c71c5411d7d16cb5e317d0a428970ba56e0bcd7edf836c78dee36cbcf0b27c0caac695479c002695ca9e47e07f825f3deaaa798e6165920c38d1b4cf882994bd2b0a9929580a7090fc33b113f418185e236ce49c43af3926a39bc8105992a636e8ec4e6c151e795742c4c16206e1803617e2ef5a073672b3ee9f338efa37f88857fa4c52a1c30ce9dc41075c7c325f1e2fd69a1a300f4c8c293d712c4ba6c9adea21c4e75d2a803bb751b79b73ac077c97ddfcfbf9c3200df3f7dade50d6bab1fa51bd16a5b72056d15143b430f6f58c2429f7bf31294eb5eeaa0133c829fd020d41992e4fa54db5bb32c6a5c6466362b7bbaf6de7daf55e6f87d04084316eaf4329a248dc1368e01c9c6e5b11b3f792cec965c4c32817465f21bcd277da08fea33a44c6a3c81c4100f51f46894b6383ae89ed969635d1a0332435653f2d1778e70def13819a10aede6a46742ebb4492f0b3dcf8fe378b16de9c91cc27b4f47f08b8bb88e98d478618c31697d4729b12b72ec81ba9a3d9569e5ee288c4f078a7d35574128d7bf550c8056c07ca6954881d31d3fcc32c14663b54852d0d15997b65ebd351b8c83342681b3b661ab11f2f9ae3a360000245a374e2462884d2c4cd4e2b4a3254d769ebd4326166a95d8b812ca7a187b07bd419e663355ad4766bbdd65abed89917199fb1c77db6392b47e071d87041c98044bca573bf71b747f4cf3b8e966d02bb72d16015662a20061849392f6226e3f134c0976f2755df6104e2a752bc333d6b1c5b2f923b8b52915c4598ede2229faff3ef1a5d52c5202578df7093b255b1c0de6a4a074a6f430d47b0987f2160e41d8f93f9fab3a6cf2096c9ba6de2b6172c401d828ac3fc612fadc9116d35abc8dc50c2efaf5b85d87e68a511bd9f3bff99394c3a1b58901ad5ecbaf587e30632f999374e7f4b14f5e4df9c268fbf2b1dd2806ec6b21b22dc4b127da49bcb72e5005b1fbe06ce7f929eb5ef1f0620e6ff0badee2500bb8f5be07ebd57d79ee7baaa8fa1f5f3ff0c53ff9b0ac850679353476ab00378c08b6ffb51084fe84590141a361f301d2c73c9768e07606af69aafaebc6468028c283fa9adf57eca2bc10820be0367ff20e93f013c319bddbc0f23140e35361e55708e5050e19e9b15d6b75f5044410c7c8550ad7596b7175ed1969cc11529521290c1becedbbb610b390e8c3e0c5c29f07309a4838dbd9a2acc7ec64a583449bf7d079d1d5087cd399c1735a88f80ed0f2ea857ffa8dbbe2cd6654e6af836afcdaa6727792984966e837d65715e8347a92ccf8a575e8f3346e37826846ec98904fa984d581c7a9e5fa3053cd5b8145ddd727ff4cff9b01b0de380e0072f611950fcad43168aed2b3667ac3a402668e00e38cf64a6f366cc3f081f9b742cfd41e84dd29cdd4a58ba67d5c4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
