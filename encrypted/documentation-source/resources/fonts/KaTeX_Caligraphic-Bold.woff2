<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a8fd478fe43b4c0120e7a5dd5c288db93187999a99966f4c359cff138846a1d7abac983174f1ddcff42862ec6c7c62b292ff79e81dd7fa9bfebd77a859e242173d209042d7835d5618f0a5f3b4f3c37855fbec9c84cfdb6e97233b342cf3126007aa7f44226f58033c229e8ab2954d347a56d455ba1ef57814c3b7353e6c67f245e76fb071e9ecc4f90367d4f31eca228301310652bf329c3fdedce2ef9889e000cc4b5752139a8af499e295e6cef2578cad42bed0d1874f8b70519e00aca1e53b07a40405912db15bb0705ec7aa37bdccffcc5dd3f63a995bebaceb06e9e28c78483929449a66521f729fd7769d8e6c02adc4adc843a1e3cd4f458415fdd8e941c0f197aef5fceef103b08804505f726d88f479766568116c8c0a4a1b33f52d5973a5441931eab50eda08000c07089d2d35e938136d05dde6e4b944b66c4fb107357b0578345186eb3ee2b9c2e306a25e264f98969520f31643cfbd51e9d10336019c9d16289a1ea0c2618e1401c6fa37642fad0f3be1e346575c177841a329b58625f0c44db6a936c8225c13868027e276c27491893b9daec8b1dd97a8ef4023b1fa91bb8d1e6cdb66dc82348513ad6952695d74e38ec79132d3179a326276f85808a50bdcc804fc55e9a6a60e9783f1b2e7b8d115cec5891896313f5ae00bb195588877be78da01c327bde39c691be0b6a7cf2005df2dbd63866abb8b74f9cf346f3d47728c297f5ba116279db78e6f97e648f8c8453224fb68816ef638af2eaaf283de14c7dd148e35f490524356c43ece249a86e46e5b4f759b91913115324fb352134f1138889630676aa66ba638d2a9bcc9a8b5e3f2d53e19a316ed25fdefd7b508bbd395e0f0b0ddfe5c7ee347f96ca7293f6acaec55d15979ccb50d0d8796d7152d81aca85173d3b8884ec68f491572e87e4486d7ff95bf36d1130dc4e5d489e29710bdda81ee3cbe407b6d10d8cb0c33d3eca2c4ca14d400555c4a43c6ba884c201432091fb348f2ab819a56cd86a4923043f06ce9b2a3925384ac7ea6316208d4fde9de5330c86f65e6547cb080b4ff40edc307bb2e7d65daa36b9e403df00ed5418d9a4cacb092aca73a9b169cb876fd61ba0e1260fa460237458054c0db14a435af66058484edcf1828210d892fae500024996bf566e88a95c6d2e052dab1aebcac0b07b6bd6e2d2ac398687dffac457e4dc69de3fc90670d834ac72969c4d49d45b9bb0746c04f9b339094baaaa1283939404e9e2fccbf2928589b11e3fa483347c3304bd14b4fbc976f486a7ce3f13b1f9cb92f6b7af57b9b5eaf14fd2d848c3f25b253482aa56be72ae490d3700a20ee0b5657765996d3777f12905cd7e583f80abef4a675e8743b42a03636d09485b3635c196609115354e76533b6e7a8b280df08f0099f22e17f8b567d9e1af141ee750dad685d30c2ee94c1c4e6190562ce4b0023666c22939a113092e9451a03520aaa10c92117268ac6d24144243928aa63c495fe3539d4928df29962a75a57b1090bca657744d247cb93e20ce454b7f8e130deedbe0bb1da49e424764bfff26bcfc7d241a86d628e32461f3e000ed726e4af909ad959cbcda6cd60f19a4956d43bd3f27302d1c75fac4e4a385ff9ee2c7833e81093ec0c2d9503d8c44799b1a10dc7e475dca70b8687b43db4ef38778b348eeb3024084dd73731c75856af996ae65aa8c68f19fa0dae94f307bb79fd0c8df8d0e6c448de7b93c93df4f54e1a14b43a0a255e8d473d5b0d348851048089db71f9f49f53b6de4c1b4ef059e7f15fedc179e2536e5f379bebb18f985a86df7932d554fb5adbbffbd5a2a67210c71f114f74ca486faac999b3fd29e725ddb155769b72e1bd1fa4b2987b646061a31a42f5897eee8ed3e7c7e070767b45f7937e48f789c616d3acc8fcc435102b6af7e029de37fd51f0296c249243740524bc66dbb2f983356662b964ae96652188bf31b76b4b35f8321bf7b8b620544684cb0c7a008577191b99ad5875f2f915aac7b44aad76f3faee5689f2c8dc3e7595fba34fda790a92be100db395a78195e0db5cf154bde011092a35ede899e7c09d9d85e3fa4c12f065db4519f0c312785e85b1a7aac34ddb733e2b51c3c1f8144d4d832a719f20f79c23e8c64fec356ef60013b1ec487546a99fb76df6b80f98d44ff3b917d10469d4bf46623f776a2e8ce4ecbc217778b3dd33349401ca28a94d06b96a191593e253164bed7a9db25a85a418698f4db47cc55449f2a3d1b0946214b4596a403af675cdffecfb75afea08f62f153d30c493aff83d82b551fe2cbccfc6b1fc5591f8ac145471a624ed9289cc62b4b55c38016545d03cdd7eb63911bf24aadefa4d32147187f76218fec3a131740060e97a4c31d2c316a66d7ff15766d9e38e891b1b2c7a71a542784076967dd6215feee6e7fa856215524eeb1a259df68cccc3154498d8163a35570638e5776c1ce4e878e37f23c4c3ac2d8228684cddb9add04a024ef4fa5339fcff740abe4a172880e6ac887da8d6c9245a0db62d380002825c3504097476df994d8c8dc35b55a9b5af4c505a473b94bb041fe956ff5a67363544c9e62eed076b7dcbc6525db62d1df7b6c30b327bff4045d63def657c3d1edcf84c667cf9c326108dfefc3b51527a6a07db6accbef0874fedf86e8dd2d8b386273667b22d8e44e173605f81408f8e922ecc6331339411652de81689e2c1f06efb8ec24247097e6eb868fd78939e70e17c0625406cc57a514ad37468dbf3b1e3d833c7f4058dc53ac825ec51f1cef9306c647f725879daa2824d80866f1edac2ca1efaed60993e3246d45b7e144b4b41d26d4bf9147959f4157f8a4579a70cb49692ccd9a96b8d94ed088f9b4a6bb9b853c1bafd8ce68aefe62b3fee13b7b544e692a628dfe8b6db69541168e4bba5aee5511c6330271e1f436f38b20cc8ab9251ea96e8c28ab0e8a43c1ef4deea539935698f327b295d4c0b4ce25f4c20192a50d165ff5d57b9c8f8848b6d0d37afdfd72dbde79528cd5ba678f8c62da2366f427b6f15ef8f566af728c6faa3ea2cb4db3fd508a7cb640c97ba209b459e4e6311cbc3f2b717943b2c93b7c37c1932c07930c4548d33d755c0261d998513a4a471c40db8cead30c3b805a9e50105554f6818eb51c592efd5fc7b92bb6fd647752dbe9d52037bf4e81006cf1770fbaf8e44fdcae8ee306d8886dcfab7be75e07ca44f7e810b7e029574c13a41624f302c7c7c728d2cc3456b2e5c67dfb7f144f5e4f3178e37de11c16dfb98802c475e009aa3bbfe12ee166706b1c39197df0d6b49c2362f54d26d8dd23f9eaf1a89ca2f209130c0750aa5cae987787fd8cf222ec56dc5fb246f39696fd09f0cb5a4132dc1b48af4788746272599de7d1cb3cf498ed9e77e9735d3710bb02f1b06a90c9f0267471a83e3c5c566e6473a4c21afebc9c4a28c65f9c7013bd70e7ca9812486cc5e64c28481dca1ec3c84b632d1dd8509e4e21b92042b4f5d390f45504405d4344f10fa384cc8298334f73b9cd9785bc22a82210602c264f710636d0c77e47a69e4e8c8e7479f1e248c6c8bbf871ac7cbec5725bff8ff7a73c75f17f794f243bf6f83264536e78091d563ae04adc6a6fecb55f687a5386cd0abb7c22f15b9754164a89bb107fcea7f7b5df88896bb53f72407421b9ec3a5050bcd8b3ec302d58fac9bdda926109bb2a5628c9dd436271231193bd7fec9d45b7c4cfe61fb928f0fe7c85dc85eacfb1710149aae41f46d0471a4fff8d4ca96da9778ff5ecf03d4a3619afcc14ec0f581f7ceb926881a966646d0c3005f46f216d614167214ac8e344c438426ae0e48a3cad45dba098c669226d40b8c387e222f996120fc004d2675811e409c23406c148c1cdc1069e19d1862472799e80a31f9a0e6041d105a12a5ea6b51d81497ea3400fa99022e1ec62e17fdaf8385e46076db4711c5c9e0998723304cc868935dc1720eae76c206800583d1bec9ea40ac45f19096f977f05196bb1389dcea0ebc11ae0134f5c30f37f58d5e44b282890d3eddc68c3e4f26bfe45b30e4657cc7b10e3f05e95c18797c3f04ad06044d5d85dae22cdfeae330c5b1455efd3949c6a2d356f25179a899c7213ba571a501a8268c492564d084d5e911e47dd619a81851612b70eb45c2e1d7e040b17d3524565d66c1e14bc47fe04643bc30a89250a74d539616d21fa4c5e8be32d42b00d098b16c3d74a00c54fa95d1cf6e24243c0f61f29535e9275bbf0830a0c3892553f267a733206016fec9e74b1043a2f94ae4707f7c3520559581a6fc619e384915aefc945f4693b065d65c14b538508d03ad56ec98302733956aa195be2a650cfdd6febe763ae5c4c0675a9adf4afb8c7594325173ecf37c06d65aac1049e9b28a0f2fc6231577745e403495c88ae76dc0dc886fdd842b8acaf5bd3d28c31f7933b832b0676253896aba56794eccff3136e53e767d8149f7afc9a38ea7997e58cc0951d6597d3076d630c554f3537bfdfb1c89e1cf6b18634a040c8b923798fd3ae2ecad5f9f1172a33e37ce70abe5747e5775d8928da4b6bbf4c64fb0ce0e768c5acbbf8deeca62c8a16bfb70e6fca0b1e931823a6df65de01e72db85470cc7bebe55c57cbb86016c7d65101aa6ca3111bb85b21d9efc4178d6c33bab7a0c3c748f70874b1d12cf4e839d672b085f4e156a6f205c274dde88b4c90002643936d24821861421799901455dfa9f326800505a0223c4a3a594bedbd1bed2f67ed15fe810946495592db3d397156fd54889b60ca22f87e5b347d7e53a2103061cf7753a81f019349c6f1e8bf5b841aa81535f06a46c08bdf9235a7e5c3bea366dd0a3103e598b80ec3a0dd79ea1c2b95acdc05b05cb93213b2ac44da9db81e0cf91284983596ab394031ca798b89bb82eccbe89cee54e8b998786aa544624d73c121f0bdde8314f1235429c05382f3585779cfff6d9719b4fe46454c7e574d4451f8ed2b338cd08006c68c626f0627dd3c1006617d877772c61bd31ef74cb6beb235feb689e711687fb912e4e00ea3fc17bb2fcbf79aed554e20a8cfa9ed0640974bcb00eed41955c93f7c2f606dcde49312496b8219875bc9df2d54a6f2b47309dfd51d3b767ee6bc48fc336141791c7c16e3526fec2f349807a308a301a32138062fb6912464897641a48574a28feb069af881a5710179f7253f58fbecf30f1706f7039d005338b482629c93f800c6947770d4639ff0e0f5c1b24e32d8bb921f01694bd8288825a5828239b6838e2a9766f8192194496f26ab9ad985e3f8bed8bae8a07132ecc83ce967b493829d8bac1d6f6d9781abfcf671a92f9e277afdeaf3c4ee72ec1c63b086d4354488c5aba9ab3fe693775840e58e70327fffa800b53520ae34264f7bbd2af722caa06c21d18df70bd1f6f8dfe789a8bfca6a34f25cd5068d89de384ac553c2d50fa956f69e4fa8c2a80683d0532d88a8fbf23595514e530d3bbb30f121bfb793e215159767e14434b7fbc5cbacada0cf8b511ccb783d58e58f0fe6c1cebf13f34f0d3d6d96ac9886bac1e8a424528dd0289c4b570145aac9850e45f6b0720c550c8a091497ee369e1670230fd30de51c17ff2b01eb8a99c21c3b67f6d1c75700ecefbdd708b40d1f9be9a2d5de5fd7ae727e59c47461487975708f0a3428ea5edd4f27280f7d53c0b1211d77af3d43603570cab8d7fafa00f1cdae3197d2bdcd786f1896711dd721e9888072c07156ab32dbe4b9d6d0e1c75f929ff9e3149c49e04ac1e89709683c103bc5007043c3157685031a3345590fdf0531ddbb0dcefcda76f1d9f49a4003611afa01c888a3c550049bf145994679e819d2ef5c6024812dd582311ae9c589bc75a03739c2725d488dabae0ca0159a09c6400008f9d151072ff122d630b56a50b8ca55206e404c6d9534216b78f462c197452dbb1db7407a5b500a2ae422c925f167594d8bb7cdb3a2e7b6524dd037319dab4965bdd470f4061061c8d94cb8adb50511ae628a8b0a883fbd39adb2bc92b8ebe73192b23f39eb072f372e4f3460e7b160bfff8e4218c88007a559bb171c78919701b235f568206c64a574fcdc10730c140f9de0c098e1a763f050be77b16836e07e84c073b63f4f209814b34b801b08a262925f8d1e5d8965e51c11689672bdee2956ddc8ca3e30d82d51e7f7731197df5ce74dc996260531ba4978943dac90dbec9b87062ff3059a968afda79f3b82a2bb61ef459dbfdbdc31d23d618c8afaee97b4b63ad7fc47bfd57648b46f2598bdba74163ee37ec0236e3ffcaaf38335586c0813a8c3b040ee507a9e15adea47d20958a88d20e43a58df980ca227f1190fcba8901f6491c353d7cdd727c8e2d6c8a3af1db0527dfbaa0413ec6b4eaf086e73608766aa790a896d5a65f774ce7ef3ed0a6a233af5997321575cfa67cbbc966522dfadba08400fa89e5c18e3de63b35ec1d2570b29b5dca59650ee48d2b0b51d231f2882e78040fb9fe5bf1fe490ca35c183f0210d8e8d5bc1bc99ff6049fa9b0262bbfe823eb19db02308f01da03ae5473251dbe6d7c243647d7fbfb968309e740d4a24bc69b15097d2a7fc9aa5a663da4f7ffb107f4867540e73735ab0c7a3b730b21b68dfd9e07284c8641b100b0d4dc4f99ba8c31fa51527de3c5bf6668a34b39b8cf2141bd95b277c7120ab85dc8aaec3401715d5709b301c49b96b61ee3a3cf6666b640e9fea22c3f1201d78192f86bb5cc95c85de402a8b028d1ca1323de0164a15bfa0d319e2d589a62be02c2836f2465bbb91b048aa28d76c3c13d75c9e5b317ed9daf3b3cecb36172c96d5375df1a4a42dde76a1be37ac8826472a83e6b30477067ccfabf46aee025c39622faf97a9b6c25ca89134330de401a40a2ff68058cc12d7e74caa2518852958d571a7aca7f07097bc5682a4819d40d8f44c1544d7d9d63345ab1269bfd17529609c84ff8caf1ecc8246ef6d7f2b11bf5ca0acec54c03a096a0c40e5fce2c6fa53dd702a410e714d5eb03436bbf1a5237e69ed2ccb382e4a63da74795aae8cc2693b440f88d6c8819cef9a06208ba18b61260e7f8ffb658d474cdb92407a22ef7c29ea1061bc3f354fe605fa70cd3ac62291d30c828da5a0a8f99bf6c1e7f0a3c7ff85deea21a29b5541e47d6b6f20bb71c2cc910a80b74337fdc29db8e37251f30630f97c6801f30900c669c545547abcba78f9ed5cea5c5c47e2cbbca340bea468f13f97e1fdad70bd956fd854f8e54d852be1159c808a079a3fa8337270a8fcc4d12a3acda8eaf8b9938acf4dd7591bc128db438aa35fcd2019443e73f90605435928cfc4828a39b244795238bd5a40657ba0ed2bf4bdb3aa06fdbe0fa2a0e6c49dad064b609029c1b6d7a6d9fb8d5b7e1078946c041ef2adde4e67f0a478c066c03ef83bf0729c8c58d129df8e6e085956d4ff1461341eb54894968c21d1540143c0b144154b6ead0c5c6c7b1af2dfa68d63dc7ccfcf424f26c4ee2b6fe2a78532902a1a8793751d438e3f7c374d728e6b35989167f62f74c0b424032c1948548c1cb99d662b7e9e03b94307110d2cb26f9244238cdedaad8429adbe7755ace4e91da80d95bcf34297e8bcb3bf162d631ddb293224f8fe0e0ea92f57473ac389c94f969abff0806ec6f69e30dd2cdcfc51ef1913cb793a0943d70b5ef1f04b0f8e3dae48627728336ac6b498d8f22af9e68db9c1b5064ee513efc0f7c14644113e22dbe7e49e868f11ad8e839ede689ab6fbc9f8771ebe89147d0c50e018c981168194e2d45218a464c1569d7aad1615eb8dd2d899b423ed1701a3f4f8a1073a682b7bc31a30a9d52cf748dc6a948d09b2124b6786a632d4771a5ebff4c240101d4729ffe78ba1617b71e34f09d5cc4c35b7448e11596858d2bcd0c9f25d5e6f88f302a3964c392fa36965a907d92bb36a694d25641cba6025d2b0e6cc273eefd7b79f76c780e08ea982118fbb63ee401b97a9884d065eddf000929a8cf76eb4d3b2bd61da72df37af220228d51a8bbc1f451432bccbd0916c92c7a0931f80eb7aac8d0d5572d5383091c464655fd44a1af0f16f0a2327631bad60e54143192844aa91d89467a4e82a1aeeefe7d66aa539f559d55d9428457bfc22b4f17ee6b38c59142da1ffc7acec843aedf091ed5fb1bdcb7876d7233e549d321c153641a786013f4c155db1809fc8e746d7fa4c94a1ce456f8fde018b4f6d7ae7b093911dcbf8580ca34b8f9cc0a0ad08a67ee00aae2970865a30ee63a0328dd06d10b269b4e416a81404423ad620933d0c1d50ac4dbf54ce87f41ba1e1caff869d039fd547d9b3ea1ad86cacd539db5cbffb405a8f838500d3e289a49e052ce4cd219ef61748fde448a89ff467c44e21ad2b3410f517645c4f356492ba4990cd669c6efd0851e70add969cb345f8f5d7ad12434e7eb3f53487aed692caacc3762d5806cf42a74b08957512ad0f5bd14dfe2ff1f2e52bac08ad3e271201b40662871f2333076b3570375fc2910477f0bfb4f94d60889d9f7444d6d222ce833552768f9d9248cdddb70f7ee6077bf81142b08c09bfdd2a4f9b1af126d32b62ebcce0ff4a431592c5ec67ba2f735d08aad28d1f0d16571951ddec278a7f68d9de586eae0fbc45700cba3ed21d2c3ecf2186d2d29cfbb55137f4ea7abbb87898576592ee9966211982477ae3ee11788cb10dd5fdcc3bb0dee45471b02c8483146dfcb2038a56895e64fa015989f83504f4e229ff301a5f47750defa5167fd4305cde113f51944c4ff8e2c93f0484519f0979ea189f9813c119a32607c31d4e7004d607f42f7b46ae95b95f46ca910d6535a6c5a12434f2697e8998d0317374b6c28e6ae76568e1b20d7f0dbeb49ada20b71c3fb03e961be44a8ea4fc3b4d38fa11472e23b2a8dd69f626bc5f8d087a0c2ba21d992ab31f3ca988b7d4b4dea64ce18cb698717e0728a72b40f584f8d32c28ddc34e02c9c9412d3fe0fc81f6e8dbab40943117244c012d37ac997a70faa908ff81592b97edbe81dfabd4417aacd1897c3fd6e365fc2e807d5fc3b6c46833f1955161986d4bc8086092070d7325b53a402cb415d5e03081bee214d218c9195ce8fa32ae7c543006c001cbef53edebb4aefb6fb88959c4bae70e6a63344533bd8d37686015758bb11edec9535361d25d849a2dd2ec2ae2e7cb521f3a0fcd5b998e0b700d7607a083430326f9bc0486bfe52e7aaf5819462dab335abb7087324b6a7677e0afe88a6096dba6eb9812a98f46686a570988a11ac096035767d2cebfdc2c2f0f7ffb25be2091d98fa3ad9f937053fb3c2fb8ebb8fee6dc2bc84e554391f513ccd0b38a26fc1f9a397f3e0e7ded28b957c0c1fc760daa6c233fddea287a318158ecc86d12b4a9f293aaaf15bfa5efa634d6f3159c70e03ec26c7b51a95489774db56feeea8a87b2fba8d00134a147795867e4fc8a404fe1857821ab047b60f019bfdf4c51d7ec0884dbda17f768bb82e6f3f0ebb43ddbc97f153879dfe6008996afb7ffe388dd4ee11a75bb55caddbfcb5f36179bc6c8f19ad1e468f861cc3709bbaafdb0df6e9266c3c2520d2bff923e267a11a00aeaef531e35e76d8023f9b0a6bcfb16925437e4c285f741b25134454a07c83b44b68995fec889b7f1fd9543667a97a3004d3e47060aa3d892a8dfc5375cf14c8288bf1bac6ea6245582b67a1ebcbe7ab5d9b4d6fd91dd241afc798fd1339ab112e0229eecda8253085abe927e7cc117f33db89c5d6a58e2963b6c3c15f60ec7795317c8e917d7fc75fa0f3dfd976c28a1fe865e0143a9093d1cb3ce118e4718949edf851dee3a9e044dbbfd14a0cdcb3f2743162301128746f32b0e95c23087814a98fa77884f8eaa2a356ec6f5511ea46c78322fd41bc463dd2fa26a7c523df1671dab8ca701d4cfedb0bf9fc70d01f31f43cd9a9772fc89586ab6b72798b91420e9d85ece8debe46bd214a6995834f05ca2f7d1e9ad6b03f69d0e72bc5f4ab6ea678088a4bc178c6939beef276f2a1ebc0f9aed7c3bc31e71dd3622010c6822ca8b0f1cd908d3734d91de76ee4c59fa435cef7179c40b7fcba3140ee4f2217209f3fe6a1f8bba823e0581d7faf43d91a3f8bbe2feb55387dc65ae87d61554b3432f6ca58285ba446000009f07de2a2a33892adf27f98ffc810d42df8ff727fe554ebe91358f7104965c63358eec0b90a856791cbcb7b6abf6040f84d727dc79ef7a54daa1b435f7566ed4d0d1508f17d5176baebe2e1b88db9f345536460a2a3585d358e3a5cb9564c8023bf1c1151007e92d4be0937607597dcb9e084b440c49641db9242f5989fc5b52d3d3e5c07e68546a2a9b8a74ad593c1f9249c2cbf7181fe0994ce85a92fa2dc3307a44eb0611cf44fe46ed7aa0effe8efdcd7306cdca649d376f2b3905c19b40dae32a0301e3de40e4b3a6d5b6f0b7067ab283626156cc07b7486fd4f4c4cba19656f7b21e2c813e7aea2b57728d279b9b900465bd3e48bdd8e83f78b3a6d20d8b13cb1a21157e677b376e6357dbe6bc71ffaee80af208b75938c700ab5e1caecedc0a9103d46ac8aae1182f125202409e379b5042cd156589bd2e50e22423fa3da0515a523b2cdd3cb0dfa9e75cf654476a7a22fec31b66f47c69c1cb5201963904fa3402ea41c9fafbb46a5935de82b17e15ba5a931866fe6c00c6a950c6e9e09141e2a46ad6b1b9fb88fa8688415cb985eb4a57568f83725bd1346a77686a4b678d28bc0b98e761f6e722d3fc0fadf21174fdbfecd9d074e587f442899f1a305bb1454f2182eeecd3e8d8ba486784c43652088e2a8172c3e056084fe6a0f664d013d3ece0615a58360f2a2052a0b39802fe4f2474adfc3240798bfe3b62231f846690cf24566cb758b6cc6d7833b1d35bd2bf0b556e3d4ae085dd5cf7d09564e16a7be79da77607f5e970567480fd0e5ee5c19ffd4616151bbc4de9a09a583353c22a7e251941a06654d208f6b244f045cb332aa74e16a1b6f187cbd280e333f8bec1ba0af0a62e9713106ae2092dfbb5438ee2dddb4378431cd9db76b192bdf7f58ef94b6a6d707054b330c39a6e0553979ce48de27b17fe3f98f025f270ba008eec6de30cd8b1c5f6bd36be9c4beaf52aaffe546be252d81d0579ded41cfd78c0f54e37dc72141fbb36890ae07bb7674eb70e9220b9394ddbb309eb5eca00940bbeb22796f9fcfa43518c8c4a4fcbbb5024b592be0cc637e9eaa4077e03d96803fcf98e8c49ce0bf0f4233d95568e209c6e0d2037304d1e1bc257392ab7a92f2f75d32e1b9b75345b8fa65e044db06743f1945b9ca59b6c80921389fc304a9a057132546146d0b59d50b90922bd40287bd315361ac31c491a641c18f931f8638f93a6827478f0053e0ac778a901554f6ce79786ac0f8e44d80754c9a00325e47967d87252a7307cc93faa57ea577420c81d9e46e9b5c900089c82f7f05c9e3ad7356bd3a3d1d015510bb74fae2ce0e7d35d4cfbe8d51d79be1c591d71c87e08ff7833d705bae7a63eb5dc1f7db220a541ed653c6453ff8e0198f1dfefb527b939c1c24fea4c131b3b0902581c1652c49a409600f7ec518108a2278e2bb0297c0e679ecc9a0d3d163cb0de62e96f371f04ad30dd1e3e51bb10039b2b2a170d17626fc7c5f9bea434714c46b11000671d571dc481292b34490065b58a0f32f140cdda0eff8fb8161c7f726f862b075733ff65175169da64520c9795b3b2ca010665439e11ea81505de740de5884179f319b0820e6fbe76acfab24fe2309895fac3cf76084b8444e7e1cc118af471d3f41a19ff4e10019e70c3f3f7a7986df8453ca94b57c3465d5adce95e25d9ce1b3dc23b7d501c2d17372342e52b0c2ecd6036bd4203d8903dc2476e4e77880311af8dd3f022815580f8618137df739737af488f365df151c796ce70f4b1658bf2503e29e416bc2ed239610992fce19421136367b5ebf6694b7e86b54ede3ea6a2e7bec3f2afe27e385613a8d81aa1a39e48c097b2cf871573f051af80db0a4c9329f629d83f53bfe4452b66073b9726a80b96a721e3f58e18d1deecc6b803d7712c6a239aaec8b290fbd9faf3e0bbba8c38c01c6d0b10170ab6f4f2b5c88a1672a99ac8d978382a1003209482aedd8004fae1d795b70616204f75d3ccfaad184f8daa9d5c757dd1f9ec45da040e1e1a771914eab5edee5bdaf263d276441df2ec1d52115896e0f671ac5a72457367217ab189fe1534da3b42e26c6f6bd68f3fd400186d95315aed19b70c1d63424c622b66155c5d7d9b14ef96d7b87c1103be957c0b271fc70e2295d4b982716ead89179684bad55773dba8d0f18f1f187c4efa454031e08f3dbd0afe00607068bd498c16fc5d1aeb41967767998909509e007bb3573e8e2f2322740a4cb8ff9140fad7fd8d97b2529984ea030a60a40614e532b3d439470bbe225bc1723f3a64f2b3049211e17b34c98ab837ff7086c5ec3178264d03570ca7258ec15ba3625ea1b82ccc1fc527e6e8e31c2b791d00f9a3d4be7cdea00c113f6b0901b4cdf0750891cc3d525a7fe26712f3df175d162284bc8662de40d7943a322d0f6a561679c73e3f4a69c7e6b9d2c32774bec52d68f491d62775843d6e2c2cfba14bee0c7bbd4a46168ca472d31332c34833a99f9c33984925b55e6179ae690547c66d9d62540030ec515d259a87c873387c3bf48c29d1ffe2164753f4470c06157a441111d7f14c8bdac328d6096c0cba8ba7d5a221f2fdbdd1e6c034276a6d279cf8824a49bc6bd93e39c8c1fde7eb0d61133457a522201cd318fa05d8d979f15934792eb40edd6df68fb1873f6988695c16e00b5ce289709ad373665b87135643a885086b69d5707878a3d9d6b345f05ac459886a4865ce48558cda91cd4c327595eda887a765ea3c6bedbfd6114e3c149722b9db0220e2026ace3337c727e42b4570474c2b7153d404bf09df21a0b2b5d5919e9fa091a3095141010de92e0437ec5c07442bdbeaaf677eb8c4f24de0c622bb7cb165e682e3bf2161048f6c7e7a573c889a79ed7f8d657e393e1613406a8f3ea5b75c3ca6758fc7d9f290360d206820c4f618ec63c16ca2ea467e98619b7dbd3da3e4285b02008d5e78384e27b233afbe893278bb3de882fd805605e578c3f04503ef415882c35f68374991b27ec21c36c5d4fe30417ef8fbcefeb7b13fe61f4b194c68e8e09adee0d8de5cfdf927903cc8cd52fd37abaf303d988d8391fa25c3c3df0952423060c578a0dc4e964926b03e3e4b8f8bc6f82d40a1c9b629925b604e820ea6647a5e7e919bf0c4469d8af22d6594ab7b15178412c81805b20d89d837d69fa4905d4e3ea311b0c81ccc92662905fc76b3b150b0c9bf7b0410831c333c2c4711ccaaff81c29bc5873b0c99854bc291cd637e6927a66e747a08552a17210135e2bfca86aec6adc577c4b040bf37ab3521181a037015ad19ebf668593702339be295a599eaceac8b09fcc58b10c85c79a38c4fb113245a6952c542e3ffec8ccea1ff420c2e12849a506895c31a69f906b34eea9ef5babcdccddb0bfdc1ba58b843ff7ba6c3b426847c846ffe9b312661284d74ce6b1d96946e49df512bc7175aa820c04fbc9453b0c6bc125cf632a531a59c422739c52c906ae42a9e399de5f88d288dd08a640571038933d58b8701edb1bfc53bd0f75b1950ecc394ea7b00f78a681c156d388162f435bc206d82f9a9d35f121ea17e856561eb702f22a1cad1789191b874fb736c7f74f921eb4f3625cd6b4272c0f13cff07f39a86bc00735f79b994c19376822ffb7b3ed497f9860a32fb803f16f039a5fdd55c232df1e54b48429a7d96e2012b886386898e3d022c3c2366842e14cc0e34c2fb6aa646837ada42e190b5e1726b7916f9969d348414ba84d586d1048e82ef6ca7e1f98969ca14c2ed9a6eeb20d619b217b09e57f5d06a4f5da200b4841f2ea57fd99d463a6d65939e51d032f2791afd95e73534908bdf3b18195bf3211dd4a3160a7d000f92d406fccdf01eccd83bd6951ef4fe6da8159421785918f501dc189e3cefcab3ff5174565817678eac00e1686de789d2807f1c7dbec8a03d11394341f55ce0872298ac7be9995cf5223334da6b241c4302ae9f80654de9a8d4a1326182d5b0488cb911f51b1cd1c876d42ded70e0318e03386369f34c98f485dab0a538fcb6506cfc1b906475e3005cd8d9bffa4992e23e7ea901b41c51165f120438ec66e67278fbd5b721d5f11c9463b4f36b4a941ebfe3ca5e6eebb5f6c228cc139b9c6ada90cab3f73cc46d1e75c7e34d4b8c4f4b8326f3998d12aeb0c2e38dfb97106635fd046e6b96cbddda782bc2f195708c6402fad48625b2344b14bf3a37ca62682ad820df8aed6e0e80eb8c537ee186a5da97fb75d9dcafbb934977ee9986c2baa1247f13339e23020393d9434916730351f9badaac6f06147b6fcd7e253469525b7a58bdbc1176c81dcaf1d087a615ec6a2c7b4831273aba73b6cbde72bcadc437c180cb64dfd0352b79432ae226f229199ace4f6a9041454acc6b55195daf9b79de0184af897bffcd60e249202a6ba79bd906c9efede0ec3cd86dad9dec4f1aa11e7a036b908fa89b4b055b3752d3d332e90bc49c20dfc3265908191eed6178a9df9591eebdbd9bfd6414bb8d8f4a5ac46e759bedd705d9f89ca5b3a2b76c4313923ca78ad3cbc362de0d3b51d3a609d39abe56a31148b789d101fd5f68d1f8c7c325fa6e2dc2ada59496f8a142aa4c368d8db5b5b21b4a3b3dc834bf5efcae5b601f6dca54b7b6d1a249f5efc0e301d4df89b6e9cfb16abea6b9b1fb0430fa6ec8239c396dbe91ca060e6570e67743e1de26ce0a26de860e8eb72df1513e20074b713aba1643d3ae2505479b4785c897785dfb219b6ae93cf731655c191f0e806e12346c2409317d28a358cd713220df528de8e54a86c54a9082a82235e929e515fbdf9e86dc989d45836a1f632a032c6b56b58f1ed43972e6949d411feca2e3361cbe99c050611a8dbf4451af61c314b59b7cd6d614a94e71e8fb5d438cba92649fa1e42bdc158c3adea9b550e6216f4deff0bfd3db15353a501fbfa18062f38d00122587cea515bb1a5a77a83abde8eb1073baef9f9ddd06f978f0c1580f4b2a9a925895892b4a3d056bfefc943f22af393afe79967bd0f743bf507cdfc826e28e41f69de8588d47d38cb40a8cfa6739465babd0802462b9e4989577f3163ce1d4c5818d4215a765dcba55a34912e524a21e1e4becb00817f1238c492ce4a3f6f52c15850f6b116d6b4afec0fb919407ceffe48717b5386d85baff45f89d2d3a938b9fa7d56f0fe79350414fdb87c5d34785e1edc66bc34586eea7a31b1a315b5a5c2242559dcfb51eb305e95c5367cfd86468ab6f5b5f5d2517c7b8dfff714108ceb53018f26409d8425350f777993adac28bd8fcd0b2604c246d290b730cf79a0048813a7c814b00b4efab47a320a04fd481b706e1db566583de3e3c18da039788680c92fc62acf7f79d24f1645f687d2fe4f6aaca79e13d9798337eab36b4cd90bddaff92fb79463fb1132954f9cab0db0c91d6837fb35744790a33ca3dd2ca28dc9d6c8ed488b3a618f6549aeebbb38847d387573ac638870a718fe32d67a8a7008b7f262d7590f65220ac1ad7171e242c7f6adfc942a256b1b7ccc72b863f77410e116c19773d0de8a15597ab0e67fd6d39e24ea991c65a917781186472b12be3dbb79371fe8fa359654f00392f0a852873ccee5a9e7586c0593434267165f5daab920aca64d867deb98cd3038f891b84f5ccc95508e6df2d3d42538d70cdd45f729dc7bb21eace3625626bb07fc3111d4ff02ec39ebf9c6b0ddde3451420169aa503d2c2fd80f3d9f441fcf0221d7e0716d351fab5af6af4ced4186e0387bd9d3e1a05d1349f284568bb98f6d63c59dd219bf0789757e1a25cb9ec6c6e37211379c3a2cd6d5c69e2128b1a2002f7fe2d354efb78d4585aab599694e918ee1fc299b9b0b93c35cb7182bf9617d435a0d276e1e40f49173bd05da5de5c3d6b65c28fdc848a72c6eae810a967410b953d29cf347d8e167d08f27505fb93f0baff4e169c325981ff67859bfe33a9e26a1f826a4e130681140b686439bc2e87170e598989f24f9d141c2ebe7e9c406423bbef0cb851f0f930945b578f863c871d222298c4be2c28ce6f831c4621035806125f3e0b72d02719ed05ad1ca7d59485517eef525f663855e5355351f6094f7e38c5bf80b38e9fa8fb25eb59aa39b89418f793fd688bfef355da5475162a9b8af463b3818988db709a1bc0a46d394b6608a0efa0e1a2cf71f63246659d3b042abce318d3fce7f58e1c83401a6f6ad2a9321f6e86baa96c9e7ccb139992e885d224749b6f632c05488e89c35ceffa18e90682081a17313f5ba0ea17c255d924955c759c71b6b4e98d1457e557e6ffd9c02a77f8e3cd546a9c8a03215afc14c11c01458e862fe5dfcbe400d650459bd36c60abfdcebcd6da6cb5f10348755040226cb341d40502c5aef25d4a5e3a34f33fab461816d266991ac0011a37f8cb4741491354e60e6284a59226105643661674c7be2fca25ea90d6b53f724aefef5946252b2172740262caafff6c83ad43971468b0c0ee628ad767a813ec540c008add6a3428b466f882af0368aba2ee9a4a89c5e1507a53347da0cbf92dc62f7237a129d9f0d06735f738f1e3780161710ad99b383de32a01f1b65ffc0245bfa8e58ab35a00667abb5cea03f62aba92c31c14d5495a5e2acb545ce1ccd80513cded26a33f4cb250f8a6be6b3216285a4b3a21aedfbe7af2fd32e06187f781ab053902b8e2f27adb2e2a9fad9d73e69f9043d2ba27eaa2dc4371057bab4e9d28166213b9521018d6d9acf8e38a87b029ed7f420c1b66f5549c0ca47fabaa3676979bab3c356336b39e52764e3c2bf0b4e59aefde4b70730e93f5858e70552e46798c44fd90c67064ed43bb343bd5017662cf956526398708cbb5b21510d1fce5826be85bf91354c2e8b87565c1c823e3dcd2edf4f31f889cde4ad76eb35675ada30ca6206d185d3082e32a8f47225fe11486fb911cd47304b86dd2c133b8749efa3d5910274f3f448515066f68dc1978966b3c4470ff4fecec103f8a06d96621786021eb4be152dcc6bc239c354e25042385f5ccd554e344afc526e911f7aa3555e28a5047774c4fdb43da885e97360ccc5f8d3bfb70ec636729b238b8149fcc5ffbfc17785c7f40a81f11ebd0b24507987b138b3f412b2c9b7483f4a12cda5acb25eb8e63c90601837925e2ef9eaade227cd58edee67980396530642a2001d1edadb6c2306583ef70c7a4d159db86372dfcbced592487c9bbfb18d77e0d164715422e3222c2c525effdd9905612eb95bfc01f8e99389472033855f35d61938bc5348a68e3a26e756d82eeefe462c389629b5089d810fd9960d9b034e2213511301cdfe302d3b3bcd10bb25d161b654bb75c1959137a56490f0f81d7008e9ea6595674a310cd105957c3772436c820ed9860bb2022013b096a255e610d6bcc95a3cefdb625deb02115a3e95bbf151f1a17ceeaa88cbdc5d28cb3975fb9cd5aa165f6b1893ba227d36940b7db6c637c3b50ff5d921d7e4ead3a7ae365586c242b6716cd54589217b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
