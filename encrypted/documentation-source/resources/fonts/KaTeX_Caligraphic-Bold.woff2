<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac2ea7913a482446a80ef9d7eb1ffe5349aeea3a409494a60eb8bf94a499e90f3ca7e65a1a8260aca118251aa6b7656bd5e87aa13164d15725105b66fc64fc082fe85835e333fec7ecc388f90baebe49719d81871355167db48d825c18afed99cbe0b59e4c9c178aa62c43b37745af26335f8f36154b957fb8e98ceace31ef7f6ab0519e183ce8d4148b9347c134dec73010d23db10328435e5664d993052395590ca19c46f3e68ca90617eb339e37d24374ba81f21b0eba3d5ea5539d2636b9a8b34e1919271dd7fd99ef7f415112152dc7e789ad1ee60dd43ab21a2194e7b17b254ae01d9a384f4ffeb3cd16edc31dd47be1e7bb6991bc4dd0bd57aee85044d3e94a5a7b5645e0ef5c354f9dbaa056ab0a1fb60127ada9f822928887a45615cab7dc3a7e251f324ac2d0183dec39f542067130e8592a084f58cf4d2847974b72d9eff2fbba49787db98f44b092761ce626dd5d61aa5a5714113c3a922b89bb11691351ec8bdb4645b7504f06698e6244ef82a12a79cab08dfdb660d64e597b8ed0fc9fb1a5dc699ef031de0c5618071ef944a8561e488ebdc748d374b81ce8fc3ad3cfb128412763f972560c5a375d4ba293d618df2700f6da98f372bc56ed5a47a858503023eb473cfb4b39e5109423ee84c45d09d381ef104e8114551dc12a482bfe7c67626e76373d23269e65813a9dc6a58762362ee5259fc3d1b58611a382d685cf965e35597243720bac3a3199c068d9e8919fb7d55d87481e63d82acc538b28b86cdb8e07e64530149edd92b390c829f360ffcf162aacb32a6ccdd015f036f342372311f74d8cab291bdc6ee9c5f16da0b185d2f88cb61a23ecbc59c27edadea6ff240276801f92fe5cccee3dfe094e149453f8ad9dfcda511c2499cd1b146429632c7b0f2e4d53cd2743a0ab430741b5ef2deb90dd65651d2277826c17123527d7138df36f00880e904418399cab984fd59708847e32aa6bd98468ffcf990993ba1b688d4e9c3073ba31f21c2c8933299d07cf57d65f8184f125862232207ad36974b6bd973efabd5c009a12136440d1823eaf8d7870fda7fad76efa4280a47dffd8d559bab1cd104a35312c58562ede0e7ba770bf801d4a1733ff771d0910abd13d10e8a385e0ba73f0b3ee7826db3db2048b190d61738c031bb59ccec9d4d0fe83a6722ea2791fe06d1e76e53fbbdaa5402ae21d6df5ca8a5fc04c598eabde1847c53cfba9f09dd895f3626edf6ba577f49c65a2d1cf8bf0f99c5a2ddf3ce723563014547c73a7b0210c297aa7ee091e6909464053d6b4a39abdabe72e4d9ed4f03261ddd2e64c12d8cb92561def2f5db0c46b57a52655eaf8fa86d683cf9d8cdeed3aed4d6eb3104d271bd8b3af0d03d1c2f80dd8b73bf2393bcb1291c1d49737c7e71b724bf6a894e04757dafcfc9f441f2a39d607582369bfbe0a947087dc9b2954596049471194f454723dbd43dd36a86f3a2bf3cbebeeeb480c0fd977ddc52cec70ddffd12e3ee63f1117c2c8a298b1a813fee275bc196e350f445246b1920ff8bfcad76b7be2411c9d3b920ccae6439b0b301954c1897b7ea99c0ce1598443110a00e06da6e654b31cb9ec9cb65e2e66678f8cf038398017d4c2bb9d1707921a8ed24a671c67cb204fdd1dc603286cd067925927d261dde00ac36d8f342d3a07907c72c103a22632dc491f0beb056c149bddc1aa542132915857ac49b7f0b967fd1a0ca341d6755eeb171a32a963d2cdc9d12a0f8fb3c432693e4815b969daf51939d1d0c6eaef470ae7d765fd4cb702ca247bc3d9b073a29df80e23e8059d9abe4c6058b25e48af346f38874ee6a66ff38af5160314e55081a42d6093231b76071f115f255147a4a407e976e09c76300a02154f24e52e39887a2d581839a72a1477c61800b419c2adeceb6a3813e2be4e4233e0f89b7a88edc8a1efcf64c0a0fbe9af917a0500d9a216752a29764e97d1de121a360465adfbc33990c4cfac2abdac6c60777069d0ea1d8ccca2bf153316b1cedca7ce31e2ce715a1cddc1a5af97536cfb0bbf83834c9d5a1f702234cc3c4ba0e59f9f811018ccbb4c82664df950a6b1d2433cb1ecfa89fd08ca62c3d1237219395f5c927438c3a11e7347c703786dc0dd00c8e6722077d033dff0d38b58b47f6c2ea652fac031a41639511dbf24207c5b2bbc06d87bc0a01f18b9d090a64358be049a16dd5db0473f2db601b3ebe0693b6b727d6c8f78e66bb345074ea73a63f3ce760e12f506e28812f868f37c286c1bef65921f3383072bc8665c8c77a6992e647a4d5b1a404f5e3929596f22978d36583c6bce8a9af6632b6d39b504d46a40c7894974b9ca8fd4382597094c2d923a173a6bf4a01814fffcc108c573f4417cd8188fe24a0abc6fe0b24359df5c68f94e1e1521001a81f4ebb8cf03094f1bd905e32915387738e4650aaa42cde8f2fb6562b028b82973f0248b6a3109925b3da67da5ddc13a400aea60759992610ea0df75b383ace15f211b95a561dba9f7799951d687454ff1c7ac44e3a8e5858ffa10f241e7cee96edbd7bf9938d6748f6e681ec33e63fed173e8ab40c68cfd57d839c9be50806e9564706336e78b69d05f7eb75769f4fa0d22801b814b686a3c3f50f0104de8b46b014a5bcc394896894d99bd7c7dec909e72f692a9d1ca1f9ee72114980ef4081f71d5b2271401ca24e2f498277709243bc04d7db02b488713e85b6c26f112088f8ed0ed3133fe8ccab8935a9b7aaa12da7fe512dd51a7d249c89f66883fa6f207d23587b3c71ff48cec4daa7f43246bb0879e1223fff1c340887a8af8582fb1febcf033b2e139d43466c681e6ee95d240b475f17780b668050838df09de367632a2c49ce20f4bf3f4c6e59c1d4bde04b093728a599ac37bb00ba1279f1fde366818ead2b4fc5e48e4127684b5fa18d9cadec3b15e0c9cc2f515cc073a4fad5ab83db0877ddbacccbf17be271763b61ab8958901e2890348fd16120fec36606ec761ab011e85d3b050a8110be92f4233db28115ecf8a079c6d0333c1afc24fcf2233dd5e22b2e37778b5a989ac5efb8ab1df0eeff36e3e78481809864767a0b3610206fb09d1e36e6bfe2f7f6bf53bbe5c38f6f58f0189e17ffa497e43f6fd7876e6569224aa3b49e94379dc02c9f7ee1bec1ab623c51f293502b330e5a6a663190e43cbca8c28f2176f585b90922076b4b228d5008d16030e71d6dc8643db05d1be74d955ff765cb83a5739e5194e4f2eec9f12ed80ce6a9fc2dc98155a51ac93509a5881a2c1ed11ba6976becfb86afefd1f815feaeea556d37ce2936d39fa5fcfe74538189b3890ca2eaaa2fae14c8e40cb2a1b60945476f90fa389fd53281ba5cf797cd1afd1bce20464ff20864a9bd650dd0a7b878b663ae49753ef41fca1f6027483761bfd3f7e58cea9c8ccfcfc285ce24a538b9bb4d2987c1f16fbcd41b0dd080d90f29a0228cc8ea60b8afca19e10871f27f66c03471e1d34d124d29b41853c4f556154b3ddf013e4e2b002815eb23eb3eff523c50cda91802782b2a6337ae489d7dbbc8d1721cd0c93cfb65f8d09c8e7f73443d2553e473d6010ec13da6f541b6f5de65b44694364bcbcd4b76ce485143b9e8d8e46dc0976f7c9bb85977830c4f47939e46826b69134698aa2deb83bb957ee97f91ba7afcf8b05168d519b8649a383470f5b0f4d2834daa2951d6f48df7467d5dc7449612d68713f2605dd9ff08edc656f7fc4bbdb8992f1acba48db87f366dffb0d816d49554a69448cf80ccbe25d858fa1798d009166bc1984ebfb82bfebf0f688d30aeebb37d14af1481ec040e5f3fc8410a159f2c8086600d25a890f38009abb43860ba9a34589cdf0b297a214206576ea0d14956dbf3fe6f88d4dd19474158a7b02c99e0a1571c8746365d57e39b256d1992a98bc1217169c1f35c95afc0e067b03b4abbe5fa5d93f9e9b7244a0761fdc2e39aec5fc2612fb711b5aa4a6d5b68b784d1d785524f3a7c5719ca76697486defaab75c82e141afb230437d716e7dd78128f9028559f385f6c823af069ac586559417a7b4900fe84a875a444f954760820c472ad5bad7ae548714021cd29786f43fcec8e867376fadcc9e8b3f9a45c3bfa73563d21e93a0235017c320af8a95e0c7d291d3c9c27578ae646485b7a1ed5139af0d3d7c5f6a508d153538e6b57959fa40a73da43dada00bb4e6c533baec5b3c7f8656db154da861a0ae0d58e22b8c919d35887890208efed24b6b1a1f150c534e0568d07ae0c64cfcfbe459506e1148134a8ce563729b9187c394a7ab413334842ebf88528c20b2faadcc5404d69b4f3d993fdcd597f55f0478110711695beba88c981051fdb17d2d1a5f2ccd8bc0ee6c1100395ab7349b6ccb5e0d31d999acefbc5b356f6ffec564d99b57fd6341732d58db5dc2d38f885731a1d8e3973110bcde42f958069df5351daf1777169c178e8cb3691ee9f625d4ca6fc4474bbc664af3bf755658c6c919d8d026b868cda00cd1c60674c2cf778c5ef0460db11bbda36d75c5f7b8839573ff6fb9f7d3cec2308fb58d16186f0d78baa3628af8be36b556d6bf92156b0d69d3bf39d35b26212dac931b61e9800ae078be572dadc3e05d8d60f5be8103879cff48e5d965f41a914a0717ddb1948afa1d69a31ca901c44b03048a4e4df2ee72019a07339ee4f8babc90b27cc08c7fe4db28aa98651438e47a76ab05202644470d8cb0e13d0278d6b02a0017ddca1b7317695422a415e86014fbf485ef88051c39abf4258d5a797d6261c04db5133c2cd6e787b6295897852adbcae12f484501ab2d84af99e7f3abfca82f465af219687f76f5f99c03f699bc0a1a3d60133634857edddb4c0d4b0577fa9756a65fb42904460973428772da907bf4dcc94a5efecec88c3fca2c4c8e5098d11e33c0258d4f7262765beda577a392f051cbe06fc8ce06cff3976d37c57b9395c8a5a55a0956433f394cdb96dd78f596fc6c8571ee24b9fba76c583533119ecccff56ee0f668c8916fe5e5c309c36c4ae93db08a2593d011ee57931c7d10b08755f692bd60513a39c1a60b4e5759239d6e809398063635129d428b2c65b406042763c665ef73180404ccb16ddb447b9a1321371f34a0b4ffad55793ab33e113f8c9ada567769b0f7ec0ccc57f12c369416fb6b0edc4dfd08b969febb4c5190eed93e647d3f4278bc5d76b408069af4763acdb71bfc6b9f1b1bc96262205a8e9919ed458c3e53b19c5a22b8d7c8dfc3de843387c18057568c220e851737d2c02cf73f6481553ca7e16db01a317266abf7a7c36fdf5b2adad18dc6a65ad74ae98ca358c7ddbadc07682dcdc674807895f93b9a98ee6e3e744ca3b4acfa66f33c0ea3c2ef1b4480112282228969d20ab92435f1503a628e5d5f6a516adf8255e84569c6c51869e678b8362ac585d04793b121a486cab1f012f26a8b684636bc80336843ac49454220161ff38924d01cf0afaf606387cb8d9dfe6a73dc4f2c877650cd87cb35000130cf92ef8c44fe98bf5c12dc0400de454fb711bb08080c9dc23fa0446218a8d7773a3974e733aa93e3e5a4ddefd1a809c803dd58e3111989f6bad8c7a8c0eaa97bd87775a76fae3aa3cef243d1783410dfb6ada48416fd03e62de3d29335274e3649b63305d9bd8b108d1477b2ab0cee2b1de38577f6c808eefefb9c84fe1d562257b7081260dddc417e54912072920e715d021673ecad10061a17fc61d477cf562bb45458958fa243fe8ed8e25a395c742ce3a6085d3dcd1fea5f18f769bd83075262146b4ce742401d29a0ae2d163cc993623092b1a2f57c1e48b2a17225c2ce627478a66f19555788fd5b70198d3bb6c24c497a440e8accc19b7d685f405fbaf2f0ff005baffd2e4d6b69af6ea42f52ce1695a599f5d9561770ad86f22c2a05315b8dc30b7eefab26c5481350b69b55091471b4a51a8d02ed4306d65c5394730bd2568c440037d44344051557f9dfb7358361a44a97cb279d1a1ed27f96a372ac7291da621a526022b83da7230ff295af1c1ac8b18de00a83dae182ea3db89fa64fc7c689c4b4b34202a2a5113f9f4663396042887eae9eeb3b5aaff000ce726d40433cf839adc2cdc3489296ecc0a21e51be61a1efca2bec36a0e4f7cef007e21456afbc35205ebb62c2c664e4458da9382ccb63604988f1fc78046842640481a8c67a451f14852c65a2aaa2db58fe63980ccd8a237c623ff43826d272f2d3eb6d381fe8804de0cd666cff05c546b2b40c1e304a798d11a7a8f21ef8e24113fc998de2f46262195b17a559ddb1070aea86f506a9463637c0ffca727dcc7d50d24005b2b8b4dd72343e2bea949d7ebb747b62aa2472845593610c779f039f1d9ee929c74724115dff7072416475c33d58dffb526f0f3d677cac4c963e3bdfea94f17be553ca9d5a77866ab63c08003ddcd2efcd019047f27d1d75e54d5deb7f4c019efc0cfdc1c78c0e979b4cfad49bf53eb4c5cca063897e327c28b8c05d29253b37ac9f0bb055722b34f8f0f702f09473fa81c9efbd96c9f96a354ba6785d68fd909a863af4e54a6180d752bcfe28b2b3b6c95a92c42d6c74b8a416e176ce303d0d69d2fdcda713d5a11b90fc8965792ea4c207abbbd82e9c7a0a6b0666121a93a4e03a962aa6e97fd8cc7eefcd7558f8393223cf9201519c4cb6475321bfe8914f0e9950fdd79c463d1b2291a4a727a3b93517245e1c022d76e346190d1a3eb03ee3fa5dced35a104b49d610ff6487b50652ff14f64aca3c5414aa146c986ab8d01267b44d0e3756892bf650475cf1e1093d1eef7e13b88e434ef8d23789c6c0abfbef2f41a52c1d7d0c801b960bc72adbfe5d676938d48f69e1f7be15c3a93c3f8c4f6a33efa33104e7ce5c7d9ccd72bb0407700c40f99ccf0d3c40fe57b33352c19bf77e610dabf8274c0bf62ad7ff9132a43a140a5bb4d6ddcb8b52bfbb1b9c8220ff2d99a5a4d0e75c20a53b693af8e6c52bf9985beee79fbf6856543416e5fb24e30d30cd17a83e95aa764d7df506800ecd354bee5783e4f260be2b74df4dfa3969d80b7f7113b02bf9ba976348578d6c065cc795315a63d79f85d6f68daab9b92de15eaf862670f68ff7d220eb7cd0a81618f98809ddc19be86b022db1365cb58fdc21616e7e57bb737c5bf6ccbdb98579f39394498543fa04b5a6f870103a0f700d541b2b35bda262476a306fb14d92243925b8ba40de2bdcaa5e471075271337ef3c6c5a20e3d3db4e960b2b222e2f90df73d4b7dea17a54164a3cae419d9066c0ec70de1e3e42e38ff14197c094fb451889e976d4a83994150f4ddaafabe87b1d28302dd21c2645ed93c980f5a39494e47ca5cba8b5053aeea41d1491ab66ee51fcdb7cc23601bd59fac1ca73554ad30dd80ff903734c848710d3168a5b1a402a23261225c419859c89189a5de3d8331c2ec7e096853d7dd3b2f34ad37f0d164b8a428bef1bc396f77e1582df734690f33ae3b4f287c1b3a745b0602dd256f2064a9d16eca8d2a821b239ede1bfdd272513886299e91f377c8c9b5f4b93d9fbce08f1f58f42f3399af726cf8b23d7817f7e11ef6f3808d21c2f2b3f201c7bb951b4937cf35de74960e2c9165a61fbd3d289d48843e1fc790a9af2d67babb662a28a7005f9075481250078827f2ee8bbcc664d8ffc1f4b15805fbd60e5c440f9aca6aa037e5b1031238928a7d121e6b808a76ab341db3cf3e40038639601458914aaf238fdd8980ca2369206cbf7e9bf90bd7a0dcfa2d8d9ad9fadebe6037bfb7768f6f06cd59bb60a020baf7d1f9b061c7472ce2ba37a412b0a5cdabf470b41f24fe3ddded928b52050472a6a19ea2e158de1cced203b0dd1fc3c7b0475759ad286bc37544849470883944313244582ce61fcf6b364a2f8cb66f0a74c6257e3ec30481924a4729ed7a45ebffa700e30b4977e826abdffb4f32422a38f34e8bc33c43b9ad3c3d320b8f6e15cc1ec29115d31981a0bd7df4352710a55c4f7945270c5c727bb22b7cc535a8300573d644c6e703e3cdda65b357989c1a09091358484c11c3a6985250a511fd9e12aaafbb535e46adecad91bb7388e715f709b40415fc937ac81a434fa915f99ac0d3bcf7c6b9d1710d3b375a8c023e8af0581d029fbfd3907a7dabff19993b20e9951c7cc44734fa683a3b298385f3fc10b15086691ad44aa58c82f88e507995cda36bfff5f9dd0ef52abe3579c9ad856b39f98cf0fe9cd5526c34f7c23b6c17ccab4db7275d34cffb1aa33128458ddfbd256b35098b5adcc90647fb99c397cfb79572cddd7e5fc3c58268c28c81e5491675d67964d93771152b5a528e04db3d1f377c452dd372c074229b0f69dd4cba6e7d91e45ed303998f34b16818501453421bcd3fddad6b4ad38a0c210b80bce03d0b8beb6188ca4788ef47588799c94f8179a2f4cc33a5950aa083ef9bb2afc1abe6323cc0af63ab2e7f61e459734c1ec4513ce9f48fca217b88d8f5b47716081a8aef7dc0fde92360551287f1b481cfd7b4325671ac7588112649568ba4721deb9a6cb63fc643a98663b0ff2c2a189f2102fdd525ae3fbbe4a9555156ecdac5f3dbdb81a49bee5eaed6fd27bd48a11b1d2b9f753231459421bd99a5b228296259e3b7c98948a7865da605aa2e5fbc6ee03f09749e2bcab58ad6bb4d0f8943346b04fd4f870a713ecdb1b260801ef2468968e6beeb6b917358a8e0a8ff5ebecc8b0f7d10bd172443a99d66802d11722b1e302d6eb70c3d4c20d7f4f7490cac48fcd4d73589f1873f01849d741507de4c5b16cfbd7393eca68ce9a911cafc3b44ea349075543c51af5662402e27b79842237ebe2cbc31fb0cc5974da223e190d587752dad428f513635e7897abe5719bdd703c314907519edd935c652d20625ff369f245b347b63f3a4ee3dcaa0ea8d5a3a793aeb41acdb6431046d93cbfff1b6c319443955dc56047fcbd3c24d25fca968812fc0d79aaa82f988f58ad86d0a12973bb61c6271b96bb3007ca611475ca857970c2a1e7d83c3bc8db1cdd1810ed213793a829ecc94e24bbca7b019f067b556a692af28fc680edca3083f62a1b7dfcdcfc7ff5729429645f7c7d97d982d1d889416ba7cbdd3f069c6d6a50de072ded49b816b5ed6c42dc057c57f82739b8ac3ee94e096d348df61bfa002b0b512e3e8d23538e0369131080710f97c210e35905ed8959fb6d8a3a61b3a3fe04f232a6607c1339ec43300774119bea1f584f683d91ce927aac2527143ae806a76913c81ef377f9d0dba8b8d0f4c228abd50118b17967870541e474e2ee76860e9b09e8bb37078bcd0376d83f5e8a4eb7214bac71d95bde67502120b1296829edf5325a9e90ca795f71c7cb76b3b3ac80f09335164ac9d9604472ba2f71fe0adfec50e56bd5d592a2b40364b371a988149fe1b1acd56cc9fa3a2ce2c4d87b5159708b79b3ac50cb2b85423957c00006f485805b68bbd7ec1d4021048ff0689f392e50363805edfd4c5862e17fd817f7a8a81149a5cf89fd7ed034e3a062729aee1c2218d06973bfafd92775066569307867ce2b5cc01f8436282b47ed9c60e3fda8c08792a099517e4384df86bd72086fb86e908a021064f7c8ca4602c728edb69c342c9e665f6707f30f59b69064672780aa62484797cb565ea93b775b9dd3ca7e97a96a964b902b3a90becd14e989a95e0f2ab92ab4422d992aefbc3e691c0747b6a8dcfe312d8d540f0628b74c8425fc0f6324978f1eae4a979851ccb031b4643fd3dad7d6f12474e9ce69ba87c2b16f67589316f157efc66eea5c6046f41c8af43286a6257f3ea487eb6a518c9724ce908894f9b8bdb461e608fc8e383c5ee4b9f838802df0457950fd0f94f702acf9cbae21d948b2510caceaf20ab12172afc632455913519971a75cf4dac59987c965686a880a32d1f815edbadcae07e07ccee2fb20c035e6bc54179fa81390d584104396971b9e94b335c2e4bcf9c1535af2e84006ea96ef4332f57cb6cc72ff3255a5a0c2e6ebe7c079585893b9bf0a8ed5ec89adc090366cfc038c88f582885e45a915be15273831c2d4b0c746fb424b1c70dcdbc1a6771213ae4d273beead39df26e52ecf5cdaaa1c39b39c1c96f2ba7b1394ee9019a1349034083285b262200998ece8e9d3cdd24e0ff93ee83d118bbd1e77ffc9b214b0bc5a8617885c2dacb3eb44e544dfa089dbba259496604a909b56645f55dd6104388dccfdf003db7105cfc1414f0a68d2cfaebfe7345c9bb913d6d0490ce87fd468dd9ccb5dd922e90088cc87cb2e693baf12a417cfb408c2e960fc808cce5813b2b1628748ec4547d3d237505be528fee28ec6011b152dc5e800fddad30e4e9d592acf5fc3fc8444e845a1bebe69504f2d8bd08af66ddea7b7e7249f3f340243c336580fc4438cacb6a464b90144717c4982f77ece35c3b46f40416777c9ab72cb3714d1d10903125b447e0f4b37ae7abeb1604f43cd06de4aee7a0c17576f155077218ca1902da4a3f04100318ed343da3f601cbd1b07d88fa5f9aeeb8522da44d7caf31b7d1a9e3695799e2a65e00fe06f8e76504f9e9ca4ba55615b7a16a1c3883993db15c3c5fb983eeb9bd765c1e9ab022d2cc67e9f26a618206a341b408996fef706a67ca3311bf9b3370a5893853ad3d0611f47b8d575ec871a571dd4d6d93e9b52cc257cc89440ef25a0bdc12c5644c97698fc62f5e947a4d66fb8a06b5d3951d9c96d2295ef03350b50d711c2e5f342453446edf1549fca246517e2a45f0b1e69a3f41e177a4c92afb116d4053da42a965c7b4920b5be4fa15f2d981651ea12b2cbcc4861b60e08b8dccaafce863dcfbc74305569579032df88b6a97aad7d0c9358f4e48ae4f1f047d8ba563d03520d6e7550378ecd7c2b2ccb77811933ec9b2e8817fa2f3db916fe5bfd6d74a2dd3a8761a72cdbecfc5149ae2a941c3b6d56f606e713b2daaaa7a14f9497ef72a991f3971f058c3a14d5c461348a81d1e7444ef3a72fe484111974582334d7ebdefda2b047d9caf107e672d00e77a30f1c53b877c7e1e7f86502a919f05c07717701a148970edb5604b31f3ecb09bb59d3a70db19f21d1113ffa04648ed2833418953ac652aaff3ccb8f338bec3fd9a6d0b91405441f7d6d2f1cb96fc372e0b9980c146657dc7c4cc8ba284cfebd2d0039e52f0aa42b369818dc7ebc2fab5e8e90f0e16033c752c63abaa5bbb2e321dbb01419095207471001c13aad040088d95cc164da2295a24c0229918bed4095981c489940da529abfcc604a3f02b4c02bf842154b1e4f66ac1af64f9608b7bef976d1b84a27b8a5a21d64653d5bbec9f875570262bea5572319702345fd0d237fac9c992e4b05ac01a8aeac990f9dc21508523d096a18807c023031404eb9f5e2dd4624351b5485a662975143e1e5c547c63a76ba8785028e579827251457ba29c921c531f598ae4081f0d5bc0a4960710fc6fea4e84ff2d06eb64c52c8d7c94882342260c45d97ad625bc2d565fd5adf096ac47c37f7458fe89d9de1bfe64c0d54f027277a9fa4b90dc64f2cd2a4fe98d2fe9753955fadf78734544efcd52bc3ce7b52ea19a92c5702c99214581e6e95a0b32c2271a09d817b1a7c6fe9e2d6e7a76ebd3feffe573003b4272ed220ea53cd992f15a897a4d07c3253a5c5e0194c626968520f1590b5b50b9551f6ae98da84e8e00011c8dbf6792f2e19712e506726b144bac36068dd03603a30bf40dcb2070d7aa3683ba4d8ee08cc1fac47c7cced29660f260ecf7f2fefc33a28a6877ec0bc82c2688dd874ce62bf8e8f47caf21d51f8d0cd8774f9cf581452db4c0fa943b99b5d9c079ac52054eb57494d6803014db18cd2ca3c7cf7ab66cfa6b23d4617173849c3e06b3d20a8941fc3c54a065aea019acd1f978f660dfec1302337a3918097efd29502987626b17810e9cb80150a0919313e2d9d7559d14f88477de5445f5c2e60f24ded718898a0be8a2fc4e79b356f9cd902e769bc0f5ff7b8cb0a37e7e403ac0e68af95c9bbfe62064b89e8ccfee2728708999b9380bcbfa5a900f18fe962baa1793f3a39c1a796431dde72b75ed21d00b60ad91873ebd74099dd8a69b6f3844bcee45acbb4cbd549c92c4e324a129b3bd136a25c22a27460ea0e0b5daf56f467fa6df219e35c1a784eddb2970a31fab9363e717e7ad9e77867912db596f76dacef5774dc9ec3fbd9b532abe88f1ac4af5c6c85d0ed5dc8d7c951b999fe5f2ef4f4a47d66baa8a214d773da8cbf21d974a86f52fffb69712210b36bed0bf054a53773b03eb61c0581a9ee1aa6050b387133294f46ef0430cc4aa6acb5c34b71c3cba5414f8427cdd48ee447ca6027857d75784f3994dd75985c4a60a699dabbd33d2de59830b054750173a8b23fd74d729b3fefa4cf12613044354e2102596bfc18bf3e1c8b856f555a0e3bc8550d176cf23d15c3494902e1e6e9dea729e6ebf8a1feb76de796c66039a8d57a56292e77c2c695a52ebaf801a0d14a46c0baf4f5ccec297db081318be7cacc61c00864d9c1c9a97fd3eaf6173e3e143234f19db22170b469b5f70b02ab49dcd287f061c41c4c6be8b416181e3c9a9c85daaad6374ae9a1738beedfdcdac4fe4a4b11be3287f1754fc791d269c9d358945eed669e791b30fdaea9e9f0b76df8715047af6d54948ad5060da47289105c1e73d2d92dc61493c0f9c0f10c3fdf2c8131166295aaaf9491d8f08cad8d5f633d1bf23fd7b8bc0af4041afcd3b77d3f3a0c57def36655fa8446de9aa80e84136736f0d84bc4ae5fd90202d584360d944fd4d3fb45a89fde3430a4f3bb06e77c3b266b855c810633767eb7f32b32f8f05b5fbfc91fe2659ac9ee214999e324aa0c58c075e2b5ad08875706ddca2ee47fcd3d5234b4d9068c9a5e75d9d1d6aa03487420ce040e163e69c7dc347f03f443322947a5ab03b1e28c1456a493009c78983866bd796c658a7e8c82962f06f850f5217e787a05dcc784727e637cb5d73f94f4b44bc739e6d4e82805f784ce4db2a94077455721bad92359213e500cde8a79f18c091c2fa3453ed008973c3cc8172a1b33bb391cd26b3d239fbceca6ac8ce23a0d9b958c298141f51d4e4d137a90acfb6b5f234dc5549173d1434c513c88eedb4880ef43ab1c2a4f8ac8e0d94dbe45f8f911a0db6c37e46fe5dcf74f9cb923bd47c969e4a864908092c2c33101b01d716e417517a375f2e033c3968667dc841529d9f53cfcb719aece928dd2d370530bdac9d760386342e22935090a9eb247809cd5183f0a6db4ab02eecf273b4f19667baa7be7c306e554e52d119ff11b1a25eed063d118c220bef7838e6576e5b635a04a44cfd453a04f0243c4baaa030e69df6bc6280eff15cf43a48263082dcc476aef85bfe6bcf6beddd52530c819c5e15962756715ee1d258fdcb77a567ceb63973d8c06716581d44b5a7c76fcf6bd31e0567ec31229a221b06cf48889d090b5ad333c6146ea82a4cada5c361a45395d1b2228c0a7a7b09aa06250d66cb363c071f1cd1a7f2bffb231ef053c19b7ae9b9b72737dd68aa8e054b976b7a87053f94d556015251e9789cef9a890fa3b3877b2d29cccab8ef576f7ad8e4671220f348d2de2776680ba235c717f16ec0eea432dd9f6a77db1c9b33edecd77964d6ba42e9b923707673973f4bef634f4178b4fe82cc3819a53ed4c78333bf114234079b125c66d262325a054ce07f3e4d0679905f1dc0c0a5cbda0c629a2967e37aa99d85ba97db193aefc4576e4fa15742c5737a92b1bc794fc8f2529089ba43282c5684716bb52395eb8ce0e9c8c530f883c6aa13753b309d64a4eacc9decc047c8846eae8b22ab2f650569c189510623df021c682aa95d30f013961677dbcccbd70945e4224b1b7601d07d28db4106a47e4806383c0893f2eb5e07e8e5736d90d39de0ab312548e6b36456f1566ce9d09307bdcfb322d338c63612adacac1290d3a47fe75ba329ce51bcf663761154fa8b79f0919a515011c9058be306560903c136bd6dd25e348e481ab202f0d9213c8129fa605d2afef8feac704211e6d65ee8cb209c4791572427fdf74b6f75ee43fff1c75a7eac99f35b8260b7c0c9b3db5d5715a67a10f5bb7f93d513eac7d3dfa23f5a0797052087701595f82f3cfd8b18281a86beaa87a9d157dfd8cd7bc05dd9fb3a2afb0ef3b77a08aedcdc3d48171d5fb89126a188f362c4478b619c796d417af1e488acb71c88a1929886b2defcf6269a366d5ff0405241eef536a5b2cc6be52de00b32c522cded6c73071d7453d98cd41b64d212112e1ecb98d4359799133400c98482d6e4ea9ab5c0aefa111bf40c9eb139830334bc37c85ddc043d4924bca66ad545b170e7dafaf0c2905a5dce1aeecde601ff7598e8d5f2704bb00d8d3e1769314aa4e0dd598267a9ba117fd870fef4439f8eca9acae9771fe8e80e61e84a11960d6944b8e9155b03420508fff6db13fbb3916196324d037d343b80ce3c7d15b152b049a60f16c9ea2ca194897ef9cd8a6042751d06d3966122e022f45a0fb2c10e9fb9f86c3d2fc69281da377ee27be12a85fac288701ff311842a72a41fe3f51e24c9698f732b2ef2545edd788a35bfdc2a0d540230ccf8266d23ac1ca6523d59a79c964ee067e4027b5b672617067f2885264e883a04343b1b89ae1b02c60efb0a118954ec088b298ba6d04512e76ef5a62b1926897ce4a73e52b1ad405f4906402f068f3cfc8feb6e9236dcba67c3d119dfe0686eb350bfc7e6406f7fa6cbb5593c069ebc8d8f4fe18187693684c6389ea9045082f3793716c2ebf31d38e32124789dae5a99e456f434bc8c437ef04e783a2d344956c972fbf47f5d612a5d3337d179c22c754341194f2460b6995eb2ad8514452078d1992f4ce622400612fe54fce7fe59475027e2c0f5ca9ffb45e9fa2f36e68439c4eb1526d5804132c9da3cf06dd3be42594febd1da4c5ff4c35a8de1ead04361079c6e11f489f97cbc70726bfa23b528deaba76e792eeb28eb8ac5b6f31604cee561560b4b3954d0bcc15be9cfd24ed3dbd743e5590036a95acbb40f8f889dfee7e6c7979b0823d815d54c753b0c1c650ec35dac4a1ddef9bb15f0341dfe1cb816b12dca1d4d565a924b8109fd7f0f96b27ecaa4c15dd4373f1182e7ab2e42fbbb28e0242a16595f00bf1470254fc63a129552432ddfc4cb39eef355be33f1358ba1d910d7b475d574a275b483f742a85b72709210b07e8ceccc4ea41cfed196943d7bba965a21f4c98cec7822349563343132de99fa650215cd3e17c3b6f90bf63d217659ca633ff0c0204ff4ee6e23ada0ae78472548dd7430a67d525ae12063b3748a823ca7c0443ecb2fef2b611b135258cf475b33f6a8b684ff2a4f894002a40ea3006b88f273ba8cdbc3611a203bc7d5a2a1aa7a06e5ebd93df95e3b447bc7d5460b2fd895a98c767d68af07f264c9de62f03ed05e4846f3acdbda2e14d22fd940ca4bc18cf1159ebc1a8e076ad455b588969c55b76dafe23afbaa400ec9f1d6d08866998e0d50101f8f68e282c019b823354749e2025ca081552ac996cf6d7766a44cf8c47f776fdfb3ff5be818f000ff35e82bd78f05decd34c5a9090e2bba6c1f9d380c289b9b2d617251d548a33acb90e2c2a9270ebbaa177d85eb814571abce3d5e57193334a0061744f10cdcb7302d7300e19c3c03b395a4365921a66219c0f88a22a7743618aa7f8119184f9b617b9a4d95099a53ef2dc136de711a944adce705fa79bcf206d3b740a0bd6a6f7b0ab77edd9438fd40fc9eb08cae8b96cc562e3de30b1c25a9ec04eda7b04f7a8980b98ec0f91640984ebbf7f69a54ef390b2f667a4a0449fe32ac10c6123d3f156d03ce4f58cd577b1e24f70d4866a9f32905b95d58cb91854124f0d37ff42377925bdddcad9960af6e73ccf20e9db07b7ff8bdee60a61da8ad88d8c8e29ce92f15e79a51cdd187c5b7383ce3a635fc68a2a2863644514904366147a861409b12d9f30b864e130dd91359037e4ed9a62f913ac97ba9bdc07238021e7b7bf10b50e39b851e136dc8ba6d912a81272d8913e314ede5156b5f8f6c0d2c2e8daad165a6f59baaef951acd12b5688f3272a01e0d88d7011e0581d0af5764b4eae064ad21929edf7704a1df3c9f92807d54e9128b97ff3963abe7b3cd0249c9adb827a3629321649d62c5c95355c9b7aacb91b19c89f4ace768411f7f50b6ef828b30a8736a84debd47ac00fe2319aaa833b1dafcdf5f094f6d4641160f795e6ec09ca8754cf1cc80341472ecb412c746c771d52a0e3083a8fa191faf7498b960a5f9a70c38091c80c3cb2da726f84e5d4dac2ab1d752d87ee8e2180d4ca4c450c56c83e2d3021ddcca00b2e43e4e24074b343cce4076cfa0ddc23158dea97fbd58e52300f897c9e14a5cc2d63338bfffa1050d939b225d9789616c1e521d25593a54f1c4dd8f7eb50cd6aef95b341c9fb1e3627e50f25851d64129208d1a3d0f090c44aa5a1bb0588ba2aa4f8688384acee7e2dbc16154754740bc9b70645a5cd5bbe4bcec1c0622352145748b47bcc2ebfe5d99553afb9f2c7dd149248ede0107301b1f7e47392204a2cfc378899de74e401f2995c51fed510c7bceee24633eabd4bac8971dce8654004c8d622a2c4246e94b1c332b8a16cf5e88d00074ab25dba1e026785d44e5600673a3041f1e0c850b66d857b3059ca349c372b45da631720b2db9d4c67f2e908210672da9013eb3290006e711d132d8c3ab3ea97d208fef992b9051b9ca2770f04a38b596ecf50835bb1154ec48e0825601371035d13a2e179843c3da880702d20e259abb503b8cd63c9176105aca1cc0f1d9487a8f1b8c0a7dd55a7b8f4d9e9884ea21be0afd699bbccd6ac9c8643aabffc90e4d4df0c0c7da6d59be43ea956944301da9423ac7131a820083fa73ede511469ec4716c916c1d713d5ae01b5e00fe9f9d15c4f54b56a0e51dddb1301dc641f5beb7e890b1cb872f7398c9aa60faabb75bd48c1a5e54cbe4a23ff3e6768700dbcb8a63e7b30f1a1ebedb241c4bb7fdc00f8e34bc713ed3fc5adf85432f4682add439ec068a25416f8b089bb0dc5a48501ac4f31ae64ffe7c6fece86bd3d9ff2b626816e8bf84d7d7ba9b0635f69fe9cb35b02532f1dc6907e919e4fe5d2326a3cee2189f297197113de30df0c5fa924b3d8fd110bbee6909377b7753f76d1383b1d50dc1cd423c21f4cc7f6b5a6c28b3b306f6be52446aefa0ffdab203d74cad29d835c8bc14790ba50a0099f8b59c796b7ac99219b62061b0d4a8b90532177108e09d82a62a7de2456e04b9b2a62e1ef9e707aed63110613aa4c08a4c84f482da70b9a72409419f3d9e0e99f4a80977bec12b848c7ab6fb68f87ecaddfe34d2ad35146567af7491e4f9bb0b598b34206ddc7d84d6bef46260dca3864e3756068d3b3bc1444f7a1fd1e1a57e0db9a3d11327d705ac6906d5dd2cf7a6886732d2094db815374ec69194f9c187a2fce60d0bb1dd510b23c0dc266ab8b2a3c16dd77797df70faf1a3a75b9be887c478f3d4cca90a186302daf0865f264e4447de48bc06c4a2487f0db64a1e22289e131bd18f2d3c7265729e6b6902e5adeb90386d214c38766c07217818f4703a92259e796","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
