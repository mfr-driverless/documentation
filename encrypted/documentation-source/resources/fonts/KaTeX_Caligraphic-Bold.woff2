<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c303c67958833846ffd5e14c8433b9cc633b6a8a06b9aa496c05b9c680c52cca6eb3e448b16ce5123f3a77acd420a04f9382b14446a47d2a68517ec89f62c89c414847c6308ee8104b75c4a8e257a3176e627941c6fade5b78a7cf5bba43a76d4054d5e0220e4723d40f82f7eb46bd87482ebc25a10a319591ff4cd18316c288b7a5e8581d5379dbdd8cd52e45dd151555b38f9ee07b83a4a14e12c43ea66f141de5fc1ef384f6d0957fb188a07348160cb369f06a259e769a8dbe0161c690bbb485fa38b43f1c21d183a1e49ac93bb1dd422823cafc5f93c242cb98e396e8e79db6ab89d386699c81f3fd1e6b84fd210cc9d4eb4b3974adf5f340bfc52993ffdf1c72da624de24d9fc319de1982f20133fe487b529d871dc3e436ef0cf26c935d0bb56f9f760e791a949fc7618f2c39890ce1ab4e5815a06fdf2cc803912876c0925cf83b8c0c0204beeb54eed9abc85234e83b70dd35af7ca3e83706633e5eb67891ebac9621e97847e4d8151a59e7263ea326dce24d0415cf25f99a5693c0d3cdcd436730c78d4d4f34316b7fcc340da329c7a057eed3e348f1cf83b9c22d886496b41a3d4f05ebaa6cf0282a5a64236f5fbc2fad09d870d926ff9f005d0ecfe7d298ddf4ffa0908638f9210b840087163a374cdf830dc1b16ebe914c14fba8ea5d474b00cc6a08abe7d44f7db1770313d52f16fb80a479ce21990e8426942d31fe1bf1879bfacef81f321c74f5ebf8ea029e9051f5034c8810db74950ead3b938fbe6c29e0ff89daf539a6526841780c66cbddb24f7697ee04c61c212b3ce6a3988cb3a935ee8ed0c5cc664e6f810c256b2a1d1bad2ce466fd8dce31a49419ed9935d2caecde07afa781358b7c5525ba01a518fee60116f8849ef0eea0beebf145d98cedf5c2bbadbf664029a32ff1a81d0fd21c01af831434e22d12fa8b89fb29be41a4235de712caf8af16c7432ceef5e2433d4806705e7cbe193a99d280528d0874df153992138e557d47ea650f7a0ce64655c6d1986c1c253e0e7e5aac2df9354680ef93281b40323ed50795702a7072eb78b6113ce1fe8dcfc401cb6ec624f9fe1d2a25e56d7a75c61ee11c3312b4f6800da5d3d32f8f0a14a140d325585cf97d3136634cd4a36387c4d3425dcfc5cdc4990abffa3483e2e32abc2b7a7b536aedf01af25903a571b5cae5873df1936814317a194d6d2a85d0155931f80f15816dcedd0603d1427ada82d9e5b148d350345547e030d27f584d30b87ed45de58b8cf757d704f789821446a1a44502001045cb00b521e52188e7cf039bf20879a3caefbd7a549df5ede989d4d8fb804a327a584ad4847d184be6c0da846c43d06cf386dd2fb189bfd174a6f30ff69e8e0aa0f2a2073a3f8329a20bffd3f1c620af88d6f7ca92e296effd3b9edbac3fb7789c582b5b2e6690c21a5b874aa2d9f0a43af1df78a0cc7c1b3c938b264c565fe90d64c1f7837a2f055a77bfc34dc4e0bd85a6b01d5fcc2637382c94c0148970cb88f580e7d6181d826c1936f12daa7ff67d1d223b74840bbf99e423d84a1d1261b382f248114ddbf118d2d91ee8b81c555591d5621123b2b934a17e566a8ad0ae2d35587ea1753065efe94f3951d5943e8a769ead402a45c993c51501cc1d2351fa4ac6aa5fb8d673dfb65da76076c6621c943e2d6d938dce10d8dbb247cc8dde00689daf98a165b72a6a6d14f35bf0bf0a12974e38e0477d548b577dddfcd888aaf2b317cd8f73ef9fd9e0000702eadfd0f351f420b668270b04b099f7cc16bb6e28cf8bc1ace12658e9df65eeb304f6505a283a9e432cd2d988dd35971505169a4caecc9e48edf54739a9cc8315d33a2bbe3459b5548a8414f391e872d229d75cd80d64ae110ca1cc30d3bed4368aa2692850a49efd5ae4856580125e20e78a42c3e30a75c1572b7238b48382164761b70c59dc42e6ea6d32c1f8ba2e6dd17fab83eeacc78707f8db286526272ab214bcf02480772674297d21847bfc80d209c05841ae9e1adb2f6da510c1f845d82b350228b94907551f12440c1f77adbc052e5d65e6beaa9a4c5552facbcdb215da6cfca5e75b36358d262a46ec15671411fd8201c6f079c3a67cc537cfe754c1e1d3a9021ec3ed6cdfc11980f3823d2701319373e1f370bc873d4309d763963e0b7c1400178c3143056d12e57487ff7866b7ecf948a0e7b01451d5bc33e7ad80fa18f5079ef0328940dd49281e547e8f93fc926bc18a33fecff05e98b35f75fa6450a81ceda00fd922d4e25e8532aea171247e10ebbe0d2262440576351538ed1f6f2ae706ea086ceaa7e68cc97e0123aa71913eac34b1dcf8f84b46f7406f1a04e8b05ff21ccd51cbd9d99949d3d6d8a26d88455ec86c771fc226002d67b8f0de35e756c04bdb1376ade9993a4b6b138a0d4ed71931714bbff1d224d54b7f31b8decbf2859186a74e984dab58785f171ca71fb97d33672fab6585ca41391539e4800ef70dd2dfcae90df7a181e0c3574f8e0ff27cceeaabd529fe98fe870a77a4674f727ee23f2c7a57b4e02f1b3c339b85f28241c164d85275e360cb14145e6fc750cf3d4d5decd7355921d9768e59b81fc1c9825e9288128923d629da7e6e7fc1dab732cb36090082ea4cde39c243bebf0ba2107f23729858af38b1d63405678798c2edc0cc2dd25622f82c4fc973a386cc7649f11712192a1bd0b0443254f4a87ab19bb6e1721d286c664fab8b1404e88b66155d3503243ba92b93e91cb6ace5ea3fb2da900a8719427d2a48fb3035209a8e6915bbdaedfe43e381887de2933b9870929e6dc7ac5e3f41088d64648e65f2831d15b5bbe3f6f54f3b521d12de2ebcf5ca337b523034c879ff782202f5a1fc56d27c9c344d43fc10bb2a8aefa87a2575d9471d3b29c208b917f90c7d47c917d1793aa4c75130413cc5bd06ccab9e172f1b83d43012621620436d64f3699b0fd8d92b54aeeef87c3e0c544fac4832ce9d9297bf6e9639df3f4e5e742b31e4e76cc265c7a5456773b827d61af3083c8bc8f9d33c54b8c068c80c281f879763abbf6f60a6902c84c02b0900d23cf95a18c9097a850016d4e204a02d14dd027f8847b26390200ce3aff96576e91ac72b8713d94bf873cdddc26ee9c200446b1e3b0f164c7fd7b857f83a9e00c1f8d79e3e94d4fc1261d2262270c843ab26f3836976d7ce6496186dfcc51704c9aaa924f850dfa68147977d9d7a7720a2a174f6599cb7d8628652c8ed0f16f6fc3a295e317a9e646f4f9a14c0075f562f5d6d7defbd60d21382b4ff8a38d0f91ae92e7c0fd84c5d36c26fd68f7158736b46ecb2da7e820a936d14fe3c8f3d7450415e5c403be1136e53fa93756ec4e21bf9b438a5895e922036cf5678104648e63cc1192f19856729f7a9f9f32e26ae8b37476bc2a90c389e84f824c9b14de6f1db241616e8da6743b7b182a05bdd7d0c8b181bcbdbe0a12f2114ada91640567ddf292a6bc2dcf920875a5f01495512c2f237aad2a6aae566c9b07d54401d62dd06a8444be4687df8651f3751b69bc8cd9c417e56c117ccc0135d51feb838ff70459054940e3f8f774029d7e90a3afd7f130ccea719579a45c2906c749d475eb7c479a92808485fb670bde9835545f1c13d6d1287d0601683505fcf228e214cfc26b0a54898bc05ab662691428f72152029af21745682fa89bc5b8b9e9c0b4cfdffbea6fa0f7062ce965d1cd53851723b8af0b7d3a9143442230e7a57ea7706873a4097107d010ba4deb602cdcc1daa9950ae0919d8066f11047bc664e53932a6feaa92329abc86248f6702ad550952e26a60210e85eaeb905e8831aaabe11f0e5294c724ab48e5f5b423167782fade140ea366ed28a99eb6d19bca5ce5d66b41696eefd8f0c1b2682adb357a927b83968311542e8f21e89b7e2c61777a43b289a5dd7b4d21fb1ce287e0d5039d4ab1da6219ae8af535a26f79797d407a6c1efc4a7c6727eb77caa1ebcefb7e7c9301497665755ebf5c3cc76860354430c0d67d8b7d2d9b62db04ed752e2c4081ad039853ac303e15d3968721ad2ea348b6870be809cc9a5670d3a0d6dbec4ec3d766c6f7a13c88eabe83e6cf4684c19845fb58425c37e1d162558fc7f380fd5f83ecbdb3445041e8f9ce672273e77795e8516d9b5e28d6561bc65c1b67a982c7fe61f5eaf5850a16f53cd5cd3f2401f130bbcd27905cc499cfb3bd59fdf7ac3ce8c83d8192bc02322203d1f3c7d1cf39abb545ceec1f7e0763e511733dfc144f037fa55b8bc1664e747889eea084515197b2c71afa2414ad709423f36112d3650f60f13f94524a57f26c9d88544d79e2f7c23c95e3a8edcee1ebfc37fae057a00eaf309cd862addb786e047382c2ebe0e0d6a4f86006a22b95450403f3657b62681b94135357c32b5e34e38f3862be03fe38d0eca877d2e6ec3c4e83edf21d4fd9975105b32dbf4d255479ec4614e582ffb961cc3c780f807d0388394e1652ce5997df1e14ffc7cb87355c4b1faaa3f5418025e626b22df4f85a12588982dc5bf02ac4dfc3f231ea1096534e705394c1cfafe118e8ce55cf83ba16e469b73b65383f5df04f3c41c3a4eb2e683588e8290b33109e1047cac196651e2be6a129457804cad2fddf1c967bcb3e2b6dc23ef2d5f7eddc929f9e17d452e0b51e0a0eb783446fdc97a113e7f14d244b761e0fa81f14b4dd134d491f90ababa2ffd85a2ebfd4e1b91e4cb738d15ef56ae436282898335dbd2b1eb67a5222cc292b8de4b2d6b069e49c29d3fbd1befbf1c07df083e9fc3fc35d8695bcd2818b95ef6cdb8aba3c034b53d969e7a16564870f7baaa98182d6f4a7b695070391974bb0ae8cbfce0de796e388d4adc664fcc2f62909759e6c3babd1d08feec5a191d774c76bdde9a26be7f866bc2ea02738de83ed7b03706c73a26278181b362966f8d33d66ee9f06588bb63546085cd627cfe40f659badd8235058524275948ed9d5b3a47d88ad1021d092bda683f6ccec3121027c9959fa4d38b004b9d946b02ef390f441b9acfe1089c6a7d8b4af61c1db5f25593e2f5bedaa5e267687d4e182f31cf453b3662f798b7f50300fc794a30ccc5f7a4f17f5fd93439adae4372aa6ffb75c194418c1c8456a4a47f0412cf53270b6505ca7e7c2724346a39929fd19ad94d30c355e4969f2537970ba00f8a0fc77c11312b8f624a55209b9bb215967e7fa0850e612c4fd88bb6951a2bdaa26651de85784e69cbca2ce5c37087b18cab605cc7ea6b00d48405cbbb3da52ac9cf5f0fbdbd371fd21df1fd8d4157af7860764f8db93a11da3d73998313421d127f35a40b1cf09030684dbe0435e03b211dd2435f7c3b08c388575251fc8e836ab7b2b1678f72e4874aada35c3d124d5d8b3fbc0ff673976b98267c700bee82390e02b2170b81b5cbfc6efc985af8ee319111c20b611b1f74510c89bb6645009256a513a5c60bdb5ac719b7bb9b45e73641eafed680d00d7b56573ea6626328ad567a047f291d1d50753f597c5f4f841e85d4625487fc98dfe71a474b66717ced6db27f714a9cfc47c359d5ad9fdabe9d34999c3a11cf0d654901f149b3066da6552904ea94c9584c4c74b3cd8e673a8785639f13e838a871a2db3d8f3ed7bed43c7690c43a52f0960e59396926e1999be6ddd622b5788ce09735ef0bcf791f36a5662cae4c360749ef731e6fbe41f81dc95108280f11d5489df58e2074c5c496afc64cf11538ca01791d765598a8c60aed2e1dabbb98ac01d1f331b11b7c36340c7f276c86dfcf0bbabed3dbadfd597db19454d6e6749a13a3952d18fe51a2b23cce8478ae51e023d3fe4caaca5524da2d91debd94f40ce581f4e13f45cc0034272a041ba6ab83c1b9a0f023d87290d4bf5f01ff68e7f78cf595e4dadd47ec832b2699e95acf21d32994d6b88bc55e7a4029bb0d125025664b93c4645d205144e213b700f6c66a84d7670cabbeb7e6a668d054bdb9075dd1ad96fca4d6eb46ce778077e52af610611271e75244f073ae427666423eacd8a042809359fbba10c624c044081270d0d2c1fe64e2fbfa472b7511accb929a7477fc42ca151308fbfea3a041f3056ebb7af88ba1ca2c41851f7ccac88f2ce1b5100a52fc2864ebcd43255fdd76f0d7984cdf5838666edd65c478aa058c3ea8782996ca686cf72f04b0541e011688e8f86c56283bf7b7f75e15fe76496d00f8089c96ed5f6f612d9b17679ee9930791c2b7984cbddfb4bcaf0757e87e1134454debf96e5c3a3b2315db26aae26a3b59f783684d90ed75c3c24fd3319e07faceaeaec49e67aa8cfe3ff4997a8532508c0a17240c83f5fc9a66bcfee6b8eec2edddc78650efb63812695fadab5e29b3a90f90efad284488b4704303314527ac3a09f1db0e52b7c273346576cc8db9205bdf543f1be8e83f45e9658774ec507b049469369472faea94c3d77f83d26357ab9d8481df1b93f3f5d804ffe8e818fa8ac2cf994c071a62d7d8e7ab0fcb9b88e23a538182faa52fc2f4bab230f90a3479664961d49cca720bfe230aec20f061db24ed92eef29558421ce7548c180166cfbfcc7e8aa0bec58358716213057cec233647423c939fb690df109c6d15d8c68ca9145cdadbdda7dba161c700379d9524de12aca91a2c9ad0624aa2e2813e219d597d49318f3e6b171bbfd68bf2d7c7b11bc00856cc8ed9ec4d2eb1bf2701e3480177e28f6296f593b6254eaad8a16b63debdc98d9c9a8fdaf84f35f341660c5baab0227ca590fbe21d403bb3026dde5d1edf17ce7ccd767ca5bcea0137cbf0c5e791d17c14a845cea9b666c541a647f1f623e6234ba0adfa20bc0b3dd71ba0a4f1b16d8e0970eac5fed52051358d9f87132c4010923f19579a5fc68c936a2997249906b11eb7623cb1c7e71c390cdc2cde44b9e6d01f30258ab5954731fa4b6be756adadda6b48ee44d58b4fe11f0920a291b43c77596decdfb84abf0e3c36122339c4206ca45fcea2fadfbef21160bc4e1d9d4eda4e5dae1bb8c53a5bc2ee30621b2134da6844ac084573757b191168731df1360f5f5cfde67a4a9bd69e93a5a083e1c6c9d89ab37a45f4b530051f1a9d3ec661124f69f115584c0202b708db78f5b8afa8a08695d8941650b0b6a6b338284f002b7882badb51fb2ec1ea1146256ae7f348fcbc922a76091270cd92fea095b0f8431675d7f81d2b8ebc924ee710f4f0d9bf6ba29f00428f7ceaf3cd30589b224eac27a57ae74d6860dc84fa64384dce5abaceff84e64e440e61c77c3e53a7fa2675e884bdd767b50a4883f98db1e6b4060a2d38be976a371423028ae40e15ac1a846a742aaa913484603de3b73ae406e78b28623f060acc4b6e7911f71d964f71bdd33136802427634ea1d515f7b2b89a49c49345d5c373a87a882b10a52f1a203c4003dbc42a2fdddb3009d8a2ccc43efe44a3e3714f5b7f372e7e9107b2d644aef5cb787514584c421b320f59b7722cb385f0270e4132cac0eed06095c1666306a52888200e78e17d8faabea56a2410ef54f50ede49bb7c6984561706a2467606cba3daa10eae1bd283c2408f509da462438b319dce6502e566f342a8890141f026fb75657d7160d195ecf8be88ea0a009dafc320326a4dd1832a8c48a709724dd3900b10bd50b2d832f50c40a541f41dce28c93e36e47b1f48e79bbb1628928fc4eae9f9575b25dcf5bba9d561b4dc38f401d979814a38711f04020c5cdea0f6b96989bf943ef12b2895189da9ec6b5092f8cd65fcc728127f443d395b980e4b6a5434beef52a9a57faaed8b4a7fb925e05517df40daf252ae2a1b1306043de5631d0b2f197dbe1b1eae2d18b46b9b83afda79e703ee53cebacabf46fb7af130d5edb3b958ea52e030ad0b605f8abf735c523f49b2b579ff0647e6999c240a714a222175c5e78dbeeb79c02f3990881fb5c95ae4abaec3142c664da09e8f94af0c4be3546798584b6c8cfa8b2b5d2ff76028cb61189c845ab3169986ae955762c8d7b1bd2ce5f9ce33d98eb9b375cbe656418eaa35995fe787b216f3e4b5aebcd840a11ce6d492edc33ed0f79764f46c53c9b80fbfdbc3d9dfc00671010203f67c3f7de76dda6aa532ec4682a5f9295b913ca67e4774f6feffcfd6b5c07fbf7870f4e505eca84e5ba29e733a3e4cf365c155a88ee745432865868cee1ed14daa91faca782f464a3c5be47053992ea944df55b63c378220d6f26d76f4e8cb5db3dcf8f5c4539cfbb376b3e4d4fa60dcdf839293c31cdde4115d13b5c9d697dd95fcc553446c26dcbe1759c5a95d9acafe851128367a7fce804218fe73a046b2ebc26278e5a81e76d31a4ffd60eb4ad5cfea6c6003c7317b989180d9e90a98da769a93fdcc0d61224d318d227a5f474af6a184b924c9e733050f051fb29814c8ee03ab16243269b3a5cc474ea7a7b7224de1ed010d776e82846b89c35c69cf5ae079115d3ce6bef480e7da050ab01911cc1309b0bf79b98a42189daa83d1723358fe470c31a98f955b1ed814daac80fb926e1ec45aeac103affd4b876d10b8ee826f7997a9b529cf403fe381780e4a5c3eb482da947f8a18e1f53732ac5435a4873b459ef0d1c0827317944299f607500751aa64b6adb2a1b729ae85c7e75eb35e578534a421baf682a6bc2e44b7c1c3ec2f5130e1ac8851550d484b7862922ac3ca05d845ed9887c4bf058baad6679e3610e71e8d19a3d3301e424a1f7871e7c636939a2d10b4b6d7cd5e3d13e1ef5c7fee96f67a32ed6534a1406f461f98f9e50ca3f4c59b632a699cf662fabda38328534f9f5caccac54ab2ea9db7cc420f441d135ebba5c9ba6623e29dbf447101e73c592dd792a7daf8b6dcedb1f604592dd3c47b3424e8d4139a6e1cdbcd58b467f2821483edd1eeb4c6506a33bff15123103eef36cd89b1af580ff0aaed5793a9a7ae253c630bff560f87b37b394a80dca3a38c0db1ddb142f8e4d24e4763dd92b991ec1741745a54ca1e4b966e900acc5326b65741ee9fee902895b0cf640413df1cf83f1c185f27800437187657857a9f244f2bb27c22abb509d36eab78289569d2c38e7496abe0de90da9b94b40f54df9ac069198f5379285f72461fe4b4e0936770ec1c2031824cb5fcf0f3570c22efce9d4449202544a88d8e0cc172762cec06b269b4ce9da05e283cb2d35d8dd60a95e44766f651df57ca4967f4e234675dba61ca4f1ffc0e0bc3b5a5d26a565f0c8b2bc2193b75d03db023d042544913c5f75dc2107206efd184a123fca485b5dc479baaec22d44b570ced2e2e45228bc98dbf89066865f67751635782b5a89403c119e6fac80254aa64784366c583b3bfc8bb4c70031888c6912894f9e4a1f1ca1d7ae4e60376ed51efe5f5eabb6ac905880f061d9542dd8a19876dbae34e21853242f3f66ad5ed814ec356dcb88a66fa93cfaef69713b9c4468f4f5bbbe1b8b1752332da006e44386b6b93255247f71ef5c9a8c26e90288ec61f4ce3b7d107e7d99229c7b68b2933fcedd95ff2afbb19ed2259bef957ffcf638427006fb08bcb3906afeeaf4b757df46511640ebcd5c1e70f0946596cfb543d70b6f2b82ab071f593e041edb327f882e7485bfacf8d90ee19a6418930fa240d66d09764c99975e33da73b007da885ca3c875d75f3c66e7eb97cc3f2d80f40e996ac03e09e78a2e7ea255de89ce1ee79b94a18728abe1fa30f6d5cba3300558ebc535d96dd864e975280f754152267fa23eccad62c424ec3e43846d2e8b00dd272722d8253dcb34b3bef9a5804e50ab1dfd0ed5f24bab664d6ae71258c8eacaf18ee2812f18e9ea24e858333f60a9d5288de905973935174a2d202a5d5d6f786197d2255d3ce5f2a49e4faae90f6ad61d098c72dd9b28a3746cad3b67917564e0aac9a49fbec8b2fbc868bd4a6f0501cc4ac9a10697961a244ed9e0b00315d1a261d80381a3bd4675b93cab3ebdd81b755ab37691b437895b3565b77264b2b9fce21747e0f77f85bcb32a3978f8694c7965c38e09eb88b40f3863bba852309336bda708fff19673820cfaa078ca615dfcc43f3091eae480b300d3f408726d8d265450c85baf0640a5491ab61962f416b64d0887817313a33a54697316f3facc7734dea202e508ba9bd75b5d73034cf7fbe7c774496e8d85b1c823010bdcc229b3f2095ac953c63078b4733ee79bb84700490e3a708746d4fb97c6d6ccb39e4861744a2eb82cf59f033c5e8a6a3e6aea3f7aa176ef74da561947ae350fb0050d6182d8189458c219c0d98b2c683de59a147ab81857b61c65f59941a71fd2351b5d4b48e435e62cb520e2f416888494f45c1903313a1c68cee8594bc7eb2d32f25aa3b0661903a8920f2fdefd63f3717370cdda59c8cfb3e72be04fc4fa747a7cf4743805b8c904554546dce598506ac1f83b9c5e9bc74c3d1dcb8c8252ba68297c34d5a1af7b165a712f09776f84805ca6c9139f5156c3721b43f49b834b48414c48b8577b5116cd1b19bfc271f800af9452e1363bf675d3f638edf305d9b8b6891daf21be36d240630a2f6c1f2f991d16c6c8fc35ad4ed63f78edd86fce821b1147786d7ada16d4e81ac1b575556deaa757230b940c35cf391671af26d2b99b383d854e7691df52aaa1e7072252850386a67232ef93f5e1f1aa9e7f77e07ad12694410a0025a74a6b7df224f18bed29d228ff0824d2ee2aa455f4ebffa811ca2829e64d6da50a5f189c61c02f9f45da387efd0dba97bdd59842c220d19ac975dc698180d321ffab0b48e4dd668990c8dda3c6eb3ed64a5a6018ca055a3e0aff8796904365e4f0b8eafef4470aab37c721b16469559274478f205a544ab20d679f3df4f63741c0c2c5c7c4f82e07d0fd0439915cb7275b192e8ae3d9c2399438548b7a48bc74f68c2d5b826f421678b19f8358a8788a4217a21de67ffaae101cae971866b49cbb4e6b74433a5ab090e0ecb66ea6008cb5da0ed089f0ea78ca171b6aa1a0163e219f05cd1e594308ae4b193b39973906788cbf545c0399e7349ce5dd66a24b3eebf9ea5f051c36f6f283e0d40f1cc31faedc89e94b7ab8ad6774947c623b430b2d97fd4f9b65c762135f5871080a0c833b57feed4be9918cdf64ead6c63c3afaef7dde5d695819f367bc87c3d4ec8121334b3562c91c88cae70e4abc2603579bc6e30dbfef193c736618059248a4bf23a8d3adb4de7bea61c881061e0eaaf59e410b8c26c21295982aa4c6c5ec95d97f7fff6360fe8e19d31458159dc3ea2395bc2ae17a63e0137277be809f7f08d564e17ba9cff2a628a493ea11cc511a756342172876cdaa45f19699e8b885f66f9c52be0c08cea14d3db712b73e55e9e09d524fb0cc91b143f781a8fab17a8d2c379613ea11893acc8f7f6ce696d69364188070d6d8503fc0ee5cffa642ea395cd9dea059d627834d8a86e69186d49449607d420bbbc6d1868f3addd00faba2b94d8d0df48d0634c5c3e5a5dd3e3ee5c1bac440f5b03e8d0f562a7fca465e282157602578c540c142f8530f21bce2354027b0f16f4d5eb40e513d1a3324a9e7b8761cad66879a061346c3584023776568c7509e078c68793a6fd6eb9fd115aac23c4cac7d0064e67933e80a561e23abdc1e79545ce8e94e847fbecf4c4b20c307ca6a39dce8d9edb398aef28104339b18cef05e1f74ace6a5cc815015026cb8ffa897224bbad20f3f0a8ef9c6e6e32fd73c2239d3f8b73634acc459c91247275c8374e1157faa98023260735d7f719ca23c385b24b60254ec21ef732218f6f49c6223a6b1b9f43702ff19db5e4786fa14b5bbeb6dcd4e43b85a753a0d58ab0401939541e0cd24d2013fb9c4aafc23ee258e7db775a1cdc2064fde6367015c499dbad79f2ed198f5dabc3c0a59f3881ce302ed6d407e55982d4f6c6319d90573794207b24cc065c73cf000064f388dcd4be16c287a0781b24803100dfe93c19721b29db74f6128440d4e809e22251f4cccfafdb915b87e9ffee2bcb9e7667c89147cacdd0ab1033b4746372e68429cfb0a1db3e158c527d8fcb4669e01bfacecb1e31b342ed4054ba09dd41d270ab0a77553c5ba24f80dba99059b1a1b8abe102dffb8348113850f7c1893b0963ecf131f87a31468eb7fd05fca35805066e1b60a1c9681deccf0fd6542636938060f98478a1e305f3d294dac4b9163dd9e4a84d2a5d34f75363154a2be648029b455aebc0523e02327f5272d37eb6b00b709f70f4494fdf2089b6ec7c291ed602f378823a7370e01731648933cd4a20403b45333f1ec6df5bee0f591eb87924aa9d17b9a2e3da2bfb0635cef314665348b38bc7cccdb0fe4e489b64297ba54efdc62b505509ca55fffe84d1ebd98900a37c9355b96526cc50116024a1fce74f68832f737d34d31424b7589a0cbc01e267b51a34d2f01061969ca8620fc5b664c228d10fd56b6a5edace59755f8411b4ab5225513eabe610141987687ce61017a51f59d1547ae5b0368f2fa0d8350dbf938a6a8ee3fbf734f3b61ba30ef5818732d1b636886eea3ea04add5ac6d36203e5e75bfba02c35fedc96ba0aa3f4b00236782c11d30a873ff092732c5c0fcc5e147b755262f1106c5363c4fe67f71287dc836fc319e82f29fef4dbaf71a3296d7caae0860bb2732b3ae3c19c1a1a7ffe46829e964384e8d4d6bfa8651a0ba35027f1e5b9a23bac20a9e0f7707e9417153f9df7d00883b14432c1d89a7371a88d073507b660cb91e39ba0fb229c16d630ac679aa88d06143db9b523d9352cdfa7a956694abeb156c0201d41bf088fcfcaa01db85cefa7a81a7854411ca63846e8919cb932e89bcd27c4530b178ad015a1c9b31045c3a9cb5ab0ab33685614020d371cf5c2a531b11da65a0a286d5c40fef88130933cb014efc131d5041549605e289bb9170947bb99a1f62f48333c6fa09424a539fe5fc7cec8557ceb2ccbc573317282803a9408a2f1671aeda3ce8b791fe9ac31cfa3633de3d9012574504dc6b0d9ff2dfd358c9bbabae4a6c957eeccd873cf3b8ad7a91caaeb83538132a6d56d5e947bde65038364f5084c1d7cc1821ce1dd9b19f6d2cade27e7c185161a910d120e3a85e3a5bc09dbf7ff6416f856963ca242764e72a47c3aa8f0e5940767f71f835ddaa0048a92adcb42df7e35247c48f151e80313aed148d1ddfbcf7dbd552404541034321abd88cdde79c9157d631e6fab3d3dc3d875ab2a10134aa55e0c6c922a85cbbd462b1d0385b210259bad3533f31d6e6b05dd371f8cd0366e7ea6b74fa0491eb5b5e3a93a8878bc3dae2f9575ce82e752bdd2cd9ea8a531b622fb0d859a8ec9c0acc486aa1f9c9c5dcca9cb7e53979f8a6836a4f904764677526918ec4f0e8e30e164630541106087bb800d3d451f8cb475fa79a819ee92f180ccbb1e69de87c39d751ff63995ebe61a9544829519675dfe3ff1ef7f4d571090f6dffff7a33f46d09086248399ef93de455261469e9c453dfaaad092c196a9489cb86787ef0caf0db71d5e63a2d80692fb1aa6044400b86497bad59f6aebf94e385456c0d53a473d0c75fd715e4922fa0f86934f46312b0a8d81696e667c785193c72b53a43dbc5ded077ddfa4aec1b32691e752a00ce859dfb3acb20533dcbe6cdc1a1e7f9106556c74abd836f593ae9b4bdfe578520ea8ee51352224dbd36921cd84103f2f4588b5b2345bfeba3b420db2563747504a456da26c602c24586b96a7a274f119ccfe12ea4d1962ae58c3f659e82edba0b117bb12365632708b1559c4a0053048b6ce909633f66c060bceec6879ab818c5a9281bdf2dcd4d801796a00edb8ebb821fa3952fab4f848723e86810fc7d77affb74ee661c5a10c1a46d142065304c38cde997820663d637386a402bdbb36bc7bb2f7a0926c03f9c77bc669dfbcf6b4198decb0f535b3e45a00eadfd5be2438fa5b34250adfd16de8a310c70a573de4f57ccda8c8bd7d82336a561d05fe59765ad047788be0592c2fccde37d13764dbed0aa28e184415060e6f2da1f0070f0e09ee998bf6b28be37454ea2a829df87c43bc2c6889e1e6550e97f24e394b4596e71e23cdfd668c615d8010698779eb26c1645c5d05b0bef7f9437196232b5ba2a1f76b040c130759db7164c4fd5883875c3e3ad854fa6a0b2c78390dcc56ecc23adae82af7f5b8969de51204e43947133b4b3a93678512b010022b5921c992f4614fb7071c9e015bdb69b017ced61d3da83bfbd2a9bdc174307da6fef416cdea8abd6bd7b5a9474d698011a02c3294156a553e3a3963d83a825a22e81273f42a0eaa44edafa28cdae5276790195316df452dd82f0d49a9e082fa9ff6194a4c5216e936c43c6a5151778a32f65dc94b32f68ede4b28e26449c1b16d10cc80fb63b4de7d95d59da02d7b0f33e1654220516fe3fda331fcd76656c4c7133db1c83adec027c4c85346295096fb63e5d91efeb5d62e9e68626a4a8461486df041f84e650b7df21ce4b02f968599e7f97b289de1fbc1bfeb574f6d0f08caaf6856edd775e382f52dc7827aad6af1fe974d8a31896e06d33c1b97895262d7214ab65b1d9b99e6b91d32e584f6d13879e99c4fa278b4e319a8292fcd8b336642b5e215701a3032c4523feed08d00f1d2f92e6dada8e16e76969320e106c3c8db61b9e2034cd23d562651fcf16484845cb8cea707bf2f6a064b7b6817fb988f4743d732f290640c7e155c310ca061aeeacd478cf46e117513fad9331a1c56088908db8201a0680adffda174c5766558c3c25c6747aaab09c901e1448d5d6b716c5c5ba39aea52d2475fd729638edb45b33caa0ea2220c5f209086fbbb933b25fd908c323c788c8f7e295bbb639cc89910f3cd824c7ac4f0a0d22f7a66dd617d43a15aefd5371f00bb7894662590f4850139da96d9cdb1dac185366e776b9002f2c3d2b7484d71f6236627c0763fa070d3d7fdd52758dee221e0818a77bcd3a229e7a92fcd9e7f18405e0af2bb482395a337909a3cd3fed546b64991547391e8c89283e1ab53ad224f83aab150f5ce2a2754bc013adc35448e9574ec9f92afa37e26b24d5934d74f69d3ccab1a97101ea557baf178f9c0acaa9edcbaa4e1a5d1a05e46d397488c1a743f537b47bf9854771f40bd7a41afe14c6f55e3e61055155ffaf835e212996d21e411f14ed81358bac7f9753506a2d82410961ecd15f65671d31abb77122a84e44c19fe8e5096736d45d3d618fa61a627745f2c3551a8c1c5b93e14494d6f1eed1b1305acaed0558181c33a3a64b2802b44f7cd43c5cfb12552e323c7659ecd60398bcbfc8b25c0c10ff62c8d1ebd055a2ec4c332573161eaa009342c63f1518f49ac942a2151dfec1eaacb1852883e7eb752929af462ad0a7dacc878dfa0e6fdff6446c7bb9271dabe977c24be8eb4d7b1496e982911508bfb9434caaad1e9f246308094366b22be5264fe184bb23787dfe3ce54627caa3f93f445dd20186d91316985433eb579515e790b95be73b00b7638a1e191f5cec791196f0b4575ee4f92edbb60b99d425f38484593d29d4298c035b2224a41edf4d8657b5e59a87e2e163f4b204d21610c90423bfcdb9cb83c1471bc963918b1ddd6d1b58ef80208463db8e23d4189d536bc80f81a67e0155c8ecb615965c7f7131eaf797f557695c52a33d1889efb825d3077abfb71ada2a5104f9a4d454d2f67cf65dc8d1df896eeea01292ab9e279718cb45c3e379b60f1302af1058c6a3634a7e1839671f07fa06eb49da04b56b0fa72accdcc5f5d3c4344e70f51648fd9d6df64ccda6c22ca222d2f3d1af6c66ed70e34c433561fd95e29b38033c05bcdd9f11f470067d062beaf3da11ad793e22baa99ee7b12f817e0abea7cea35d72da92afea9e3d1cd6c9e7a9e2b4b8877c136ea820e65aa9ba6a874b516671422f8e207dbd0d31d7e59ab11f98355c6213f72585adc42cf1e485aa6f0e1b7a3b2c44f0a7d3e9c6640c71b949895cf99b6d50221093688476e7950af5a3eccba7f9ff12c6c90ca2ebcd7a29a816dc8e19484d220e0e7a0b77891bc4c64786fc712f38476b052b65573d2021c13b5f3ec1c0d6b0547a25ecc8970090789a23704fb38f060a17fe62a277a385543c686b4c8934239f88caf3a46f0ecf1ad8d55dd8d4f1a5eb54b913ba11dc1ba6633d284cb125e3f1f39f94a569fa66817dc95116c98e52c0d713f08409ecd5d3fb0802f270e83bac949534a14d3407992e2f40cac3d9bbf228c61346d1f375f700adf3457dcb47a2e79113a0759054f0aa7b09defd5c181a3620da551da20f25460d1395fcc51f75c0426f26deece58c47dee5699e08607d426136d69286e82085d73626e611eec9e2f6e7cea5e23256d61749d35be02845a1335a2351b3226bc9f2aa61d90ee29681b99e5e8b8ca1e28c2c6fb1443b0cec1fbbb3a01dd718a75c57a6ede53271550090d4301d1eacbd242b82f3db5a557d2d8b9ba0117f47469632363d439074cedf030c2c5a993bede0927e5a8e3a66d73c8247fc9b8dc199dc0af6437ae4ca0bf1abd3d72d0ecca4295cb6923dc45e8941897b1fd6db7cc0c4c02428461d78d5ed9383332f6d571434c1f2b3e3471cbbb1ad166845e93ac25b415d79407f945ec3c5eda538f269545e5cba94bed06a041a6a2c2fdfab9272e93e1665eade92a551c71384b2942b68b5f1cf001e39e04c5df032c6f9050857de45a08c53bf40280f1d55527a66e557de2b14075d8e519a6fa617034e25a0a704da8c2e6cafc7278c46d2385b287b9e61b2a8488ac40004009f0c78b26e76d7ae18cbbeea8830c0d7e9cd4c583bbe25096e388ca1fb646cac39edf259d20052f2c6a5ad6a5e5870b7edc369f3cf59aead73857b5d7e24b675dbda1815404845463baa3f1fdf821d35140120399ff9c4ffeec3d1fa6149a554709f1ad5e618e8a7f9eff2622ea376c0d564d00965fee62e2be079c0c2c44c87ebdc62483ac39f947d28bb2225ce640019481be3d0bc9a344dbac79b413655c613b5628cd55d8b6892fd753d227c306cbdd92fe8f615bc3998553510cc31c20573f8d7dee399aeda1019c4c95f1c0111ca4ea7343fd096489aa9b88a5b98ef5cf42b1016809715ca90fc9baac576fbdf0b8d1de113781d4b1a7eaeb4e70f2e267290b3da65eea472438c219d2ec97e83f4eb025a2513ca07993999d4a5b84d511bf1713efa5f25fd8ac5ffb531e68253d799c86a199dbb60510175b2c44eabe131716fee203355ba36cb697c65af916958d4f39b593c6cd95b066c92935fc403c78f456768f8f1b5ca8998cc2b07f740a708505870e58cd4bd626e4866e46c83f1c04b295da7d2201d89f3ca16ff8c2505d46dbcca4e7517afe4ca805549b95db3242df91feaa538ecb0f41ee0d82cd81097cf6fdb8116e0f0495ee843f5d65dd3389b4329cc64fab61b45311c646b8abc8fcce4d92c6eec2b9c23360fca84af91cb72a2456ba130a1b7c37967c607849e139a83f98dc35221e3df9ee2f7fa3fa27b6576336d79a2bf9933487908e04710c72c9842174981632385e44fd74be5c173462e0ea1c09f5d13ddf0cb9d38978ee967532dbb9969cc2b5db6ab6efe9c1a74be140c001700bc361f78347a4f56b9167180c96012fdabc603f3a07946b7f2578afb29765e3ec4d2373b41ac6b081c025b8b328e31dab9bed28b7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
