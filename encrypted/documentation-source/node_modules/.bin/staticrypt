<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f4a245a1d5f6ad19c259ec4e2bacf94b681bc0f088c74fa0fac9d62dd2b8b37938834997b49afd7bf89877ecf9ea71a11f1d6eccf0a0809218d1723d69574d5135aeefd981b73da1e9f01a1f450447d478d01d5943832e563992dc8ff629237013742fef701931f422521b91c480651a58ac60393f67648395295360de7c4f2ff8eedb37b1c178e1b6c2015f77a785d3063cd5b405780d1c482d59abc86e1fc7c299f19ccbc07bf3108febf8cddd18f5864c96286585c53d27810846b9b4db288eab49e7a9efa573f6291563dcdda7147fe74d4ae3f369478ad17c0b2c930a7afabb7679046dad328563ad0d9f703872b5fb471181c435c7a68f8c61128a4af29238971004ff49a84723d7324154b61f00febfd8b33c08b9de1bf7cf3763575bfe1b1ca9026853f5971cb15298efd204c220060170763b4ebe9d84e701d7fae08a90a8d0a419305cb6e6c02cf5566d2427c5717dc0f1151a58dc2fe03a610f0b0d80a3d82f27d1d26b8ead1f2621361f1d23a73303b704a1b764e8bcd11d4ed71566c6aa6fa92d2cec5a7ef7364e436e94773a1153301ce4fc68e02ea1f207bd27f01759e4eabb5229c13d72f84092cd260b71e3f8f1a3eb5e161de6a6a20b1efc24a8677f7da176743e8f0887094eb74aadfbf3fca6f18328087b0e2d1e69f2c1ec0bad05568c1da7ae1a7149a684a7e76064a7090b0897fa1f2db93458904b21a7c1879d45ce65bd145ede95a30cf9739a62f979a48321cf9ecdb6a1a79aa7f8d1c28b8bb3a9793ab91a78e743ec9cb89fccce325d4290e666d10e64caae22e8dca045a36c4b09d02128df12014e2a1502e358899f06772f8f65a1161ad44a70d8f4bad18f608713a3c028d2118518c9127d6b9f8db58a85bc0a040502eef382ef599d8a745b6670d888f4e8367cb51d709af3720b3334729068c00c28b5105ef45f37df8ec56123fb52afce73004cd2f6e22827ca4083994accbb8ed66464da4f0fe542393af40ebefb81be6c6c19adf294e04816423ca967a8309fe69786769eae80bf7393756cc9f2762e7dbfb0639c79b7f739321451eebd2e8ec313b8d42dbbdf73418b6017d528c23655394200918a9672f467581c2f03d395b553e5c305a125a19d161797d3b8c081c5e38a656a3f4803509b2b6b07769c3fb09369df36a0e262e51c57591bec7b8b000216e37a15f09e205676ed7575a9db80f72725154aff5e2e91f01cb485c70a211d4f93744f747e7d8bcd657887ef8ce26dc454fc90b24a41c779d9fff669193361641d7a27b288aa31da4b529ad04a8614c3a0e12dfc494c29a20727e71046b750106b83de670d3a26c665a4b35435feedc887a3665242c751ac00102007eea15ed2855c3f2273a378009c637af165ab479f879173ecba08e9a6d005f8813781b1e787380148a358058d09f5ecd660ec8cd2fd6e758213303f333d5f12496cc67299f787ca8933d4270b25a1eb6ca5fb3fbe58e833eccaec3f2a335af5bcbf936abc73ffce7d675368224ff310836104d73a49fa5f8377fc4006dee63de853c8adf26b6bb864af4047770653c6a7db2027a9b7923e71988af92f1ab23bbbf567ca7c70e0b10559ecf5c06febe0f7e7a98b520411bb4714d835bf34e8f03706f069390a512774a57fe11d72ed86ace634c376d585ff394c8a1af236163a216646fbdee37cdf883face9b2f32912288a6bdf0441871b822196e7bfaab0bca8c2e08009f700934e1622f2fa3b55f47bc5109d122d5e48ec9e90b1eed92b58bde0332d7341cce04094d90e7d26e7767a20b4ed66e57b2e513d488dd320d06f33bd579cf6c8101be4d9cc561f448144ef0d92978333a6f3425097f264ddaa07f703cee8ad2882153d1329ba98b1096b58ea05f541e73aaf14befce7415bf748c69d907f25b81d240dfb09d616df8c20a43363acc117a3ea42a581c867ef7e26420a9373b549619bfb211245dcb27cd601185595028e0eb5d2102098021d7be887853801d7cbb1a17c8d458e4301529a292a2332c79b72fe3327277d08d2ea740135064b4980cc77937be2c31d8d5d8defca572092c5d4eeeac72c49e222aa4ab02515e060bab1f2c5bd37120f667d7871035d2b20572a650a8b03415b376d7672043acdca194032a29d69425d77bd41198c29be3f3c0679ce04fe4858d8cbeb5a9542902b9b26d9f6abb604c78ff9c30b6ad287603ecc6e19d97afbebe63de0c2910ec7bebd3e63ba66e928e1d025ff429de60503990484c7dc6acfcc8947c2ad37c7db5b34fbc25d8a2bb917db94b71d92acd0f56b41bb310918145955569f7398bee85fa2d543995aeaabe0f049c2658997d249e5415b5955afdc9a7d1ad411ffee8bc0e446eec7dbacfeb94916d88af5d553447ee8b5cf2ed9d8d70e87b270a75c586ee01d2416ba81c587d43a2675e7476e8ed3a178ec4bf3b53abcafe784e19ea519622718da4652979f34b65667b91db4911f5de6b0510a842b61093cdb1d90d87bf2ae2a06bbf20d0d4c51f42f7fd53eec2190b0b3a89677342ce2a20d21629e224f8e20bef511defb1cc94f775329272915a2fcfbb3b21a5a031e44914ea75f4b5c5d3763fc2526282e5e95d59db1ee827750a4e02c3be0e5a020572aee3b091e18d69f29c826b68740078b1278fe7aa251d5c3012ff4fa9171350ef58bc93831431ff4c4696a89b6cddda08373444714989f217ce4c5af3aa74c72a259ef337cb469ae53204d8bd40f909c0e14997eea98faf3c985d4a95950493a7d2d43f36324a17d38c83dcb981b49c1467632a29aba9f3f803c2ec6bcfacfc0852f132291b3542da70dd16cd149027291954dac39c5ad2fe7cd205b6f23f6aa7cf02450b6fb450ad77bf40e0f9bcb9cdd245e6ae6791e02c6d23886b4c7bd102bc4ffb8c4a494701f23bf5f3e6d794d8d43eb5379ce31a2f98c768d59515fdfe258eed02d290072887e6c3147564d6bf16f393f9fbf2402e53939ba6bfdce5cfac69c957b96ca420508bac4fc0677f6521e8d3101c79e62d573f5dcc94afdbfc5cc8cb3d021c532bd0425efd1b5ac415960ec0d2b840544ec114f4670fe3f267ebda01f52ee5b9ab2121913a77d565e444f750a8443c2754060784c1002287753a7080aba2cadb25d27c6a894e0b9385a4a47669ef046fe215136c0e835d9341b7e55437cab32c57c3d1797efa746795c8b3be9c469ba96db435fae1e7b66415830153585cc76628dd3e40a154e9237fbf36a0ec3bf1a260f27659b43e7b7ea47f758c4533127beaa0d79d51c781da7720723ff295e9c356dd2054d46c4560679684ad90ed43c25605ac667a8483c2987ad2332a7a9307fb47b28fadac35cdb2081157bacdf96a4ade89fc9a83a715dd89b2e4545f8f04498675dca08ee03fbe085fc8d544983291e011bf70f7962b3437ae1ad789ef3490f606d007b7e62bd724cd3bf34561f022b8b1e196d88346a1f80c1271fe96264677e194fe727dfb9167346f2cecc6eb1f77ad6cb2a9f425210b9fc7c5451d17fc748c039c341e0d5088b5a7af836d42c1e0b8ec9477ea673d8f961842ef31a7c2c4092aa2888ac47f2c71d575319f37ce11d7fc109e38bce60efc7a1863dbbe3d776f35819a940097508c967af2b4f938ff16c64fd9b5d0dbfc5ee93dbdd64ab8915cd8e374b563501c4503e850e26fbacae7161b18d76d3c97ea157f12f051a469447841360da8c35cb1964cc5e903c44df8f90cc5ae47785d794aad910d8af46942ccfc4e4c6e7aff864b134056e159ea811eaefc24483eef082d8023ff1461fb9bd59a41a7a306fd4004f0d3f2e1969fb2483b3a67d6aa1354ae98298a8c7c673d7117483612405e2585119108caaf3682eb05592d4902030f331e958fcc9c549560beae49240cea85cce1f8aea2d44d81102cad54f7bde0ad14234c5bc67737a1567c1bdfea2055eb384be05cf1f95384ca2a6865b7e47f31d52652742aa5dbfca00e1bf240f514f6dc174497b87ff4b38e64e0b6c1e985b61f4d2b8f2a54dfecbc82bcf897e2d6b196720a6684c31c6b834493740db0044f1b4a3541879c0a4fa2970fe790a1fda762b8ae59e7afdc57548d472c7f576c228493f2981bd1d47c1ddd749fc44df37990e79b67db9d70302dc9fd3a40908036817287f3a659ab55ab18b4b4ff702bc26ba068acdee9e5281ce4634c4d092ad2056b8a4e90589235974a18dad75dea9c8b4802ad8c96f3dbd0f6074bb084cfa26a33627ecc20378a01a6896d925f60ae5522a212f4bec0603aa8013e3a52a463673293163a2487139fab24efcfb493e22d9fd20d1f19e138da6f08cf655b65c069c2b983b0071dbc683b7abda302b06fb11a350fecd11ee4d119850968bcabe35ef39d07488277fe9b450755ebaa1ca9a117c5f23adb01a8afccd572da6d7943265b9cc8cab9e65be0439719d24027a1c227d599d5c9fc136e2e2487f1eef6814d5d339f42496a8aaced31795f37837259dbaad61d70f9c069e5a96311af87e428bc7b9d91835e48acc9af1a43ed1ebf8dfdf26eac5ba69f2287d465d219b96cd3a384cb77af1e40f54ea7966e4d35627c501e7249571c9aa8edc396842c4e7067bc95319644307ea507e23f470d9dfdaf1e210548da22a803261bc2293da04fdbb5e1b1527ef7fa1314733cb0653b6445fb281670bcf69fcba345831550045568760db612ee11d5bcdd02389e600f579eac312e4fd112f00d92255d297b65db27165caf4255953b72277f98214666a9e83ce01f2b40a61f0da9a6ebb15627abdf07717491989581bb03361644e3a9fef143ec6da69663a99e0671c57b4c614fe88d14c0a161193cf3d226e598cc8b58d91f9651ed6195478ecc001692afe67d8270b0b8c43e61aac258a02ea53c34ef4d6aeaf2eeb8b9dc3d915ed5801b8d28594a995f71b4bd08de690de0b397b48bddea220b8d4fb6bc1144b8c4ad430bc212d1f6ec075c46ffe430666e6d63a3296f5bd0887867c27a7c00f32decd72fc3da1dcc1652d11ceb1cf078ceea30f0be826ee71a84aeada609e36a81309b0ff1fb1238a9c01591a4e24e91f773e6746c399d58587ef5781f72905d95dd28f240fa9f0f78dd7135f67f46b9495fc1ee57389f0e4825aa805deb7aa70ab644382aa7be70775ff539edae6fd58b2772aa9d63ceaa13d78c786a1047530da64c04b4221ea0254ea07342b1f38abee48f37f3a5b4826eeba5c62e0f457508f98f41e24a9883f48328d093f6cd784b4addf83b48dacaf792fd75a90d1a40c822b3349ddcd370f51b099cd980f075d5564a110a2982bba8df1b8ffdeaf5cbd5f98e6fe32c5add5be0f5b6808c5a8e210c3c568c758c82df2379e63899669a866bd62c6bd4892eb51e7b1d6db60bd3723b1449495b929f84d18b6bdf35827493c1f8e46b05d707edb3894f16dd9122c0e9fedc7047f3b054c392402289a418f1b7aab2ad1af2b6bc397300edf1869529b75eb1280f7201d0f6aeae56642a9b44cf8ffc0055610cdf715b61b00086e600451fb54132624c5534545026ee6048881307141b0f2369d30231d929b3f7d7d2bcfd03a1df41e1f5664291d5cb266641810d809ae4260884e6c5426df09efd351fe1ba59c57b34c2d6d33792758f8e3954ba45dc21d12c84bf3e831e76c64a772f9962093f226340f725505116ce389a4ec7a58fd0f6c7da4fcfec598546ba7eed004d1056c906c1b71fabfe82a8efcd5cd56060093a43e89aa7054a33885ae8f4f3c9c8a8310ea61ffaefa953a5e07ad66dde6ff48a3f04c37f0c79b9f63251842fd7e360939824801f74b26ccbe43e5a5b4f21cfb6e0d1ad81f45c75f3164fe89f03da1feb8493bf00add8ac90ab1143abfb575aa999c1f77df54d76ccde199cf9fb23e1add881540a987941e9b6e39bf886b1a2cfc51dc867d6761c87deca5bbec828c6948037ac4a3aca423139bddd6f38fc1f2d6a95cdcb4137f2ac6cfdacc08ed03318586d3a60b11bd22441fbb44f0e90cdb358360cd6fbdf285001a25796cc19bf2eff0ce3282c2273bd351733f21e4a9b86d2a5ca4d7788244459342bf7716bac75f5d4d24ad4d650cf3ee1cd014c4fd32f797ea56d3ab0eee01a47abe2fa46f12ecd5bc7dc7d3b6f5f7eb90d3421106681f251efb22539854d75f707873403cc7a3e1d3f7535d4769157fe2ec1fcbcf97d9fa6a36e33cd93271f594a78682d0a1cbbd017bcf83f1a59cdc88050f3fb35e17a67e2eef429fea97f9b5984f1faf2d8a6907a5449fffbee5df7bcb2875c938f5ba524b5d6db3eb10fbde64f24b5edbbae80ff7300535e8e2ab4186224d1610d1cf2ba8293fe7e7f2815789a337b7002b55f0e9652e4544efd2df461a3164935884190c57bcbbe0854366e21c15d5220e123342ae3de57cf8ec20b34ad7d0c55745ccdae75be7a32482237fdb0142ebce1284cdf7d825ccc5252ab5602a2f50ebd99370c152e2cf9c250589ad3d9cabffdb32523977d14b32e6a16976844d894affea3ac575bb6c762c49c5895a5ab6383d2d56fb9aeeb7f4af580609026d6cb0504c710c9618e187568b917d9974e0ecd12c4f32c34dbcba94fefce1cefbefa38629689e71aea62046788ba7de1ae16f2409f63cd5288a2383151e1406f67c76440a1abe8816ae52dca230f2f5052657a2b34657c3adb5fe1273589b791512ac464347e286a868df3bef1a517120028fdd357a11d15423c6a88127ea3f41043a9380795e3f0db2c9935702687a079f205e6f6457e726b7234b7e10f745af12ff41aa115bf6ad089c6202c544badd28a06855531e3fbcaf39ced6ac9ccfc641ea9a7d151ee9108c824741a8979531185a2508578086c26c7b6437de3d0a331110c98ff802085936206f5b2a7162859527891d888f69b18957fb0650375fc219a705ab062b0af489ba0a8da51e8db648000197a5b18ca9356967548cb4c285b658311a32fb6ce90eaae360e8f625901ae50c1535653a5f06a3a529729611b1c53d77e86e0aa25f5e8b449d2429a36f3403512710a9d8de0d7a4653d0c632b416e71d55f0de3b77e7bdb0b81cf1bde7faf957ca23a08587b94762e0966bc329a3c75b9428f481c5b1e155a35b11cb97ec8dd1507606b4c6930d225a42108a39041e6904919af5801229b58a7533282d10c239a321cdc33d51797b8ba4ebb41a6e8db65510a3f4dae3c81333691c40ccbc7e6e42ee703fd948fe2349fbd726981ef2ecc7c1369b936394896813cae07869ae3f47a7fd6a86922393cbc850dd734b6a88ff50aa223d3e938d6c18ab8e7385deed702afb584edc5b96a3693c8497652bfca7142cfb160a05fec1cdbce6a795bd2c8710ca10f17df54c8dd3999d1ce64cb6b83e7202b30d8269df328a220e8225d69274022acbd78f2705a5ce20a3a5c64cc99aa582e40f5aa3df7057c18dd7e4663a590500bc6107d37482e8f50201f22562264bcfc098d72035b6ee9c719df4006674b2fb58fd9cfef6b6513966d82e167845a56defca0e43c4128bf3591909b84869b11f6ab8426dc339775fbb70fd85bb464f791236a299456a0201025e68ad00297240e9d4b062288659fa1ce8fa5522661d9e59f856e494cc75e6ad55794c6a5f0e69761a2f19f1647377d91a68d0f3356928afeffb313305d228673ba08ae4527cc35e43bde4533cbd82b871618f1f5ce5282f104d9ebf7cfd6ed58768b322a9aec8a2e655c2b1866abf1170d23987507009341a57e37d3d3b24ed7e03d1b6d77665b472047469d06c63c1708cc05a16e3bb370a9e49dc55cbfe865b28738250385f39318fc7624b196604f39f6c1ecf6bc5f2eb027a68e93f27a12e7bb6e21a241ed4e142d219708e5d9ef7288042049dc77d79e7cf703260eb83092cf95a5c40520ff2431e111c8d14a314bb801382ef2c05c388fd8772b6c8b946f23f2c087f401c7af40a3891bcdbdfd7885965bcc20a2dad41fdaffdde19c3048b5731fc9a2b2c246f088b160d48038669cf33fabffeb2da6da0e40fc38a2463cb8ff5b88400d41b17bc91d4e4ae1965a9c044eed7bbd9bbbf931763481a1855c9b702380b73d4abe425a046a7e81907e2e62f22125ef465f594232ef7050a543d6fd6e3a4ac87446851133b391d1221d21498b38f303c00f5bd4bd48e39ec7e199fcc21e19a7b0e20d8d5a5eb1b715b39843c75206771d9762951bc20f9a0712cb307b25ef4e4d4f3ebce47c9005ed0679ef4ac6a00cbba4efbf188112b68bcedaa6df4026d4d01990aa691ad459e05b2d83cb835b42ffb959b812b447d542748426efb591fa2f358f9fe05ba9a268cde542f4127f8b57c7023257910a8270d657bea83312109e1b1489dbce2b933108e3619b3f3263fe498bda61482b996ebeb11f69f9f94aee2f7d825ff55a83b5b7142f6c6dfb54a1907e646fb25b1969761f62d537ed391a9f566fbac6df1fab0cf69de041e864ed0eae6c1bbe49a51b98aef7368a25835089468ad88fb693aa12b0a2ddd1af2f8ac42c53070f258b8a6a5d96de5b5f1775c48eb4e23df8c24a6456e4749810a778ee7f553852e5b067c3dc765395de7cba801137b4d45514be0867b28e137e90a59b281b0de8285b0bc87f932cbb319bccc56a263eff957e267a28280086fac1dc93ba01595dc88c3ba2e0d3ec86e708b27ac2f078454db012bd579409647e0d6f7eb2def1fbf201808f21f28b60e97f80f3c22157176d8390c46715fb899ca2d7ed22b93f46a9cd4321d7d5bbdfecea1444cdb2d1b890d1fea3f0c85a23321f5cb0583f7afdc1740f54f8ec5178c390203b6b3afb808d471d822f3cc497815fda9e5f1fa9db1ea4242b1e76c8ef01c2f5991c668255ee83e033e7ee159609a612bfa0d4aae6324f68cdb481318f4216a213f97cbe19da4a64c46fe0282070affcf172843f5ba40e827ab1d5f8167b0cd30301532b91f3eedfe69b3ece2c78ec5a378ee42ae4b0df949eaa2be048ef6564e99f86396c1445af335183aaa92c4d123ddce80648833b69d37b6aad8cdc75e2a83728f700dc61faa3f79fa0d73bd6548f3d5f0d184c8bbceda5553198571be5a3989cee02a58e353244b21cd0422d4a5e7241ff0955621be00ad2de2c1bff7a641371546a8460fa4feb044ac1529e3a56a7e0b11ce34ef462723c30e4dcef7d3ea6a023314553d1fe1dc3abd08f1e426f8b503c5237a3bc6a1bedd794e199da2a05dc42e83e9b269a3bcc79f99556e62e33035f263cabf2bbabc911c9ac383d0ff46a1260c296a4d19f814fab218c744e82931ca1874f4de8161621dc7787f2459680674b93edbea604c88b859af5b4af3ff08f85a04eb4832d72258379b7031ae0b2ef4c5f41862243b9b856397acba79c67ebd85e80f1d61342ac60a227e37ce96e8cc7deda43991e3a7c10f3e7c862d0ac8771798ae498b188ad6796489754d5c06931ec627a7fc2df66031f9fe541a35d2e193981570de9b766bc01ab1ff6649e5ea113c20e30a1653c8f20b156f6963232d88c38931ca0920414da17da3246336f55e2224071995f8c2acae58def5ab0df0251dbb65abebb1c3a3b8724d2edb410b3e83f54d78b14d65f0b95bd252522fd12aed84c10190fe1f48c82905506fd955ef1cd7d927991604f75fefb688ce8bedf55f5ecb02e5a57520098791743bab5cc258b5b41621145c1b0c7a9efd4d53e7190c4a7b60974c3b7dc348ea55a84d9f6e2b52c3e17b5e0b0bf4050d4c91335f3e216dfeb2dd32d1df130163ef7c5caeac40ad7b58f10d081d4492a1e7f5b9cc7018ea8fc6d86da18a5623c4d412ea65fddc63b85dd19a1588075143404f64edd1e5630bd7bfc667603e4e1abcd2dacc460e12fb21dc838aeaf6a8da282b552e81f17da19e9def48c262d9fcc1afe97cf94fc408cc9a28717a99e7bef326a41f26628f263acd852dd12ec737776f0ad18509209d80c766a7aa69c5c66c0d19b7541e16249e08ca245c947154bbb7407bcac6961cad77f9d4719a9aa8da01cbd351f8ec0278510bc6d8925dcb2d8becc41cbcb827805c8d335f85667ce25a35e4ccf4f6408b18be3d8a7892757287661cd99bc38dd4b2e2320dd041a3fac6f6a2708b3163c2582f2a96f27b2bc70f57dcee9e558844030ded0838e33703b29671b9993b6574d081e0db2108f8a07058f82aacac1dc6927095c2d2c12921288b20789e1208fda040547e0b6b2792cc839f6692074b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
