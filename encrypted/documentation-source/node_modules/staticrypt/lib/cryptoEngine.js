<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"330a9010d383bdf75d14c6a52efd85058ab195c5a8bd01a6be312cd87862c83cb6ec19ffcc62d4818292cd567a62fadc21b5997a6d4e66538c30466c0c7ce0e608be39e37f18e2bf04a8586f6449502671b3be3f546e277b5287334094fd511de4f053466144a2552f71c5d39e5f8a6a74ddf2ecc5c08067b1835cf4732ae3ef3d5240f3d6cb097a89bed82103dabe11422a5503ecf601dea2329d410085edeefdb0ed8baba8ce3ddf6e46941048d618f671a11bc4f504039861acadc0525184a54faefad7c9c9bad5002969ee5232442025f4f0f5a46e593f22a1925a4c25c556d0d23c9924708697df73dbf73e4b59774076e46ce97fb49d7c26b1cd18484542f2cc52356310ece243d25921b4b74e0fe671f31dc7e5943d0baa2abaef52fc5d8f0cefccc8eb04809179b52673811839ed80cb0301269a1d463981c5344c6bd25f5109d2cde99a814fa216e5005fc6c4fb14515de843f8a81ce39373d256b3bba4e45eadd6a7dbf9401acbb9b8ceccd56d26a9675cedc56a180b2c172da28ddf891dddab18e8a6eb67482b2d9ba712203ec15211bf70e02384d66375140758397ccb1d41cef6ccf1e65aed6fc935ca618d8d4d9fd077ea0fee745eb99dfd17180aee3075bd4f2b2b43bd3bf66f3630734832a29ca57dc9d9bad33e0ba94d7f949224016bd666f872854c4ecb3c9b9caeb8f79e10ff9e2de84e4a597c92040393931bfa1ce3075d50b5a635cfbf595e1592691f672890ef0b1e8d521c9a43821a85a8cfc2f68d8788738c3021cd622025fe5e2e683a37474074ff58dff0670a932caf97fe3dd031386a76f61691292eea01680a8c8003dd7a95ebab36448734723f64144fa9bece398ad464d445d8f3615cff0e118a86f38ab898db7d3964ea97ed0da1dd5b3dc245f19c4bd8af4e2576db193dabe45dbd2d7f89a25e23b93c69b56efa2e6030b28a052cae4d2f970ba0ed63189c8f9f5fb3aff0f0ef497ec86f19a71a33a7411e7f782d784382fbd264ff747c4b67935398b361126fc492062ff8813b1fba16565dd059e9d235a1e255a042b06f9093dcb7db693b001c74a7eff9b29e9b5b357d8d6d91f5edc70f1d9fc934019ebef1c0967152f39d03427a023f49cbabbd5b65bc33a79369a7129d3c790fb210d11dade1f262b979b114cfeb21568ad7922d483f42ad07a53a90a72992bf5da26241f0ee9ea050e56176412b2c8b82f4b3e57931da18a7057130cc02472c2a315ca52cae80bd758371682ff0a95d58ffa48076f7565b561f8c613f70e176310e5ba2de94ce3e4f48a61adcd5511b815de05df0d031b2fa38eb6bc985c6d16f590528f657707bff704ced022bff44c5a3dcffa41898edc4aeda20a7c42b0d919182fbda9b3debaa2cca11716d5e60e5ba309a0aa277e551289ed799357c2a985992f30dff1e3460de98247bcd88dffbe3392c4975299d399549f5a7df8bf3b645844607b99bf65dd2ce6e9706b111c3259db7539c9f1c2d3e29448bf35c711e99e63f83e35e180661578a2b5ae63a6f5bdb88e2e7b03a97eebc4509f7b8946905ada6250fad6f90440690e030c584e272970b565fc32516299339561e71c8642b289a52a4527ac68058a33ea7b96986bd24b1a7030b4650b66b06d5d66dac316b528e39c7a6d87a516310a7432fd67236a1d84549d1982736e44ba6215eb129e0565ce94594b365235b1823c9f66a36bb30ba392af58d129e7d11fdf9b58d8a8f1a7d743bd3477f854aef5d75a0de0d5b967638d872ddf69590bed6c0ba34fa92eef77d2684e71119b76eb1c8546ae2c93e105a9be0387b51a6709321092f1757a31dc5ecebdeef6a9cbe1abc708d7902d55a2c0e77e0847005ed388f77c198b835cf03f0d3c4d4f9bc74802f53a5039fa0076f9d1b8f9ff7afce96c878f6b9a77d41a0485412887c5efd36223734f881cf942f3e5e47af75239a2400a791466261afcd43adf240bd2a19bb247c8eb2a760dd6fb7c13fd817e55450287d9f14b91f441e74de41d1eef769f824158dc67932bd90f68f5a7608a02da5427fe7d71295fef7bdabece93cbcecb03c806fac7ba5182924fcf81a9811ee10cd5981846e0c4be1147dd9cebf4981deb2d52f0ebd72967ee8fb5232485f72a9d8a1f62bd2a86b5f4c0b6764d90e17b6b72e8b568b4079e0c9980500e6c9b1545c73d06634afeb4ac841d608c46383630b6cde0222d6c442df0ab544006c9eb7526a7f94800b63d2ae7a927af6e23a4d98f19a5c38ef83ea6e7bf31cbcb2eeae03f967d968f06a93e65dfb562bc1566972428b65c8549ec47a784c9fae450f342bef4fe4b4db1bc8f2aa2443a36943c0b7f147805f117415c4d73203e2355b3b2a92dc0e137808d4237595ea6115535fbcd97a2dedd1bbf19be1eb0e94b1f8c47424eaaa111f0192bcdb3ef3fb80a28e885e3ca0294c04290d6452b4ba12c41ecae10ed153bf3f1c54ede860558b355d72326ad319fc6bd3d331c384fbf815b86da9075f91d068ba0fc88dd982d5c371ea4a548f1c931616afa0ec04c20eaf9a76e9f70ae49a9420d2323b5682acff260b672165ce9f5ad806ba3ea8da61a0ed246473b6c2858eed6942981755d4323d0506ae797dad702480b5146faf8e530e19bf7b2c6c591a1a8b6c2fbc7dca10d6bcd88a179f485cb032b772fd191e38d5b3da4e26c4a2ed044a5d1f6bc3503be811267080a6c5c63543abe9023f4b6e4b6452eeceaea3303a2ecc2228881cefa35b25ecb2c2acb768ffa50bd93b00a55e7a4b9ab7f14c8ed3f22dd5253d748427de7a75b94678f276874e7c8ed2e8535eb445ee7651f79a4b184b8e9e6d68d3c4d4d60899ff906f9a13248a237a727b38ea6d61d136c808f0fa11c21e3257528b1cc1fd8945a2a0a0916edd653b4b266ad0e749c7908c2d085ef52a802646b0720b3724c0363994939fa915e2924a6a639263cf4db7eeb16c8073c473e71034e6fe2d56940653ddb7eeb3e52d4970debf702eae43fe28cbeb87f5011ae22a89ab65da559ca0700f3f085c1faf15a43d0e7e44f48554316414d245905768d1644a28749fb4d83197f2f39ed5da91f531e71e3140615390e4a55fa06b93ef6e42551fdb21ee45d394033f77feb4680362511580236404528252338c1eacc5f3f52d001e38b007f10c24ce8cdeab3d502b488856f18dcb31610c0b35d7bfebca8a31f3542b334fcff13dc83e40375556bf34cf039c256d892a5e94446995ef327588d3ce33d765fa30e55fec98c062deeff5eba708232ed67d196ede1794b422b8561fb0a4750408424e361bde51aacf25358f18a56cb80864ade5744b01f30a079f25aa9f471af09c16b72307232ee9988537e7811af2cac10485d69dadce0c01452dd1727cfb73b8b319c190fb3330d510a8125660d2a5dc7f03603a5d66d2018c3193282d341c62168ed51510d5f5e6c33be3ed711a6d6077f77ed69085813a9017100f435f56a9d8eb198df021aa74f293c401ff9968e26f44f4e7af0a7896464ce1483fc98f2d7cc93a3efe7e8d74434a3cb2ec19e7575ce9c0177d4bf9bd4ad2f5dcaaa757ec45ca9993952e4afc5ab96a6e49c40bf5b1b1a06ab2c5daad82b34eb8cbf7710f72a1beaf822b0772864489c55b5dbddfe721385d824e8879afddc659dc48b6cb3d6e2fb7a028afa252cab07560d0cbac5321b2a14f3607c1c561933ec4fb54bb96643e1ae51258566e9c303571eb1c33a74743c42c7a52210e6e91c2efbdd0858e0fbcb0b02ad719080930f58ac8371761f8a61886c8cc7a3ff5dc6e4bfd2603105c52a613a54165e52daa5faa736967d77bd40530d7760fb8493fda71693d12751ded1c976a19d5be531aab8de73f4f3383e7a60c2f39899b952da2d6e4c3e5c76682b8034a0ac9c9f49977457133e2e12ce9842ceb2035de115692f22c6dda90fddd2c7be56199eec32bb871628737bef94e19432f88c3b5b62791c42ae33f9effe005049a7a5c99cd0bdc21ab670d38bf6ce0eecae1f584895a0e92409db56e9534ba0b9eb33f640acb217bf11b080914103d17fe2f2c95f10667599a35a92b1797f44213acecd4642af7d018bb0dc2478023c412b6bb58557a14b21e1b5e931922dd23cbbc5af52e8b64dc1fad76620bb52ee8181c6810542b6ceba16ef98b17ed79360cc06b0ec1ff175fc5947bad39f6cbb78c2554789c0e7718f3b7cdb4ea94ffd6d832770e14dfb34b5a25f9ca5403a4d8e9f4b1a9364d6abaa2c8949161d874632f3a8a20deb1a96034d7b0c05571a09ac56957ef001778b39052231dfd98ffee3d0763da4e1727f7a777544632d01a62fd261591e4ac9b4acc443745d15195c7a91014d95ada5d442f519aa3c56e7909dce6a372591dc28c6862bccbccd191267a6a221a277bc85f1a37f5a3bedcd765e4846803a986165fc4cd76135c06708eb8dfc7e46d3fcb50d85b7f7f2f052f95a6e8268128f87840d91e645cd8bc02ce2c2a7f0db6b46a952b1cbd18edd380228f1e11ac9e441aa641a3ee5a84912afbeacf7446fca5dd12efeac85fc1ea3d4bcb7ace811391df0d29a4987dc74c6cb019c9f3608d72cd2b22d6a4e41d7fe018a18d4d99c31e4373437ff773f2aca8ae2143adb011241142a7a0f4a4a8af05f2838b6b1501fd9cff90435b13a50ea003ee5473b9933538a0ab25d3f491107d73b28eaf454c5163782d2a676fc6c422a2b933932fc6537c3f790bb3db65d7b7186386dab780d1cc9deed08373408781d15ec24e51ba8db0f900a484bcbb20bb250c6328ba6cff79f870f0af1666de2ab29840f1bb89a3fad20a837fc7b40977842e90a95ac951ffd624b130f1d8524391b79fbc66ec91d7954e89d1809cbb280e7062ab33aceab0a47a70fcc67ba7bc1dd7f6ddbdbf8557078b1576331e6914ae5b571498fe5827ccf49122cfba82d33d08ff01028f233d35beafc38ca914444df63ea2116e37f7ea6ea894fab4a6f6d40106372188f269c50efdf2bc005803a7b8c3c69059f2d66d1d8055ee6e7f592be1901d2cfa773d1286e6791f293385fc4dd3c7fce944b68ecd38df3b9b609e757bd98e218398906f5653ff335be786f61c1951edda0022907b47e408d8e54ffa6000cf2dd2d44cd1307e9fe49266af0d16be6a7d213d1c88c246e2114b313965e008d05f8859feb2533820c482fe91904116bbc4cd2723077364dd463c5cfec9b1fa7d78bf6a689da19928b21466bb2030d4ab198f54025e087e1ded8a98b63c3693c59e3f64070cfbd82b2249cfa8ccf66c9a877b295585c1b4eb926efebc0e984ac8c0fec6c92ea4c84c376cf4853cae4af82c9f1869a015bcbecffe181dd979bbaafd940e6ae2c8948895f6cee64982bb01515410ee73090d2e14442859d3571cc93ef583dbfb6e9eaf686228e0e57a8882d2dc346583ba2e50f430429ec3fad115320c09c7842f143d30d74cab7167af4227aa94534d1407b563c53f4665883fb4388e9a76372bb5c2785ebfda3b456ed4578506a1a2bc7c0b585596c3ca9374e9a8ed467990e7694c73f8b23feb7ef977999f193e1f1daaabaa2fb8798b149f4b8c23763bc72cf2ef92db2959fe3208585c20de4c263da2be675cb5293c4cd97d1eea1cdf1d69e1e4f58eb69d16c55724e8e7421529cf22e30ccd3e18d09e9aca921767dc647dbd55b2eb34b2fff9955fff35fdc5afb7ece6b1b1b216c9ab293543ff4d94e2b80d32d1b08c9782dedfb3f0d73d8038b3191beca20405a4e9358d9f1107fd3c0173cf47890fa3028c121f92a8430884ff2cc5728234e4d969455cf875e28ea28b34930989e1e2670fec44d37e3482c36fb71959f7ba1ffa356cd2dcac3a7ded984203acdb8f3440f61b1659915a3819be71f0c802c1948a6ae904ac6b8063572adbd8e43821e4f7033a5207266d7a051a1e46810363c97fb52b4dcfe3221160f95a8f60633d63dcb731e2cb4ca8bc2a558d110feaa5faaaf67fffc21adc3b21126edb353246ca379481d1bac92518ae949dbc2936f089ac6b018354cb7477ada3f3738dca8266e0db4e908a4ecd479f6fb27e9eaa826f2434b60287d3d8da77edc08185c123c50861f64698d7610859e08ad6af92fe7954d597c7d46442da668dad38372c7b6b5e0bdf96a24f718f50e508b5f78452efa616fc18b082765984a09e221bda65b0d8607c4ec577e5cdbe3ca5a58e2a5da4b35b0d4432a75b87eb4b5a128b3576d94023bb989d9a27024d5a066844cab9b514a9c52acd98d31775ee6c352c1d78f13ab67d91cec7883019951a3ba3a673d3504a85b09c1d4d14365dd3e9bebab61ac742e7a9f98e0200099e56c6e9cf378cbc26fb7ca57e30d4e400e11c8b2f36f3c674b5482c276eb47af1b06a9f012c2ff2cea0ffd0c9aa5ca406638365a1866f6acc8775acf2a9fcb5c824bd13c881ef48008a12bb3041af56c88748795c67e1c7433c13896710e2d1cea49e46c566de81df901af8e250a77e3c965b2bcfb9491ca8d0c00a528be352d5e2e5073296caeadba8de22ca340858017511ed59baa11a340d515a1f681baea4b2895bf585e539b5753e78dcadca45940a420abf67fe67734d75d231e4c6e086a20f31d50473cde464ff2ca6fb6e193afabedcb921cceb740051f380aa4fa77c76383ce6af752d5ce0981da77029ea6d7f40d4cdba1069daf8908c5d387eb39447a0b733cdd3b3a5ccc9ee0cd26725083ff202807870e5e209eb4b8c2f3c0133815d25375f2928803e012f532b162019c8c9ef0955047256fd5f3153104f558c40ddaf5675e6871e41326bb14ef531e0a9135505ef0468a8ebfbe383537a50d846e874d741b5d81d17f49f6945f854029c00a483fa572e4b8f1d76c31bd5ddf62c1493b52d541127706e3b426779b6eb18df5742a919d653512bbd8eb4b2fcbca36d7a05fe1f016085136b6b643c20899c73895ebed39423620fecc69f633ccbb0ec2f0f6bf9386abb7e0eeeee28598ec04b33a38a4f56dcd13612b1dd649568fca0683f9866f8e681992e18a3467412a0b6c677877ddba5fbbfdd25094a432b358ac665e1167fea6cdc55c9613dfc0248f87f9e44753c270af231cf336b41212045f5b5a01fd176d813cc585542e7ee86f6a29eddebeb2b20944c197957db18e6e5fe33aac1286024025d0eccc656467fba00cae56a3b880c1114a68352879373b32b4da2811304be40a9945e35d65c21a945a042d9d47c4d2fb824ff2e681125606eaddf64c0ec5ce7a3d65e4c65acc2f0ebd76dc2820fb5ebc6f29432bad61c3b555e24f462911eb3543fed21344cb7790f05c2ecfea25ca6cf7ecc945a5c24230ae92d05c5389c0fba6500fc4451a95637a1e16bc9185c8df4abaeddf4aebc434a9118c448af1208abb49fbf166adba497950a40671c6c937526ccf45cac71fcc08e96ef83d8c34c24253e529dca59699297e1ba3332c4f6c96b994def3c13c1a25759f15d26eac9ec4d38aec42612bee2c31f4fe4bf2951977e188a73777fa1c38290d179a82efe584f0ec4bed3ef43dd98dc49b97c7f570fe83049c0251eee17a4f1e0f574962ccf401b14cf01b953fa85d03331d614da1b97cbb7e5e81d3d65af924996c7955959059df902a7295a806c599111b5da18157c84066050a13b8bfb9b19ee6b2c911fd5437296655cc628e63c71c7e5fb22a994057cbd779c8196f87d37ea8eb68b16443b1be0a3c6bd21e08020d3ad76f56f94c7e85408e8040de3eca56e3b50bde168a90de153bc94446ff58505834a08f4547f864f84cb5e28a00be9c08b018265e1595ab99af4946b4e7d7c6bf8a7b8382ce42a68c600e7c0fb852e89f349594ef3e87d446fe4f012758030357584a0f421e0d6d13a3b4834e6c41dfcd7dc772232e8f72ed87ec0123138c612508cbe20ac79b7df135c4265b5f5dd4350ff26b06746975da2ce49a7ee4b891ccf5999b8dd5b778972cab1a6aba44e466153dcc01454b0d93a5beb690f7b11816a8bc5047a74fc015a9cc3ec684e9a104137cdf129c276a5424a032bd952dddc08f48358b84128f2d6180e42e99366de84781d9f127d1b222e2bb177f6cceec45366ec8bd2e261db7a3a324a88aceae3d09b04efa72a315deb07850bd8089a60ef1cf982bed3f0c699fc02d96c40383ecff35e0f402a9a3135cb490ffa331d58bee7e5d9e70442e454e712999928475e6dc3d4c3137bf92a3af602ad02cebfb4eb814d2ff665a9b856522a6115143c37843e625645f68dd45951ec4e5d863a2fd67de6d4c63110ff155ecb3eab08f378c9818ea00e34a1c263d3deeddad36b214b0fa7e208b71f749aa26e1c8c9324036f4e249f3899fb5dd6a03fd01beaf6ae3786868ea852674eaa49d7b46586c8f6cced148c1827f8a793a9afb07bed6222b977e698dae05f66ad31b1209029cf08d25b32e802023cd557c3a394c08dc7215de292c716dafafcd95442cedea5f38570f9ff6ce4b3e20483a62c5811376be9e8282b8f9f3c27473d643642a748ecc3fa37f97f8c985bd100872d79f8b37608ab5b9b840a047541a2fb6d436b0c074d672a7a19a103616e74a98d7ad373bb4c3d9916ab5798c8144fd1a3854bb8a3a3555bbfcd18883fe9052e05bc92ec5242fcaa5c2378c7f1b064bc287c8cb7d68b96d8d204b5c98cd719bb18024558e8fec62f9ffe1d2fe600797bc809ce81455531233495a56cf5d1fb61a04ee335ade1e1e0a6081d55f4595f532128a482f6d598baaaefffd00ede84a2856d44e6e9728aebed0d7141aa0fa13dc70e4cf4e1b533359570d2b6471ba794eb6f00655d52a12602a0268a6380af20226096e44a5111614990b38865af59688bef7c2da8c54525007197d0b4df3cc12fc033e47a5de05078688cb7e6573ec72fba9d4c0a361f8629bcab600f92d9f4e4e7d9cb3580e2f32fbaf8b8ab59fc4032932abc405b788ff49b64f9c35a7b6896ffa30107c9c7c571e3dc18683bf804040076c4ff125cabb273c96f215fe5539a07b06e7b16f7463b78f3b82152bdd7a18d1b15a665cdbb96b2a3256959d4fea027f56ee0039a95967691991cc6bd6fc68d5bf181f44c54518ecead3e6e10d4ec219ef9a9168004a2d291722efd4475e274735c6bed1629eb8d51a932c008d0173ac56a5aba59688dd7c173aa030adcd535c54858cf53fb3df3780a71f46e5deb4897badcd71472cb2e8635ec17b2a0e4817eb8d656a4419111734ef81cdcc19d07e10f406eb9d7e7d676590161895600cc993ab2e89fed43edd6d1da71c825c4be808c8e85097f19531415fa5eaaf907ed0037e2325227d1d50ab0b1ed14cfdb0c0369796111ba21703072834b5c8da3a0e487b8ccd4441ee51d259c2a19eb7b605e9668157e274d4daad0065544cab7c9526e943153111a8a05d5b5d5a15fd3e56f78ae398a3ee2aeadfebe4a9105037a8e5630a49ff0f2bddfb16b3daed292d90fc2b2f10041e8998ad85cc7a664ee48d25f4142e5498309a0220bc09a06db2bdabe67aa187538f6440d6fba3271797c3acdabca150342e51405bf632f62656172ccc1f1a738ccdba9fbdbd793b02c570cf39e610aeb7a41a806e1be2a47205793f2823d7933b61b49a6de3f32f702eb6b72ffd6e5626d6ff17e7e5e5af5cdd1cb2cf5c85489fa590d29d21497898e6447f67fb5c30137dee26b9f2f1279bb0903cde18091c25a3fb87a8b06ecc88faf745a1a733cb660351b3de80210bfc739ed1763dcb8134f1293a3674a8e8f8afc60f5f5b657efb67da5f2270ed586e3819a006909e43ca4d02a072329e7aaf01b753ce4425378e774c568b7d421fc9a48f755f4b4dcbde7032f763fc0571091d2cb0cd46be72009f9f8efd5b474fb1cc6c72fa160349bb014d7efac15bc6275b1775aae92215099e16b675924e7de7cab3e9604479d324626942bcf90ce273414c2fe2313264a67c5edc43fc2fa7441618aebbb1ad47f605b99c25e303769357d16558137bee555e4e46e38c57a6ba6f1cbf531000a94b0bb34f7878285e0c93fdc6201e10856d4a7268f618eb5523ce65e78f6463551f1a670fe8cc4d3c7056cadf4bd0739ea53c55101c76d19b65f9fa9983f13b3dee8578c57be9d05f95244a785b72948a211a36ed3eb1c91ee2b2fdb02411d4314f7c407214a8dcaf59817245d8611605826f303070e5d096f883caefd555e5d37b89822f2e37a19a837b9cf981a88a4482b5996237b2d817d04ce7176a046759f8ceb180bf695364e60a6979e14efe13b8f3f0e816b8b5698103309176d369eae4198d44d40b3ae1b3d85c87a95309cc41161a8a338c8485d828bfb3c6355a698616da0387508947a2f14cf4e959b21b3a612fae65fc0d51337df6dbb515bd9b3a689d9a944a508672d348528b066c4ef867e5daa2ef6daf33da113abbbab133d4174944fa051b92dac7229cfaec2058d5432bfa0c3e76b5fc5100a5a21eadf30534c824f9c8b7736b499b38f8cdf55d37b06a6e2836c1ae389bb0d7243e0a79bb9605090ab1e52ea674a3b64bcc9a7aa71eb50a9d21776118d010dea2d7cb12318c46d8e75f3b12b181a4552555a09f65217c4604631c9055f15b96b8cd0fe62bd83753fe3fe7a351a82f04c882fc1e53e10c312587c6f1b4fe3f4f2d5e950aa08ad3c0453bfca7941bc122ea93740c600340e27eb835567bc200e764a5bcd2aaf5f6e095192c5afbefad4d9388f8cc9e8ff206560a898ab37af44fe89400bd6d32cb6a7459414b3c68963377fb8ef78c2fcf4d08ac4b0fd928d51638f2ba02f86486e62b24b8e8dd7f2dc8f071e0cf8e9d23e78c4acc51594467174e34f8998a0d30fabe26fccf2760448a6b5d5f71ef86d50e349a949d2cb4763a5831af762bb98a6493c151975224c3175c372870de3123c40f93d9b0328c2f7486f388f9c923b71fd57dd48da8517e1e81c44d8d935750a2aa1adef0dba518638cdfe9cb46e4e185b9ad289bad1e5d1274cb13291fd00c4964fb68138134887a2ec519b62984b97f318d96303f639f9d2078eb9c5a0eb3a14ee045e9826e8673f12ea0caf56a8a0d701e3e767602d168f0ebf7bc7ca36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
