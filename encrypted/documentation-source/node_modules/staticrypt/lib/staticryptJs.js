<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6345601d2bccf4d7ea10a8a5d4db29cbe432451c7da842a39595ee786737246c47a9146369272b1f7ec90e4340dadf4cb20304ebcbd10b684e9b6e12fd5ef27414c52ee47c0e977868a0d2c84e0ad7180dec5debac41135460c624ed9e40d3abfb2b95d5eb3283111fa674ddc11a91b6a09f42b4d63a42e96075f94d0012907ad519dbbe705637f4c306cddd6ad540c76329b455bfe136a4482bc3c736068dc90dacb40e800fd73f835f4fed9c41098d49d919ce0ed0b6df6cb108e7bda7a2483f51831d1ad3b36935c974a430dd5f4cc80ad8a64f4c7e58af6cc72e8beea34869f4898702bf0d84a1bbd85212d749544d55ca999c06e0d735dd6e7de2eff77ae73eada0d6fe8958d257dfbd3fa0f89b86b3be2314ec3d82c6fead0cafe4873d1275681a59bb2a46e4c1f29fa577caa6b936c958269d62527b26ec057189797d352f0e6a2542c74f03ff5c418c640dbe314006f115759a1e3b14e18d0ddf39b0d521d324694242b1d69623185bdddfeb52f7d58a96ba1c4307937e412d8e3e1e7ab9f2ded3a97740e29c3364b0dc73730d7b7ae3adf89263a41508bdf67050a1db7cad8e04e1f8521de2a9069d7acad243189faeb7cb0c47ac349431605a5341c1b1d63f361f33c320c7f0a9dffc97d199f906a7cfd55ac8120408d6315a4ab988905f97176d37b8d4277496e8638a3ac248239d6104d27347afdbe1e570dd78b074698ce4b4abb35bc05eccbbb0287b5c3536d8b05ba34c36a3c65475b627b50ee342cf07c61387077a7d148413f2480dedc0fcf350294642cb35811c676b0a84bf5e3d14852b3e9fd7f3e2e5841381bd553c6ba1015f57b435958c6457b89345ac8907f3e9403f960a0793928bc249235399285c4dcbe41c2c87be6b281a328be206d8ea4f563c397cf7c0cd50752b579fde69e12417edd6cdf6f40a54ea8a92eb6d1708a547d37946b15bd4e95d814d5f0b399fb24d32d61865a9a6708dffc6283c9db514144455a7130fc00c4980b609f7f117f7f89a0965833e5f24c59cfb8c7140ddfdebb92b15beaba5505090f6e9a3499e737511e69de94f054d7b3456becfbe52d83ecb5f757182b52128610c399a3d36e4a24b52ad00969d7a8fb1b89a7882f5ea4250b72f41df61c4028f424b3c90f3fc642b6ca82a9f9ea1c08ca391ff4482ddbf33defa98b4980ba22917ac98d5fa9ecd9af176d12b248d4b80a2ad03ce422349e850613b054f166b563d4e9aa42d60a903c8749fd1ebe01aeb149ff93c2d65f8fba1c4653343df2e8caed5650807e89fb13e22bdd03e4e816ad6520da6d2596f91a3b4f82c8da2a52f482f6d5bd6232507e9e0f7f8191c2880daeae5fcb6fa26dabb7578c172db1db1ec7e55e0b11f7b328da70b1feb0ca885c4076d01a9afad2cbcbf73298a6899e005107722a824d53e21a6438aebbf2e3548113df06e3d38617fded63239329394fbf34cffdb2afe7e0e51d94d06e003eb996a51cf7d2a50c674cb4f52331bb6900bc38ddae8abe5901ee53662ab6f42e58a7f049dd9c7452825974351a98ab9366bdd0ed3efca0bc46d0bfc2977bb745addc18cc033b8a50eeb8c67971be78e9eba2cb962c5f95651e9259205ed8b4349095ea0c9eabbd13e721540cea6dbfde6cf5e922e44db1d1661a8a6d235068c97c18a87bf5f1395218bfb487f63ada6b972933e410cb5dced25df55581fdc44d0f6910d924e02c57773969702af9e6e9bf92ba43626ee94f170d75d4362c1996fa77c7b5aed910b7b23ee2067ffd5d42991a3c926b9cb8115288c32fc3ab1b9e290afd6d63c5d0aa69576ba6701495b0099916cce892ce0658a1eb144a1709265c77f93bc037be076da08a9c799e3f55e42ce8a0f54b07236a266b0eb9822a47c39b2e27df1271ef3b037857602b7d187fdd6eeae4267378e3bd9b3c025b560da917d989cd26c05d4cf86f685ffb2cb87fc11888b2977c53406f42ae5ddb58d74c8a765c1c2c9ec70e2017cdbc459cda200e78a452fbc6be7d232b97d47bfc35f1736a824ff6389b807576c68807bdb6ed902011968bebf3530eb72825d1fa3637f950f9bcb7eba7e3c775dc98c0e9a1ccb7f4fe1e892e22a4521f0914599c70fea450f6a6d49bf613cb1e05df66b97caa8810883dbf8e02ae14f6ee1acd4eff47ba7929cb5485bd5e7afe25696933f3ee4dab1ca5ae3afab4c1e118b16dc85d9e2a0d5deece23f79c904e1d369b27c844402879a6fbed4cfa0ff3c82c09d5c42a37f160aa4016a65fdebb8c86aa278d193243141ecfcfdd7e6669f22bc5944f0d5bb1eb5e3792c38da272da5bb6ec5093351d2f7b3a3bcb0247e726d1f343c9a4fa3ee4d191ead03747f64fbe9ad218942538b86b51059b8bc08d55f7fb5845bedbf787da39dea117c93ceefe5df86ddb57d346491ffae22b408acbc9c7236e5e26ebd4fb532217e27f5d993eac8add63ef585b826430795fc2dd5d1f0851b8d1ec7bf816f191ab36687442540b15d6ce25d1cd3cd7923306cd6e813dc4cd95848554b12f903c11e49fff2b548e7d8d89c0c2976efdff0a2114e99e5251bea2c43476b0c6724c6e3e9010d9f2cc57b3cfbd5d60723158e2807dad78ccddbe09621f7a2d32c0129dd9433fa8fe2a461b8d6c1af4cd10e19994840d4da010820b4f7233d6793f60081147be7eca1ce2c6d64541dacea01babd0500a7dd0dbcf9f6041a813ee02c9739b16643428e1b893e9b387ae20120f811a59db020787b9a0eb95d17d2271c927ad3eae55a4380c98f49c5f8867fb06d5d6534d02adffcf201b4d5610f6bc725b6dcb7e4efd023ec371db64becc8593fb1e647e6ddb1b14a7d088578b86a7d7245dac8ce036f2beb8197349b6c60b1bb060f21ab80d9b7cb0e3b04883ff53151c14693f5e9adb013657ccbd4c347576163611c8db07ac10c7b06edc3c60410f49aa6e3fd5cfff2725a20bb4cc8cb62221c0f0618d6db7d5302774ba79254ab167d4d8ee6da5fef16b8cc5754e2c1b0079703391812230af245bfc51f5930d53ac39c73b5f072a168dd6b0f649eaa7096215afcbbca94a485498644dd27446abd531d60c7a576ae7d640be449da6de7b200f18e4d6d21fea2928fdf15844c45b567a6d08bde54c24e56617c7f8f3a50e7db24c03a753d9a0818b1c894189aeb6aac4068bb841395177907b2fdeb84c57e2a49bdeaf0fd3162378cdfda9b0a6396e70d1d1e476eb47c8eab43f990d2d3bb484b3d679c8e5caf83694c891075d08e7cff6793c3624066c5bba6a9dbdb3ff6fdc73eb40a3874497dfabb0dc29cf131e96b29208d1b899595c591f157486bf384ac6b7ef653b1f27a1aee3ed14c3fd3a8fa1f63fd7ecb1ef22824fe8ce3a2b3c359118cbececd552b1936725892dfc760d3f104ae2859b97f926b2809e8a905dd272b41f71ee5ef58fafb3d9dfa6143867abb644798bec8e695f2908218c95e59b7da4623bb6ed864ae16768ac4992feaee536d237b8594c123f59d10e53dbb3f863c2cddbd8a961ae2da71466d483550c8a54c7ac433843047a36d3596368627ae892e93191f91a33219e4fa77f8a0fd46acb0913925f0b35991bdb0c78c4af578ea17c300e68fc01791a749df7845d87dc8f7ba55a2d06d75648022a20e409c4d831c3552dc641059a8af768d27d4cfaee38523ef848186174f2c762ae574770f1720533e91d70d40bfa658fd56b272bcb173c1f7057721fe5312510bfb8481432336e8cb6cfffe997d95dee9523f26fed7caf1ff5b84f9bd57baf6b21837544a1466d2b8e398084cc6f0f7e31410d7c72e21b94744412af8b4c666247dbf89aeac36f08a6b1fdd3aa44d6bf5831831684505d6bbccd47c5e3519dc9a166808bcdb7ab969dcbc9ae79743caa8be0f680b7630487a6a236991cb1e19f9e789f29cd9168380eba7333fb6d09454f2a9596ba9120bdcb865369ae0f538d9fd682c0de004d9c492654b3959d9ba314c9088ec9ac42fb71533a263dc3b025aee081f7e3a4f5eadd197d58efa1c9531f3a7d8c63e0a7bf2017b429e84b9ad071722002283ab1208b8f535a469c6660b29d1937134c48997933c2188f86a517932c7e38e5787d66fade6ac4bd6fc0d7b1f7e8b5845ddf021803f52b71ea3558158b727093b860c6cf52a7a2004cddd3e398126c53bd880932bc8427be1f585bdaab0f34d7bedac6cf9acfabecf9a15d090051d9ddc5fd408ad6fe98d246ff9415f69d48cfd95f4115c94596da9d2f4d212577eb0538427a373256915098a693e4359b20d3fd126a3ebb29e477c3e445ac13ada1872d3811c17bf94ddafdbeb6d25711111805fc8c4c89aec3b066c76c589a926c70ae580059d303ba5cd476a4bc6ca2339ecba29669d3b54c0bd2d73b41be3f1806241929345370467a4e0622ad0bdbad2459804d8c2d98c826bdfee65d6efe3333d27b18f0ac7d60af0b9024082a1007ba6ca4390e2654608e963c7bf35672cf9e24c37c78814bbfd1304b2334e72ce6789ac4e753332d255f2e29fed8eaea78264588757f1360cfa1b7abe7f6fb99515bfbbbe2325d8d25a7fff33eaeb5017618ab0780c2de4ec443c7f6f9e4d276017275f7105104d1bef8146f6dd7f5c33327051a35e14f0516720ec2dcfbe9c387476eb4f8d513c532be4066391e7dfb5ceea72c3eabcb9e91ca213bef13bd59e1c4e0869da850dab7913fae34459a3cfd5eff6c2127613407aab369ce91168e990e226b5cc96a31eb805c83524f2b9466988c0bd54c11dfaaf60c3299d1abd2619fc72813b19c5e17467fb30716600b742d60a3c9b89f71e76b9b7989fa642915a6673f05ae203b0e26421bbc100573fd63803e746e29cc55d980cd73b55245d80d42b57bc82e098745f94e812f02fe22ba453bc1504a31c4ffcfad1f801735ffba7fd53e767f7bcbb33f86385d7cca814f7a310b69251cfa757a459fcf41fb67ccf061fe09c93109fc75f1a67445c8f16c25226676814a18332106d7e4c6a77f24ef1a75d7cdee9f2b5ee1ce2235da5859a8d1379b69e2a5990bbf6869ef574937099539faca05a4cb337c3d9004f3d3857d79890aff12511e533d69d892bd07b8a598e00d56b11f56607cc0f7f3ce8d100f9d54395b29a9ece2db35cb783a59b33879bd169cd806afe383da4b096d3391773b5da40f7fe6dd92a759b12d4dc71471d84cec441cbd81b046037e9210ac04caad00f0f28812698149cf8a4c5f1efee4a1afc941a96f65288e4774b71e8bf49fd934adc36ab91c9a6b8c70f5633a41cfe913c47b1c37240cf021efc86ec2d1f02f55d49959c2c33d2bb012ef90e62f176632d7d4acf2d254eaa32ac9bfbad7f966c062188d453b15c2df050c452e51d4627c00a841c80719f724e5962aeae1020c2eb30fcf9655159b1df5542cbd96f0972e3d8607840725cfdac70d89c37929868b5bb38df0ada54ee6528a3218c368f102218a1b0a6c9c864c6119bf91ce9a70b9266f828d801650b7de881a4d60de3e5910aa2690561277f06731e76338f2265fa001f4861291f5444754788be6fe1aa9a25908efae7884d65fef7f3ed7caac4f56d54bf59b7266374c7530bd13cb3aba5828a0c9f040b97a237323bdaef00f1ffb13c87e3592dc3357a5086ee4d82ab419dd7323024b15dfdcbe83f59e86d5ae6b1e1e7d4751e4a3f6cd3db875184962c5419932f5ba78d3d3e481a20dd0b26f4b4a48ca6cc01ffafa7981838b11478013939bd24e580ebd69e48451241a01cd1d3c42f4eb322e7b6addb04f5ae43dc3ea32c55d496b0b94a84b36e4ced77087d64adf844c1bbc8b32c23c30284ddcba921318f9688d5ef8759b5ec0e1d22e732f4198fb0ebdfa25f403612b7f69682dd6943e3d411acdc6f8c2eff2bd695919cc7283d175dab2a71180db5248c8a3c2d2259e2b24fefc842462f9d394db4a95a775f26aa497b62322689fa9564bd946bb009f254b515fde505bd3390dfbacd28c4a76debdafd9aa1b680d4003a52444e41336ca6ad8515d8fb6b88723b059a536f5e501e76dd6666961cb482768d383271f68b22f84104227478df628c60891393c2fae08467948756dbc8563707b0ffd62351252558f50550f84a2ee662744aca1cd62aef5766845b755420174413b11441820aa301166df1608da00cc8d8b06784c602cb7a03034d551a496580879600a982bba4f3e96ed40df2814206402434a7951cf9a6a9d44a9618bca123a8494c61af2e771877df02c3ef954b4dc5b2d082236cd72bb9955b089944a0fc8a9fe4a147607b558bae0663e9b60165e569bed4b4ab78d7108eb84b07c5b2f86fda69a45e1a5cc8e1fca17aaa175dcd0dc04ed6f1aa9627e150f38ed0dac6d10530a6480f6d07672b97c93573c340c1a49bb7797600cf9fe08075ec5a11e28d5e783f78ec1c6630a47573d41990f1c2ad4cdeab46bfa83155f4536347c012f5fb34c0df20446f884eb74db3c0ed498220583de6fd75de615111d7fa8183a9b7200e164e3e32d054bda84c280c72bb0790a2598c337265efc34175bed76df1352b4635786ec932c7505cab036a0f50fad3f40c5a1f87e5ff18164a802a4dad75519f9e7d2842db5a4877590d8ee199cef2793ed1bf5f17f71f83d3685cb9ccb868e48c87c20d3ca1421821c5eaf1c887e4893e60c57a0459b482415825d8fbf5bdc0d86ab3c3de7cc1a3ef5cbe43ee0689c71f229b6ec241208425d5187c4617ba3c74fea1d476f465a2632adab476915f963b185ec63dcb44ba25554baf5d958252ea83f22fc55b9d40c5c919e45dad689ed435d1c24d53979e492c0674584a42268252d618c0169f982194d2054fe3b68ad08584a9129d25473c7c056ea3a475590bbd50af6a60482f434b9369ad784d753b39f57a13632218a872982790c3e0001e90c30d8072d0c38d80e1b5a42e467eba219d7e53d907742d1f0f1ee0e1042f9901c500edef56ebc3d6f6838ac6c13c223e334c0dc49fd3b78205ed2a2b3570b0d6687d6ba23c1950fbb39e023464788fc40dd84b16c3f7e6a97bcd52b95fb06938013dac4f85c1f8b87589daac62a8bb0a020fb5eb8853080adc489ab3ed19cf58434b3b987da531b32da853f213a4b9e6e32a0a2e55fb0d9272bfee6f293f858e98f7631e48fbfb9cc4cb56dd192e8479000660ee1276632179919e8b074dd1b743446d4823514a23e6c4ad430636408de902e4fae7996cc28b31d6efdae539452161ab0f85e494ab84a401a01365e1f836607ff7430191c776a25623b29e9cf3cfa4e2295935ad45dd0c7ff3e022a74724f68700c5586a7cdccfa3d23cb0271f6c2194a92faee690c9d5531c770f20ed8a1a585527bfbba4f0f9b9c541b5d4e27d7440ffe41b89e88647b429b53f17b3068d34c6eec2776e055bdd1b47b3ada831e4799f411397beb2afd4c0b288e51043465e0c16ec34e694067420543ee68a8b25927f62b28985bb6ba0a1f0a299b4aa535f5be9ff946b3e23177b53a1b7a5de65562c791944ad89e0eab3a6bcfbc21df3ea0898770c92cca51a499a886c6532165aff88718d553333ca926b89654425b24a5613ae870f3ba4dd91c3447fdc9b47ede3365ca4fe3d337344082847989dc84eb5befa3e9b20041f9784ef64786468585d922cb1aba3f47c135d0ce82838e2cb51a80b82fb538d586882b2007f7e02e8d1765c9468debfec7bbb8f98ebc42e346d119d2f04e8b6fe02c3e0f8e70c5bec3933f8cd37042134616d9ae5a609eab860e9be7474249d485a6b7bc9269b47e6c6f30aa99143fc09af513a5cd9ba0632223842267467d983e20944105ca84b4dce8c76f44f4f560e72d82e8960a97bc1aff13b451412c0cd0fb20f6e5e1de6a818a5dc4739a3f39236489fe98f03730ff3574007d882ec96bb0bfd6cfefe5d66962f17a96fae4dfa29318259410f536295b59604592a7d6d90dd7d593895bb5f8a34e6381b4db0f458ad7430906199689dc8bd3b099136caa1524a35a7f2cb79d3593a5f7092ffd062687d340c936e042e52eb5a0e5a23094c75d9bb1c0c8803ddd4419a54a60f070eb2f9be54b67aaf364c31f4337ee235cd7cbd117d47cf7bf912d4b9138320017ad78d0b5346cefd9e0fa4c382a3dd5a0475829741996db0b6b4090a58b8f6744e9c4cf167e9f14c1f5e09b0e58b71abe85c6ec8af5d778101de5ec1916780d92035be00fce483edb9bbe938e7bb37d7b41da8342e1ad0a9efbe7865f23dd3e7547bc3fbbe94be3e430178e7f1636be5b5f3e156fb8b205bd116f2b0fc2d0803257db9d8db055334f1cf9c65198dd26ad086f05c05bd28ebdfa1d285a2dc05abfcc2f65773e1f766c879dae39b8d338c40010fc554cb4a1dc4efcf931b209ab6276dba61504f96355908c766ecd1adb7e36f16b746d7a5521cb24fbfb9bce558df1fef5a7844260c06c84b06c14b487a1643d035fdff313d2553a48749585068c3ca988072caef5149cc384f12be6cfbdb4102123a02a22006acfcaa93aad39a3900fad4e1a62b2edf4d237286306d2d58b3695ed24458ca83bd51304bd01ffbda5c98faaee36245dab74b1ad29ee9c3114fc4577b81fb899ea6c53b1668c0ab6ea65063a5d6ad4963044d48ebcfc21f2ad1084a836daeb567646af3f179bcc5ca5836b0c3ead6cc2c28f006d5007dc0ef6682ab6d6afe57b8b5c22816ae4232b50cd8b373879bd6f328c42aaede632bd1878744444242a85e9ecaf8f212f028d8954b7e64f9505c0890b2b7d502abf5d359f77577c09cceb560e1cd3fb0e36e20e5ac5df4ff06f93c17494965ec925068925ad874bd14acb25562098fd5762172318ecc2602d447e7086bb2de666bfe79a66da332c1bd12b99c7e112588b706ff2002f6128e36a1ab27edbb17aa543c6605b0edbf3d4b6a27f5659225ceb75ae657d51aacf23d7a71377d8065b021b3d3db7028098edca3790ad850926084376ae3ee2f564bb3fa66e9c0403277b206205dfd155a745756d79e3aae99aebc2c767f5212d10d32142c966aaf3b3fc93a755f4b783e731b41fe3817a424fc525430a1f00241999793ccc44322b13c08cedef2c5c5d405be454c61c308c0e9418dc6b3d5c41846c7e8a1fa00efefaaa3444fedfccbf2aa29ed51c02f007ad7fd5b078b3df300f14afe73e5cb6c27ffdbde26560bedf69c6f7fb5018fd7295ea8bbc193c2018106256a7d3cbf5dbc7e2af7251f11d539945ebc5ba20b9b43006d9be905093d43727a484c15d64e19bc6cbd87414f35f81a912d7da5a34f4cd5396e8a9f039f7cd0f8e856259b788a7f88e14d4fd798f2611dcc924368905496d54d36dfa4b2069ae67680cff92bd629a69d41aa5b547ffff177d8572b691bbb389e5626be678633ebdf745702fac36a4e0d5b176da47e36f8b4a7c2209d6e6384f5a5594e57ca2f58116b8c8440fdf046ca4f69353b431b0137206b538761bf15189afbcfcd179dfab0fa0a7f707508ace7588d2333b84fa510a4eeb2908a07e4b3807210e82cdc1dc2e2d2396fe3320899c0dfdc73c94e9a43e17dbe7756582cdcb42219df2b6bcf30f523ba18ff2d5127b337aa7da138acb14375cecdd63b422e6c4e5a6b9ad8b4de329aa6f08eead39adc583cf2a12f03747285185fc699848a45eef42ca92c8926c441a7b2864c79443f44df6a341488f75790d59b85888d8a9f8fb35908fe59e3f9da355075605dff32ab31385843b2f9855aaa0362793cb8decd1bf836d14a61b3557201b9d2b5f286c201d134cca76c0b4abf14b33bf4ee78d09280d2bf2e457f192b73cfe256724e6fdad06900fd03c3aa43d0851dd8f5bd4ff28e676a1c1064a510ea3d0666c058f73dd2bd05a2d6075fdd86a1f3aee29ce8218149dd5d45679ae980b3af65a278dceb1befd36a457df8ed544b44c6d1429359a293f4f14f43a477d842c20fed30a4fb12900efeb21dcf6ef7041662bdb4a4249745b9f73dd9c4d163f1974be17710b9840e19eac6646898242483dcc9ae328fd5533399e92d5166251ac93b2a391bb8f980ec9fc111fb03949fbdad2f56e9083749a13a2af10bfd940d02a80feae427755971f4b4e90ab4e90d25b6474243374d4b4cedd34845b228dcc52a059495ef18900a4ace1eee0ccf5fb9eb67c7a8f21161ae7c1357c0fd403c7e18a051c129a0e4ecfa5afabe113c118ba0d3318f092058e0d4520e91ea84e48b4caeb532c9d57e8385f814367f635ba2dbd0bbb9ca72a47714ea2b5c95bf5ded94bdec8a67dfaf97a9c8a71710104d5fff8d55fe4733d016cb0efc98f9c4af7e11e84de6c9571f066b85b261a50c5168fb54eacee9eba8c387379b73c08e5e00d4201d17605c57c5887310938ffcdd56583afa7809d2a51c05dac958551f3326b2c84f90cd0298b78e3525e69fd0e7bd9f8090e33c7712320559cda99e6b62118977914c20a82a3bbe2040656316a66491647ae7c2d7c519dacc3b7217ee19be945593659192b2e70cdbae319ead4d40959dd1b405238f88398e9d280b588f68635e38615e8cb1bb1762282477850739012b5270d32d5a4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
