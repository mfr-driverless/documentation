<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"852b3c0cd24ed9c5724d4a8cf5b56e75757eaae0df66cbd76b78ff3599f923946826c4d9e1921ad52f04968b376fbf0f6105ad8adf5285b019eabb916ae78d1ce9a9a6a58716fef932035b5606ff453f72ff86f84e46108192db7fc1faac7ebd277069b8a34aa774a6b2dade9bd4e9b74c671851fba7d88683a5ff98dc613ac23c8c2592aeedaf846cd563a63269d337eee4401844874815c26d9a85e483f32a051b8df8a5f186fd5ad5c46fb8ba64c27c1f01eb3f4573105febf92655999062a12b7d1d0e80c91797751fc6b4b92688fc2251f023b2769832547b87bac2dc321b45a35ffaf084b0d6e668670172e95701de648f24b3790e88b4f3140bd9723a796e2f700749666108acae969196c511c28f60132353f26cbccb826e40cb53e422ea876f27d3fd75bb15bd32284d4718e5ff7e38026f00e065cf6a4023f9e068380a53151473bc811ecd4775493b49e23fad17844a3b6bd9f037c06bbc44f44d7179f7424788b134714a1358dbc3a1648092c79eed8cf49b800a846611b30362709d9b5f39b80461ffc7eca57d770b659126b6fc77d586140fc6f688203cf1241ff62a04a7b0cb46f6b375ffa4bd3ae9d08cb8413ef63f72875ad1b0e7cc92972e3a9a7e7199624b4042fe679c4a8cdb856dc4cfb9755508c16106d0dddd5caab529d1b8cd5fb9143660fa36a282a6d4493fc7ffe7bffbc24a0e98539470560e8fee44949d4f16387dd23f7bcb43b694bc917df94623758336c2fc47b88c7e6930e34f25ed4f05a7766c2de8b15b3aeceb2fbd7166db92c7602202496559ef1455ab6b06989d2e69cfd9cffeebc53e4728f857767890af886300dd5c0d6c4d39836d78eb858ba64e9651e7dcf4715f33f41ec97e78d5d9b6da3c381d88f6b85bd33c8206586990ed707574d71752fcb879616343f461bc6f633f4a4360899194533632d32fa8927aa103b973c91f5096dcb3a3d0537e3e83c80a16e0cea1d19c7d3ce42464123aba09624cd958b8529c2ee447eeb316a1ebb1595322b55c1d0d5b47e84733ad0ab31410cb9bc82739dc6add787c1047cc830eb987adb6dc7093d9b4160153429b87283af4723f51d9485624a40cd7812986c51ed849f8a184ed269b3a8ad63961b3a841f1f3259d9334bf8f964ce480bcd545dda28ec51d5dd898e65270bdabe211d52b36490e91120d52e9e068699abf570648b2ddc8de726ffde126fa73510d7e9af3a16ab3151256df9ae31d9e64700dbb8c327ed1bd03c9066124fef238d80bf8221ae7d3298060a838c2fb6f3a4b7d467f4144af67fae16321f23b47d5df4c5b938b891b522997845051918d471ebd106fe0437f6505be8c26570329727ce8cd0b52fb35c60ec224868a3bfd5d26fdf6c1e47dbf71721e74663f24b4ff8b0cd0feb17f6483260e514e80612e0fe5ce82bb0cb08a4833877043a8e4843ce93195549caff9d2e67b604435feca65e788a968810a9a30c3394974a0405596a354186db7eb5936f81b4f480bffaaa1679011dc9b06036d29847f7ef2e0593a043d8ba0d8e96a0dde16026cee765d70ba888f1ded4dace154b10a0ddfb908ade0ea75b351f8898a945cc0a2b29173043ab5a33622717f60e3e999b965cd1295e088a23833057b3e7d624a5bf3372e023170108cf22d500f9c6526bc348638cbb7db021b9d959215826e420cc90843bb5f75e4c37af43cc80a8207024bc03946e69151ad4876d2745dabce4e08b701f7c96907547b7bcce372dc30af34da3ce83db99e5d01d596696f4dda8965ad9b80b0935c2eb2a7f32f35f5dd39de35766716aa3c84a5630ab8eafa363971f1b346f0e7fd5d09cac4c64e0611253968cc6dfa6a728707c8549f7b468084178ad4894fefbf5997ccca93f866940868db458da543e962af47903069a8bc884fa21b54672ecd320c335bc4b45f21a43445983394a06b82bb55281b093c436d7c46fa89c7a900829af1707e6133c6aa804f274e04f6cd72e82f18252b287bb389b2ed49b0fde70d6260dec981da914a53aa02f5bd333872151b4ced1fe9827eaf8b41aeed654f54a2a14f33b10a97716c82ba342fbe632a71dd41dbdf6db5f301b36d9dbb8f2b7291f167ea999a3c6008684e8db72809fd6c6bd17275973c98f57455811ccce67cf8e4bb2dc04c268b472a03e6df77c44f59d5beec20626e960ac2704f15af0638b8670c434851317a12e25cf674d6b5db7d58bb2679ff9735814fd68408de6a6e0d838e3f3a6351c8e6b228a3d9a5d32861b9bdc99e15412b101d5e08cffac664d4f5ad43b476af96a0bafed830e96c2272b61cf1194835a5cff245a9f7466194f00c775526aed877a2100dd3636edf3794bd8ed0d3ddafdc7628d4c7a9edc5b21dcbd529923b2ae3847a400f07270a1f25d3e6fca62805e94b794e359d6dd63e237823f156c6d5ea43953cde94f19c49802ca8e2ced2288e92cfd9492168dc096313d71c96fbc1bb6176e9bd14d347d912bf0fbb10577375bc0955120010ae46b0cf685104c76d5124bf826d82c1f8a3571d68f03474299bbc686532480ee32d679002414e5ff6886bad35a36e18eb5262d176ce461b23188a1826ea2a410640f3af49637752e7a3983b5cd4127e793886e5dc9b325bbeac7dcd9ba0671bf9cf3a5a077539c760cd488af80609dfee4bdcfa5b1e540be2f748b465b2c832ed2d4e122cc3a5f1577b9d15d301c5074d204c0b1be7e88dc1b9ed99a5008bb7e7f08eb9908fae7713e9df1f6aca491401912acd784212681f7f5d4475ccbb36af180beecff529bd5bfb3d6f9f9b2e603301ad3ceee32a7a99fa49b8701ed96394f71c8a1279772c51c24c3b0a22ca45c04ea7b9acfb7d8a5c6b6f859e64c13feb645b0de4271ad3d55233b4c8d9da8199a4ab37911861a6133dc9e77dd20a780f4787c2c643c4c51c96b3aa3268d7cf217fc3637de91a60e09d4488885abd3e9f4a3ab4b86f55f3ec190e44d1f9257e49a84b5d807b3e196c017f9d2582e5896490a47d5c5dd0854343839bace09dafbac20fe0c607b992eb938a263e35fc9e35732112183577a92aec6eb37728c98fcf1a9e3881b0473ed60aa0b81c49b58e7f2e151ba92a4dc0cc7b3fa31d558ad9b338488ed75eec915719ebdcc98d83bed4dd55726aba6e2f42dd36c44830335f0680197119a57f14838d4f894473dbee3d57c358fa00f25951fe073896e09365655c553f341d7b0f258aa9c673152a8d66e7bdfcb319d819abec86a477d8a6646bb4d11f20f8383f2f4157b6dc7181806c2723902f479395c350ffdc7a5147d2be5cad87f3b6dbc067f17c57277c816b68bcb078e42dbdc334d6973952d473440e25337a22e73d8fc7f392d0a06c5d73ca0b6d693fdf258ce6daf1957248aa8a38bdf4b3be43384ce068821dfdb222d0849d5b164a296508cf9c673d14c6d86dc95aaeefedc097d624425e2cb8657b9ec013d6afdef8735d78a0e8384f531449b4696545f9b394d9bc81c6e3457d1fe5afc3b22b717395ecb4221dd3e0cfb2dbc316e37c7afa93fe0c03964fcaaa7f4ffb8a43386d5bec43f3c2f21e7949c46c15ec6d941b9a323ddd997fa3ff0e4d48f237efca1582cd6b53523dc39feea853cb8b2b95091c94723c75ffb888b16f5282ad088d6b1bfdcda83d372acccc00b7ba29b016dfcc45b456610ae6c7dd51ae3891d448d70bcce64f4620307446d04f1b3699e1f3190cfa6ab672ae789a65bf6d97aeae48d75dc3888cde3f3aef28263b0352abe541f27a5f74c178e671af9a53fc5a67861b26d84dea2740ad44200d507e5676a88d5e1d998808763f6b7a813a50911444125e8ec4f62df34756cf8d753946ecc4a16c16c7d45dc5891e4d910f211c9efdc755eacd621c9dd1976c6154f9d2184d027cb1b379f779b3addb803bbe8f97faec7cb50f1ee74541ccf35fbae7d55b7214b1d964fc31f6b8f2d70dce49f473a4eadcb9ce96871aec42f2759e9dd8df9815a89f5aff4a25e9d1369895c7857d0f68c5045ffbe2c4779414574ed651473e0df207e910bfa0a0310829c215f5bf9d0dab29dc99b86d3d07e798ffaac9675a3b589ae9d643af4711f982ab63ec76b2e2a53a1564c5d3ea22b407bc023ae19f8d9c3cc88e1a94b6c9d950ab7072d7e9761c2c08b6a8f443b36417a802c4a385a42eb733b202ffd9a5d599d47cb961b6b7b5c91b9a0c6915ac033eaf27b6dc774d520e0044a3b3d5c189a5d631b33fc78edff557b978167800f3009c1cfd25841ccd14bea4c183ddcbe8b4c555add14c347fb9b3f217bb4fd40b2a935d02115d4942063e53024893c4994d7fa1a516365fe0577d91f8428691412499d635a702fa9904aa20b75a79d7d9bece0e628ebdfc7c0f4b910f83667e2ef7460852801fd7bb9db426f7b266abd1511750b3cc6bc4d115b4ac9c04e05c2028908b8026f383218262ff671373e1d8e46336625382b2d94ee398b6c783816b2d85375d4dbda4b63494fa57e9564650fb97bc231bd2905574852c3e68c8af87f511b08fe961d73dd098727bef313b3a89fea102d6a2e8e9ed5df4b816ab37d97279a92a4371979f96fae31c29a242de97e5e61a985cb925c5f39ff74d6b8f7c514aa323d4d4c851838c02a07ac9340feabe27ebc13d2e7deb6b2d97ce2b181dfd4f2ba3666a02e3f1f31849f40789e435a13025241d03fd8d39dcc04e8fe4d0309b719c915fd43a8361cdcf45fee713518d8c59d5daec6f4e42cbae4ba3a37d6e937c3b820d518d84f3d85839d06643c9c7870d2730682a570b53b6b937b7821bbc0e612ad19e8e69591d1a5cea98dc59c1373cb8498fd73501086ac625008c56a6be8911e9c5da158fa2fa688db382075f072cddcdb852277302e33b8078fabcf29c2d19edf344e6fd4b1ad65bf67a2088f1f515fa2859f1325c4f9deb2730f8604ad34ec548e7bfab0a2e036391380a261f3e131f14a2e10829fada092dab80844eb910face5569b452ff2230cb04a6c58574880a7e5b9ae7a3663c9baf74629d9a80d1ab04fa8eeca38f30fe52e1a489b5f7d0ee0a42ced1080a9dda7653102ee65c89323a0167039c61928786ed3c74c4b4d9304dbaffa66cbb11d094a296e24a96c2713d897b1270ff99c83157fbd226c259851423ab218b7b8d5f036a8b50df23f1425c70859c8d96db2af8ce495a79fac65ae4fabff7c8ee0b351bb8231cbcecf382556ba0d0513471e90e045a222883b8063b909e6e41db8fc05ac2439c7d91bdcdb757412d022342334df4bc52706420a48a19062f7a6a2ba54f2a8a0ac25124f791dfffc6eed93fe3c8aaef3d276a8d0dffeda7a2c20dc807783458ef1d993c12c82560d1e5661e015e6da18b45ce9ccd380327bde8c966615842fc5a539273dc2e98473312a20c161e2d42379d16aeb7c3eadbd520f4ab7edf05b27bffafc1592bedba071536d65f696f4d04e64b96f0202ad9041887c71465c63c1bb91c2e378790ee4de57628beac34818c6e12780e9bf9fb557be1dc1e9fa3440f7b3c3c5c6faf65d1a8e8a6b24bcc13a3b76fdb505a70aed47387a22f763bf65c251d7d156531cd1b98a004c21ed16d247f57da47f47eb06a8f943a2618f7b4f87410954276a17c69016adf4c4934d0997e74c505aeea5b2c687ee11b43ec2ea735ea49b3fe81a628311c9b375ba4e60dbb24ecf18e658f23203332ea996a6e4ca06a55d0203fbd252b6569a99ace9ecedc576f730b433e60e25ed2e105f95b6dd63028658189e50ad966776f3d59918ced5fd71a520f50d7c27c96c7fd3252c9cae272287bf7fa77f382faa12ad74888f4e2b12214a1580e104c9050caaaa6285d4cc9c775afaa7672fecb184127faef379ebb33f498739ffc7c71c5f85cd8ea634e85a43a6541ee650b7f457084f3422018597a153b68781d806bba5f969d7ff0bd26869338de2c40f823c8e658fbdfda8e3006b17b834864f4dc2497b78b7ba77d39085cec024e0022b880f6991d666a1982736c9dc2d1667939ea6c37ff52757cef84f8da51d564937f1cf0d50e4e490aa07395384c7c1db59ad90537fafbc6eafa51340739d9a9712bd0a6b0cb5947ed4790a1e9f5437def0962ec691b66822ade3afe3f46b6402ec5b4d6c62036a2684ea9e2455410bda447ae905986ac907c95ff5aa65a25b9fe97bb4286af4d68c313f9bd5e4a5bf6c3e1015b3d7b82beb4af28e47aea73c9ada146e650a6f30cb642a03a398abe8045e3a1485250e35b3670cbb4ce88adc24d8a4135405ba2f97a8d7cbb234eccba419cf389e2e868b72069abe3c442fa8da841795367f0f91b5b4bd433adc559674000dbe24ad6c8479fa8d43b11048aa4acb249af173aa5436adb2afe33c2e5fa9a46b19f383c674f60f15d34a62d3934e1e9f3c9c3554b1c56f813d65f2047314c03cd27d0a80dc85626886c88666586c406ed6ebec49866089076387d23aab04644c2c01300ae9370d91f956f6fe5e0240274e4e90f9a979d6dcdfcbc0672a970bdbc43ce4fbeff13f6c3a6331cb5cd64edbec33cc41295b43772bdaebea8de59acc163fa8bebb040fc6c47303d25790ae1b3aa0566b8ff0ec9c1c39b4a4b00cc1f052a8031a2ffaaccdd967ddecd8fbea2df8fd82f66e18cec3227b90b5e789a38143cdf1b5e86de6bb7fb362fc045ddc125bd5ddef4fe23d31ff771162b46135f8606092d672b29534d11f5af4e97a63a37a8ace2059a5ac806ab01b9ff499810ef39ba193f78eb7cdb40b4c9ff6fec37db0ef5d2a051621f0d14fec68b7d88ed7116fc662a3b7aa5abe2dc1d51dc771244b428ffdc6389c17b3db4efbef178fb3c206e2bd6028d8fd9bdf55d3740c2b140cbfe96c75d4900e1da546cc0b656b030ac27f1cd1f5e376ffc045fb5e61b9130ca106927ff04c153221af88e250637f59177b3248c9adba2c0e1cf84b17bab758b691b495749864fc7c265c3a276278ae0a4acb717a6c2dd0e71089b3c8864cc1ab684fc506fa4c57942f94e0ecfed78a7d9521aad70063ef0481e6ef1c4b6c1ca0fd8d4a17e59cdf6776855e63edcfab87b4363bc2ff84f4fd3b4f30b2c3cc7c31dfbd4f89964a63865be7b89f7520a56ee997d02a201d7711ad240bbc09dffc05d883ac6a059845845c0c85155584d975fafa991cf2a12355b2d43a2a8e9759fbee76f44b448907fb47591089af967381a0774d4113b90e71f019e4f88d887121383a1af661f0a59494976c593c524480f4381b3469fea21cc9cd8e41b497acd5982d6f0ad736c36ff01a9cb7df5f6f9c6c6641ebe479faae40381bf0a040d6ad651a97ab05c1f2da2a7907025da93198741f7fb9698c0b5680a0bf81a1e1ac17263e37d42cb3eb6ecd77b3419790460fc470a726cbbb12c2c4af0ca09d25f9580d8054851cd4a805a677977d77dcc1afe5ce0a07d7efb5cc68b3efcc698a00311d9f6f68c8da083598bdb4cc2028d3de00b157ccd0622d2d05297bae021c88a7845117574e81d4b54fc27a2924b1f32c7ee033ba7c14218d32c7da96c2c714178e1ee5319ff28757933169087a61fea29ca9703d6a5f27c90d02049ff9e7c7d7f446c0b4eb552f102ad7b5267feea971c718c844744f51b94bcfe8cebe0f06df0fd8c2913e316c3e1696a426e90c16d045d986275adad69a95db164232ea231712e8bf50ff437d8ac509a531819d27da4cc3eee2f508cecc9b578f893415fb83df541fd9988daf39b282d276d9d82a61606eaa6dfa2eb0c4a8e09c150fdd66b8962d62ef59981cf90297dea4de8d5e3b24cbdf5cbb77de890fcb786849b7af234d1146ff40b9b1a7ab426b17608188d210d226c0f922b94141dce041ef0e0389817e6b409e35bbba3bd279c56fdb258f870a93d88fc6611ea14f3339fed081cdefeb455f3d6339391697e88f7d3ccc64651241156c32c188ab656071ab725d909d152f30c3131583c474ac4c6eb96be57648b2e659e8c5566d593568d3594ae30ba14da275fa1c4abb32e8d628d9c4db750b30fbde488e9dc430903ae22a3c3154ad2b1fd054ffc29c0cff4b6d338f7f246d2905031281cde785700aeb042f90b7c206f6c92ad37d9eb06e17d49906af899710deb66f84c1be2255d0277efb2a5603e95e0b13cef9ca19d328f049733017a11219ffc7d51bd2d58308bc2bd48d57902e5e7f07e9e955bb9f440e1988d2047c1852d1525a2c9b27fc665290aa98105e9449be72011347fc5f792aabfff6a6a599d40d515a90c37b84aeff67cc2af59b560bc4959c5c31828a3e87d3693fd67f8bd5b00c2ab421eabc2e194b3f39d996d2eef7befdbff49c92f47effb99bff9a8bc59a2abf44ae5fc59e4f7d76d1548fb4941963cf9a72d06d58fb6e7998f7749932d0e6d9b25250a51fe8ebfbe9d1e3fd1fe40cb2c2dd03f2beebf2147537a25535c8f025f64fb4e6cda13d3d581c3718d344ae13fc53b18bfbfbbb09d08291e7ce46d7dce529dec27b0c5d914fd844070e5c059a63f6289d814a5ac6f44763a34a76b133206479f6238564b710984a079a20bc910adc4fde679da77d1c5e399cc2ea3d51986edd64480268fc5797e9be339d5f07d89842a4f7d5f6bb1166eafa8e42e1940550113018048572082a0476e5f563f1c9a01c7550639dfbcce940fdb73ab31ee0e5aabcb1463ab3ff19c1435dcbb89e6658ec6fcc7e540583e4d9236eca8eca0678ca57565b8039bedba3a4531497442af1e6207036ada708066b05412fa833bc00ff135e7fdd5f1ad7cf7bce2cb96285f28eb1d61ba38f9869bcd27c07bd5569a74c05667fe87a1c195f6a17b6cf062ef066c33f0b47a585f40a2f220cbb4ed97149d5084ec4955b2a5c235b8d16af35ca41076db5dde5a4775fc79870e697e1730794d9de7c5ffb24c384a27e38d687715df5029241e8f1c966cf2d2bb005e943c3a4e7eace4a94b0376ff5db0a87e23412553c0c90206a842e23f30e8283201002dca5cc21dd0f3bca5afa98726f960d664807ee71f304c0004a398f3d344cac04f98729a4b023fe9cc6e79809c334a0109aa6274dab5123f525ba56383ba39c34f50ecc2b2434479406601496d089447f11a7bf8c934b2ea51a5a49cd4bafef5eefb4de13702997f8b1719c1dc31e2bc7105eb8866d1afb6e4ce50edeaef03544717d0e39918f58fc857bad5e4b93f4f8e714a93adddd8097b1323de5d5d915165bf5ca2002a7e0c3f5e9d871bf9fe1154ae646a158660e29fbdc828f7dad3eed49a3a836a83df5b4054015abbcf4d379df8023cc4a1584bff2be7f899635feab6c6fdb32c0caab33d24b07fa63606db7da3c61e9d870a83e2325e00775ef7ec30c65ce76c6be38c7c98bcafbd2b21270124a29150c0a547a2e844368501b547a989cc3372b6e432ae7c5d7776f484a247a10d478f4588581297462510cffbc433510768965f7b670f7f8892adc406c3b1007c6af3a235e9b78c3822f14b8aa478070c177c8688c9adec007716f607cdff9aeb5971b657316b8bcc31bbc34b0afa815c67898e16410dad29ff79b5265e549dc44bf25168c9ad261642abf9abadca7f520e4b48f8ffeaf1981ca340c468aee6d9582344b7f8468bd7d351e12ec36899a2bcfe85a322b62d66585eaa01805dfde9661010d3556a02f9fb5bfce38477c09486c7d9dcafd27917bd87e6c19d6ad6223d584c66140e42fd24e159cbf380637608faf9192acbabf533dfb67935c27cdd9a4140e943fa66163d08d739a6d04bf9b286b5fddb837e681a3f6939a10a2d15fa4d05aaad2830d8633e6c4b4afc755e9b93c1a1eb9d6d1e1c7a4dc058339e2debfefd5327c4f0cef24ade14d5fc37c93b629d5b6b5a3d073297d7fb35bf72c9ffc75f8876079fd6e775a8dce69e7a65a58e5c988c1e681a2fa00a9f71b5709ad4b8c0a69c6a728119773e6036cf0983c2bedd747d27df171f7970e8523f44950765f0f785a719b06cb90aefa279f3958b63d3f2c6ae615320b55f8ecdd6a84469133f3bd140fb5fdc4bcf1da392b3fcadab54032fd8643ff4384935b40154b7af3a0d06402ff0d2c4a1133bfc802e5ec6c3355e6d3058c4d0175336decf45b9e44c4f6df91be6ab4e005286cc2cf67f227fb1f4b28b360f698adc4e75bc30617e6d0f2c7a51ea78ed8bd926dc45d7f76e49ceb5c265655eeaa8da2f4cf5fe0553474f959818f36854d9a7d60a913316ee1f5f4e6ae7770d8d8f90aee38a959d03335a7d7c1673db7b44829048c71b1fd637beec78edfb15a95a1ccd7a311955c979015b5c9345a31f05df49e1e60b3a7826923f4add1a6f21ae5b899931b796ebc6af1a191d8da8f990324a796e8c9cab901527e51a553527c31f7b9043e533e4c0a3a03526b6f98289a34005b0bbc7b1463a484c8ccfc69b13a8983587cf568550c1f126bae5c50782d75c73248f7212a2f542a180e20463688ad1f018b69ab2060f89f98ae07558cd50a3042ffef7abf643812dfbee656388f155955ffe94b6b2d65271d8ab96dfc8b31183314204ff49d651b079cbf4f8f991e86a3a9c33097a3b96e19ce36840e179adf1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
