<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69b1229f6846a476dd37f3ecabfb26bc506da09539c24671fd8ad75500216af7df1cfe6c67dfbcbd304e0bc9ba08de9acb947bb7c184fdb962aef2174a1650b46c0de08c1bea422db9b71cf32dd58772477639ad502db1b8508a20a7e93e9ba3cd03fcabf803f7d6bb881843b7d657d6c1a12f5bdbbe1125b91c0ff1fdb60243666a0e6d1a444ba144441081d77298b6f36d9eb86500ea1a40e4900dae2cf5827a18c9c247d25d01ade000b604a93e4981294e428e4c208c78cf0adcc857a68995634a31433b46138fa7e7af2191832c3836d0b6ec9c6d64412ee7e83779db47063f4be36fa00d4449d8bf8bfb003eebc703c8caa2c55d49871a6592f37bdaf5863548ddad6d779fd0e160fdf79bb8dcbe8ec80a107a07f8c9717b0446b8023b71ee9180740e460d0a482e670c7252bd27523b2c4de27fa27c22d63e52b3478360d6d87d52d50c04e683c1d82f8b8117ad82f9cedaeed3724ad8fb82db358852c80fdb6ea84b1e6409cf2dda25e8a7d44e1a490c1d674251abac28a2b7fa83c75ae747d8f4a506869153ca6bbd1e76dcb892086437c22ab511c622de656a7d04e4d88dbc1b4d20e480f94530f505892c0887cc21598895ae975362e8fe4698b399386b916a3ccb2155ea2a566b69ab8d5918fe2446c53cb3adb5f422b7cb97761b844dc8fb585142bb0024d18fee3bb18485fc61ccf1513fc48df0b41f2d771cf34d1dff8b8d32bc6969aca73999464cb0618cb3e0210e2c3b3db07812b3c4a05494cee4b5935df1b628d9ef0ac53d46950a91b4f334ed3d843e54310c9eab549d11b970aa46ba009ba6508f0ece3410288ae5248543e2ca9d622190551d438b06f4af8e7fd233ee2bf06834987d3e1a95be0fb70199751f7f2e85b068178d3cb23dbe78c9f045dc0a52273f610be9971fda4e1cc3789774a57dae8eaae97e934dd3195730b21687dd085decd466d5a3cc47effbfd57e3d1ef48dba1a02a88c40d33278a56ced886678cae2587799fea48b97433df7ad61cee261b6e517f0200579cce5d7c6a68580380dc2c0c2d528e514a46a08a0d7a42ee63467804db488cf08f21fbdad9784dae905e266d0daea2abd790e7dfa2e4246557e8187e4dbb2ee00c6f7ad556fc4646b591ea262e3cf289a82369b4c984f588b6f2ed7d43244d51fc5f5e272fdb95dc5c94cf92402b6e994506b9c1ba5e76cc4b9ad5f29799073803c9ba9890f6ec6364638ec01e77a147e46e57401b7f353d66e24bd2adf4dcbf48a5e77111a7ef496cdaf5b51d76e59418bef2a9cd1d04d103d41f21e4fe9125c3d5d27f31e06c6e4a063c84745589157cd8a5d1e15f048fad99ce9aba5a74189d6614969961b4ac7a7ea18019786798d4c60cfd77594c565837f575a16fbe18b2edfdaf15cc8f7c22123da2376ca5d219b50f1f1a4318abc051a5f18eaba35506daef1bfb5212307d4d859150567e615dd2729dfe6082969f866b3554ccf1ddde99352371e5ead0c21e36689da36859e73830b2921c7f471f7b5fdd8aca62ba257c20824f1bc655ed1d61dc6deaf30c2ce9c7ad08b22333c8334a0162d4dd9a91b8d74b56cbe8e1cf9f93ab0f0dfc9ecd87e8e3ada5ea5d53930e65e1965cf97a9c2b64fd28c586eace98369ed06c0f2d9d1fec0fbc59b5aa1228fb15152dc210237ab6706caea07732108641adfc40b0945e0ea0ff68659d22564bf5d629fd531bd012fbccac39c74cf37d4619c0380035f1a07907180ce9dc25a4b2405d434e5d1906b5bc4aa8afc872d4c2ee83b604a65da0334755883ea76aa21ff14d084086833c111b9b84cc648aa2cf1b794a57a78eda61e2ebd114aef0003731c08eb711127daf8b2249eabdb01cc9eccfe870f02841fdb951ee2db94ab391ef6817a8dc66ecf4299ea2c5ae3370aba89f71ab3510f09132e28cef0b0617616512d52f9a20e559614410ca8951621cec7c4d3815f0ed0d027be075c57b4a7db1b2e441a1448a10ba06753fa13334dfde68572f87453d361d5e1290fb424c3476d39e06e00f967f38fe4c2414acb8058c9b005a425b7579e08a2d12038bc23710522b25f4341d0396eed3f45f2db30a9bcbe31937120a2550ac46a2ff889f3f45b32042f917a0464de50a9f1b51072221268f7d98902a94419c3424e7b227e9d9f634f62edbeb1f0b734c89c4e5af207843a29d0151758df098a17d87afcf515ab35bf2adbcc3617b166247866b6a06ecd64e4a04b63879a2dc34e2b028972cc2353d642a99585cc7b65aaa2a3939337b4cbb5901d3258e1f40ab5621f487bfecc40b7ccef94b35e29fcb90eb1efaf16603e2247c8855695c534a9d464339ae545dbc83dc8e30c7a71cb53743213ccdd55577950d2038ec1b9ca7d87d2122c43351f07c1b10da0e8e412e6e4c89d221862887558da9e4edffa71ae09a96c46f60b0ab8b52307f02f88e6b90d5eafc84e7c00b3cf56d7672f220b9f3f4e4a9d4e428048a37ff8a6a6086b6eb33eb8cc32edd643cefb6a104011fbb9ee6343ada0b8522c953c5b35c821aee7be691fcd5ed3b949dfbf0d9fe8efcbc00c1f4b6298fb800af0475d516824f59133d1a97053ca135282980d69bcb877d5d421979844aa2fb35bd28556bd62b8aebad39eb7c2f3e22adaa7ddae0373020598921b0b9b459df04362d7bcbf22b12ec012176f0c2ad13b2da3e93a5e50a56d74ba76fb55dd30275648ba83062bf9dbfce45780a57723b1156b95c9e2e01490de30c4d09d1f0d693eb1b9f9013e3d28eaa8ec864cc4f5dfe86aa866910237b652236265d424291f0f63445f9d11ef764c7c09c7a122d67477dff6277c7fcb458b5132f0bc1eecd89654ad9b3ab88a35120008a8a7af9da8cb5bbfa1eedf2ea9d8a5f648585c6778af2e7525d6dcebe5034dcacab6735f6351d6f9903b25636a5bcf968d32581b248748620e2bed92228ed6c4f7bb3ff10160cb0f19fda5f02ac2981968557a549c100c9b9b150106e283e1a8ac12bfe43e0b499e88916f038a19290b05aa92abe06bfe09e4a9af0e7ed4f459ba7cdaf5e6a6a96636b297af5d51ee48c0f6ea1c9b55e18b1b2be208c57e85e3a3243dab178f8040d38a278ff865b45e94edf62ec5fd52c943367f41c1d4a0a28417a595c3b3861b81d4f1466bd8d00833781a936a2b2b938e59ebcd65c9a0f8c56265a5ceb7bda47ce330c5d189aebeef3cc18e817333806f4b2f0f7acd1b6e0a3620265b08340590ae9be34991dfa86a6012eaafe43d7a74c505fc89717e86d03a3b0488a3fa6a0ee2bb0336d50254bfa543781e3b09f7a0e5da31f78545888d1644df0f3280df461b4df8e4c982640e5ab895182238c75ac57ed11d226a8846747a09841a2ce5a8446a8266779144c608b971dea152e4aceac903388f0d0fb2da714de8b9c50c5eb744d93e82712c7b2855ff6e6c3f822dff461f9801fec514952dacc3f7201fb8b51b485a179c8e0ee857cbe01fc7e1a1f8c102d9c4c2a7c5ca7b23bbff6d89dc0cd84b8177582df033a4394b848d3dcfbcb79586d5fc6ebfa207fbfc2539dd8a88812a8347fb4c08f15eafcff354fbebb044f179ec9d038cd47b250458480966dde684032ef752464f6cd2c5b2d4865f5be88c3776ba83dc052af958ed85f029239611140653f331394d58a279dcc6c28d79f30fae5bd41c786baed02654b2fe3a60b1bfa51cefa86c42f5f270a18ad2320c9e60e4bc2bcf84890f1481d649883ad71bcebcd5693bc4117ac87d75a547fb77f880bf4ec0402cd31787d2635ab5ac35990cb36a812524aa95c88b020be6f24497b25c60fa6870309272005b3734cdbd93fd3aa35871e064b73cfe7ffba0e20fadeb5d306ee6d28be5f889d9c7e8ecae4b3d77a0d59dc2ab23b458b9c4b04b45a73922f49086d11f59cd8d0a2b61bafc8f0aad755beae7af362990b54c657c33236f744449bff72b738f495059649e83947967f1bc1fd7fcd62cc713cedc4797536dce6cdd7fcdb810fe2ffc91767132f5db5e7806390d2cc3ea4cd1085b2b5b9a1a3aac1912044340327cf580c44aeacfde7a19e13af7f881c3dfe6f5a74f8667ae02b85b1583719d0955617b6a8df5af603fa3ddfd83e70efd2003dc97e9505075fa640e3d4f628cb851a61c6aae45ee9ad161d101853db68c1e1b62226ed2820c938374a93c6266c0c623a1d0aba9dbe8f5aa6f21ca4b1e61c644138c67aab8df2ac6e4086738a360b7ef5b5563aaed7efa96392e2bac719fe45dd8542b6a53115a612cb58c4158b894600001ee9ba6fdb0889e05513abc9cc2e9db3299edbbdc8e8c80d54fdfabeca1db538c2765d964ec102f6695476d1cc13a292d1b8a9e27300f8603b7f831e5b60bedbc11a64651298efb1c8add3ab4ba3828ccf1c1a0463c13521916a456ec4d6fad50511a91cc40124a9a63870f33036b4682f00f7499a1ecc9dd8c98e5a58655341a9f54d7d73986bdc1411233f8ac94c0b65b03de146a57a9966890b5e7c1f04396e77cae6d6622e5297e7961e1c65e5259bf72c12dc1c5c3c4ccea41d45dd721ae758fa90db2cde57fc8f67eb4e98a1ed00cd1ac1881e7f2675933fd19c78f1fd720042936f194dad17d4cad7a39f585315cee5cae3ff8018809a86f2fda70482f92a75304d951de5cfb44652d4a222b806959e8a2ed4e8592c6dc88387570a56af55c2446fb79c245bf54a30a9a10d0c64a6d29c513b5b7e77cb2eee2802e1df80811ca84967c5ebe96c97fd7d9dfdc56f91f26443f9ccf431cf6daacd948705b8df7be57ff6e6121bd047748ccbd45f0f67dcb15848511b01c32ec8124a731f48612b894238adcef9e81e1a1c10eafb86cc665bf07107481b6d97f81ed92c90777af0ece9b7ab6e3072454312bf6c0f41e9828440fd0a204cdafd596229f259fa1abc0c40717cbd0bfd971c68cb56d74d094d06a96057ca22b2d7972ed2d4517e80325b699dba336f09785a7d5d23a48e9a0f3dfcf2d5ea1f6a16dcb1c4843b7df43cee7a35876c021a27420d9701af8b3d214d0cd24fcf7b03f8a0dae03371110a473095829c381e22ddfb4bd77e04b195a8774b126e76de01147dc117ebffc912b5fe7e04e97b6187c5fe22bd56cad13ac17d75cb68191af9d02b3e6eba06d705f51c4abaa905a70d3ef2a6d3101949ffa32bd8e03f8de00d36685bcae1e508794db145effeaa7a19a5717d5c16c356a6d4e3fe1a5295429d92a6c5d27803b75d19f3dc0ec830d7bacc24800ab825dc73a4697c8b0c8c64ca3a86efe65ad3e7e8e4ce384993da15a276ab0b0ca90a5df4b2f3588879548b3414c8eb90b27b5006e8e1a6f3d2556e02c4d51a73514f3d516c53b10e29ffb3631d3e384c347c4684e7d8c61a9280e8ad3ef1c4f92ab63cddbb8ae4f47948feb1ffd6a44a15d688a05477cec5870c1f7fe219b45e7569998812f425688e43717e2588c163d8e4d79d971b98db75d0872f503577a5e09eec7fdb2f2fc09514d125086b08d45f8f5c2b9a6227f3a4b1606516d99b108d71145deaa2a7dc3d3d1d4f80b12027c849ea54cd5ac25e03e9170d9f767d3791df256ddd9eecb215f97057b819ab6a6528e748835ddcfb40f0b98b19574447d17fbbf187eb320b929475ee393118c4ed738473d2509a39acc3fa37e7b02d6f516ede38fa0e9d9126e4a5b843573a3740c101b975db418e91579235cfd9192060865f9b8c23a2276aa1ef931e1bf19c056112efe60c0f613d9e13a0aaedaf50ce1cdba5273ea6a1dc0bf389b7f104f875f7278bfa5bc7620836a8ceed5e15284a16123e1723503cb527840f918c0e871b7ee7237d0e0e03678875b7b921e6ffe90c875ce660984e77f98e4ea1b9cbdcf01e0013f555a8e21fa7dac5634c9a2020add236fd9d678087d9f1e9ce0385c22bcc86eb7f0c2dd3571249301f913bb18a491591bd79bdc8e515ffa68a41aca2c2577753bdc6c788a61b6749d536f37f7b268f330f1bbd846e8e64145f79b1bdd54f2c7a57bcdf159dd8b7871d5893754bdac16995c33287ab863e8af2cc7c1f895c63e98a8a7aed893e57ae1643811e5b5f4ed3058bec20b80a62b2471fecef921a13faf41eb27f4be2e3e01a8b12a0fbca4dee5b3471e3d08a5ad4f37314c7ee9b19137ee7b5d980970ea859e23a61238ebcc321d58650b69aa9ac3b597072bbfad0479756860da44c3a2bba86a45e2bd9c58a8c98acea6296f7d0d6d20047768fd565fd18bc767db5a231c6efde97b804120f3ead4cdc16e46059a87a5556675d86f4ea766669b1dfd69281577b0b055db69e6c1798e5313c88321f04d93cb8faa24356742262c897e4757dde0a5718940c982c72ab13de85df9ff8e3d3f1c0309f7093117b205111fe6063b51407d598cdc4fe812a46ccca2cc62961ff26c295033a424cdda5c48337832e81bab46e97cdb84eb91722b76adc7f59ded69b347706805f0f7a10c1bc33d2f6edfcf406256051fd6229e40b035c0cc4594b5fa14229137a6df52b9a242b55f8e5a7529aa74a4780c378f908b6ea3f1490ffa6afb641d55896616a6190d0e00aff727e51dea1842077498e1f643a4cd71625aa0be166fa5b4fd46fba8ceced1bfb3809936c9e69c7e3f7c0cb46cad612b4002b2bfab6835955ffe955ffe0de32e090477c8cbbe921f544f23e99c2a07dd9b44a5f2897597128a87d1f586818297f7aacdd5cb7b274c5743bcce2b981695c76c4a0bd78ba80c0c1d50669bb1409abbd153c60f8b2a787de78bd8586d9705fee3a635cb5d4be1f7861ad5546c0fad73f0043df205a5a456ab6898dafc1797942f2c07a744c1c23905bf57e4b6bc80bace86af293599c1907a54f6c95ec20d5b4b9d96ab35cefdb3ec519e54ac2dadc54fcb75ef9ba867a491be15c3cef8aa62b44560cb981714710fc9526b0f5a08b7c12a94e0976fbce616600f3bc173c2bbbbecdcdf1f3293b6235ce41ff4ffca9523b9e722d7e1d7b8c611709dd916604c7f74649d0e09353ccbc36b13da08401668626749fba2d5d44ebf96ee5cd746b6f220976b706c277098374d14e7ef52b1de6a688b76ff07aa288d278d80eab11d7cb65e043f4c7d213b9fd9b477ad3e1596d8b2d7f3a049a6dcfb4bfc3ae9fe3607ca7fb890e49df2c0f82bd8ad906d5ba92e2be761fb3e0e2bc17c7ccf1152c606da796ffa883452392c9c6b2bb6e0b757c8a47ed9992423407a5b420cded22290323d4535643bd3bd950f856a82a38144966b56bb62ab94bf54ba80a3f3d0287c32fdb61fb808238c0e8cdb28e57bdbbc963effeb9aae71ef394d61a04fe2bef8befddb42f52eb959822d8e33cf54499a5db69a4877a4ae6c452055ba670b1d40369b755b2cb6db1ab8b800ecf053a5663431a504589fd229de9cd349b4b12cf5e4cb43a7557964169c05013594b76214a898d67264fedcc98618c77d82ebb0e536adcdddb98e4f69ed66469f5ca570ecbf6cd9da8136a55c16fbcb4b2c72d526ea2c23168957f3ad6786ee36c6c58436d69daa33ebaf088545ff6f28d2d6f19883a321a330e81588644c935ca7e88a6448a876bb1655da666bd0338f10adb16fcead9847efed4f05f8be83c41fa7ef7f44fda51d6b904630c2cb1980df7beeabebd7db1e8218ece66e0e5006db4d1bcdb573064615223814c97e56c6c3023aeaa236d7da29e6f53dbbfa78251547b099c35abeb63d3d669e45a7176efb4c815860e43948f8fd2100bce53c4f1532ffceb06fde5f4fcf07227ff56f454c47ddd6e506575159a02c5a18e659714aa217dd48882eedfd316b4a2b0d6a804531ffd80afc78927df7fba6dd8f96ab13a066397ad5a995ff2833326440271ea076ccfd67745fe872c2dce9158dca5775c77cf1d0719e5753d8328dc06ab310840570dcd97e070db02cc49ed6693032b5a835ad1d85b292a1d0a0a6f4423acb91c349beae3e699a395e64472d16df9b7afe30191c50a83cc2d4661dcdfb768cdbe39de94a2622ead064fae21ec1181657c86716a7e237cff1b858f421a408b78158b61f626c3fdb0f00609b11e8a0de86cdc17d989e71d908b65997377800cab67c3d52bba895578e43ea6c349f67ad96cbb8f800b41ae300f786fe53a13e571d8d41471fad835f9f86c2ce67be0627ec34e81f45d7e4e035aa17646b65fe4a6ab215b1c5186bf693eb1299602d1421e9e2f502220269d76e9fd96de173afb61e884651ee69a2ba8d9de5aeb1a1a4d6c06a2b17acaed01837fc68f2b0cd745b12c0e998c84a095a398f470fe8763f740cb5cbc728eefb171005437d5478fe95e53a649341a51de519a20925170f460a445ca34f92868044324400e54be65f23d30be4cdf3c44a546d158a8bac28eef357495dfd4956ea2267b75a312edce6f8035fc571c473ac95cbfe4606609f4382b8a20a9f5d702fef6c73c411b576cb452f8a7ef5030423fbe5d3a38290840701f19aa37103832a1144bd195fa93b1a84694036a853fdc13edd3e112e96342a0d5b9fc4bbd3eab3ee8395b2c6eeb20dcbdf22278ccdbee70565b8fbfd8d6bc3aa844e31cfae6d14d0fd3ef6b8721457385ed0b50c095062df139af9a338bebc8ba1b3b38802396c4ef2e01dcd25254a6455d2bfe3c91050fb3e9090e6e033d57ba01bcdbe5c47560bdf82f971ebaf65163109c0b47b566c1bc4544eb069fc19d0ef17030f3d3f7249100e3c7dbc6ea758556a9b8f806d5b6f151ac2639bf94ef4569e012374422b064b10a7c233f4982aef4755e5ba7c8cb880e9bba1034dea2d281091b6a04c11624a089b156c222b92db0044229c23105b5a5e42e05acb85606fffbd89bc086a402b660a3d47b55585d94580e769d65d21bd8660135c5a636e4a490463b41e1a989c1b8c7a8b24de4883dad20e3389b0b7c11a20037505a16f44187397bfc68dd4ec410abad996833c30d0a7f8cc59d3279149ba1cd41f905bef712d09b63037e11f91b454d69a3c97a7d178d7c9bfab48bdb89c9c09ab6337757204fecf38415129bfdf7c412d4e93e2f725b9f3c42c77af9293a1104d5aa182e60615531acf8175d2fdbd297a9cf4b58c8f00b7ea4f7cc1a9f855d34c0e871361c51016d8b6fdc9b428012c31c3b820be1822d67819c9c4b4d4155154320f1c9f422cd373987717a5fe1dcfeba764f2a4be675d96b245ac151b8e97b5068ea6888935ef5e1f73d3dec5c998d42f1c2638913cdd01cc56956cdb0332bee29f1b56b13cc607211aaa0b8ee6fead77433629ec399fb05f5ecb1e90be8ce63b54ceb85472300c5b7666b100a82f8c4bc37c41116e520cfbc3cf6fe757ed0c4d4b1de775c04722ffdc604cdc05d841a2fe0adf3e6aec5135f7b5fb593d7a00e1db1bba747720bd71a5665dc1b3073a7ed88457bbbc4dbd1d404b3a3fe6cacd1a23e628dfe89589cbe48cae8b98bfb8544bcebf9f84d2f0dc1c41670192e59c732948b723dc25c4054c76a9d8b9d22ac3a537064619e56cc4b6f431fa95601f6f66a82058028823cae684990278748ef35de86f743f104736f9e07bf9120549d10f7190d4034c0021e160cc83e6f7515f568e5667d0fd1788715dbe3af9de27160ec9e5016c5da5078dc010876736370b40603bc328b2a989cf1f53a0a1a159cc2112ab98cd6ff5d9ce932d6f1561e03dc1251ee0b36f13e286841eb7747b2909e1fcf07fdc1c039960aa4ea8f66687715898d7e6a74cfabe399c79f4bae65606a3e314e4374a0d075f96112e5d98457b5d5e1e86e2257c00badf239d70ecd4cd497c1adda3a3d761a940522f382a166a450c8a650c557e174646ce825fac7916c8bf1dd5b66dec3afdb37b233a9d1224eaedb5a79972dff72c214c53fe6f962cbf45ceeedcc44e50da6768f7f62490dbe021f68b98f52d8651af2bcfccd192b47b505da10be0bd33034bbdc24d27b844f5726a29914cd217a273aacbd13cff3410cd8064d8804542d72ce09666cd3d9d06936cc76088037e74570e087f18ce8b8f18980042e90ee577eb705f58218b457e34b1540c0d70d487a89b34f9c666ed0b83ce774bf1a0e7eefe3a5e9b93319ba0df9e7a398b4ad576029eb76633a7722ed443903ec8654419bbea789e6dee02f7842291b211be42758078b16caa2e663d2eaca6f41f6409d183e6c807fb08c1823da2d387aa7bc9ad9d59429e73e76dc8cb045c81404557187b57b1e5efca3a22acf692656603d26fded0bb2f161a698ee3120368f15064b9c3c3a878f238d93cd4f0996ae04e0aadc71c41b52cc045475679f14019a0dc8337a5fd237c1b051af8a39dd02a4649c12422ce2f2129e7d48d94b2c0dba670f752d199c34f3b5b1fc2cab46450a8a2e76b05f2a51ab84da471cc343b3ad3110250567e64428679fa287f28dc77cd0d88b4cd72b1d834684e0a9e129a531059104d06326f764bbb1eff9bb9e218f56d9654506a08f8e310e1e601099da48bba3f6b3c5fef053f51c10869d67fe89e5cb5d526b3b46cf845dee5f089326165d12a3f093f3e0455ddf58fe811f62c37b2c5185b30966fd47f216e53a20ce63043e9c7762a88245b32a611fe88b924c5af2b942ea138b483b71b2e2f745c24ca5347e6b253e4c16925aa48b358b2e82c30638080ec4e1bd3bfcbd098d1a07be8f24017c4dbeccee24d2bc365fcc6b003e1cc310ebd6fa330566cb6d7ed7efd54de647e4727e378f0bf94d153d8879948e058954855942caddef4e3ab93881185f7531d29d949b5634213735295ac155a873250e626689ca59c99c79483470b28a2bbf5848b6765f2158fd91f1552a8baaff59d15530a78e06c584c7a8b92d225cdc9eeac6560ece40eb4a2fd46578f7b62a75db8d558be7561933f5c68ec20cc7248b020f2a05b015c0b46da90acd18fdb5cb3d2c136f9c2137408d3133a92eb41a2c16ccc14f675be1311a1c27f76b1f82ec56d41a6021d2961589bc727cb4e37c572f1dbe7a41b4d2839551c8dc711a4721411f6bfc488b690bbdc2daab3e9113776266289ada4b7b34602554ec43c3668b4a15d0bb756de6a2ad34d6344b8603511ab347d08c82888da97b2c6846de9877e5ff31e309310e095ad11a7baec92d9b57bc7da1cd3dc4b89d75a923c9592676b6b5305b45a4194b95550a8d691daf3a8a1ebc39374a97368f3b24c0ad972501e430f0911012fa318125d570caa0b926bd42ab860c44257ba6038c1ffc0dbb5fcc264b50d552f60c7b4de0e25445d6cff75f5185e6aab89d3473a70803e5025ff33d2be78dc3d14f59137f9fe52d366ad67af294626237a6fd4b5e0c901bff38c8af019eb9ac21147c8e0c5642f66a80f1d18ed2de5850bf2a8a2b257910c57368ed52dfe160df3519d7f2986a2f16bc94c35fb2352cf7a6388f7df6802edad45a472606a8a3977d496ac0be0c6a2e3f09cb3fbe12c9babb84315528a2efb2173ab5d736c257bbdc959ab526e910c3d92f6e8ae0fcc8e13281b32805df4148a87bff2d5aa9df4f196cfc34239d3824cb0fffd8e4ac57857d90a3665171304fe051b85d79cea8e49dbab3202dff2408c8670f85e98f5aee714c48308c56e102a9297d09a348aebb5e52143733f2b02408bfc0a3cdfcdd36f262028aa8cab8a878360da7da43eba8e60daf378051e6e519215874e303d65fce657d6307741f4560f8d33797d5607a4cbd2454931222d30884e7f83a6e110920a53477bb81df103126045f4f531345b6c692d4037ace61ec2776ae5ffe8e5cf50c9fccc7a168f3bd4b214650b206f282ebca9cb23f5e33b8a73a9d09da73cc0ff7e5497210a17646f786bb41c3fdc86f53e6966c3d0f051cb75a6e266df538c8a56aeb685eeee8a4f0bb36d3fb8cb4241fde8ab38cdaf174fb91abc30e00720043207128e15d0cf572a7f28eef038d8fb831a73d63640a383fd2bfd3acf6f3c5f1692b5693b89546efaa24e0fe44714bb0dbf9670bb42163a82bdffff11949d22a3ca5a9191ff179acbf0b8f794ac93542320668f7820490ef8bba6a15ed54c986f06e330d549b8879330d99f6579543576dfe90b34f2db6f8b141c902bc0ff1280bd1d09f06234a8279c8322b9bea45a64ff479573a7355c146f8b9af09670b3fed07004aadb81e82a7173ed0521183300518e44d1ef810d115ec1c58f66caeb1d809fbc432741a011b2d5aeb0faef8f8e70d8d1789fbf6e73f1419749b9cec196ba584046fdef78490ba187c65de464e55155a9172d50bc13da6ef7dd451ee3eb4a10d5da398b05a672225eac141d8add5647fb2835239a2fe2338985cd51acfde92d171db4e4bcde18fda354d9abd24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"230b31f7eca75d586ac749b52c1898cb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
