<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83800739da9286dfe550e47969df0cc37a21304dbcb1a8815bb11de84b87051734105809477bc6afc38c56e89f32fc47fe24f7be950bf6cdba25de2c8d4d62b3aab42f32b81ba424405f73703881b545867abe02beb3c21eae56d9dd67e584ca60227f4fe42c8035787dcade5e180fd03b84e24942e7aa3c5fca44b4155e5b28a665539b111a8904f1f362ac03f439488265727c679596eab1165868f3ebed43ffb5a2aede4fcea6a819d2db4db6cb25a57434b0e35fa81a45c51341c5e781b5873ad3888ec7bd1d37d688fe52f6dd7c0e449268f2c36b25ba4765e7a794d3badd12a782a2e620d56f6217a7c9faa57544636d586b31370bb23ebd49f8445d6d435565aa97cc8321f40f5c75aab9ad887dead208c80c589f48634407f047907d33432295d7c1c4b6cd3703f0eda058b0acd4ffda455ac36aaf489f4bbc683fbc29b97e0eaa5347ef9fc557f4fda6c8681db9d1e5959ff52fb1540002eea2b0228fef3a74fabfb4d410f9939e31067cef66ddc7f848318d11da23dcede97d1e1252f5c2206da9ceb5d1b1499f08e4ad72623c29deb399ad7d990810d94dfe66da3114e56aa3b613cdcee8e12ea55c8c09a17a185690cf6d62cb86185bfd471e8263536ed9e5e2178fe13668aa7fbc6b6594528f5f3cd661df9ecc5f52c9ad3c5aaf3c43a42c65a90ab085ecab663e4a7df5c836aba3b136799befc5a756cb4e271f7b077128be7b9c00800dcc6d9911438c322043dbfd6ba7f9ef1073ac690147906c80dc06a3ad0f9761d8b6f29b9369de82ed277a489c333cdb165791b08ccac8319ec3ef2bc40ee69f2e225e093af403d701b8f091eb37bdacd462c9685920a9789701871658aee0196eb04c56c7d25a87977ba7f800a487d6442273ef4a14c0695927cf37ae10b815859b2879916e47a0e236c7dbf01882e53eb8277758c6df63ac57f32d433ac0d2b8c6e3c9bb058bfd74b094e2c5bc0366cd9509b5a64bc6bc267488b9a3c0e8339fbc94b6eddf5a32608bb93a1951f8cf756caf97f7d1f75ca907fc2ea6b16b3db9db2988d1712419344fba7f43b62de3c0748822ecb872346cd92a244636762767e1a525edd1ededc101981cce83ab5e5dc4eb47eb9107f0593833012ef410c7dfcfd540e84a814abeda7207e0842f59f7b7ce4945987364bf136a08d1d8bfcc5c63647c05fa9063d25fff2f48fae620a50322f9e8f1e1bc11ea80d3d0b7ef889a56bd87ace54a7fe50df82c95d3dc79eb6294da7d438313d1dc74e796c6b41c41ac357d8fc344ffeb311b2bdae0d6c71229baf33a8b2c31fb64167537243e1b65aff8032353f8bc0033b023c59d86329298d501bcee3ea0afdfde927d7126facfa2665ca61549e8993cc5c1d5c5d8635e6db1bc3e564b84ae2430cae5cd76bbd6b53028a2e7bb7295e1f7c9c43e4128ded72a2e6570900dfb75d5e24d7d4bb3257cf609f3641cd9dbcf6e610525bd458f1905fffeee70e54188f5685f9f74cb60c4010028313508408d1af42b3304802d308d8de1a068484138a0963ec3675578be3fc1bebf82bb7139090cfe1cd9d798cc167ecd8f34ccfc37f454a4002f575ea06e5316661a724928622fa0aba076f12a59aca36d2d55f5a0c551439beca3089bea634bdda313f666eff6481523aed240cfb59f64a74a43813ce6a781b1b3524188e669a965580842a6e52b8a9430bdba2c93d237ee0cb37d1d20f29fd03e845992eb88f6a65b21a25d14daeeb8b27e6b03b8ca1116c17540ba161d3b3bcc0f753378fef7958ce200cc1a21012df69b61490938ce1d017034c1ed475d16bf857577c691fb7e05fbb68ab2c425795305efc15bb8ad358d7ca12606c7f77b80b37f096d871b8e6ce15a4033760a0a10cc0d085de76a67e3459930c4b9458ffca732b53037f8074407b1e0276f3fbb01af2bacaab0bee7b6e402454733128f1cabc61741013532d16f58b7487be93f52b20c248bde1235936c90bde3e6a837819f9a67c4579cea44005688d04a815dde3f6c870cc7060e376d81bb0bf37c6d1ea136381ca8731c31d7f69732e1659c49e8ef5c91b6125d718677eced2932c0b75a17410c8dd88a978a5e06edb3a5d69b7f1af6d88709fd140720326398ba0e4493a63ba7032545a91ee4335b0eca2cb747905bbeef11350558291965a77fbb6154ce562ae9ec81e8c822c8fcb50b43a5f63d3027c4470c6c7b88a4547facbf5c60edc50809eea65e75deffe573e8ede4a8147deec932506369cdc0e33b6e8efb2dff6673101eb77e22208ec8e8a6804396816ee719b489d95c5db808c6e9252d15c5138bd8a3657adb5c2fbd02b5edba32fffe73fdcd8f600188b703a1734b036e5c11ff61576779228a4dcec079696696cc0f4f0f69001a3a87e9db5135c13f9dcc617a8275fa17b641b1946bf92bf29be517455dd6eeec6251122770fb8c544479db752e375e556ea335909ab78e8ac077a96b6b0b634e6e1025bf3bae742deb5d210e4ace863b7e3a222904189725a77ad46245c2d22074487969d416969da6c62f1da9f3f5b1cfa52cbdbb4e0cb4ec25376b9cc6571d48906866f072bc36e4013053811ea5927a093b95ecdb4b95f3a36ed404b702059429f9323396e44bfc961b994bfb4e09cea6a319eefbb6ee6e965dbd5696b4662eb073a8d652a164af445e6058ceae50cee30ab58da06b04c45b69bdcbb79fb702efac59cafa147537fae55e7eda953aab28beeb31c0847c22b16e5d151c8c3e05989c2d61ac163712b39c653ad4fc5d00b2980b890a7d999de60a93045c008a7b031721ae6d20c03fadbbee55c0d34bf2debb919dbf8b11dc4fba184f0b3a719f581f21c95936d6e4ca58b7d9c97a481b1748782d21d4054208871401a2264a9b54fc415e91bc86f78958979037e65e56a60224a9c7dbd6aa505b94cc8058d668c8f928f97ba2467cf5d33505009d4e32c0b9193b040f67137336d050875ece69d362a2fe7c4a34112b08a87fc58c343d5418870b8d05aae5766a2b7d8d0750cf4cdcbd56bf8b3de2942387795da58899eaff842ad635fdcaef1bc0327763723631e9e5c53df1ada9b8daae49b652f0409fe8aec64b4b028320b7af4225cb5c80d565e3f877e80a5981e80374fa3f62fb3b289296ba17523daef403bff4cee9de4b029d78742313e18ff7209a15c378bd15b930c197f4109f98a2fccf788d4ed3d11fe8cf0cdefdcfdecf59081307f39efa335ea31ad265caf9a4b1981084cd9ecfbd3968fa39f2a91ecd190b29bc205d20b515d1fd7bac3f0ba273feafa2106465063ca935b8d4f88a80d2d1ab0e238c16e3fbfa6af1f93198678c5b02f865ffce906f81c9575c8e30445ecb26a9c61c24bcf3f342fa230ecef195112ab8ae0c9af1fb38e8f7b5f83adc8f3e4b739e89c72170d9c5f9634918cb9185c2ee98d886b4fc90d1f18f0eaea334521bc88b5020e6ae6cf6c56f7a962ab540e285d824cb3c0b0201c6257aadc7296e106fbfe0b5388333d7ac1e99f029a6bf19cdf4488ddd6d54d4220d6507ddb60c67c49258063ba034c2f64ef16758e5823438a13d4e2f50f4817641b0c7262358ea63912cc34c09a70044db9a1af2813bb75f6e704ae0a2c1dc321d856f23de1ea8aeabca738fc7155638000e8121c65de80465f5c50376d2a472ffc3d870f40a14ec9c4f45b29e9b568d475cc73863835ecc6ab9845967b45fb84ab71158d3617bde44f220d69dacd66bc76524cbbcba0bd32d78033cce9daeb3d1f9472b239625b681d8c0e1e061d4dfea9d916df6583c2693c1fe45b58d6724413d9259a62bfb44d58680697acbd902cb980f59311cdecf30478a5e5f775a5f89525a1ce85895d0b4b79fc0f46bd0c612333e42e0fe46773517c39c48d7a5abfb8e9fd9ec7acb6e6d350abd3d4fb6266c0e8e01b8e6ec005f64703c7eece1acbe79a048012ec75bf5aff7088b265a559b4719e3aa4b2ee6d660f579a1324676e1012830d7f36781800b59f00b33777135903a721ba53ba3cc212c750646de2c8d2816097b471a173310e48695c5ca235d92fe79ee0f9323e5927b51f5e268cacf854d6dcb61130c827c2428ccd2bb2785ec4e350c1295a3f8e85eee533d3053e82b16ef3a173ae35b3803fb6e92f587ae91049bbc4dc5e190c80814a5ee9e12b5efb302398fb5d6f1867c400cb11765195caa8331a257bf5a90fceacfff170a5359b7592c30a3cb8f38d87dbc412b548c45ae296763bdc453ac8d19141370232befbd7cae2da640e9008e8157bd10239f086acd06ba8fe363a7072def9af2c3a12f74980fcbcae22795606d85774f2cdaa03f4b2cab1ac50e1bdf7df9ff30010d6c6010e8e27b9e2e023f7d62442b64c89149b9e3c9d957d6cd659769a8c8c46bd54f9b4ce3c2ac0c6c45ad1ff5613f433f6b3df8b0dd3f742d2d448d4fef8815444373fadece705a09ffb2bb7cf64432ddf001f4eafc45afbee8306961890a2db331710fafbc86a19267cd7162d1b51f1ac2d9e82ab819dbae24458a3c2f7f0360735cb0dfbd71ad50df37818c2c8feede35acc617f3e64a486b62e70d370c2b1c86be423c4bfd6664c5b357c898676eed5551e0021d63c0142e619e772a9be7e7c4a66eeea3dead22f2df13dfb6bd8faaec65c878d0f315e1e0835f00276c3134f36f0a065efe1a2ac422f1051ffa02269a8efbbf5c326fee79d9d04922ac984748600994bef4550f8e747367b4f102f7c29e063c15ea14d7a0c82407110339ecef378756f7f04200a28c829b7332977dfe5525e5210c3e7c8053f65ae390e4577331d19185fd3b7dd221afac3d839d4bf22f9eaad2dc9cea776c59bd9a81aef7cee4c99f3b8aa8c86d6f8b7aa6d8c19f9b6b4f6d596051ec6778b40e23d907517adbb3fe64914d3b508e187654b028fe86fdfea83241e5609c6daa4a116947a1f869cac352fdeb3928b8ed7b36380491f6d5d8b8980be603f1c8f85bd19ff620811af25392643319e1e1444ae63ce5b8c029d457aaed01039fd98701e03e26dd9608e3af5d4487610507446b94e4f0db728d775c165d432d32d1ef9efbff8ac4ee24b178b3a3fd09f56a5d1caf8bba9375aab52a9f228c8344dd7ca31f95a92b6699f509f20f64da484f77fe1f97e946560b1be9500f791b978802104c43be24788102fd7597442a7c35d27749ea529aa9f1e22bb446a2398338befa61a3ec2c9c6354506623d77f544e10b64fbc3d0ac6e3409770c2b98db43e50ec6e952706e16dc7463a54b2eaff285d46773ed2bb446e50cea84c6dceb09403edaa28f564616e17649c23f04ae1a88835f7491a394b8d4dbae34ec9e4b33656bea26028a0299277f98f2ca378eaebea422c9dd159163f6a06db9b289e2227c2bde058ef11042fc76cc55e9be86b3a40bcd91354d349b51b45396b7ca05b7bf26569cacad71c510a1896a5f9adb8acd4da8b1d9fa761af03267283c2121bcd741d6d004ba3edd8633f76fe39b29e67d85bafe0c5f3c5522cf6471c77273c22fb5e1103939b30d70f4630c9ce955af712dc12f184ab769e3205d61d4ae17225ab941f64f6984734c613f05d86b7cc5267e53755bea2f9394f65923dc68080016c8ae8b21bd22ef475dbc5834dc2bed9677cde011852f108964f9ab0784ea647b6503b206cc2db0bf7028128d8fec8380a14b1dbbedef5fd4f54ace68619af0eba564c5eb84abf0068d7ad9905973e3acec81ca1908ae5541fa030674ff84a40194f07fc22835f9df7bbc377a0a6a1becfedc7666e3f2564d6215006d7f2bb98a17daa0d90ebb8bbf2557127470626a7e51c39c1242891dcee1ae7d5092113efd8a9a4d1d35177726282dd787e8066a21a2e574f306d1cb0cc2e753775591acd2081fd8f4d1c5acaf921a9777e430721b23035543fb520a0c707b5ce45e915681fcc28e45859a0276c63d264027203a8d057625f61c7c047f1548c3b9cb45affc615e8248d13bcb802714aa01562deca6a5e93ae186e904fb9aefea95d7e721bfc9574f8ab8d507a5bd218498df0cc23bab7e7028e4c285e595f91513e2679fbcce02f9aacff104d875f563aa58c74682d56e8d4afc524df383f53a77362fe96ff502464bbba473ccfba04be0e6bf7f5a4751d8569b642dcbcb2db9efb18bcb418ddec8a9f7ba12f8d896df6b7a444a06662aa940c8d22ef8e70e62dc2524f59d611cb02f1bb746c1610287031a83a99986db4ccb81309e6c2c79e004fa958d5f12d6136fc7f9c40ab10a3d2694872e00e20ad95cb35f1d33f3b988ff8219546e7e12228ddd860fd6122713ae10972c539470cb12bae384e7fa13ab937d1817965e223fd25da6feaca59aa9a02b0c2ea6ead158689343d1f61c865e3ca9576df25026ef796f711bc242f96fa44286f3ed8de30d23f7cd53ec6f5c595ea074f3d48322d64a0141d7ae31009d1c80677b43065598e6de94c5a9aa3913961623e5da920959f26bab8b3b3b282433756a42a1d3ae156b8584b869e85c228857494c2ae8e9fb6049da2b7d40d76c02f49470edfbe249d8f97200444a3cf5f484c2a96d92cfb22da3d95cb80005469896c5a3f6ebc87918f9fa705cc534386383eb450a14688bf4b261a7557ac68beb25797d4e2729922b8e125744002d516f9d9ae49e66348b6deff6974dbdffe3ab6e0ebcd0c4027d95933c849c76d8eb70fa76fefa195124b73c58b560ae52b6a890beb1b596445d6cb8002b2b6bcc8eb5d6776c4798410fdb92f9edc975a9b1cbf36842cc746380914f92942bef86d4c672e0a01e894f2d08a481a0bcd1c1a7039206144239c36871f868e4130f1f1cff7cb31b4ca63b7b207bbe3cd8ad707789f6f658550eac1f686831144b3667b57516be55ebb975c44fc009359317399fdf4403ba5cef06461b7de1362dc342978bf11f534624050e16035c59a77e85c197baca0ea3ebcbd4a7c6a2b52453cad7a2a8b012253b60253b36d9654b34716dfdf04bce6d7dc0fb7d156edd4f8e846e724c7427911e68333ec1bf251a08b45efa69a5f3825f5ca6f0eaa6f6acb503f456eff8659a13fc388c7b544e03d73d56bfc1d7cd7e17fb0fa4b10361bf9092e2f641981b6052aa9653eb5fd0f94ee8648bce20c8cfafe1b4f73067a691f49228284f19f80b93f38a88f1bca6310b69a765ce45fdc7181019d6d21b5f585aec8b64e80388a177aa3dc336dd47f328949f69c5c3c97cd83e37f45ae0b2f8094ef5a67106df6f64fe3bcad6ee1ac71dec16b6090394aee3f0837343554d3c80cf94566b25e3976168e6fe66c3d8650bf3afe3ee9ac6fd28ee3fb1a341935921566e8f642921cee006a26aaa59f08e816657dde5081aaedb03853792acceb6654b31728059e9fe45fc0454ce53b69cba6d9781728e594af9632497412a80c5d9615f8a63f629052e8a8b3febb7a4058d670c0fe88ddc318f2837d34d72e91dfbc2acef715cad4e55dee061e9710c66c04123f3e2d1173f43887a50847517b45da8c6793e854d358a103037cb285be074810b40ba1b85208d62dfb019d52f58469ee078a7088fff0f6cca760d42b2dd6c3f3025be5dc85322f712f1cf6375157674eea29584c70ce445a9049a54c3df6264a2a2a12072e77c9ab45e2887a096257f91a423b15352011d28cd77346964723777fd052b68da7cde1fe16fba8c497e4bbcbef037e5643f41cb120acf3394ec6b97b1e50b949a50a318f993ffecae5a9543090b10a6f0f68025266794a2d24bc97dd317a3113df87246622dac471cf7f91a5473d93c8097d9a28da0e6cac1e9a3a2cd0a76ede84338abf6b4075550da7c5c24c260acf2d66a4fbbf92ae6ac4aeaea8ffb107575dec0d2f5a64e76739148f61edb48d5ed08ab1e1df0605ab136f6ba88145a4cfef7f514d437330fd125d593bd0786713238a38a8958ab89d059864375b1379f5a96d9c98e68786af259ed9eb255abafcbc5cc39dde54d308cb68573c19de605959133415c0f1e3c51ffef1c06a2aa5a6b3d54e8a3bf11b9c4b4d3f7545684db2e78dd7641aa5e01de46a2491504e7058c8e0cff816341d71d08a7441fe4d9664afe98c4948d1e6a53223a7835237a48cc40c933406017b8dcb4fd4fc064434f74f7fbf6416d2fa535de5ccacf3bd165ab5e5ea45c8302d17419af5096c73af72f1dbf73f5a0f72aab9b901bc68bc52182989cd17992f506f72b7a81f8f0a837bb531db0865a0b5bbd1249640cb1796ca00e1285fb1936200043465870e603495a17acdba64f0b41dd21fd49a0998b081b0f72a5efe60496b4596640db4928a01673db0fb010861771aad42636384a50f89265e476147b3348cf4e8c0e0325028a542813fe217f96372105a1ea3493907902fe83a9b92644c5350461a8bf61b770b304067afa7939edde622323768327d46456af26361849548a06a1a74a6e7eeb15cb5e4374d2331b60f000604333ae863674d138b87f2479736f3ffd9b96ade1c988813d7914b859ee57362d567d387ec1d0bf0053531962f9592e6ae1256f3e751b0d7276c57bf5b9caf957c2fce693362fc4bc198b76d92b0c7b75c8359faa7eed2dc4c3e64c2fc59bc098b97db3d15a4c91ac67e106636e4312f6df66125e8921f1b2196df29fa42febdae39ab4048482cecda11e86d629a8126e936cade683ba8e97f776cb1889f0560998c0c845bf04be43344099155799a591e7fdc3c4160550886f68147345d0a5fea12fd45bb88450971cbb3bf145eb89e360b7abc3f5de25959cfe7e92b669e9b50a136ec3bd81689740fd36bff2ec69b737c88bf4b5a57d53a28d1c3a1cebbe12f9cd150f209383c4247e6612996dc2e62604fc070bdea7f236d25adb370e12ff076df06528ea1193e34e4fdfc772bae3c16aebf101adb5eb365727e89991ca81f125d9335fa6eef798170d7dc10b81bf08f5260566019f5908779bc10333379aac31e2d920e56069fc6c65c8ef6aea7e44153d3619675364970b6e7f41bcc6a42f33d53ce08bc7d42c83fc03cfc91ac5e778f37e99f959a7cf54dba1b2afecf9d1fb062e13bc984e254b84b330bde90f09d26aec20e74a6e889d1533cee69ba7b09ee0b4113bce76c2b5cb1c7a63a292607f0ba592a5a4f9902b56bb596887b05739b544b682c45afc50b2423c411052c0e00da28d7c16d75e56f4b757fe92a52943bb260bcc5c1d63ee247a2cb2b9e9dccfaef0e498075ec43b6998530e204858e93f50441205c769b9e43402fecfccc9a54e7896d269c8ba11b08bc2f9bd3d9cfd90dca2dca86a28ccb4cbe363813bbd77484edd026ac0322b880c36cdcf2f64c6cef0fe2ada7573a012aa92a65712ed16447132d94b1ce055c225ec7aa23a25bbb3c0fd65600f8fca5a5d1359b788905ba40fd37f80f635fb497dc2c2b83e4940191e9be2f84c7fa74b9e9a091e2afa722751ab3b2c85cdc043ca6a50385207b1dec6c27a3144990b8b3921a27cd95aa2a04b8e76c86997d3c767494ffed605bb4425fa3d3b190a069bd20e7335bd463fcde96f294f1bbdf503121b5f45160d4fcb0a851d9535fe1a32353671df2e500d3b71845e4f8d094004b333a3ae62d98adc2a8710aac0bebff6988b279674acc1a1d5a8cdfaeeebb56cf840a7683df6c7d7fe9131a4a1edc8e92d85aabb2f593260c33d1412d902bbb38287ca142104394e41c4b16c996dda1f1e012e33ce44704cd5f95ef487cd07bc949eb6a25f718bff7ac70ab12e4426f4bd32df59197e26147c169fc6f7f1a53a34d251ecca7b5f84ac4f8ce3c609c92e17fbeb58b6edf5d1a27419cac4edaad2cbfef6ef2923233e6782748211ae3efdb3d69bbce0e3684d26ec4edc6901cf40d57693da52e7e209664568bb1bc5429f6f68c5f55541784bcd29b91c576a15b0607219cde2519daaad4434eb83605e8793c161800a02691f84b7b82213589dc93cb6182022b883aa61cd310e42297447a5f9e53150483f4c54143c91be1240a5bf60cd0346bea1a2820cf9a37d49ef3e3417192b8f1de3260854e510b149f2b1d583f3ce375904998388bdfc904671d724bc2a9d8497a81b16e9844d6d92d3f840e8bfe0c7efb45bda36fca1be3d43cfec828cc7981c7da5543f97b8293f3c539977c914c120c0c0af83b39031c05b735856aa9e1f912ec5ed0fe911df426d21478b74bc8f4f03df36dd5b0246be7bafbdd7450b4ead8000b6fcb1ecedc00334956a4bb8ff8354c36b71808750d53a4ad0286811f846dad178989dcb40e1a8f5345e76b3879d854646cfa89089bc352fb5f6ba72bcad6150343c01b06e3e1cecb8538d693fe1750314c5facc16769e3ffc74a93474d98dd4e807317a49a1de0fa930c18fc6f03f06b83e75b10cc95ac86b30161c099071725044057fb09baed42e2652647c3f2206a7614949abc64cee1026f70460358ee171d66fd7ba82c4678b69822000ae7cc714c7c4a631de40c0ae0186d9e3a6184a3b5a23ffcde81fce120888797ec91bb8944777c32639cfc83f1989f4426d921f837471e740a6b9be5cd4e2f82face5e1f9de48367caa0b873e3bd306655c500173d663b2385ddd3935c87d136fd2f66a062c3e3a6e78607f73c54b5d29e4d784bd824da12dec96360f62feb7b3b5092407d5b0d2f7319c439b3297dd0c16495e1e72a36a07ab637dbb0bffdc9f0d8e9567327b8fff7a53f808af3e7a4efe12a95c981588a1a9164b16e164ba78d7fcbe4491f6dde39d58a65474b0ab7828284ce6cd4bddb3a0f2db8dd9b0d618e558620d44e239b5ae0acdb1db5711b0d6f4c8a1a97d2e0395b83bf6cd50538c5281e7a51c014148991ff75a13b9b28e310b3153593631ed423459a44a59ca9ea1b9bbfd9fb34b1b19dbb0864bf40326c651524588542bb3672cd0831723c12252c10ecb4e1a207bae283a519ab38f35a01d2d2838b3a347b221b53b7ea4ea38e90d1b57437d3812f9aeed01d6a5f3718833ecc0c8ebc7f6cce29bdd8d42f928a57d6d4d418cfc5ee3f847b8fba21986a9e5a1aaaa9cf930264b237ffa3f1c892d4b9ce25d73f6947da7c6bdf095d2f7355702699f105520a431b4fdd2319070b839ab8c5000117e8553a5709e35c86f4b37d2d2ae83729cb9e8dc5f9206fad86635e9a20460c9bc059e4c1e0e8706f6cb04a2cb751b562922bc9cd41218ffbc0f612acd260ee1e6a9dafc66ff11482049312a969cda1917e04349aae2002255e818eacb422404ba850715ecee7ff233f1cba1243d528550eac0807beb342e1c20ba9e59f718120eb50b83fd57530000a9ee844001f1ed2a03c25459202dabb9699080de23eabf48323602febe2f65bc28dda756468511c44e3cbd7aab7c5cc3e9e48b6fca8b980639c36a89237d6baf7a44f6c77ad9971c981d943ee45eaa4d4983fe13d8e970aea666d2def7b86e5d235ce8b3a8c5d4e2f64dc02e9a3db323465a6b2c866d8b6a933f6b1ce515e4b4e31c193b68f9acd86bdef5cb182eb598e81b7768538f30acc86e7171054e9e50a050801a8e9cc585a2d47bc0143e3a0596561ee77e445d574a93b859db92b7d0677bd7906b9ff77c92a2adf4db233855cc0c015c3ed59d7c8a5fbc09416614c75387aa8f6c2fa6939dfbed95063eff31a630f309cc6b249a57366e9d55cd8ab757c887b8b8977d53e1ee6167e7b54895860719b0ffc21db700fb241c088626aae502bc5a43995b2394d3d59efaabcb0b0be9f50f65efdd8d414fd52ec99f8e1bf19edfb017495a68ce19055e35af2e6c72ce7201e3d383fa3ff4463fcb90c022950fda5a070cae5ec4e5fbd48126f8a344050777bfbfb3c6c383a061de05a2c509420706123a3962148a2ff54db5768533c9c44359a15b07eef1d963becccd7556005b43f6efa574f08eb53aae88918dc2d0ef91a668e63afa9d5803778afd0a6036a88bd4a0fbbbea586d353f90c6c5073dbb9715739930c7090d9f2b447b5060cecc18db7068f9da3a3666be564196375d5c5443cef96f8498e78e555dcb0d673810592533686522586a394fb7e0006f8334329ce6a65128467a22d41890cc45af64dc7494ab780a9366a59079146e98bb5b34e987e2a555c74b4ca56a8207d6e5ff5e73e1713a3178b370f5771ab7439efd298f3b64cef466a7174b32afe46258524ec88052204cbdba58ee1e5af87318c5c465c50e18acde1728e58ca0d75a4ccd2ac9015cc6f120eebe033abc48536cee4512a70d730ac47f07965baa54108781f2a2154aaf36327e5fd2d70b6b4c0b746524cf243b9bf09875842209425679dc1916ffcca207c1da11e970d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
