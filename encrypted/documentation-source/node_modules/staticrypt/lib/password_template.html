<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1e61eb4c893d881983d2e4d94f652e9d54eb6becbe817226ab3ad824474807349cf80f1fb75332deb6e8358feebbc4a6ddf7dddfa94b6e057211dd203e1637717c6f152796e2d8ca53a5a8a4b105ace01d8aa1c77337ddb962ef9240dc04780bf9941a4861c26a94de60cbb3518cf8b8a6470f1746e371dc6a0d287678961b3c5bd2d7fdfdd41f71c8550c621d71ed534ead1b6cf97eae131a2269cf85d4e1cfc005ef37ed0e4f737dc40bacf268f4ffb0e93b2b76cebba5cf5775f75e0f55a88cfb78d617e6aabc18176eb20ffa0d34285cd8c1a9aa3b076f3a55fc889cf143b9c083af5744e4c543dd8a55fcb1c8535ae4c40048c2a311ff5412a3bb3051daef25d54c96e49c2c3a16c4fdf7861a6c96eac9524753b56bfb56846ade13c12b4b6177be4764ab214c3ed83e7f200beeb7bac3adc4ae05b900fdeb2fd325ad1126de229f9fe4e55c74b6b50b7acbeceb3b370e778d39fdfe252f8bcd3cea11b63b7291448160c3e80966f195c3aed8c2e2035ab2b2f0069692a0ccf7570460dd5ffad2c9e9611be01d573ac278d7a9c3354b0da785d48438fc41e6a8fddcee00ddf462d399616a8184b8debb1ddfb3e5e1b460fbd63f46f0b85e2b44b584d013b5648c0c00e2dd07a211aa2185e03eada5be9a7e4016de415bdb95578f69150c276363594c099ce34113af84058eddd1df39df662714692c59212d937171295494ff2cd4ab5c1b2b761737f3f38d5ab1532f231d7b22c271011308a81eb90b267b1a4aa5a173e1911efa1d302a77256732305b69436c91c38e4cafa03fbb73eebe3137c74925533b2c921c9b345ec2e8b2bf22db2e9713434e906b0e10ccb6fa904a4087b76f38b5cf873f6113349d64c400b8b63fa879fbf2473a37f5f8a51cfc1d26a772239005cdbacb0ea73b37e3972dc06b02a1d43a9e00113555ed9c129d54daf96ad0a32ce3404d777c7e432e5e2a069a953e92bd13382712f8f13f9c7f8f0b65878a47cc4275c381671418d25526c2fbfb65f9e512c782a8571ac213a5ae1484764f6283fb71db19f62dbe2f0640754a05b30653cfaefa1fa03a163b002953118370d0dbec170d6bdafa0ef3912bf05beee6c64f3bc5f1b99e900ec92abfeedf44e06e5df13016feb20082358c97cd132ea776b59760061e7fc3bfe889c15eb5b6379b258a17ad50de17757ec7e9c0de6b6ee80f50cfe0d65809d1c77eddac209cfe557f0acf5d6bbab3047676ffa3332ed2c913a6de53c48f67cc3b37c8930c31db11a44090e3651b210f0bd660c15a5118dfd9c8dc2d4670c33b3d29d38e00766cf4ebf569354b073917b4330b7f80545211980b7f15078aece0206c41143a0b891da6fa98f9d6134cf4dfad32d5987d610622d09f218432ccd826183c41db74b879e7e9d1fe47401bc8cc726577a2a3bd1c6789d317248828ba1ff59a475466f920efd789279c045dcb64cc72b88666f2c754d7a8b9f824d612abe61a0928f65141c9cddbe59566c94a80ef060498725f0c5583c0bd9d53c8ab7924711be69e8dd7c0c2382ca6f1eb68cff64ad0d69996c83c1d0552fa65f1338c20917b36955a863981f47fd189ec7cb3d86b96c4e0e22654ccde822103da044aac7ac5b88cdcaca139fb457b75bc59ea7698581b5873eaa116405ccb81c84c8e1775037badf2aa63832c89c905016ae3c2ee2156f7d9930f5500bb96efde56956f4ea26f56f878393302cee0eb3d5f588663107add3a471c40d59a6193ede89c4c18d982058179d07fd3ccadc8dd085b74e2dc08b55a15c7809c42fe3415fdf2573b00b1c4fce869d5ac31825db006c7776e9c15745ddae63f72179feac01dbd1b07cdfb7ec08f13b3414c5e772b29bdcd5b064bb0a6d8a7dc2b2b7c1dbbe36cd5849e26adf9f9c23dfe6912363d822bf792f12d18f08233669ebdc86fd3c6bbffda430193f29254bfc51c7e6dc8b5799a0c2120e8c3f9c9c6238192eb636b95373ece3df045776c16039c8dba211f2ce0eb7970310b4039afa131fac99333919e4c328cf4bd08d5bd199bb5293dbac547cab693c58a37da894f650e1f19226e310a4d0eae31fdf8ca794e2799f7c8d2e88e5829dc046f9c3e50348dc24679ac85d04ac745d83e8d64c88aa6c4a0b80adc3091aa7cade94f50d1c76faa001416426d226c2c9f2a70b4737cf1ef8ecb105d38b349d71f3954dcf5ab9546bc8bb00f494389b19ef1f5fefacd21e57ce3266abd0c4ff78f8aac26d74f9e77b33fb575dc268aad91ba8b4c0fb4e2e0f92893a5c09739d175d3844fc2eec5247e5d4b55f9dddc8895b9c9e5387967d6d18819cf5b205ffa5cb4fcf6ae558dafd3863f11eb306ddc15158dc88252728c1dde48e27dec142e2031324bad50c3457a08c2fb97b98a3dd63fc09c969ef1419d5964db7f0db151851a0d9b8f8f2dce6ac91e08ecfd4b24479026638bbf305b1906010b52ba936fd97a02e0665f83b3c19bc12cf4f1bec8cd0e3e1bc099e880c03512b2c463fb177b5cbb1651f9b8190af8a02ae1991edc039834a0f5367cb0f5dca5b031c15466fc4660bc1e41e44b93935961036fe66915bef0541396202482cd92d26e715323c35fec943722cfbd8a7f76f3e9f9ead8967a44b3bcf0e69ba6bfde82acbdfaa52be801a2a08f9d8e4a395efddf2d10aed28c6201ca17b3da0cca37eb8abb4d8e68e42358f947ff51e812d326a72008e1e694be55f5e392df701a4ea9cc2a132d73d4578bc299c0e0e9b07f65be7bbe767dbad14b538da0990dad6dedb31b457fb34fd7437a67e6bbafd92992b88e297c425f981e8ad2e097c09137d97fbc22a0a87c47106fd50e234d1bd58ae483e7ab77eecca0be38087a9c8151f9a7bc5624c20dac9ab72787862ca1dce670d1185c0d8c461bb4db4c455eb4aaef5ec5344cb36913de6705721dcda1f6356ef7c1392ab69dc08fc2f5edd815d0342bff10b03babdbd8ef3a67cb48c30411612054b6be469feb23bfd4653db7b351fc8e26a30d5351be09d047cd7e37fc2fd6dac3117a3dbfaa6467deb6e144e0f6e80be98ff72a691078811b399cd804e3527fa01802a2fc18fa66bea61bc7353dcdac61b233dfe8d67d4d3ee7a13abcc915c321e45a8f863ab7ef581e42e45ec2958115366813495364d3b3d04952f30085dd81f0b0d09d35fb216ba7da4f2e0b26e31161b65d0b192de6abeee29fee4ad7bae362eca241532113313b343e76075eaa12f21c650b350a93098659c83609e33a7c7808ffd270730ea45674dc47255211f3b80bda273052a8dbcaa6aa53394b0d87a91186939b0de2b7bc82f040a0f31030e7666bcce08fce80aae6b7def0731ef622e40520e617eb4a11d99ccfa82a917248de22bbef5939000247eb5d58286ef07559bac9611f1a251c5cdfa1f5aaf582d9c8b29bd6559a1dac1710769899172c39e6e7834409397ab7585e494a34286b1bd1869202d85e4c1b9cd11604c4927c262b6e392e4461bb7d1bdc1c804f27e5ac1e75e0b59838b8e88261efd698475dfac8c5b18d8ca60bd54a78f87b1598793dd99ebc1025a5dad905f5138b81fb6ce095b8108480dd516a5475e364214a103e5ca8e272d6d527731d4c3e4f92e1f9c4fdd9e88b5be4c21edf0e520265ffb90481b1d4e9f9685136124a95692996c5cece85b985dce8cd1c7a5b185f3386f366d62becb08d3ba170963c8bf0e38b649be009ef5357b397a8d28bdba7aa1519d6a592fb0be917c550daf6973995135def7826c7e6766a8d7fe2dd728a44a67d90cc7fe2d491fcf6b62b65b608dbb4e11575d403893fd1fc6059c52be3309ab55f634eb1e6830011e15fc18f9fbba3715f2c66f6a4e76dd4a959434158f38e91a42b5a6010e43ffa228c5543647a6555f85690bd9392bb719b8e249cf2cfb365565eff45fc9ce2b87351c86af71c36fdf8fd9d5a9195b0a0c3e427dd2b58443029b00a51fc5df3a47dd6360445f6e0e94bab43d66fad76bab6488223dd78fa86fc851034ea77b0c9ebba92c7006ff3ec1dcdcef3a99d64bf1277c7516814ed15efa2a1e8a563921c17839dcac42074a6610825d582c802bb4954976732083d9f850586a1594281f172ff2d8f4e26252b3ffa81550346c12177eb42f989043b5628fdac415dfca0743ef5863c2913b67cafce3ca37287fb7480fb5854117e5744b1f9b0132c882ba06c465ae8c7868daa8e73902beeb7fe036ddde60ce61a5a37c1dfa47f43ee6d938a918aa5428166eadf474292bcc9b910027466b3c96df74cafaa23f73f71676ebf1459b057e01189e3a36aab0270469f68cfa84a223fd173f4c82b9ee6df8d7f076bcbc13425dcae3b612ec603dbf4b45e888a72f96a4b15c25613a02c1f7ac035dbdc52fb9a422835b1d6717f0106455bd409cd0f9d871387654f0c5e577c1b060d79b04b9b0f76cebee229b7ee83cbfc77fd9219e73e5e59cd8b3d3647e7a6d7dda6b3b30fa87f967bff9852d974cb4502e4510f1331450a6e1d80ef8b74f4b01ed62bbb65f18c2f6c9a3b7fe1680990bea2bf2ceda1543a5573aafe29a85a5055ff5aeb14feeefa19a1d7ca277cfff2d68e826c9d776197243a9c14fa4b89ed7303c5d8cbe8fd66fcb87107af476bb7a78e095e5856e96f97d0e39a84a0a0e92f346ae9708c4bacecddad8419c1e219b65903668dca8f3a7b2ade40b4e45ea7526ccae8735842fa9b22fbd02e5b77a44027d86a53225662979a3318d42dea39f299f59b59e72b45ea5e6e3bee7295f365ee82e313df928dffd0ce8222b396ffa7df8569a0781cb17e94631e70c921a11f8acf7adb1b7b23385d11be3c6be31f2bd3794d887928b7315af1f07375a97d478c795a554814ced2b675a7288dffa0b68b7f9b263bb52849b014e061c1a07f72fb2d097e254138005736f5a897d4bbc8f3debfcb543ac1eb1a760976c39029dbcfcecd2b6ea37562d361f3b7116548e7e305c9ed0066e2d446b9378bb2e8d503238c499cb580dc09c3e8c6537885320fd021d0354233089e02654a2ed54ba4d26ad0e7a73334cd64c3d74506d5d90c6c0727d32403858d274cf73168347afc86c0795250b547ab1eb477917a8b438e5e1b99e505c603c314b435a8ebd907ec4390e934b62c23bff04321b4962973e6edd99dcbe80c41554189b3a631941699385137216dcd5fae15f65d602a6edfc8de5bc0db2c0d2e1bcf08f1086530712f17b5d3c01c90f43ab862990f4da722a2fa45beb1efc1c02112aea95a081dda5f44e08fb01a2dbdb1bec319d9dd07a99579f7aa1a6877acef81752579f5091c540befd1efedff002786c9ec975927aee63f41607bb412a70331974b2ff392b7c27270ec63d1356af5118780e409984cc151439c726280ba05ea06fea9f82d1da302e36ee845fd6793885cbf65c99fac5468adbec8230832f920fc63fbf5fd08b2f51f906c0a3f65e3b1d239edbbd467ab5ace7166e4ff007f7680c6ddde31a4bfc20267f2c9c99f946a62d1ab52676ac427591c3d411dc9b5944c59e2945f174de5a00482abfafd3a26d655c35863d2fe2a432d5f58eea983b670c7f0b21b4a1fa0d347a06608a41039ec4c6836bd147986fdfc8610538c0fe399caf21637852d2a80e0a4a2e14cce23ce46dfa86326eb659c63463c529ca7f9a559471d68e9b5b402ad6308993d3a1965beec10c004842535f9b9fd00ad6d38e820b838b8c2ec9eb9d85d8965833ae45fa36bfbcb78f3154327c1117be3ae61b8bff16012b7c450d797d25de5943f02c2ace05acabe35fc0feee3c21d7bdce14a2090058e7301e323c43e5ab4aebd5e89225ae37d4d6cf21de8cd5754c2a2e5484d0e2061e000edcf06440a0ce1c2db2d3acbbd9331fb6c400f3493309442b12410ba863a767128134a5b40741cba1c5bf33e80d388449cfe1eaf02786b6c0ece91573b4908f5ee51aa154172d1a8f652f123a7df95e167985321182b4db9e10842373c725e73659dede8def29f23ebb9f0fecf8b8bdcfca07eeb0cf5f3621f214e74286243ad6cea3e7dbe0d51e50b7f71eec386568c758c1302cd86c0bf06a8f00007d70f68d44b4627b43eca8f77148ae633202f5bcdf2e4ed40d91a3c5d0c374f93fea79a3e4e164e8ed7fe1d663c41e10b0d6cda16ae412c86154af4fabc0bd2cbf2400f8912f3d6adf6f4f7c3e93560824d882e1a5d43bd4d324360b9df89408a08867706b1c15a04ccedf5f3e087e636c83e61048e97567b4915316f4d28fe5bdd6575757f3e13ebc37d3f4355e1e0514e2415c7362341db02745920c5cce7e175737a47ae0fbf8b4da6ea80e613e175980eea0a38d949bc49ce594d378ce4155fcf80b8db1f7b4c7d49164836e1b1ce40a4efca6ce8efbd3cf2f46c62cd953c799ae5336a2a99fcf1018267a2f58a8fc28623033aec283465da6b35f2ac4d5424724322034a6cfb561a66f6d37d218e9f38fea983e9ec106709c602d2b90eff5043a14b90d4049560e11051a50307a261e4a391e84bd3fa4b80574c2913196494f6bf7a92078f999811887213ce6b1e2739acc40a71e7ec28fd624791111e0ebdb196d755cd030f71e43db01310541c6b33bb03812f5b816e23809ff07353bbfcdf7eae36e05bab24448c2a08d9e21f5016dfac7ca37797bf39ecd6eeb731ceb628b56dbedc1274f2717819db96497f0e6efd5510e384c49111b38522ad83e94ff8b0970ba526bde94dca10fdff52f0188e31a42b321f22956585ab0e08b26b246fc4ab1f7a6f6b14edc6d10afe133e9c5ece6b23ee78646ccf3aa7d7b649fd28cf64825774b3f46e0721d3a908294aaef1dca858268c42dea38d44d958d97f22bff7d46123508b73b83f4700d7a21513f546df8050142c00e869c3756095c7f25fe530db0cddc3dc407de36e04fbb98ac0fd61dc033515acaaaf76676782e27d10958a6f08a2ef6bfd27f4b3d463d3291f58389dd7167b7e5c38919a0430bd18b6cd8123e4179ccf3e98a09e9895b272b9ccec3c064035cf0174e364e6b284a15029d710b53e1f0c6b73f5f667d2c4844f1b968cc6f028c9145b0e344179341367851140d4a45d961dbfdc637fcaa556c6dc09abbd84aa9b3c2fba69d6739752973a659a1c077c3e0d5097d12b7f87761945ce319181c02d2f42f0cb776d4edbef9ee44e0ee526c413fe0892e6218bdbf1479b1d0b8d391230ec1e88074c9fc54e5f8fb252de1df78a60f0cca293ed3d77b7a91990c5aae470c03d22b5ab991a2d9d3f031aaa3d1b53b52e6c285fe1bc0391fc8e5e0cf92b5be4ae86711e2ba87cbddb7a26105ddf02fea9fc4aea6e2d81912819053a0db8829b609be73e3300aff32e4974b3fbbf5ac9706be2ada969a7f17a050d5f4a588f30ff80d5c953d73c66fdae2642455cc4f35ca9f1fa92df14a0fc95d52b8b1491faa404d251c7e473ed13323bd309969ccdd2f42b0eb7aac56bef63bfdbc436183e792b9ff07caf571e3d959ea0c0569d775c2a4dc45e528878b4a36366b45af3d5a928d5cd91e4f64a2c1d81fa47bdbeee6616e52f483d49e41189fb2b85c2d91e42bcc63c490372d2dc5171dd6bada380e68d15147019465e97833c4a1bcb0c8ae204eca086a4ab48ede4720ebe9f2a1d56ab6598adada57fa9d617523763cfd918e9071e2c593f5e62be5f2a990c858b8c70b0b68710987ea58f7fdca084b338a2a1a853d3fd9cc46aad37ac95ddc09f50a633b6b4ff7b37b0b0b28372c0120f59bd4065986995f95822979974c6b0c72fa8f3dbc581c38de72f41d551baf7b6f38aecda7e3d06ca28c600a89d5e1819ee24e5e5b5bc6ec6c590de28f6df526d09dd075ca48330dde5714225c6e34c80f92962890fe7b585190506959182d70b1fb9899b8294514b7312eee6262de8b214e5377acea06e145eef1f95b3f9ff6ba9fa47175acc1960eaa4d1270fdcf30bda188b0d6c38b6875029253a3c880ba9dca7f0dc748de163e0540a824ca763bc8bd1fde4b0da095b8266a6d4dbf8d51332f3791107e716c54b975df0b555fb07737374a2f5abc73381081a5547911708dc92ce12bc73cea80a02f7b6e16d9e607ccef1d140c8c09c018e1e520d24de4945306b031bf7b09384ab4dc8cd604ae73a020d759201c701e9b5f23b513f7fed69d87019f03e327429641ce2d2bdd4a243b882839b4c9742ccfdd59a2614d90c17e10e0592382f7bdcacc83b91cbfe9dcc36ee22775a1b9b201e7817a4e8466d1660235f0724316fe3789be0b341d4ae40e8b4a8aa33d856f69635f2f2131122d9a1fd20314b82481dfd43a75c6e80b04c3eb91cc457e7da9dc9efbe0838c61f052ee01d762bfcfcd7d93d617e10a387a02aecc079ce6e465260b25b46524b8c8190e72bfcbdd04536fe5a83702298e971e54175416ead47df51bdaabd16ba38aeb8f86e55e3496d5f1e41f71e982887d5b6cf23fe82c2a8e5846b4ba91ee1db20add30a406dd03fe517f7c4eac96ea617312d4ee2aa36bfe8b6b1ac9c0a74a52c3cb189c7a070ada2edb437be651cca40823d2f1ef8bfc8cc318be61505fbdac565a615c54b4c9f119577486c465621330721dd126b5fee403410fc85357252a1823d7409d4ca2531cb41f2602ab86ccd20bc3e75ff4ba9e405e76bdba3b150ce94949fd2bef3ab4c6c995b379a07d7d4448b7632c977842f145b8b62802c0963dbf70c391a06283e2f3962116b46c6d4bccc03da2c0d127c9aadd1123aed6a1ccb39eb174a537598024300754e6e23a3dcc990294243f058fc6c8dc656c8a2d8e469d586d4563a8d3d681ad0f93465b20d2f8b644b8e6a1bbc0ecee25600ca5b45c6305cfa255608b7c0aa6ece6093b6e9471e1fbda8533f3f0c8f0154d89b351fcd907b74757a94ce92666af53f620f366db8c293afd394b8de9da2f818f7214302f2578c447d507767a7a2eebb51b42d3741e2770fdf52da396e44e6ee1d9f97267f4e0a7093f5e0cf0803ae4a778e6b04b8c61bfb30f41a2e8ef7bfddf233ad90571d1ee777ebc66999d3c8511e56b639d8f71f2fe7d066f16131d4e76d07b3348657767857b0cc09325bead0968b0c0e071f4c41b4a761d7241b8788c3a2d5022da3eb43d7d536f4fcc82650c40ef2fe33c7a1823a850c1fc3bedbdef58d30bd9ba40d8a78f475631bc69f5322abe4c36c608fc31dd512ed7536b8189f0b7150f73bbc3d634805f69b364fe4f3b1aa23af8f231e10d029564a8dce0e490343af99a12527a77e275d24d39f97229e243f49a0dd968495b0f5e6c3c97fa3b50fff97a4021ef4b06127b0987a9edbd03aad3ee1ece7a9862fe47b0611bdd0a3193335963b8ab5f0b7f040e396ad4d2990240f360057461e3c87a4c51fff79c99f6f430556fd72f9c15f2f4e644f6e20b87fd462c734a2bbb177b12eff1ff3f8c3b2b3ca088a55aac33925d8eda8d956e73896e236b337802ff32482a4210096455afb803c2d576bba9d0da8ee1f668fe5466ed26a792e1438c322529804a0f73d8ca4c48f948486a37c71a957f6fb33b169d2f282830c049cee6c8fad3df950efaab1fbafb142a89ce0eca3a6c4bc566bf01f6ad141d21ee94b5d3fe5877026cb8df2c3e023ff68e0d11f997cc17bb9e1bea4149d0bd86acec9ef309f5fe0217b13b54c0bdd879bfc39bca79abc2218d2635622bcadbb56c12f257671c353a653bf19a2d21af822e030d118edf9a6de566b0856d26abc87248b39752e8ebacfe390c77cdd70ee114b9ed5ff1881c56a8cb744bb479f29fa2ba007ef2cd363b3014c258ac113e72996ebf57b900e2894d87724f6da06c831e4794fa75a9150d29287a5edb27ae66f9f08ef18d70c7cd5589294a1720e47cfe83f5048748dfdc1c5c5287755d22936ae4cc8ae28e0bb60e5f9b5e23962b459bc7bbdcfcd719515dcf769c1dbccb83daabec2187c19c1c9b83199724f2f760334350e806de9345643bc84afe69d83cfd38f4184138521cf31ea06f370c45b0db39d19c54ca18609dbd6a4d605fce1ab22a035d4fd464da0fdc4cc3e8fec9901fb87aeae885b658bb1cc376d0cfb307cc7d8db4280d4a14130b958502663ea795f7e173bfc6a46f739151833c85432bd29b6362764b33b64da059ae144caa48ede066373b34b2515aad1883202fad589e784b2b87ce31267ef4985aab0822bfe06352e62514eb2572ed40cd6c1a8134891ef0789f998c526c196e7852725546ec770f0bdd96eaf274308ac380a030c15cfc2b933fabe47c9d289dbb0ddcff120c9ee405e27ea783ac46dc0ff04a7bd55041d3c4c61765888ae010eb2f4840345401177441e2fc8deb82ee6a87d4a95e8430163e98945d40ab3345a79e46c5dd88f7b8cdc948e701c4634e63116818f28d3b7df09db923ee42744ae2c5346611dc68fc2458a11a881302e11786cfbe5c4d972dfe1db71dfa459d2112c73a8b459a938662745321624ab3c1d79184e9ababa5074217851b9890b18b0298b82d39675ae4aa7c57a478e5ae68afb1228ce29f54da236650458444aaccb1622060141f1d4e7492ab960d53509aa888a18bd598631ec921179ad23ea1ae86e277d49a496632eaed2f6ba8cba98fdd9b40fe4c34f6129e7989251e288275ed9229cdd5872dfbb647829f016b3b749187c5e2b59e1ec26b78c70ecc69953ebffdcec0f3a0e43d82b24cd783caf19ba96d80f1a15634c9d64f9bd1d9b8d6637c098df1cd84230e5095529c4f7bc915ce8e5cde8cdd9dc25ecaf1f77f93c8aa5571ce30d899cfd93625f0be4b87360dace500eefb6a53e64ed129823160fbaf661a60f3f413a5f7896b4c07ffa4760141a8fe571e7aa1b9fc6b19ea8cd05ab0a0149de1c2992166f4372c2cbb8deaab77f11cf9c29ebe1f08fa0de4e7101fb8bb580e514722131c37ffa1e7aa9373abb6cb480202d3438cdafd5e6ae16c9d349ec94c27835ec818b02534de16db10a04d860f6e5755d07a3085abf0d825ed863580f85b811839f1dd5b17230de657a557dc10e55c1a4305c4b5a68ecddfe895a1676421d091bb94f367f85e3cba526113250d254215f43534dad565f717db5997247f53c92fc4829d767579a46e5f4165dfbd1524dbdfbd4180e23b8f0350987569a9f6fae3bbb886baa8be22f75e634eedb14608655d1eb91da1506f4d73c846bc44da569cf42bb90f10f123085900eab410746b56ffa9aab0bd028cddba53637da98d6d5816154a5f14f216eeb6c1a7e668a596d2edc9c752a48481e12c1619eac00397e35d871744b777759dd722861f8609c1d81aa283bfea33385294bf572f4050adb8f188c28d4587cb95ef2698c4b14c240c6b1e930fb94ffd1dbcccd7d5b38a9b6d15fae86f158c14674dd926a7cddda6053585163dc012489acab29adc0f82a8423646d1979b80f2e23686c4a75ac03b9efe6ccd90367ec5227dd06af40a66f40c0db45f8a0a2eacf044a59afbcfe215c005a6a69bcf69cd426b3b67be3f33d3ac46a7d033efc3118225e71c6c34309a81c217cac77679169d09e65abf5d9b30aeb1b04e94fca0993e23b7fb290c6f9f57d94efa5b1225eeeba9378b3394d73ec277f9fc95995df94a005e1e494c381442bf80cfb8166ccf35e9a2774caf8860fd4a606be26b91c655c42956a12d3adb566e7b4da98588043b25fc5059c26ddb3fc3f9da360f1a8e6c46db3ed88d2d4ca30de00350748f1cc28ed41ec876917e25c85603f9d7a1c422ca691cb0319f776ab7a4850dc982ec505372d5d5dcccfeee0d305114991088ac5386b309c36b3c19ee226d03f12c0edb48fed126aec9d55dd5a76a45b459369b5faee83764084dfb2e8bf42a7d6fb84fca8cdb8204234ee638253b9f1ea4c56857ff417a2a1a0bd99064e4b26630641470ea9c991d1fe0c62835b77825885084cb58eaa6db56c0a0078d2a0c46000e037db5b8504a3fe7550fea43396b8955e33e4e2580b82ee5dcd281a4f942b72baad2948dd851de68a03c2ca65a31b3b16bdc48d8278d8f5b26e52f021c582568c475f3c01dde34c1e74016b90c11af3dd75b0f6cd87307d1377c4ed7df43b5e7f1c1047c995183b73d9418146ebd1110950858c29b7ef7b309d1b3dd2b0430fd208294d42daf36ef5bd8a49fd1c887a6e72e8a880b21271337cf87698e2a5d776b2c9fdb13fe36e6c9d1587a74ee3d654f85d7c3fdd60bdae3ee4a35b0bd323a5576fbe249600c28b9984ae88edcdc4c95e9f45a4600d8b2188be8724cd72c038e8e0a1899b0e81d52563a21874b691a8961acadd66de69f144ae6708400e7ccc918dbba892216f02b78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"611747593812e15197f2a1cfc05e740a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
