<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb6a4f265228ab4a3308fbeceb8208e28e545890ba14c9f3e09c1cbd00d73ef10d610bb4198dcd740f71f56b708bcb0457f058c811a520c9d20cff4e286186355c16d38db32c5340b9c25c5d469e4cb4f251f28321dcda49700c2c10da83ee03cbdf60c5de3f71361084da61aee102753f0618d9a9d1ca6ad37b4a8742d2bbc45823b6e2213cb684356b5d2b3cf8feb4319df6c2c9cdc9525597fad42b787857fa95b55c9b64985441e577fd1dfa51f07f0bcb8b31b6b4cb0c43407c49b606ba441ca941799c311890f1fd51b5e7bac6a533e5759543aa67280d73c2f9c5a6f0e620452a58eaf53cdeaf167ab49d570f2292066a29cef01b9b137e9a26034e3c716db7f2df09c7f819f9d744fc14167b378f5da1fe4a7a1781045754d2e65795eae8e55c1f794377b53cd6284e0ce4aa6c73003d6067b4436b6b4d0b007686317066fe81575279a6c710ceb53c6a71e464e423e13f14372aca75eb164ed94b08e93e1ffb551a5853a23b80615b5458fab623cbb8eccb9aefd8b30ce26b9d96c4d1d1dfbea53f7a6d59b23d23f45e567887d0a5b579a05c3c37af0a894f4fef8b634e5e790eee07fb96b7933f739bef42309f62c3e0055c23273d89ac604a08631ff006a9bc2bb04b8b1a0d987a33b33fdb5865414d217716ee2f706d03474bd5452c0acdf0a6116bd3e03dcc555d7dd163757684770a73df9fad3e6261895def0633add18b835bd2ef44a4da083a9c4a4261cd9a1d874ff37efef8f5f4ab1f3cb6766617d0b77ed43dd17600d4b0b57d952ac424b1aaceb366bbd5923fc88078fe9d03b3dea2c89798e0b085631637d02a1e8afca1174d483f6b48cb482a3524a7544f894552445da604a5c18f45bbdc8ebe34725cf342b6bc6515f2bd0306bcaa67f21de525fd7ea3c4bcfdef1f62dd1efa91dd5794378b12a43ecb41c17287e489c9d3fccabd259d45474adad484ded1de996ae93b9d1dbbaa311c87a375c9d0aa202a0b3605808987617ddd7fb8a4b47acc82aecb95e938493aa8558947957a388a4442552b1c775c75c8afb75d753bae3a00c5981bb321e91aa6ec6e5298c5a44575e5a702026784ee679c362e8758071377468e6737ffaa38ac72492e2ddf96c64a9fd27c912fff025cbb183e569080d6d2406eb28eb54c525e0f0e94debdacb36c3f2662e8fcffb4aaad34b71f3abdf1381b9353ee2ad1bdba0c09c73e9dd37f9826a029adfe8d89f6f80b5b0bfed639346044468493ddbd100b055d116c61a1ed1b169da7d5d4f79008a36e916a9275a9a64d0924f4526e866de9ffd70f87effc8e932e46f056b8520e1b70b984135f324b8ba57fb9f5e198d7ed60e7615ba7369bc669bb36e71f206202358daf5e1b710bef94ef13c3a6407217b9b6826878f52979e0090e4f90e5bb91559b289eb3a93577b2eb514d648a9f55f131057268f4c8f0f09e9fa9d90945d6c75daf1d43d2879e5edcee3177226b86446393c67edefa96bf58100e9192a2788afd5ea664038bcfcd5d10be66de41422ef3f029bf80af3b9a5a57be8c5492432e7e4e2f17f6f0ef0b95b9fc34c08fe8349b4096584b22cda8c41925a9433bd04e45bb2fe0dcf050edf807f7aff64d4b6307367faf2487276a3570bc8e3b7a39cfaa7ec44d2bd7f0e726ea83f387ba5dbabfa0cb99b7c8e5fbdab9b8d1bacfb4538629921eb0d1209be08e254dd4515b1350bae93b80eafb20727de8bb6f0753617ef77b724401e49fe40e7b9432683e52e359220428f65534cef8af96e4565491d45dc80520ce8469db896ce177777119619ba59af19cbedf5900bcfd6c38bf3cfd92c8935683bd68c09ffd747aa4c8b83abdc0f23d4cec3f3e1093b2a7b04426ab342135a2de189bbb628a468ec8cace1b8531677a028da1eed01a2c6af9cd1603bdcb3f27cbe48217e8ec6deb0e6e0ada946256d93f9b10268c324fac684cde273d253c12bb31ccc8b9c3bde228990a6895b93f69ccefc76d420746a9b5d84bffc669e2fc6d1ea0c2ad95de20ad808a7360de44a9eecb4c8246b3c2379704f4eb34203fbf990d61cf00532d3241d2289d9503bcc9050dcefd0c865f79a3d2dcbaf039a40c07d202ac3bb6a0d3563c7d74529eca27def4bcba0bdfd96d296b66764610af04364d3fb79423661147e98d4a8ed402a5b50bdbd6d68b66e9e414ae5a76bfacd78f475eab7455eed781fc08e3da7ed5afb1a929f0c741ae85a10d8af28bf90327ba0c09b50faa206c75d5ecb803bf8424b01f2e91b80a6997e37617884e9e4f7a3bbaddea0125149452041f7d900afd5824fa6fa302748cf01068d4a82f90f114c30831aabdfa7917bd539ce2382cae15c95df93beb4e2126413696bd086c732968abb80053144039728a1552ff63847a535a39e81d49ace36e73b1264f1ca55b3a9acc18bd2f45116507d5d3e30e91775a11558b156087c4960b14b01f44c7a07bf882edb4cecbd69727c3d828223bdcf31713879fad828a756ebaff1e36f32bcf7fe89ce590fb0caaa5ef2f8f597ec536f71f1ec571aae767be706df01248d2964f0a59682f4bac86989141bc4999ca413cea5e127c0451ff152b100262ffe054c628bab5708761248d7d4b74c30925d80293a21ef51d8f5d291ae182071b53c9049b8facc350ab0a148c050ba7864ef1aabcd045b533c9e2fed7b858537a5e327e0a4ea63d11921d89eea0e93646a0ac270083f8b7f22b07dd437c95e3b0ca9b9f7e0b77298a4bda6d5bd3ffeda1153affb9e08ad7c135e6a2ef40e73bfe66d257e727a2c49d4aafa2e9303ab772503512c51889ca541f76adc857757ec58323bd7eec39bc4cadc7078ab3df0447308d1ffe28d5b60d631a6b84484395da039d789ce7c93b65fd8e543481a12d553a0e9df10357a3cbc6978de33b77d4c5d4bc5b077d3998e7f209f4c15e39ca42b72e13987503f18b5e15b48ee2e5b34b054c13a1c4401a55423614268ca3567f26de7d25b79d0472e80aa0b929d1caa02d245ccb46a3ec47d213664818d5d3c206b9b1f9fee874cee85692e7b6dd397b10148ee15433c8430d00f3ea5ec6e33899902bfe9d12becbcb426cbb7a15266cfd3d4d64e9452cec73bbd7e871543c5fcd3ed548aa0325304066a821e885c89b6db09d7c91b6788ce12fa57497ac3169e98d95d43a2b0c4e4e1263949fbb6bc0d515c2f6b5a5a9f5513d38ebf0c0f22c4f5f113d828b936a2ad38b3c925474a22613d6f07672dc32fbc866c3c4aa4a06b087c037157095ccbe1891e21c2078f7b0caf56ab83d926341683311716e9b9c9d5307ac00c4cadb0fe008c7b56031c1559ca48d2658820aa2aa14f229af7ab9e483f167ed1e9cceb6a7ba6c2c03c66348ec106bdf05cec873a93a58e84a8d339b0397758b9825ff6fb11e18ef9d78d6e2e82ed1e6ae08e1f5049cbf89420df98e40a154bb557ec8cf0cbb80f78073e20aef1e96ad463ae0dcda7024845290b3aac88d528c4a42a579b9a39cce6ad2245d91edc88bde444ac09590921a170944f9cd3d7ec029481e3cfb398a52de480fd827c6676133fe335ece13d0df790321c71299c9913ece8c8ceedc8f3fb54eee6b0408499813f7662e086c945e599895af95442dc7a4e5164e0ac43b325214ba9b1dd524bb1f322f935ef9db2ca9785d0abcd61d905536bf94a2abe28ac4abb7292e0d1236e3c773ec036d3f5e7f7b53b31581f20319c2fdcfa313135d5a49eb995365449a0eaca851a363b2795326f76de7f544b4fa11a5898915a2652b891e4a18afa83dd34e36ac78518a47d16ccc8f0b0501059f0848baac5dff803db998cf667a286bd94f328c45d21ae07bc37dbed36f46094997173027fcbc5ac749ad83dc860bb201c435f068d43661e47535a89115e65e4898ac6942188286c5a8f5cc34d9fd2b3d8e89598468488095ddeb8f626365f3724c8e56b06fdea543470a1fcb056f1a285948c0902b3e3cfd3cf403c2bd9bec52d003976cfba5d1ab4d3c6f2b022d6f12d9ec669db91eb5b9fa21e8d64a7285f8e15cf50ad19317ff191366508114a659eb9e6a660866671144121201640c45e71b9dbf7bc1aec48b2da6e88d50dbe2e6da2c57608d94b4e51f629c213acbd727e708f1309da214d813a48b645ced386552649cd61e6faa9e5ee48610bece03b5eb2091f56c8d4facdf41bf4f1f009d0d3569be1701e1e461891a8f29367cd5780bc5d51c79ddf3dcefd1316c23ad810dd53b90c3a303162f094aa671235c610f29272638bc82070a0f50d301f5d042167616038006310168a5bf2127cddfc51d30e5f418cc9afabeb2790c21769da59e0c9713e078282be80bdee87d8e255aaa56d17c6fe4349802b496e588dcc416e155bb6d4e824f913339294ca0e721c6e2c4dc92f582e690a1fb415037b832bcdcb718aae095152eca66d35625546d6318f67e6d5cb8b81fc65de7d555d6d2db6b950737f27c55beace118851f9ed1a96eaf10cbc7217fad7c70987f23f0313769b4828c800198642fcbaf4f3281c2a5c15febd347cdb12bfafcf0bfb1f91b2854261c6f506aa54f6fb106243f7c14d36212430e77526e7e39654a32c927fc797847bf24333bb52d611de6d51087d6bc188fab4aed780acf0ce64df2b234e3614efc13e641faf9382126d2a7dfcf611918ee1128ea8e937b6dab08ec89276e11c2de867921a59111755a8e9460f981109e5fbe9e61860eb82d626520763bc639cdf63146d4e3f0e2af7fc02e778d2a6e696aeb6f052e71fe2b2fa25ea796907d52a276959bcc5bc448972d20a73744a09187bd6e2646013f47d176863c410f5a34c88deb1e1ee27baf3c604925dbf03007a41087131fa8a23f8f4b219bda0d916bf9abbc1fb31d19b1f15419597e210d2bc2f593fcc1a82e48d8ee2d2df254f3cc846e5c7ff7c93ec459df0c7ad718e2f5e36bbfda24835fb9c98c0c3741a9f2b5ab9ee9b31c462efb61bd88b469668a3f6ba0a47c76cb542e50713ddb4100c54ef29061c1031e94ee89a9f0549f307c4b45c75886bf87e6a09d46a1327e43bf67631c9a63b95d6cd8be3344d98f79f054b285559079a87df4fb21953a1e89c3bf67c681141b808df91a38017da0a5e4eea8d80a857bc4785e0f975fa92d7a18cee20fe8bf69d55c830c9e9f2918457139ed84033439ba1ad0017ebd4e77f8aac61b597fb413a969d156acca381b9b9cabff835b5eb90e4652daa5725cb843f5ec97ae398622e48a2b7f20af50f2cf9a340f2f1a998ac8c1e3a833a940520c070e9cdf2721bc8dd77544ff97e048916932c7e895d0210e1f53d1558a7988b8aeec606098e590316d9c0f00da1676faaa0782c1b4336506caf47a94ccc4f1467dbeeac18f24f69dc5fd7a15b9c0503bc9287b0ca413fa007fff292fb03835e13693ccf509e0f9ede49cfe1e8470cdf748ff2849266e4d35569108ba3bbad57ec8e9a9c83cff454d8a4ae9a9104e0a7b09a59a86db116da087867322660692f7bca09309bc0242fcaaac0d53dd1e2e80eb2348d83db14337e564813c41ba58c70f1dfd1ad488d3f616b6b5f4608452bb4e6058abd0c9168998bf0f6077e71f4084b4d43e9035fbd91bd872d090109836163364e7c187f7d83f0829b567f2d68a0e690131f67f3ca0994be8d7bef9650f2cddec1b3a4d6e761bc754c83eb7f67e902271c1184602a9c72f1eb2111637c19baf243ec470c019e744c7a936c429a1daf3de7459f8c16627ae17dd9bbd53ba434263071406ba258e728a852ae4d5d3cb2136f9828ba978d82de8230fea1866e6c564eb35fdafa0568ed568a3d3649ef9f4fa205dca2838dde940e41ab222c77889fe0ba4b235682bca9703e4c4bf52e0007920a367fb8328bd6544bfa1e8058ff6a0c85142fd8de5ef3673385170e1bef26447d8f82a5ef4ecbdadf46ff82a21cd267f0c8cc2c207cc3e5bf311df26c0c7a70dd3051a8159bd08ac502e6a26729e166358a8a00834c7d281e05a85766c75d29d558cc88f7b53ace3b07239b8667b31515c5bf9a47ffe685ee561eaaf7fab928251da0c34a6ed406a9952553fc22612a5e2619cb5dc2e0fd1bc64e00ae631069f25a6561593e6baa6e8d19157aa26f5d226da84d09a3012ce2495ba4e3c2d7b946407941c9345772f8db41cbbfd2070535297766ce084c6ed42c517f4aef1ff9495eb358eb638dcf4d446ee8cc5021e4de26435724af7f0b52ec412ff52e35f8b541ff3cb9aca3d53277d54060e0d115a8ebe11cb45eacc2e16d39f7dcd7d7d5b8363e423735a4f9bc0ec4ccff5b4ab2aac3a7096bbe7df92c904bfe274f7f01f05cb9e6ad33c8f9a49465915b15d841c4c46afa4a65eb5275d90806d53debbc06f550266e5f4d579797ca04422410d6dd58c8c9cb2102d8ef2355d3b1fed8e21b183eed7e1ad456c4354ab8c165d4cf0765b00d905ad83da5da538e7b3a0b83bcdb44b73a6e1b9a324a079a7e02e61901a1a2c9f2e5205c47788c00c8423efc7349fddc8ad5c1b3fe7108ff57def14682cd698c7b6daf502174adb1daecabd290fd36e5dad1ed7808742548cd259e07186c50ccafec3bdb46cb1b70562e367d3a5ab90007d959b89114d8fb21262db3e567401bbbdced6884cc6a6a5d1a853a1577317e07a1f4190b63cf7c4b94f68226acecae98c32c5e0a51f4161886e485095ad0156088d4a43ec024713e1686f4e706029ee96adbdd76a1238134f5f30998ec9357493052d2d40e1b95d470850208c4fa6d3eefbd3f8a8e94b1a8e3e9bba0217f48e5453008eb7dee2f885447ee06b2820b036ed66c20e784d3b8143d75176ebe45e00a82e2535f53b1791900503378e5a948e2186f66497d0987205522c5578e8a4745106e792bb15f212f6a74d793a8fcbcd6fbb4e3adfcd4fea103fc3ad2afed21caa5d0d7a7a9477c3e448662aaaf6e4b01859b8b75c6aa57bb8e4f1975cf5ce4a942d757c6f262f67e03a3a4f11b9f0072341b4ae883fa35a469056fd1184c81c441c84d88d0f46aa8324c0a6855dcda97da575ada59cdb2487d53e37335302ebaf3523c25564991c5a94d586a6da0ba3b43e5459714e9910b50a103d00676f881cf36406778194c39daafb2c6c725a209949c68ca12611f573e9282e2ba6a0e9e64e5b6a654e759fef83dcb5e3d3065ac3248c1d796787a8c0234b0a2ce8c4c055d804e4424251ca089a1216136a39a9a9735f7e40cedca613594cb5dee97006045ef72be9afffb28651229e20830c9f9ed0d60db7612cc7f12e552742cd2fb61c4877e1c22d05460d573d546d6f5f0a24f889bc0775f1be8becb1f1a473894f74a20ca5573a5017f43109ac625887da0a35f3829223acf93a140a9ce6645e470924b4a8232b10dc0752cf67f608cee48aa19fa5380761f7b8f3d7930f43b778ecc37240310bfc9ff7b573e9f9a35ae468aecfd8da6cca8abad8d9b448c79b56a590552810bf4d1897020c88ad5801a7625fe328a3266994e2e0b5be93df69535b21481f0fd2f05107272d03bc2c36353b7ff345ea6459af8b5568c414a76ba4366fe35a106931d58321057a9bd228c5fd43d48025a7c5cd185050f6cdc258994ad19362ec49380e2ba3ac7e2fe4c286a66d1644c7a07d8a9ccb48bbb6238aa0aa6a9580d3adc202080b63ffd6f190345260d0e9ebdf33090ec8e5c73c803b090ae6fe035cc1aee99de6fe45b073e18ced101213cca1508a37ef8d993ad8e3a848426d0dec90b393f4f23b30ee37795a9f713a0ef0b08eb1d44f906bac231bc03ce07dbd7b03a827df93cf2d5db8c709124366c7f6dc9b10e57be38e36d5527ebd62813c996eb4a70b715442881bcc73ffa29489c4e1822394bd18218389aa329519deb53e78bebc41496984c0a969984d51027e51643dada2a650b3b85534222feb94708f84df084178ff4d8dad2e21a6356a2df67ab15c3007238e873aafbf3e7d4a75d898a5e9291c046ecf089eec511ed32b9ab87e9d8328a7594b87a5ef9b5ab89c1ee06832facb0407936a0c4eac1885f23aa53741ba6c9ac4d5151e879e126e543531f8889e008cf2369dc321e7c8ee58a24090a7b0372df4b5f642383ad0d90c7e73d5fc61e40395d9670dbef2b28593c75f9d0e2b90f1bc27d6cbae00d1923d770ad718894958d352e7d49b52f9d1aa627ed8249d7f79dd42a20d9ca162302efc0e4b848dc396ed89e274adabd0bfa409828e114d4003d84db17fb3aa44c762a042fead000e5904d62e753d023494a9c21b37109068de76d7c54b1137c5cb1f33c409914ea17161561a6f5f97ecf879c137ef509dc2f3f4648921dcc208e409221deb7e4ce8c0ea38d9df1e411529e62ba573dc95bd72252f019adc10784c560ab49c184ba8e4e69aa739ab30c3b02dfb5cf220a7f7d85f5ea80530686a3a7c859ccacf20a4c6a6c0c67e4111c309de6e808e4eec307f505dcbcba0968c220cc64df024388b48118943aaf65f9c850f701781a89000cccd2e4b981b50213ce9e515184a1e5fdabb7af19d52ce929795b83264b68cd94ed6ebb904b61945b04e41beb3bd2d4de128c45967ac4d45f294813ec39bad685f5692db214a92af9c5b1180ea015eed69ccb7465b2b3b1bf6127209eb896582dc594d11e827caa4e430d78c6cea85b99d8cc5f2edca8950972cb0cf02da62bb0048918138974ebd3fbc68a782e8c41f6e4ced6a582b796fd48abcb271c8635d69eaf60828feeaa944af2b9e14fbc36617795293a55dc9f93badb6b8a3e8c50fbcfcc5896d24d22b2b1a37ef78ac0f458946e0fe3b3fd9917ba74b8d0c837f5005f3a802e293f89ab8e7e9b11ee10c9c2cf807f74c9fde429b349c1962a34ba090b695b95b70f948a353a0cad6b8beebcf396a20a809e92f196f5210ff04f50aeab2bf96e6fa491e6aa74f460526c1b6a951d34e58d30ea85bcd39eb1386bd5e9e072e46ad19decbde02d9cd005133e73e3459403a0448f0937e680dc21d19dd017bd3f5a9c632fd384eb4a772d9ff8e186a89200328668e31a61bc5ab169390cabe7de35eeb8ae689106a0c17f7697693c40e6daa1faabc2353ef7ed67df133bd70c774827bdf33de9745bccabf3826b8ca7a58bbd859f1ec5b886bb846e1aacb308f084dc18f95df9ec272243da262fb2cd7481445e168ae80d64638a406f7296c1ea90cb0c853676035858db18648cea3aef61f7ba77b5fc6f0c82ed6bf08da59b7763a4de16af952ceeb4a3ff09d3694d5df35b59b27b02888dc603873df57063e483275864b677739d849cba8731f77e444dbe43e66dfe32302eb318f8ae1d4f46d9224b43060320f750bb94a897c67aa76f753e171c275be4d32a165f1975d56f290cfef62647057d496f9e83917ff7e8e9b7ac9d62bb2d4ed5ffaee6dcb6c770ab7b6f35fa6747bf8b0b30915f40f07b28d8d1ba02959eb2b04af9a4bf99d9d91e63151925f59516da2b91109f1d85a35be614af1ceb4ea6bae382fdcd5c096f56a36ea0652cead91cd241a3afd37edf17184dd0bfa5c458d76e92b2963f3ab160b5f64ea28323dd6350c391fee5223f50f135c35070e8cce3eaf510f5eda9f5a0db6123fad64bac446390790dbf6103574759007fa0dbe698b22d197848be7e987c38930da2ed785280088172ac57eb7c737e0bfccf845370a7fc98845d0eb7b109e81d2f906acbd3b1fcfd3411d6e9da55fa020cb2b94332e54926cc9378dff232920adea60ab861be22c79b20dbe681dd7ea5de0d8afcf0559dc3318119024fd3af1469d47f5cd3cba72c59b7adec5cf4fd4190ad38762f7edd4fbdc2c0f08b7c82061e66fce98ed90a99106e8b75bb60a99ad5b4e597e7196a18c066937e3a73cd7ed84600489ebb1d8e379c2aab4c8e1dc240882ceb73c97f7849eeb5c2e467eb4d1a8a90518fa7bce98cb6e6a3725c93d7aa497a8c29115844ed1f3dfea8ab8a2a4a1829e15b853a00e9321036b809894908128298f6dc3a50940c47cfc1e22f28c110d9d25d338de3a92e23e227c56a1ca5e1db1f5398707d4702e4bd8a458840360d7ba8c16506f3b645b8ea0920b6bfa6811a1556b6cdc28f059e5f9d50454140a31a3433cf05ef3ced791d4b3dbd10c25a71a4e17cd67f27cfa2b13347c875c243d883339d84ce92917206a7ba98104beaa542f9cd5561daef085c335622c3d2aa31dd080ef2a9643c0230288dbee83d636b0934f0f1afc3344e9b630a381c8ba94a211c4d77050e4b59873e75a4b68fec0b09cfa3ac83a6caac707f10b84068e0cea53c7f59ea66457881c1af90e5ff785a1f081f324aad1292987a8f04a57bb5c4e06bf3563184413e1c5222c1a97ff8eef6d6b5609b7f426788aae3df0bf197771bc30f17ced42b37eeca67333bdeef3dacf001c20003f59e71511059980820b91a2faf32466462164ba6fe8e6d440942c615f46e107dab85842436c33588ef5e5e582eed7573f9385084e24a3a32f1fbc381f905a8527f1b78acaa93d203c564a32b29802f8cc348f9fb9aa90cd46d6318b11e8905c3b5124f18748722234853e031896f07af10ac2822d5dc5cfa0949d204500c646eec3580c9f53549d7e09e2d39f57fc24d1d226776169ae829ee13105cb66ae64dc19c922efee2aff6e7e1e1bf9d5dd6db2fce9b6109eb033cd961f4f800e356dbd054d0e24552a0f5cfe27877ca1231f96eee21815710a82f14b30d0df1fa192e8064c376902a2bc45174132d35cf162cdcd313d5f63323dd75eb793b7c107941abcf28a82ddc581e6a896b60f90b86cc69762ecd3271335a2228c6508e27f10bf66ab0e6eef54f156bf2fc5e6d74c93d9ef8c291b140581f40c2f3ba187930353216be5baf14251f306c65b19d2787aa90e1023d3c7f7a4afb71a35c04c112e581a53540fd86d2f7ed0d2303540656cd022a88370edfbd085f23d28d020dfa9560a8c0d023ba0ec096f4407c64023e69437a17582e31a0c86c4e60eeb8c1a47380443037e817f00fd43a938591e994b0c600b7d5369adf5a6feeeaaa70f18d943425250a34ee324014276a9acaf4af0b5c7d45959cd3eed4bbbefc8d592e7ddd066efd7d003a90c3c7751681cdd96910ae352205078d04fa3a041658c66edf34ae4a9f345c6854f73b0f2f3236efe8295c6a2541cd31b596529381704d6bf4b1f3c24cddecc32081c17563b35f3c922a63820b4fcb62adc4cb217ffc366e810f76eb74bf51e70d286b1425cb26f6627b7a7f5f284ff5d469058e20af7c432801e69a76130ebc5cd365214381ad45d22d0be7275661f3814ed16bcf9c66a3890cc22b43be3c7b965ba78062afc50f8e3fe55bcb1cdf920297b6d69f22ddf78f8854450d8be1b51833cf316019a528119b694244b4d6901257b85c7dc9b885fedd5ceceb2106a16bc1833fdc53507c62bbab6c01f86ced3d3f01a01d9fab014a4a6569be141c0d3d7ca60b73a0afa08ef462e066ec1d3c5f9a6837a39c2355673ebbc4d13919d7bce7bd3d290c999953e0dc5cc0fc64a23333e2a8e9ac1ef0e047be64021e868f393761293ee210f3cb6daf9cbc55db6c9ac1f4a6c6977482e8a235a95c837948857b71b15a3c3c2f59352f01b29203e315df898bd108f927247b4aef959366f4688dd6af3f9c31169db9d6e56e5b5f1f109d6ce39d864cf56be03a9f96497b2af65178e331f249a049ea382ab8c5b75a3fe63480b53240969c50666d8560e9ea56d03a497d8e12fb7d99b1aacc36eb3ffc36abc98ef15574818c2f9a15c74a318c9a387ee28903d05ff03e5bbd50460f48c4f3df47a4a5d77ea529765e2f3cd90870ce9f8498e96a0313b62f8afda567917a59c9f6f512d752159f202c3eb807f4a0170da5f6f15eff8bfdccef8bb1042c87934aef5c524f97ecf4af7814ec6aed328de65a4de71ddf0a022bd0afd6df970c170c1f93a5c821c82b2acb6029c2abb4c505af2d27b59e3277c0ed36a1d8081c1eea6489916ab4e05a5f4eda87c1bc8c6886eb3e3c6387b030579e404130378d89b8557a065274af00440190fe8e2b580a90b6d65869f6279c3af4ed2724c57145ca365a31a3774eb843dd186f2a5ef3bd3837d8270bc76991399517b6e64f914feb8340b4aa44b1dbcceefc08265b6ea39bd85e8dceb3bdefc6cc8c103c5e7eb640dcd35b654fe79dae974b68d4ca29590495ddcb57101f572269dd2c4b9184d69850d3b10aebf910134857bf381da26e3aca3d0333fec065d951141d71a8e42f0f10180162842953d9ae529695dae1d5eb4e631d94d84667d68f1098e0ac138e349f31a80af0ad61cf2a609e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
