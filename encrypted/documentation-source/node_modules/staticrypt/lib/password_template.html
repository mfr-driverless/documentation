<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8680d1c39ab87460576e29e3c510e61620933bade6633d1ceda44c627d13045fa2cee4e6242dd9e30fc96ad2281cdd53c357115041eaf7cdc11efdc72449377dcd5f22dc74c6f2737204296b9cfe5d688d1665927b2a0866351b37ea279e8df31162c9f2f92cbeb061ce62e01e6c7f8cc3e7f6b222de874a62928a6edb0997d428d838613aa731db2b0a982709f637bf39699eb1b7ab80c996731acbef99ae844e353a7c532a3d899b12fa481be6a75611bf4a90af450a2b957cd3e7b3465849c78b2034fd4b7dbaf8bb68f711ef5a8b12e4408209e17337732c3940d0280ca4de4944ee73fb817248940939be36e6124df849baf8645e92848629a76e8996148cdb2935b685c39d3fb82d46a35cbab1e7c6d751241b848a6f831ea670b0f3b443ebe9ddf62db6b5bd193a0ff0117af8ef6f85fb6ef43f1b417fdd5a9fa8637abc92b268565f1906de9f5785046e7f68f9400bf18fb0b55a135356a59a1dfa7489374c691c0d7d2f8aa0973d18036dfd3a205486cd1d6dd4e5b2692b5791128e6c03e4d379b6a5356233f721fe24178cd0f1ee8ec3fe9cdbfa682f253d1c5fa600af09cbbe6af4701e7520039b08846646ebde93ad06c101b77145090f749e9fb0c7a22f09f8222e7e8c9325680fefb0108fe75eb3966575b96bb21d604a0b7e441804e7457b2e9081dbd99710a392c4a08b15eec062e8672f75c3243dd70620bfe14965bbdabb14661959ca6e45310c6ee8777de9141458b3f54939d643bc2ae9954134ef6f58c863f7ea5c1630fd8d31e595c91437339bf0d63702a37dd1c6b12265d8085817c66cb620a48569510559a8ae832e4ff4a50532ce9a7158470616f1f984686cbc26c6dd6634b47daf6bc2dd334429c51d7ead39ed0905ba6fa404ac238083254befaccbec44c68733c425cfbc779e1362b79882a3b290ed0b19ac2a13de11cd0929649b914433882a4a422fe4d4c8e68f575c762bd8af3c5cfc71c43f7bd38e80923fa159d128681e563e9f4977aea090833db9c7982e7db570ab18ce6a3c3650af348c0b060a4bca752e06c1d2af18c8a172f44633eac9b4244e03d11aead26ff5999f44c439161c7aed482c5b017108439751cda3b9ca243da386e33618ed6937c930b967b1e7fb20234499c0f7f9484fb6c6a9cd543c1d1aa6dfe955bda9a334ef85f0ee375fa6b72e89e6ad2bbeee29a9baabd366f50398cdb44ec2760382f14a18a239e184cc637c1283287489a869f7ec1eb61bb1f7370afd9fc030588e4d9a950d76824a2967ef3d0ebf68ad1dcfda15f2783a4b2bd28b4ac2c65b916d2a922371e4e1621406f2119374b69c862c85df7288a51292b1ccfa72b5ca91792c085a9d0e4702d25b5bcc65e09b5db713d92a0b1d58287ae75df61acb2c7fa3eacf9e873540a9b1e019f51d632777af547937d7440e9ffd74d4bfe4a7ab2b02dc53c2141bd6018cb6389f094172df04d0eae44d7d4833ee4c59c1334bc3ad5d604b580b687802c6fcfab39bb9559dd66197fbece2e95977ce7d904ed22b4dd8865832694efbc0aa8ad48ec9f398fbb801a2f71294057fc8c3c443e361511320fbdc6e16d054ae9135d07d335399b5bf694d25d69027e44184db005f58dc291fb02d2a56e5681b610c0a5113fb34013302826ef93a941ee3f7bfac6f0f87a4908cef264ddb1029a2248e18de77fadc943b9a6db1da5305ef60449f317e316fa8b0f8ab418e13607cf2d510fe3b91b7f2fb1ab74f189ce733708fde509c86d38aeeeb1b2a63672458a640e1ef401c226ab473856fad3a0b2e1dcd723cc2da3d1a1d6f99ee2065710607a036adcc4501445097d188639ee66b3e7ceee541d5cc98162d16b9a002f89efc0a7b5d1210a501e47d9f7e36f8ba8f9bcb00d4479c83cd4f6b9df4bc2813123c463ffab6985a7d3066d52e6e5424150a6f948215061ce4817d770f7977b9f4774defd2798b7bf3da056dba49749e07bdb2af488582d39223938ef5455ab76b3ddfde47ed991b6e04e96a26ac5805b8d091de2cc39a7eeb70fbdc92df3d9fb6157ded63678fbd3d4fd07c5bc0834791aec28b9d78903e9fde62265a9da4549739f02a82351859072e2927e9752f472f4a01d76d5d21aa64a88df9507edda709bdecf4fa0191dca512f585d8201abfac0f8c0a5b36ac1b8dc007dd55dd37211ce727718dc424ea08c17750b505dcfbbbecdd8835f5a8e3e05c4226071a697fbe94245b0d50e1fd84fc4b93092f2d6514f60f12981be03ca615e0371908a5f0abd312ae69dd1c8d72839f57a7f46ebbabb0b621e72f3329417910bf898ee1a8bda9c8373532c8f540f80672afda16365f7a1381eed6164c79cd1d842bcd725582fa9a79dc49f0d8479702bfe5f54fc60e8e8e3041fbed65d363fc98ea2a68b216978d3f738728e37574e25c0dc4314b5e52fb3110d3a18506a4f41a9ab570841a4efcd3f4509543aaa13aef0131f39134f47a4452707f8779f52601140bd0b3a38c1abd77ded71ac7e38e84403d777f17f5c65ae820167b725a3e1d8757cbc4a003897d8a47ebb2e91b9e43a271796245f3e2fdd0893e7b4f8c5a130bbab0ce6b4f1979a5d3643eb4694e42d98032998fea810709036d5df6576a01192a3248e60b7221db259315b1c542611ba52c7783a190d924077ddf2542213f15ac12dfce841efa24f4ea95752090404f21b48c408fe6339aa8024936fddd343e2e36147bfa5a5ef82fabba0408337edc1682eb776208098bdb49baece5c242aff66b2c7dd8b4f8421fe8ef40de7e6a5769f9208d50354419d751c4e1fcf985b18c2cf3a2d40866967535087154882f53b957a3c7732ee440607d77332242083420e413fdbd9f512eb3245fa5809a729188515e829bdc5e657a23fa7e758c02457833245b1e3a74cb19d702bd7576ef0b9cd68f8de7e480aa9448c3503a046099dfa333d3330b7b3da98a573a5a35fb87a369e449f8836d6b27c22e07747c3cc7aadf0100fc1e8a311641203fa27ffc02105590d5e986e7ead3cfef6f9b6edca3ab65565b619f8c7919df466d53a7c5c2176698f001ca203b14ef9bf6923c6d6203d52c619763085726792f6ba74d5e0c672c9edd4ad506dc4f82ebc7de78da672c19bb85d504d5347a092062df0f200e5d859ddf55069c951828b767408abc95e6b9959f3217d3de63adf05717a3b2b8f49f2ff8d0068ae05c51086527fc51207aa49fc29ff5e2445bc4fd86f821958f25dad0ff36133051c172ed2bee47b1e98d17da2ac09be214dd7cefff5f9ed4c184132eb4f55341cfc75f4689e7a34d17a9df59eee8f7a495881186ecf198c953a98c9f25d50b3ab6314a39c7f768ac85a9539d6bbedc1dc407ed75abcdd18f80b164322c6fea9506d80e26dac68ee6e8e6c21e1f4f45d3fee58b365339a1bb83c330484578a1459b552fae0d3f1a02b7f9078d8f14b8b8ffefbb78858f013daefc4cab2f1920a61884f0df71c6bc97ebb4327fb6dcfcbcd56a62d793030017559afbed68e93167b325fa85a16b62d1dd7970143e00142197227ed59a33c4043d965904e333250ceddfea11ded54676b91faea7abe3c6ed9f5c6703cb4e9337ebd445ddfc14e37b8ba32ebe3b43fc5fa2387375a796b22ac67c5e8d08e4acae80e88e2d53ba90d578e844c2b7983d5d85aeb272ded97dbc1c2ff9ebab3fc9fc95cb28a651bcf8febccd474858226854e06e1968449b316788558326429fcc4d04377f1edc3cab975b5550dd22fc945c5ec4aee14a37597a00f8897fc505db9b0b4831e70ec68b146557758e992e65f5f163fbdf80decdbc2db396be5108932f28d6ee25837d602e71bd685efb4664e7a9078610de8b08158e265a48d383f097999e4d0c7dde0f0531f4dc4a33a6b4ec89a26578dd2465caeb0c1ab9f8b4ffc05046f9189c8088a0e3a7735fdfbceaf1e044786ab4cc254d9c0b8e3da4d94ae94f59b427cbadb20db4ade35dd88580c66d95df34ba04cf00d828754c1564816f54b58fe5a56696d94401b301dccfb812cafb08afcf308c50e058a21ba0f2c916b37457acc48237f291a990ea656171a27d2630d0a71fea64cb6c27f912cd09c4b6febababb702851d38d2f13d9c419988c5c39e2a29643a86823afbaa09a7d7cd994bcd818f37789e290c21e81feff593eb409b97039997cccf2570cc0e1b9a08a585f9198fa9b4b22976421c28d285a7ba7b5800d1421001134a6fccae0f2ffbb60cbdcbe570992428485d21d12c16112996883dfd0dfbc4a57e24df316c0b28fcd8e9bd9e9410a41b4a5af446dc81a68bf4d9342a121cfa59577f60f823d861dd7f167865f8bfa15c6f2cd049b712db694afb6daa88b6a9e0356189f4dae24466642a83f3507146c43542c504bcc2bb8a2fba8d392f7c0457c912bdb254be1872162595620735b4329406475655f31bb6f15ab2fbd22415262d85b5dc88eff01aa6ff66ff3a9ab33633ac9fac8658e3366d13010113a7240f02f8a3b641a31fbf86e9d96e83142400154f6a74001f74cf4d90988ab6cc3e6be681bc7d3dbccafef7a820d562cfe452867873a7c9071ead2e8310e33a11fc6a671bb806baeb4fceeec8207e36ee3d9486880280a0245baca64e7707305df1edf977fb8d597cf71557b2fa74c1a3d87b46d1a7cf206b0d7e1810d13b9e89fea284cde6758f12e1a1275d58e18fd4a4a781000e164bcef2a0b6aad1f7432d2066a5b1c812560241326557ba1b9db60310d2ca5c6d4fbf47ba9538b525afc77dd2bce58766da6cad2cee5c3c3f96e06f6c07418aa7009af7c2fb3d2c033f2acb8a6d1516f71492175d41fdbc41cb3453b254d5027df6d2b8d19fe6b1b3778d9e1903d6c541bab2fc0c109add06f30b2dc8d6501cc2659b928885f81408195d347b88a7ea58ce36364d5526780eea0b3e72f5f54dda00d91977b95ddd946438d6bcfe2c31551c50b52a11cf426f99f1aabbbb072a8bd50235705781161e74651a6b07f84714fd422b6bda6ff27fed12bbf9408744eedefd85c824c001009c2039d42cc3652e990f368efc18882180a4a2c981dd1526dcaad44899eb0ae2cc34c31d71b6fe4db461db7732210686b09ed82379b514ffc9e2fe70b43de1ad7f47be1eb3deaab770f1c274822f1a0c5fb9491b10c2589e15275a14c06a34a0e74669ff22faf67547b27d0b9b15d8d85845511f167c1ddaa1591ba854753a301c06db8bf20d57415262e6f600d0d49f481988c5f0c2438bd5dc631ba0955b694c51e500a198d07c83e84882fd23b252c500efd464d4c8579c215e73e9e1c1f0875b1dbbd2a4eced58b8b686438d2fa93943ff041365cbb9dce34f9ab99798fc1a85b10f6ee1f81c475609355360c927a3880213b7a074d43c95ca9d0e2380b735730b96c36b3f10ba31900cd58526c2b795d45e29219285384f517343a1e789924c470a56c0babb33637a8785d8000468260e3c06f072fd6c848db0aef632adcfda51aad2b4b965aaa082060dc56e69ac555d61a9ea972ee7848a664b7dba001577fe45ba4ec4172f8c42c5b361c0d53284e84149f307ecf349b9d096cca94a3e3a5e0e3f90330d1157f08a4f604f6c878c8a9f6c5505f6622a3277e1234f0d16701f801767112e2850f007940c8b5b4a0a5937fd2feb34c670b1a40222c79df18b46b81234fcd53ddeefc7990529b5bed56a0c2249d968ee14a903929f9f9d0f2dd24028438f917b3c7bfdc1a5cd3ecd09a1207eff8e0f61f2dd53c36c14297f62e75b4c080d03ca9010e0bfaed028d9c50632167cb0b026dec3d930a61fbea90f034fe02f1f984c2d06ed5f6b4fb8d175af313bea9983144240d41c9cbfd9b05de5a77f64a60659957d4c2b80d8f1c459418724c3ccaead082b2276ceb17aae615fc68f579964d22b96ceca553f73bf928eb5d914804ad9470f2be801b66ef69ff1a97431e7481e56910473f63db35862769b8a7e462ba31c6b995299883ef4a894e8b073d20162f58cd910d2e0614e2e04b28db864d15b17c3e2dbf900fe54d1a588e61da6de4d1d439f301cce931185950ccff29e5a521546fe3e35a096238796e7ccb00fa79ab02c28155e761a1c3133fdbe9192bad29d286f14de7c23dfcd74790a5d55c5e979d7816d0144dbb82c2a0cc1234afd8aa3accbf273ad112a44255b9aea799545c10861540eb43a2a38536432bf688dcdd823c05e20c313429c2ff5fa41c0487704c9dc13cbb148da3eb3398c3991662ec4efca027ee73e8f9049b913b7f17ada1e9c5a1e649c694ac048b34e2dc4957e27f2256639d445e17deec4a2e53a7bc518b7f554ee2e9c8eb58f9b0836cd9dc68756837870a2d84b9dec9bf3698674b3c182f9e9c0e220dda7f6a5702a8c599a690819d2e413b0dee0259d2bc3427a187f131e18ee2ec7a92a6b217f51611de1c607ad0a8c06afcf18eedee836d6460bb8abf1a644439005881d94121ff8976a96121d28f28b56a8b0525e59cb5e16ba199c8b1ac3e54713ede5ac9d0f4cd471abe877da5185673bd030105b3c0b992637152fcee8f65bef5651ed9e13871927e9c67aa2ae2b3c2164e0497e95a19cc46d5b95d5281ba5714b69585ba19e1a6b2151c9f3371be8f3f529f25b153ab42fdd11a39f14cdfd69d04e01c129e6c5eea9540ebb6c9a6233319de51a4b2e18dcf8cd4a9c5ec4413c12da13a65cc37529f727e4fa8ca2f7f199305c4b2c98a2bf0643d9b4333803d6d72b1ec2d9e0f849ba4227251a283c2003c85c81b9ccfd8f30e67178415fbacab238ac6fd996c59d272d6b046bd183c4e834753a397596aa50659dae0d6c2c5c7000177eb0fab92085dab5112ef8428b2ebc568280a7aeb0e4324867ddbead0da6bdd2e778d81e5dadf271b3cc78e4af5f6e82f3979d85e2ff7a0f6a68af67f0dd17b7bd7539107e900dcdc92cd4843ed88122cc2fa50751fc7544dc8342de19202a9b4f2cadf3088d42521c6b35df0f676df72abfedf4fa383547b42621531e1a1adaa8eb715007e014e894002f0eec35c7e0e2a8e0469771e9e148423a54200522c648e5ba3d9479c1af9cb4134afd2bd9497d4b2c05687a3619e9f03beb1bd331834214736ed780c7d6a5bfade6484f91a98f1c85d0f0f40b3f6b98a65687c4baf34b8f1fb8a5b66d8b9699452ea700fefa6ee40ac910a1aef4eb4dad52475f1ec9c6f4059d528425c932cac18cc018feccbde487351dc8889eaf53b5319c19841e8636a390fa79ed811a0918252343123b3a3d92b940b0ed5667d3b8c496356653c7c1b169f4d31a5307bee86b8e070c4978d1498b76575da4c0a502d5ff296a902aab293d0c4816104fc865ffd6886b755b05c346e585bdfa9778862be29dc090dbdff1713100c58ad254e22ebf22fb6226d8627522ccaf88aaeaec5491004849657a973e0221da47e35c959d07f4ff396f86b834e8def2961f67df0b4c8731256ed3a24eb8a5cbc059b85ad6f3f6a9e6ecd6fb3c0db827d4d91597c06e2ad2b70db1c72465ff82feff27f5fb949876fbf2357d06c506bfa0bb40e75145744e69a06408aa041129fdbb5127917e02fcb4440494bc07ac7b2eea5cf9df3cd115e76e5deab07f137fc43a7c29656b9647fdcaf12abb27aa0460893a1ea9cc241852152ddc110608e403c64766b817bef41d8259b709e571dbac2951cddacec7fa4733ece236f4f273e6bd8ac349355bafd7b4cb788879fb4ef97e1cf8d595e905f5586f7477e10e517258b972c44a06accea99f033f1012ea22b738b03a16dd80331bad5d169656a9c465c52f2add407917d5b4a6a59e913326169b1270adb639d18d45a17ca79b9e85d3c3203856fe03831a53897480f20c9d75cd5d95ac2e2ebe61f597502dc2ccf7f9b3f7150811b03a0b4816c7a5ab7846c53885e11f82bdeb823f351147f0b41f68576ae0a08f718cc0c9994baf8bbdea3b6fea5f00d169728ca448f3d1339bfe7644a48128aa62716306229fa949ea7cd5cd307a8342a808f7a62dad55142d0b3e4e285e12d51a6afd500bc0289778b9ce0800a602a03ddbcadb628911c9d390b757d8f82c28232d4b21ec84efcc240e217a2312e92673a3e3f8be3fff97062cb26be8c57bf254fedc22b92b0baccab010176c56caf6c2678e28e76038e309648e53537453641ba6a8821c5d735341cef9e2ecf36b2a8c01471f82038eba7d18cea413a0658f41cdc9999df758dada5e8bc37f4bd521a40e01011c50f614a879ff21eba7b7a0666b5914ad7c2eb9e4d4cfb8ca9bb437f787349516603a27f40118d0081b52c685903d97af04df7e5bb5dad5d37f69076b2554d518518471268c47163269e26421524b233d38ace88a4985847252c906b241b86cdeaaf39bbd5f4a98d4af5bcc875c39acb88a905990fddb4ccd41fcc82fadf1e0540018209a71c717ca51dfcab728680ccea191a83ff85c2e0af9840d670cc899cdc371e11eae6b53ed55e9066a23a4b6b844d149be341c02162d66d8e97f55bc90275a077d286040c890c3f82479a1183fd3bf2621b2429695d4a85672ae644d6f0b82e73361c2973b91750fdd94ca74fcf4e203f7361d747f3d6f57ae83a01fc0479a90e749fd52ad4a2a090f3fafc5ec533c008ae1cb9ff0862153667fc490c0f23d9306c8e37f09ace956806469ad5f509a8cfffcb16763b02b3a66f130f441abddafad8e6b403b98f0e131ac8d6530f63cf38582f3aea2f0062aca0d3dea2af8787f1fb3d253c8befefbab8bd8f99b72e7c869a60a8e2904bd417305ed1b11f589805216bf349c7202cbe991464981684f77a0f441ca34a0837aefd6b8ff54c90c3bd56dd78aa11b65504302cc0914fb0a31bf886cda70d6d3b3d61b202370d62c7b9a924b44769b77b4b7d6fdbe1170b0b679fff7d12879ba646e7bb6d33314238dca09a08dcaaf332978043d91d1363f077ff36eb92af8bd8456535fd17673b9452ef763a37a895c14e0c629b4cc9485f05eaefd961d65a8c83566e7542da1145963effb11ec86089548ef9af0cd150876f54ba03d377bb1ecd91f27c557f4dc16b0d67bc40af9f1bd22ba987716a6a4d74502d8c62f42c6191033411b93286434700e4d748f2593d8444225247456cbac126fde49fe1736bca0b20d3e8fcf5597913debd1cb18c9cb330422941c9f9e3a888b9cf3c9c9280b6cf4219f9798232fc93ee46741721c7564cdf4ff42505d2ef9e01449c50c213e87ca14f3b12d917770e3ddab98009c9b2065f4d2a23431946f29c46cbf2b9eb9b662c75522b35741ce163028189978adc953cbe94e57266c773bcab8e034618d533202761948669bf3008c50fd871ab85abdaf2c96b59c29cd7066b09044b695862c3794af2fe0b711edbfb732843ac70bfa3f77103bdf1fdb3cf1ad12d67fc305221d86e55a5fb854dd0230d005e692d8254eb7ebe7302305866c42757ef04001ed752f77afc4f8ffd25d478aee0866d0755f143b852d0f07f1aea1231f8d6611ea06496e36db1644149addb4881e764a278b8dddad2c380ce762490167aacb311a9e2dc8b0deb15322ed86fcbd3b1a156a4c2e49d92e03e47b678180ca288d6fceb123f0e9814c277d00f69d329d45fcda48b5e1a4509c88677fe5e2e1f03ce973d66f735d1fa30a0093b2da086a3a851fa5888ee3826a854991ecd7924b3d3c72e50bc121f61d40d7fa1a528495fce9a0e06223357786a54535c03587db65f4388e8ed77cd0d4891c30d6b6777e3458081cbb3087d45fec748dfb73d1253f296eb5b5610d736849a40fbf725226575de39092701b144d722ca0390331cae80be79fecfe255b93cf41a0d28bcec962bb7f352a1eefbb7b573be7633d0e56f9782f883df0db5d3d91915cf479c17486c3dcec28cf3ef0c2c7db98f1c80609364fcd6eb9830cf0fbe1970d0b6d502b661d84ae884971d0431a661e1b1c2342bae626b16919d8487edd4b422b4ac672bcc73718beb9362f87d3220a903e18a027376e0461166f212eba3ff5ea097b06260545a507bea6bc1e143959a93072f94296c2f374928d20cdcd1e0a6b1f0a3bcd1b6e85801da9dafb5cd392552bddfd96f66baef2cbbf1c632d4e1521e2d488a8165ebeb8ed5e419f52e2def37894dbe8300df03af30378cb6f0ffcc40031cb2ee5e3ebbc49a28d34cb910ea4848bd7e4c5713d5c3e0623dabd8fdc220c09a7e7b272c59bfc7b3a232bbaa72349dc3ae4a53dfd3cded23a68f82bd44126d7cd72b05bd639795e88fd4f5b345907e9c6c620bb1b9f779cdf391ac62073abe8f4b3a6d8e2cf8e1a30ace41003e1051a7cde22e8cffd4514181d752c3cbf09ea2ef389d503b4773958dfb8d8c3642f144fe6674ecbc674b1b961b5ad42f356960a62231784f981a3592c678cb87040f3a0a0f5b5c4fbe5a87af96eed72b3ae1574e917c473bc4341e8718db85cc540053e35c9b36f26a4bc2a2de301110c15107deea2d16cd5d3d4719f2d1faffabba4a339007ee63c1c667d2b4fc512ec7816a2cc957dde1255d8b14f336bda9032ea891ac0ff1c82107589c0de01aa76044a3e2e2aeebd27054f58ac46ca80930f9b6ddcd356caa5f035f7d799dcc428ef9ebb402416da208152776fdefa5f8e2180d7078e6338928028b0acc2223c1abcd86500ef114d938009716a048625deded8a1d55e715d9849a72925cfe632fdf2ef800db5095efbc0297255fafd7cade4f7cc80301584099f6ff240bca454b7cfb4283559f01e69a5c0b1dafcafa571e8cb146064641bd53cc8c124966f873aaa331ded44c99966a51a70f59c0e8fdceb737f06aaf5015d6012c36593e9669ef37fadb53c2a5b4464ac579a42ce6bf7c92679eca028c725917b84581832bfe53e97ef3eb633e331193b5619e461ffb6da4f710112738b353eb45ee805df899e08821883954d7ad90a58a2ce6b223dd6c599dc8035e23714ed8c91d2305af6b0261c68868e04ffb27f0f31e5fd0a2c8524e9732a7f1932a5b8c40fb979b80ad19ad1a10956d7375cb11d03a90f7d8304039d6723064af88b4deb50c033afa05a66927bb40559077ea49588048633a74c7f1a0c3f74fd7c8ce4342a8fad669e21aa7629b5438c33ed270a17da254ffbe877d818b82973f73b6145d10faece1b4d5e545a5457dd1f09f712434a20d0dd108890c58ad20cdd8ae30c31315412507340027c6e8713b53ff512c3f0e81fc2e4f21cfebcb20be25c44dc6d4bb1b351c84df86b9403ee78716ee19061b8176bb1bc03f2dd69a54ebb0857ab0df83cb096f6933520bf829e0634f1c240f459e94de9121a30e011e7df15613cc7725bb6b6942f236089434144d32c76ed1ab173476078a835bbf80754227e64ff30a5acb2551c01e14539e67748725e178412e0e9596507ce41b25584c96c097a83dc687c126b1b8f0cb40f214f909503be4cfa82d284b23f368bf811febd470f3ccbbb95e0ef279407f122e282e1f7e508a7a2ad10e1d10125caf450eaab333588cf61fd37c60fc57c712fcb0d9ea7082db77bc8f3892a79181554d9d57ad1dff6b04c8014b2d6080e9721967741b333e412d2a13bf585e1e0fb87289d21548f2257f2ccbd3289b0034a258a70312b9ec747918b6fd1bdf70b4d461efec102fb795ba83b023e9c0cccb4d590007c9acfe158c8981a7883ca26d7a1504dfbc757e54a49e73dfac06b3d48c94ac0750b59c7f4698a1dd406d7eaab9a262ec5796cf9c1a64b10587132c8ff32e8e5566a7d4b809ea36aeb270ee195c174255535f12b2cc73035ba6d128d8f9e73d52f71e5d3e83da64e2d74c29c5b7de23c63a8030968fb38bbb2d4980cf180bf7be61a3356663a6727171cff164d7f75bfd3c789c27ab1fc721c48fb1a6905918231357f599469369f889230ef7ac87331af67c8ef91ae100d3f2385f140ea3f103128adc11700c409933eefcf5cdbbfa5a58bc27cac0b35f24112b9ccc740a5708d1cc3e7750a9dc5e77df30069a1d3c7cb4dd23554e8276b632e3c35c4e9d0d8417c667d9304e98bcc1dc44a0f2361195714dbc9e89df151e4fd61c103baf3155aa85b1a9b967b6cb86f92d813ccfd4d6d829ff9c3987fc36e7b409bb5ffd6ea9a1534150521e741875319d60db627c8ce360ae460e5f88364ea741b05965c9bd9a7ce055e480e2e0ec1908d3b14507feb276ff3dc4397654890db063a82d419f6dc0c34ca3b6300f5299d0703cc2275baa5787a7bd1745b2544cdcc9a9ff7987949e5a4bb04507eb7cd000051ee4662ff01ccdeb150e3b225ec549ad6e126014c8f128883943383b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"512f35fbd110c812023c863c9169ab8b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
