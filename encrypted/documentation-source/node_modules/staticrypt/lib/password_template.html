<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9608038a0841cd1285b9369c6e50f1de248beecd1a1c96e562cd30e7a989a933ba08252769efbc0585450d8ea5ea378519c60f5dc779ffa9b3fc0f7ac5f6d2083add301c7c291663327ae1559882c33923493b3f5fc232b0d9560f688191705bb6f7c61aa17bf1d9f511bcfdb8b9ad27fe34d75d0a3ddb3669230a749e7dd613b98d6a8c5233d89234a549ab0156ae3e774478c498bf0fec03adff69a7a53244d2654d01cacbeedff84fcaf904f60ceba71f639356278f2a3c6827ff596cbdfecc9e66d0653eccadb816e13285245640c2ba7aeb587d1b831d03fe8f2167a7285f3567ca9794b2db33217b848dca3a5f9912de5e9bd15dd7b8ff07ec6f88acf7e7bfc47cf7d75ed055fb5e86db41cc3d077b0c18506161bf377c7c435d33e1b4a7f2fa3d3fa55dc969ae6c83606dc6cc61e3046b986471cd44b378ef35781c8fe09d5ece2a68e71372ed13e61ee3fe19a0f027e201ddaeb6853a7aa83ae6e858fbf13042e1c54ad6e01322478687b115ea5d145aca29e4dfd5cc84438e80ac3bfc8066e0adb1ee90aba4d7287650fc69844d4a41b09c5d872aa68b790cdcd96dca1593be0ba5bc4d64eba764c3b3e9b1c74f9e91c8f06ecd871e2c808cfd5a232bdf7ae8c3d36fe5d44cf930bb14b25183e071b5a93891e3d940c96f4e8dcafd546851a04cae6757937954bcdf6ad4f1ab01ab6bc6640e8a47d92f1b654de25de1c2bcaf67029c9331ec82739c239777675087c27c70293d904632a97378bcf4a8fe8468bf00a34ec7027a2e47a0c22ef4f77cd0c737c41683f8e510abcb1b27da22795ffec3d5956c41b13fdb766894da7f7d0b0d8a87702e689fdee8c07632e5aaa6ac12429061517dd2e0612caad58d4e68211175a852b9c3f466d92e24e46e4b5034de837ba133e57623e47f1b87c12a2fe043c0602d513557c52a6394b48807d6d0a147fe08fca665ee3b77b438e3af3e1f469191decbec86437e1b63c0d3e5027ece16f5cf5226d3a41588e0ce60f1994fd9033824b82b6804f5652953036ba097a2138708516d2c72d552e1a32c9f0bfabe058f05e97dc1bd0adb4eb6c1438798d6d782ecd0424022d37a3ed347bcb61d8c22b1c9dcfece379ad367ee5754dd035abf8b4dc0c0802a44c19d8742b554419544333ca1761df9610509724c0d4ef65ee9f29434f8792ce9cb9d7f879a0cd32d7755a6c4ee244975ba1a8de8d5cadab318105616aa740e0ba74b4395eb194dfc251c584229f6fb5179dba04ce1ce2420b14a8c1bb56bf6584e0d08d72c295357d0f38bd2d29017fd985ae76693646c1a1a2de6b3c5f100705ae659516aded82a2fb4a093c667c58ed69d9c8ce5bee485446c18b1940ed39634b9dfa570d8d4ef12935917c6c8fd789d399b1bccd503ff2f418f509d61ceed0a6900326147b539268cb699ad14097bbb96f5064200cbf8af3b23b2ee804f7986081ce671beff7c634a597e9c1b1c37795fb7187a9eb8bb0c73acbdee66d38d26bddf3a923abf6c37c4f2b67300a04e883aafcbd7a1623dfbe35f8edf1261085b52aa85fb627f3dde95eeec6bec4fceaa402a51ca719fe64812d2ca6fdbac0f30988d0387359ad8d5118c0c0cd93e68c22df928009255cd1c203df6b2cb85cdba495b4345afafc7a20a9346112dad61c4ba5cdf4146ded703de9a0c243f68e783f991b2e89fb138f82fdb67b0e147c0c3c42a396d8a40aea576ccaeebe5d7286f74c69eeb52ac17d04b1ffa85236762f05c08ffba5746e5f96d56389a8cfd068ebf919044c253ec21773825daf7add81dbd769fdf93d5179e7ed67e35378d463f8a947edb971b5f455a28239ced7aa4ed89ae64c66180b97ccadbdb6e7d41bb3dbe2bd9dc62dd8ca3674bef336bab67756b6242fa1cdd953b5aba2eac72d4db61eee8628536dd54129eb13a8c9779364abdb9409c55adfecdd08cacc73d14a8ead9ffc5eb239b7cb78bab500d69d7109de7a88cc1c021274e2dae7452091fc8913cab8d9320f413fc0d099d9d8de45e3cc468776b548b83a75642264e7feb9b8b677a4b78837cb462b54dbe5039cdb8c7a0250e6537090e83c60061cc446625aaf46f38f38a9e452cd34098b1d0c6e9442d1d37850166fa69bc72d3dc178a1dc49886c0de6b6a7be0d20428bcc2668b502c8e894324508b23eb6f38a8f72fb568c5709b9f33bb10d2ae720bf4b00f7a79a5e7001b6b558ef468392e2992e56aa497a88dc2642f6e858e539bfcba060202f042c535168eee52e48b4f862cc7f7dce01e1c61475821eacc2ae1d0e1161d6fcf1d25361dc31d93c93ebae02e75396ebd548ddb81a43f84761a68b97ecf0d8dae2c206a11a9ac791265f68d7b4d4863f9846c4279f725a55ea3d88cf7a6a6614fcc5ad890b24633c1d7c212107077ea71f71496341e860f0b1da3f0a7ca25ff2f76db14d10af9aa3be5698f36e5743689ccabf3b6f43a782b2566778f1df2abf3d69cc5d8743a948928acc4065a5857fefb2a9985e1059a88ccb4164b89621ac49aecdb5a03e2fa7c4ca32591c37616f7434e576c1e5e54f2ee750421c8933bb5242b7532a450a7ad846b280b52c11adf180491fa089ae0bf941e53c54cb2583eb66bc6bfbe6d27afbb68f6a70e72449ac0c90c27a9840893163fc76733198af99fa57224a840b9d6b2426be07a9ca4606a15e09dafc0c17f68975eee3172ee3e4fbf5ada9966d98aff73eb3c4c9e28972cce1a1895cb36c4ee6894f5ae3f6377ce8ef88c5d4b30411be835d7b51fadb4caba59a8ed88609930be5b442174cf94984a434ef1b2740e36c4f77210e3ebb2ac8b2b4f455d44db7af881740797bfe07e66240ead647bf9d65f401efacad6c64019797f5fac02fd9f1f7cb9fa5732972dff231ffe18251db7f12263b07ef8f6d19e37cfcf303438bef6036f1d9318355e6bffacfd520859cf300da6269793b7017bc44508e2416a1d2e5bd8e8204e3abe68bfe0beb6e5cafcdae01da0e8cd82c57eeb907bb5a0b779e8103a95fc54bfaf8cd9d37b54eea2459f95c67df2754c54307a94d414c79b7776896b9584860145a17f0feef76aff6d8cccfed9665cb3c0e6d28001136bfd8b1fe1ac4b8d0e1c4d9fd9f4a974ebe797b03e7fbb41f3b8bbba02952db808933c85bbf7a4255505fc6396e928fee4ac809e20b3b7e6bc1d91f8e800f89d0261d8f0555f75fd3f5db5c54395792e417a02e9a42cbdd4b6b672fb237d313463e8d8c26dc40655ea1eace385aa85995c1ec7da01e93192bfd0694373bea6d42eb40f1a0440fca18638c5318064985ab12b8c7d0867c02ac4e1f632ccd54c96a3a2b57f836acb62c0e74b14ca54cf347f6294e3c290e15f419e9c18b4d83347076e9273ab0edd373716cdf4a8292f2df2de2df25797f24c96988263132da570591accd95efcebe122332ffd97ef319510c0d2c2b26309b5eab134c6f570f935c397ab15beee25fe67a74681bede2e4009a42cb0155d06ced667b0e5395c10f4c391f8c7e16ef196a814923c14b0d66bea58f54c9c7f8ea61841e1465e7b97679e5864034e4b3d8912cc066d6c534fa0bcd5e234af0ae892aaf09e893d24add3358b318f9cd0f799aa049fc73f1907cdb702d2294c9cf3e81c988f52afd0f9cdd06552294052d65a87ff6203995b5bcb5c3e09dc671b1782e4d433a8f8290317b746e32a30dfff451c34eb10f0c5cc81529cea5e0b0ae29093e8037a7d17ecedd68a6bb2b9948290cd75ca624f01fe069ca6ef0155d206ef26afcebf4ab438f5a0e09baf9278c4405f3915a17572e127b2d5aa80bc1db24a94023789aa0d6c9fc992702eec75052e8597b5f445b45568539a655c5390261bd19dcae207a3027c9ba01692f5a6573f808a5bc4c30d72417854b3fc78142daf73e835a49b1be4671f8896757a5315d71b753da7e8f0563ccc78d9cbcb942bf94c49dc29b4f23eefa593796fdc99cd4f4d7ae1a5f16953cd543d7e4f5d429f0865d42edece2a00a35e021a3feacda69f4432c6ab05b6236f67580bfe0df0eba101b2a3bf8ab66d9f9776e87cab60c4a26fc87e376e7275ea3f95214508ada6046bf328bb81c3df5d6ff5c1040c32612350d2415d47688533766edae357402985295c6296fd499f75c12516e7001a5e07f47ccb7c3674d74f41c74343c98c5fabc471ffcb4bb30d9d610f32b4db432c6290176b034cf5e4743c6791171b90e3782b232255ab96106444ce03ab7e23acc77dc5f496cf1f870b1366d54968cde63a8cbccb119c2ec19f63af97420e8e2964d09a455a87c740c8eb166154b99282656566e1d4526e7de6950923e98da0edbeb7aa7a33539113922de572fe3c8560baa206b5f34811447f258f0ab75a10dc77c2d0ec208730ec8ddb489a68b12fe320e49c00d71aff3d76d0ec2ca3d6053e86d3c053379234ff88bb7d16bf6b7341b113a108de19faf1cba990f2ad7ffe104e84abcac7310643119dd76876c728da1877947c6ecfd39b9ceaffd02d3f5d8fa9cda1203c6153c75cdb31b81fa24ea1697e0d05e6411073a1406379bb9658e69429fe6078553e1c89e1aeb042e1834cb5d11a9fe617e8dd4ca9006adc5a760ab5a1343910bad201656d365547d9f53e522bc7ce430c99c91dac716f13ed9066cd228214da05638905b11c9be44d68b5fcd899832ab2b241bf1065ed50462d8be0659e87c1638931f903c60e883d36fb17548a754ce45c54d5eeaf559fb85e74c631eb2d50d28a892d7e2fe6f98cc6cefe457c6d63775e2d4b8636972b2b5bb0a1a882c5e18b53eed79fda68788dc6ccc6a134b016345493e389b0d8ec64acf889b52c4cb2a4fa17a30e46a027d6df36e27e8b79f557db194adc06ae22c163c685a680cddea3104ea5d6c9957a7ed4c0dc7f466be24929fd0356e9da5db9a34bec5a2a44c6da594a7d8657d517847babf59d4b340978adf1508db224f241e95117436816a2c8feba2789d4b501437eb040661e0c98d5877e277f31ddf1a4605699b862c429660ab1e4d6ddacb0f576d52357169bad2f614006d9d6d9b9c7242a6c239e801d45c1fda60f98b21b18bfea31e854df5c636b0461b1491a98d2fce2733f192abf2cc9779b862c8c410f8077f3aa3cd52d0b6126d57f8c32e0c656804f6e2668e3c594095c049113a38a4763300d29661b914bbc9bc8fa2f5425b2163d6da655bacf813716ebee9bfc1fb9bfe8ed1da36b89ac2f4923b7789ffa307b09c6291dee25c0d455e481e9a04acf3182fb6a7717b0d8071e1fd2e80f9d90c3004186289c51e620639333bad8c3302da555b1f1068e19ed0abbf5b6c230458188f5bb74c40eb2a94aceb5c5d3ae43d534b89cea230013c9a9c49357b4fb516cb954cfd74486f5507b7f8162973276128e9c861290ebcf0d475eb88b161e003af134f22ca765f2c6aab3075fd1042a27d95d0ff31ea9f21d3b6cf21c31285c3792810be4a7c2ff235296120a664968ac647c3b69259d8e7bda50c7aa55900e570f888e74f70095c309d9d07fa2201f885194ffa477dc095ce02232180656ee576fd4d4997e87a8c13b6e0d89bf2a1ef0883fdedf8e269291dc43ee5cb13fb201dfca6648c9c7a7e97a6bb6e5410e44afeb05ab387e2b7016ff23c6cefd9a5ce41307ef7d1f08e0bbdc2e3c9f111ea23268c67a0eb6dff8af0edf3bbb8794ca51867a7055d125c2716287b5d72aa22457a3191fbb63575ba55056f4ce8b777d8fc2fa43d2677e4017582be14c1ff7fae9c616336d006102ad3738b5d77aebd11139d4154567bbe7ec794c462a26a9bca1d7d68932727c164c526d8d9adac4f041cc53a31f5821565f37e81dd2dd89784bdeb1794e9b43dcf5a75c2f3772031057ca6eb778337f519cc4cabc5bf90eb3b194950669355fc1a59cfffe5a38a498711d62d67ca0d09d358eb9c7b546b6d124f35f82c14671539313d64d842b586dfb865424e4cf99ef6ac70ad0b4134009b4c290217185fc981e323d46b573a800bd376482cb64806be36bf9070e16e3ad743b65d38650bdc246838c1706b28074ac45a0ee70279b96dc79840cb1d0717cbfbcabbdd6801f499f834bbe0ad308f61f67c52df15322526982d779787caafe21a05aaca24c78d6c6688b2fe9ad4a4fc1cd002fa2bc16b03abf2eadfd82710342f655ec8b733d211f75656cb2818f5c908d9086cd7abbaf677a4c79676f5f5a2f301b79322911313d14dceb29b3924d7af4461a8fcd5612b31e5f43238ef4bc0e790ce6e57ae9492352be040e7e5c6901ee0a0e07451c51db6eb31d1342031d6d6a7c708f10e503ba56ab118684b17c37400f6fd80b4fe28c511c5e0474257fc29ef17ee434551c0760a9e79690f766bbeb03dfa2b9e3c556c56eb63ab732f9e2d27efb180635b24b7819114bc1a6bac12e031cd26aeca332985c0c99480492540afbd4979e9c1b0c852ef13616a11ad08d2cb3df2c831c2a6a9b3a37e00021dc21eabebbb8710b61b68c179eec493e8607007dce9f5c937c8e797684c7eba1e1a4f1a91ec1f78f0de18ec420c56a9e35c6ea557cfe93d94909d58a4fd31b290611d6ec5336e75ba20a2686de97fba85dc8704ac20fa5320608e411285c10e2970ddee114e2ec902191493946033eaac66b44850b62f9cd98fa777d9306a18d48aed8c05dedc4069c2888caafaa1b8242644c7f5d0452e26c9c1c8a64660a04ff941f63ceeb7d054ef38764d14b2edaac73c28f89cdaea21b72fbbb6a6e0285acf6366089edd8e64e117b66cf7edcb6d1b52b74cf5a7572f4d9f7052de9ff77d1d561c25afba3f497a3b8f3bc232a345f7fea431f1ab833ebbd9e04702ac3d0435956160ed9786319c2bac15c59ad3e29a4886fd63fb47a7f5d34686990357900c9047813b25f0a930b510b755f148d4c413da200da84a22427b667a7f134c725784cc4fd3201d91e7973c97b38fd8247c88bbf560b93368677ccdd0f7dbe1870dd3e8f22366a67379601643cd773f682c86ad832f03cb1667687dcd6b8676f2027e3dd6825e53a64b536d3c956498d5c5623f8383b4ee3a5a074d7e840db64254b55daac219ca3a26f5f3c54b9f81501a20ecd0127e685891e6096d9e94b25f31188a2814a42f8910e4f469317582fddc9fbf6b7345f33b64aa3e5a92eb0f1b2560f5e5b6ca813f193ecd6fa5f9d0112030d9d74b0f6169cd9aecf8b8b27866087cb745e27b684a1c8c641ff9d81997bf47d1e89611c49f90e2b3ce72232215955dc10677da8ef6fb123583b7fc3d78933ea64df066e59f0b8f51fbedc3168f402000ae7e3a1ca0b449e3f6e117144b7328d22af7e1e9a04dd453086b9770e4f105199e2e7cb18be886cfe7152163eb61e3cfc453a01a3a85af1a7228cfa08d3aca58c3f026d9816d7c400b2b2cae131ad03886d81666a4d8992e95394b3c442e3864dff6830d5688f86b86f4a547f1778af6383d3074ad95cd332c50829070253d1aa90b1988372ce8d77eae30d6e018ccae2b563f317ca54ac6e82cf519079f5bf08614141ecb306a3a3a1eeab8aae6a82e213d2e29c3a2e79c4ac08817719ff96749cb09139d0fbb2bb54b9222e4e711492636dbbb5fcf576a335691d981a0b677df257a4bc6c931144eb3aa418fdab08d9035399a0da1c93a0476a791a7973d46c7fe55977821ca279ddaa5856870d57ea5f4d391d72c826f07dcd2ac7d59a9b4c3f15d9f86391b9b5e8de0af39212987deea2db51c1390dcf0e007c5a3ce50f9ca8300af7d98e5acff1473c1c4c9e5c5e6d748950f5d8d7b20fda718dbe31000bdf2ee4c78a6f46d8aaca15f2a1e966db6af6a6f5991556f6c1c5a1ffc7d8c1db8a4a69ed56118a643f013c49b12a147a1da1c5428c79afc1f29ea094cd3f42c1eb0244e8914509a6a5fb49c07007f04a26e940f6bb4c99e23ca8cabbdd1de946530ca15cf5e8b19fdb4bfbd38a899463bf5e234836944a2c895b97b2f86252fe10e3b44139c356b72537ec0edece87e7df3ab3c0466f892e7c3ba3f9e46196d92e28dcee487092c1837a03ddbbe36392384410354f56bf2b0b1b8b7c92f4cbc8b7a301627d0ff4e132d082abf5167f7405024e5b4cbd2cd422dc7f7d6e0e6b2c53875b12ff508d8f5263d89e2f5b7dec02d2ca0fe7d0c539511c1b8f5d915f93180410a8d2ecffa03c2a0c471453cd94f1a6e9f9b0fc8035f49c80bd8468f0f8b9dedc1332396914d0bd3c989b5a9a582076d0518bd15af16d932dff7c937fa5ece416be8fdf11789cf1747ae5b540d85a9f6e90eb5f053ec323d8759da882b420301747014688cff2956ea9d046b2a7594b6e4cd1787c294232213758855a83b2bccc13a83cbc25a339e01f430f3be4fbad87d74acfde52ebd493bdbdb31b2b08ad505483e4db8dbeeedb69b2b12992cb1d2d4a7d179afc87595a81c8f5c2a8a1a4d606a76e15c08e2bf217ad5ac9e2c8a26cbc8432951ad0ca008520cbdf7b6145076b65b0c946215330288efe0afb06080fac348755f0165c389c983a30264908465a2b69cd58ebff6106a4ede06af7c937366c69856c19256330bce2e3b74a18cd8224ee80aca62c4379b536f66562dcf78bb33338ec02ebbe76a1596a74fde684c23bce1cfc1b786f623d0168f52a460884ad54f0020fb8c44fffa73f0090909b8bfb5e1757d85065a1cb15bb952963b9bb5b997748aa0c2d6f816be4286184d41b9a4b0ed0ea9a7fc77b1ed54ad156bcb81c120a6622e4cdf5bf930d3030853b81ecf5eea17808c10de15c3eb1ff3db422df82f78f91c986696a89f0d0cdb0909bb37b566c32d497818f49787322aed20289172131f4b4f1caddc60f428e79a60e4a63da9b7ce0863847140e659167b827b3c0c3e4af3db94eb17c1263737b849fefcfa1f5ce401004d7bd2a39a788a54f9358755dae375e3936ab4f28bf66956ef159201722231b7a325fe6a80ef7cd09244afc80a235386997aca09259eae9c69d8c6f2f67bd0a3ec8d711259aa3bd2e3e58484597be139439d19f9151c485459b02c34289612edfbd42399b714f73667bdc44bdcc7e4a6eb3a35051ee036c324bc65674da2df43907015058e1966aa25e6e0ce07aeb0c95fa16e8a911014233d2c8c2cb257bb1d505c17bf3e36aef96f585cea8f8f7eb624f9a444c66389fa48fdfe0743b88cda9bfce44182d5605bb7e163cb649dd429f0747c1bef6f841688fbd4e918bc8f60af820f11c524c2935b5f39bedfc73c4d9d56e005b5481f651104aad346f2395e942880c10872c2094969973f2424568d78f10f466fc8cc5e0afa8e5c5a41803d80eeaa28f45439faf39d371287cd42174cbfd01adc2240e5ec586876b00fdbe66e179a81b3e8e360a7f58baa0261d6c00b39ab3a8db475cf2148a17bf12691ca8eaf4a70eea6f10551760c34c6d080e8bf8498a87c238a91d4a42ca006fa1ab1afb34a73e0470a41138cb8494e76806a7b0663f3eabd3049570c7817c3422025617c0a38f413e71e24510650811d345b71924d15bfaca4d517d5723f2ab29df9976c0551233410f5e507f837943c80fd4aabc60f75a4e2d96922c967d8589af078668f89c6c03119d5f46ce4709751135921ac1aa01ff0b4d59341b8c2ab0f16ec136fad3ae1455b60c3283d95c3fe69907047b4cd67a9337551d4cb22df0c50c3e89e71e28a2cfa2892ebd586221a7e4d23843c32e56b8665b9854211f2d9e84a4312e7c4ae21d40a4377c28443eab854b227f12614c114f9aa3d6159ee672f4df386054f15fde8fa65016f15d58f9e82a681d07d78034f032afbba436ecd27a02bcb3b3872182a4daa75f18e2887d8e723b59dd3f71bfcd285fd77e682183ee2187f58a640b854bb810a2ea7923d4d735e60641402fee63e62e7b0820e7ec4b3e88c1e9453547da2af6e9fa2809d0488ccff0e9761b32aaea21633e779e1f1b7841bb35010c442d983558bb588469124b81fd8ad0b0b286a7347c3d616c53238f601aa29efb5a180e9354d07e0803a243cf2fa42492963943292b2dd6db425bd494c3ffef284493ad6cfddff63ce33995caa00016cb8f22ff6dbf17c8566601e65b9ee09f51a0c2d2cb4e0b663b3a30df55c09eb156796b48c9746fe80e8871852e95351af789ceda69de866d2d2c0fe030a3864966d0a6b17f4c67c67432af65355083e4a714ae83d0c7ff3fb83a9dacf30ae9a894adef70d41a07bbecc0d3d00933407da7370780c1172d87f92318870551e01867760a6849b4d0723d80b140e255436a89b92ab812444186c1314118dffae355cb99b251d13fd19b79019057d86b4f0049af32e1c279c465b9bceb6ada6b52d3d8ad80a805b2abe937528448ce096fb1e4207832231909ba74599e61ae2f206ec6548f67aa88bf997e205d74197bbd32197ae9fd5e3d9664ed43512e4a06d2e3b5e0f61e7729f05844b3df719d3fb8f8c096e066a4ee2cbd3b452dc33405985490eb801149277ff1663ff33f87a32ddbfa695851f42bbde3b1724572df0988a03126fa20fdb2e770630a63d87f55db40dc876d5d1f1dae8f3de336167473e1aa1f8d106dccfd9730303c35adc0d353ba1e9a7babca1c82c9b6afb1c5e71eac0669e934bef25464c1d698df3bc6789537f45ca1a4dac639b5fe6b5b3815b5137c8c9743d1f0bfce20f59c47891e301871c2ac36cfaab320339f688232f4af49bffe40cad6731c7d2ef4e51d620a300265661a60bd5e47548c6af95b8588227b9eddb3d20f732288f562b860e092c3ce54c6bea626d1c9531af30032b9c615adac68e1dd61e90f9217f8fdccc37ca5c12ec1cb5f5d8d5a7e753ecc0bd4b4a70f752613767a473280b5503b373f7351b186ea035bb6b0658de36fab3bc208030a387d80c7f1c3c85f7934f7f2bce48ce67608e7f31cdae9a60d7a1a4b34bfc11a38cf891647df1af70db71e345126fdea0d54e9b1cb4aa1ff8f0d8f2911cbf1f2aa5b4b3372004668e09eb465808fc583ebf70fe66a2b6d4a08f842e2330bf628d4d764de4a10741fc1dc8e17d9666f53501e792a13bb64bea034e041ff8410fc180e362b47f302da71f8a3050cef3f86725a05459107e65a72d34abdb867bc46299104a9084a99cbad8f443744f73e0922f391106ed392ce8f172eff13ea6797668d35d3da8651bf17aee5432e2c88485f1f155e6737500866fba68f7b44123137213dd64f117e0945020ca021b87ab0921fc4954c3b2055c4b1f6ec7c7b2d9b341805d0371b981d6a53048f537ff6198228c872b883d2cebc05f4b84d2f0756d6a419e8266189948c062f88207466145361cb87d1546c067f428a778038bbfb0f36ab665ee67d764f05177c6d05cd77d2576402922a4448768ea4eeb36646a978939c5ff615d320c8d599908ee85c01e87e9f1288dd78ec395575ab199276038fef8a8b6b5a36a21adf93bcfa7ab1cbfbba54014247d7def3621ddcdf1273916a16ffe8480bccaf2363913bd0eb031542b5cc15be271aade4a2a3bedb0b143bb23740fac9098e199fb8c7bb4f5920818fac5569c6f07d4c3eb5ff7f25d131452fb43b1179aee9ab085f31707f34dcbff0c2970fdba07a712b3b16c402787cc39706665d4c825268a5ece7e696ed5e745cdd8163f5d4f0c220280cc0fa8aecb0fa1df66e346809dc1af1b6ff2b1e35ae439927ca2e8b0a0eafc6dfd5f551063ca84a361910882a99445fe984b1bd268ae1682dc91581f604fa89339e717a99a19f4584ac5c16edd85d60ead1c24c340f47032bb990a66430920ebc830e723bdcc862985d7f878ab740c706087d05ec14cb55271c5b35ff32dc2b7d55a7ac3000925f73ec3fe7d81fc18c98627576e1f7d4921a2f28bfa5c5ce542ed53f51e7a04cb7ee03cfc1ca2da1649cb284caea0777aca3762c7fbf2ba172e1cdc7fa4553ea4f3b1a202961aed536c80e4a9af700b1e5c60f9677aaab38bb48e09519744305128fb3fc96fff11cfec713c2ac7459e82ea12c5f429251fed909d03a6382770c55f4a758f2dafdc26d23e7de93b41034bc172732f9e4c0297935f374ca79b5490256743189cbc6ccd872b58bde1fd4799a94cff09c67ab194d6abb2f475c318af8e872775632d6fbe80e3b9893cd78c2bfe73938855de3981b6d665b7205519c8e2325a13e71822ca630d5bda272da06efef3d2d0847a2b70653deb5c0df2abdbe507a1c6c7e057fcd935c62d40cf12be1dbdda146aaf9d7904eb65f5b338e1e45bd1bcd3e35b1cddfbd3e89be6c5cce03cede70d702a1151e6d9e19df7094280b1b56a43bd757408a5dceaf1c5140a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3929cd796153f8b728c50290db89ae7f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
