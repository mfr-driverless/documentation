<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c933108177a7c92403f362ff58c9c64561c1e016bf628aced3bd7e65074cd852d8ccf92148baab8a02b7f7663c2286f1f23b7096a6d79578312492dcf21da3e99375feaf42c8ea67d85f7d842cf4b45d8cebb7944efd543a4f699c626fd3304b1a2ac8c76a4cd3bf57059a847be9a2ad13789e397f5697f686311a6207669383f180c47a62dc9df323bbe8fa55e7530c9ec1d051136945faa9024008a04da08989df80026b7bb001bc6ca77031315d49438284e7829b2de0a53c724cd68fc1b51ee18365438945ed312cc69297f706adcd4de44151da8a05cdcd1a25a60368f94b4d95d31a9b7e457e8c211961bbe95df5ffafdf0878f44e533d0dd0e9861a7658cb784345e11d036e855a09a5af2b43c252a3240dc0d06e883a480b0dd77d37a80d4cd6ac4212be0dfcfae742cadd66c7fb797e11293c51b80e2041e8ab9ad1b831c5617b6b5403462e6a23484f609099e2403b19f41ae22c70f66c1c53f247ab1a988f5bc7322a42ff840cff59deb2a573ac48d52feabe2cda4a3f785ab9da688f415a174e7cbf10cd43b8f5980931dc548a17afd8da0dcb211bad35a83a3338c70c41124d624c8c15b45b421fcee363359589c04938bb570563048dc46949e05701f9c0a61a7d7c5a5b951d14de292c56f887dd86e3059752c4f13cb7dbc15d00f0956c522c19194837cf6419595b70afca9c2bb9fdcc8b0729eb96ad4efe69a7f894a0a7e8dceaa872db525a15098677f5b5d038647f91ca3b3c0e0a9ce7b42323e72c75202c56f13e2b385494d6dac46cb97138780c91a4276d9f75ab819387626030b9bd2c25558f8122e25b6e72ac1a2e2678dd566b12e087283b02473fc2cb58594799c37bcd64ad10459df2f9550468737cc7a4c6b0da8760ba518848c4816b881b945e16c52729815d62ba1e6b67cc7e9996ba951529d984e6568377a9cd352a314f62c05cb9e63bbcc66342e05c38151770496a54fdae8b00993aa772a99f8cdb7ee8fa8204a3a65cb4576560d4bef0b637aa5bdcef21f13d85f89500c07e16a6d26ef2096ae9e98fc5f5b78e3207b177c6663d92247673cc001897b1c94bb9042dec746922e3b4936d737feb1b8387e3c1dbde91939baedd0f91ee1e7f345042e152085e8abd11b441c5f278ab3dbd80a23bdf737588d3617c73dddc1e60c9a64605296ef1825d10eb8b11c85c5289d4cbde619cb224a5fc20c4518e88b736fd7e38fe53c711a68ba4c83a0aa6f22f797a613d0a725ae288c5c27603a7bd65f464dff3f0e6dc1f1a12fc207deb3f9a6121c22f80ffa9adb3f1cb03caf7879faa93a2c17357bd679b24f610629d88d48dda2c24642610ccd0f89159ba5d0b140cf60fad8557f642a51d92e8d09861799544ddb49bb07bb149d3fb8c36789371323e20c557728ee6d2998cad8231c9483b2919833f01b7537210f7041dd8e8693b71108b480f9659931faa075b9956ee17581b52672680fda4ecbda8f44d7ce2cf01f65ded9737e88973b53edfc2c023cd37ae64a4402d09c08d3c88142524a319db4eba9090338100486972f1d9de0e8a94149717dc04ab61d4e5737319b509f4a5f33b35c509885611094bce6600e02af70c69e6db91b89b089c5cccd9a7d276529f47c4c319931faaf7a25283684d31882abf2bf17027ba88b41a198988e82043c192da42a80b720e91b8f0851ab8fd6a50677039cbb5896ded6927fa8b9e06dc2c5739d02bbe86b9cd46267937d31e40c0682a527c8deeb40f360c6c97c4758de0396fa051b9a968c68a88d292b76b79d65aa78af3397b67d0be9d360f284b39b0ac34854bde4a8afe96346f66456dbdd71a85d2f37008d74ada211e0eaf028a5c845c5cba6102d0f0cc8e3e6dba10a76ea5ab70a1e884f7267953bb7019b2bf6362982ccd82df97f6c651050e8ed01f3b13e9d0c57edb29adaef020ca5d9f4e165413d236240b67662d0dac234d4d0ce32090a28e4e0343f551e9f47a6cf369fbd0d969d3e11fd8e0f2742700de4ea6ca43f55b0fddf1c2407185bfadef4a97ddc68562ad33b3c3a76b5b0f8cee0f98cd8fdd9fcd6807f8119c2253637b3bf76654ef62bc84c6008cd0737340974fa931cd89c76fe922fb03607864ed535f7e66260ddcf426693629b5d382f35c7d5d443c40b37bba2b34d4397ab0f9f7aff08595fdbe367ca915b8968df1718a13bb439f2ba94e760318493ec2c2f3be049f9bf47db3481123ae18d9747128c5a8c6d8d9ff985670b5f3f7f58579cdafdf46f2b40840cd687521e771a2f9abe10795d7308dea6c670120466c3efcda065b73fc85d3eb82d21d933e8be8c3b720194b28d44392f020a097871d44f3f30f21a21a3c52cc45ec6e20415f90e8a372614950f2965566e9564a68c433b6150e76c6cd27e8d9c010cfdc501e97b2ef1994279f335f561e0b54a5884b57c431e8f8fc802947886117397add1b05eb34c3205eb6b1c88f353dc957f8abadffcb2b7e503b346e87b15fc590602fb63f9cd045890a7fe5ab0c321869e6e8c4c9af767b8848362f81f60441e4986230ab59c9299a1d2806f2fd32d4775a4cb4be78dd76cac1ef9864f99078fb2f0b487f80f88811a14286022ad0aabd2a2b1e104dd76beaab114fd8bac615576bce9d0e8a53a01d55930d58c1aae3906dd337b388ef4e67553d8632342ab4eda5c7052366f279008a4b66915bfe15f71a8593b343019e84eb4592be7361e9184131737712a12c5098f83036540a37b02bb9a16dfde389d7995f798831dee6fd1f60e052f7043e8ae353a389be31be2de1bc9f65609c2962781607c3ef6bbc08d7481f51641fe216f134b188fbe37db36fa8ece8367229fd2feefd5d520c60f7ef632078878331eb7133f4bea5f53cf5102a3214893ce8afe31201af132d153a729d77729010db0b5b624874a60ab5b6683ab84411badc3c776542b82f18034fd361326a5e054a71443c3f65855a9611342151112f581fa47b5fdef5e200537323c1fac4cc390569386deaaf57bc08ac374a29599639e6c171d9423e1e5f0f963cd330c5a16d5289b464cec320fd58796720fed9ef09ea638b30c7b5e76795fdb087c382a3320404877926cd2f27aa37c42a34fe78164161ff90cfd9084444e25557d0543dfbbe1ff4c583462437b7c52850923cd37cb89c450882e5cca49294ad7e0a2d35e0223c0f38e5b4531ef5b623f8c0275bfc9ac0d338636891279e6efd428ccb0d53753bfc428c48d41e28fdb2eab2c69df9c6f21c7521e5d5b699b32a562d34ee85c5ba5445d9a662e3a5d72d6d25470fa6ebaf51e23b4c4a96ddaff7937bb68bdd7db7c096e184d7d9bfb41068c8140754dd951e5fbe84c7dd4db767a5c6a941ddeb88b3b95f8edea4e895410cfd4aac799e2841ea68aee0745cef25a8bbd26657d0456c29c626574b803989e2909d37a57743f8df3d606eff77d619fbaa7084ae38b1144286e15df2f558764148b105abfcbf4623fbdbbe75c82e99e72eb5fd076244a9d247793c60257972959bff69be8d3a2653ae4d8b526b2c80f943032cb2004fe28cd21ef108ce8a58ccf884cc07450404d4b809486181f29fb948d4fa5d9bccf3b10b987117efdba6c1e3c8ada81021c4cfbda947e6cb448450bc4d37416d4f6008e9bc8c5d1c05609787d9e93aa9ffe417c92e1444514b2cd0867b3225a0cedfb144bdabdb4c10a9c90f45a40404a0f035a9be27e58f2b06c6e2cea960c2d58f78e166567777053bdd2bebfdb6ef920092acbde6283ca2f478679e70f98d27320df23a93aaaf47e04bc834e06d970f48f9cec7e6a02f3c9c0fce4c146e1bd58706e3f84cb12a2a91818fa103d6b84d09c0926b00dc6acff612db68a2e89325e80767d78ef23fc1edde2896e40695b1f9f88bd3b9891eb7683b3d61f605c7b6cc716403a59ada6a3d9713146b14b05d391735a76683b6612e5440026ed6ce93262faa137ef50a59be2654ddba06a3119db3898037785aa2c6acda6a2136bf559a87ac5ea1f269ebb9b45db6b3a5351b55e08e0992f421b4f3ecac9427144587045080189f74a01cbcc1c5ed83a3e85740dc8599e19ec9235291f359a41077aac18f993fa4846d00beebabceb3fc694acd4b30972a604ecce9d5f024ba85dafef496a5ba3a2452fc3a5e1b4721dc0f01d8bd4df322347f320e6a485e9e5b567a9b6f88abf0fd605e1bc7b672dfb0a3b7136ce73ddc2957e27783bd9fbd93ba815e6f43860afe6bbecba913d15603c071d56325b109622116eebb8767b075608324b08904bcb863a761e8564706eb91450fd21c64f3ee38d95d4f6e6acde9aa00f5dfda3b9298726333fd85ca82ead40d63a0973f82c2150391dd615501741f130b0b19b96cfa4e75d48d47da6cbbe298425a785b4f8905c2e7922739288f95f02221bebfb2485712d325adbc6fae4b9596a6e13de851314f2f94c62b32f3e742d9ee002c58084e13f3906982fbc237bcf727d4f4454b0d9a512f2b5031ae8658a021c77092c9f9b7b3eb99d2d1dd8d74a9a9e37b6d6fa6d7ca527e6d2807c1a97526435872c7deabb9344c1f13e9326dd6b553fc5b0c37dc2d7399b7b0537848d38b960794b977b78dfcae82517b6bdb6f3da881edeed37176808fab2a4854bf66e884b91e5dc4237aa9fda62e19b9dad2c9bafd00c97f17c26843e8aa875072622174bb99e0920102080d2b2d2fae5e0d55fc613bc907e7969a5e90962bb534e96a27bcb9240fd5076639c14b993cad12ab750d4e5c628f2426dd598544525033f1768176df16a4a814879529c08f59f6bec8394f4dfb835f78ee1f7d8a6adf868676a775d6d2b348cbb61e3c2573939ca0db37db31dc173c004e63b472b7beae30f6da1339344b194f9e6f36da0b183b3cc3340aa8a79fc41cf53461ec1e096cc1809eaaf41a72e9c14df4ed79592ef4533e3c7cf3f4d2b2c521fb8707e5bd35ac255b029802b51dc6df07578ec91a957d3f289f5dae44cd3780593ec6d0e161f2323d7518d4493f575f8536d0858a86fa3bd8399532bc11a2dad74c959f0b42d5f39a6177b3b81ce3022567492e3e9bec9d8bc753f3b77cb3c7067cd1565ea5effe20991d4be17323f94c1b289f514bcb163aba65f320cac078095935cb0d9d1111fc1e0dccdb4b540a2902684ffb92f89e149ab18ca84efea3a5da4b300483e808730274f49f73b380456204dd69211dbbcb0d2829e1acc69b12cdfb937457a8fa35afa2bc552f3ca0c97f6b762011990a51ce42783381005eb11bfbd8c51d9b46d790ca8b543c64feac5c58c4063516e90e3a88794e18dcfbca1dd085699a6b9d8dcecd81166823d2ed175fc60373da7cdbfb804305094727f412d65ac0e9bee0d8a4d714e4d35ef9601a2243c50348062bbfc684ff05dcf864678591307edb9e10aabe4d7dff13932bec1d8191fd8628f8946ad1184851fe9e87c995d3816c51c230ba5ff2cb12e3699c8e648a08682311623dd92cfea351408b667708b144d7b297a444d0cd409e090b97de1dbe2a8388c70072252ee16f9012dfb4392637911c8fc5472a4bb50e04d32009759b1c0e5e608dad63be329c61925dbe48b37a198020e1cea7d432e58027c8425579a2e59fadd18bbe6b926ebfc206cb28d7ddfe563801ec95f7f113178132ac9d674d4e116cc73446709460e745a087c53e25e3b48e08f0bf585d1eb3c588b42dfaecacdde2b5c1bcd4eeef09da619081feba2cafc732d95c1f57fe544cd4a8f7de2b985006a5f8fe2e3ae9e84b09edcb62b76367c151a22e61cd477a6b1483a61b21712ff8ac5cd341515c7589509e4152b35a79910a66ba72f5ce89ac2202faca48f3319771be1dfe10580a4a82ccaaa598c331d03b03be879f0ae0951caa5a4db100698a4fa1e776e4335c03855d9ad191aac1b6a0eb049d124dded0428a6fb8d2a8d4711021e4c2bdabd7c331a3bf22fd5649d89d9d66bf6af9d447ab4f07af569588c9b4e8a8bdc947445ebb7ac87cef5d4aad95af699793945fbff2f13d867d1635144c651f9d88552df1ddb8e0b6f2c26b18691ac5750ac9d3fe50e7d9f4cc23e261a13c3e882be9e2654ac7edd4debd8b00a81e5903b219af6ace7c51ddca04792c913d8e6c389eab2769bef8f22b0a87afee9930c0a736d0481b43a99f89ff5936eb43a3060b5787189c30cedd635916b72920bd9d9d4a50458f9c6c92daf50485196fb9802f738fdaedfcacfceb7c68710ed401523623ccd5a1f75a60ebe33267ebbaca0a2fe1b9a57da2fcf469914e88bc14fc5e8ac10588728321b0296bbd4ccda0e129ed57357c00f9008e98c73b0dbd02c39cc877a9b5a8a7d741e9237e0deb0032832112278357460299860000fe23b2f64de5a3c67744395109bdc9bdd3ee98dac52d156103d92d864857fde250f53bd5f9fff4f77dcd3bb80bc74e945836f1187968b5ea5c20f5c428d717a56877475fc2965e1669c6c6970cc40b0699644db3e7fffcae58e9fa61c049dc8e9b50d837a43ef47a304678f4d98b95e4eb867de3a38747a94bba3ed5f8eb101788f2aab8273edc163669e5b9fbc3c1658409ed7448de933d6da19145cddb53d066d378f69f343e0e12dfc24110a950cf4d373f430b2783de968fc0c1ef0f5b9c589048a4d0609967595fe444343a205d5944e1f8ee185d2a1c44bee8b648d29743f26e042e0af8116ded129407f77f1ec58bfca85b2e82eab8c5ed628ba538cb16645b180dd8923c4ba1f925e97a67bd44e7ad7a37b60c77a81f9c71a56b9f177ed4dd657113d2ce99062a7d344c4bc23f8a7f0932bb300634a0e1ff9f759ecb00877ce2d6394185519d7c4dad81284a453f41aa0f31e44672e3ce3d55096ed299fb0dc4d66f57a1644cf8571ac3a6586a91a592c27211301671a4920d9c4322ea7c4fd131d82264c84160f8debdd553dcfa53a5ea10479dfaa6d7031358c5ae9a885b4d595b453b68968c6dc3de57da91482e945d7ec480ae4faea76900fc9300a9af122eea7c786fd3769fa5f0c216809a2ab5de7592d75c1b2a44fe9c2c0989408548321ea575cacfdd95572dbf1cef890ad31815584869f41e367b4206ef46956623e4bb636df8a85a0fff5d18b1cdb69d30f4cb1f5408db3c61074c1127b3e893450a0dbcd73fb9183996b681349dd6c84a771130c23c23ceb044965cbc94a786471b5252382f64a0b15379910fa1b9fc86d91b9ab9cbe0d5acf6e76933e8a12c851f5dd61d7c20a23949620fe867b299d054051253f6305d663426faca63c6b7e7132f97d0b883f46e9477aa254e31f265794741ad5e7d91bd738e84c8df234a7fbe619f74d63240de86443c1d57af02ca9fd35e2996e5b27c45080495ffc1b9fd00e78fcce477482c9a0174cb01d9ad12d8174bbf3c442069f007f3071edccd88b96633f01dbd27503bb3c33ebd8588f89e5c023323ca05ef224e9566528137fdc449396d441d765c749b88a6ff9f552fce4e39d1bc7806914fa1cf0c48f251bb6494992ecbb8fd015d0443c484250bdc0c28e43389d3f03b307526c3100b25651f5bae9cc9f15de20c874508872056e6c25af6de94bbaf9a326bee3e452f67747e4aa206a73a47be470a8c5619569cf29162a5227f5f79f79a9583f8fa9487eafdd453976fa7c92af585e970a0ecf20ae5ae13d13c95e4291bc33a1894f0815b3115fc656b19da4ac2b158b57ab9437a3ca1e3b09f5654280755a5d42009cc7329d3586a9085d7403a923d4e70b9d2d6169d132ad826780f7d4d3c9df6dd31665538d8f402370f77d6a96d62aa977f186e8cf6af6613afb886bf39802f18c3bd9150fee80aff8fded7c33983d590d5fcb4d4bc872a175fc960172f028bf4c3987c0b3cce441a56fc3779575b7ec71a993057d5122f3d27b34636c531fd1033c149f1e6c8a57f0adb8a6744bb1f3bed328720a0e035738a605de3b065cfd4721b969dc5ea4fe211e7ca34e9d1c2aecb08295352844c8dcc1cb5ed5a1916ade656206ebca8680ec91c44909d0bc1fefc334550bb8378c522f909d8484d3418ac99c9fbe596d142f8921b6cc8600ce73162d737639d8fb08c8af930d33746abddea856d64d4de73ca71fc7ff9a83608871247d7d3089bf4cb052c4b0f9ae61eba6a988331e3c99b683e11331882d39ae83e4fa794b08a2cd7888ce2bd90b29dd7914f7a5e02c51aafb136b007a5a1a8a60bce90c6df57a5ffb9beae745ed0e2672d43b2a9323ea82751fed0e6b898305a151696b5c062b5a72397a7a8ad140c2ff8eab4166b9d8c7881e60026e9c5d925e42bbc8414a077f08d1b152babb24d9b5a88bc2214b162868fc862599ad7d2b5d4984da08c96584289a6c2e3d0480100e47c9a14696816a00740e3d46c909e8f65827f393a5702195d34e2a9c51bbe762d666b3abcefb6ce93cc01930469868117d71dedc598c054fa14c02226e503b4752a30c53c1ca667c9a5fc104cf6c49974842672b8238a4a14ddb560db8b63e9bcc5c019e445158af8a6e341f416b74290ed8c5cf80ff354fe17f3aabca479305b4dbee66aecb05ebaab2fe13d8ba005c3aedf841fde086356460eaae7092cc56830080401057828c9e7453945e6d19c8571bab6fda64dffc8bc417d9b4e9ee36b9cfa1f371edfe1ab05a90822eae962b5e523503f31dddf58758423b22c12cc361e5f34ea735ec87fd48b727c6cf327233df064f51d675cc82fded8c6a70f88072ea1446da8397c31e82d1bc4400a2b5a04a169cda2c00cc0e312b0dfea5f1ed8e6a71c7cf4e2f6a76e5e4d93da19785051188a2b2d967f4e876fcc6cbd373b9b09787855967ae5ae363bbba4b154ec9b2affa0ca17c0fc7a3d8f12bdb26641a7ffb37acd164cea11d578820245ba09e1a08952f803c4a16901410d645becf89b6841854f64ed049bb557e545eee9d0f995048b3a7f13394e22dc4ded83c97a3f87b34c1e8d0a0bf0b07d81ed7771ed9b5944fdd858919f310d6857c46374fb494c9772b7c98547d3c1cae30d32247ebb0ceb1562ff45d69a102da07210875167e9c6aca69f6d7ca8304bfa9ec41cbaa8ce956a7966d5a44bc4db7e2bd24a9f0b51644fac69b5eba1cc05d47a060cff39fcea2f322af40cdcce5c8bdee20d6bf5a000bcfe08b379285cc5801a0a91e79f5ac60fc98f23f42b53a2a66fa8bc7b4b97e9777851d32e29377f313f2701eda947fe24ebe2aaee8d415b5cf0b189ad6c2051bde71a3d87c7e296dee1829571ed0035b0062c1203c4afd729c377b821ce960573fbff189378c825d9cdfdd2f9c0d155bc0d3388d9cd3a2da552a264bbcac5cadb429deae1e79d26a8141dd8624d248a127c30236a4093d875feb166f2ea547aeaa8f3ceb74728080c403a177b9de8015efddd6ed92e844bcec94da6803b66974843573246a9784dc952080ee8d018979f19bae9a78731faccd73188eb3bcd2a5dc6813a06aefbeffd9b4189d2c5995c5c11f7393c670a1826238482b38def795cd42861ae37d252a926d78ecaa151e7c83eafdf6821a3e1669f38f48395018b6de7952df3c3a85079dead378e1e3adab3f4032d3ff0955c74a6a644993238f57118f15b7bddb87d1c52295a76cb6730e449985282d65fddb6881c1546419cf081886fa5020c37f6cd6b4b5f1bd19f97f9c6ed3c90c7d85d3f5185822197ca81f246ed3c0c8e689e93b6d35ac5f6250e3d9c22fba16fe93cd670680c26f6cf7bbd7187022a9fccafa82c71b304bd89157717dd4d8b5b10f68ec185ca339cfcc0a7eead44bc115806f41364ebc6b00e8a6d7698835df9bc6ffc7a5722f818844e69f0e8d349e4e8bf51ab40e9f92dbcc72e5a5871a3aa2db581621d97541a85396ba9fdde013796126537452f3a043837b649540a87b777a19e0608b8c636a33600a4b8308bd1ecd50a5e049dbf1f4d199fd8510bd9fe056162c1a62d1434a1fbd696d014d60756a92b5890ec2dacd967b1ae0e3e3cd32dc1fe788dc3e1fd2266ed4624c833665fe7a06ecc66b309945a017b4e8ef592669c5b044a4af9abf5abed19e37b5df47328f73658c34946785946e706b8fe4f86656280cbb762cca6ac307bd66571327250f255f4007c293d23419f8a5e968b940142aeba0997abf0aa8b742f1b2577733b0ad388c21eda267266b4c10c5ebec1ffabbd63514592ea0d290d7532fd154558da5592ec769674a8a3fd474604e744101ba0b7845fa8aeabe8308237e7cb717aadd148452f6a564e8f2ad62efb55ef0cc22fbed04b8b8e60d22dd6ad443e3567b11c7e3001e0563c86641329ab8c04b3dc5dec6808d197a5d3ffe8a96554d0a8b213a5ad7f01e76c2475e7b7f769b335ebd92d142593a8d80a0f6990a6edc52cccafeb2371323db4a8972b61d9303dd627890eebf5cd0a1bc6a28f6ad9c681becdc597dcd5bc4204a925e0da5d18b22fd8a45ee6048f4fc103d9a71adcbcd6be65d4378641c378ed97407cd66910136d519c39b500f80d04bfbec6552db54a18d68474bdcd9e95376ba26b458252e19ab58bef5478892636ffbd103892068627b479f35188035dae1a4db9ab3140a3053b70fcb66866122c9825f6a24e8221d97a760c1d51a55c0551a9c17d1ac8e7113c3e580cb9a1a9d889a7e73eb793e0c985e5d970d8fff83da92702434258c0e9f2512a899e4a837807669102127fb34de4a583a68cfa228671b428d1329c8c5eb024df7e5ca7d55d0d485eebce7bcbe6c473b141d4d96d419f62edb65e5917043a1027c0b6b5b4573b7b8fae37e974ee2c50d74c02c6c049af590cbcfdbea1e18549523d92c33c0fd4d4f79d6dc2648bbb330c2fa1a4d99f9db0f9209f9d305cb38dabe7cbf8b6eff3dce9d882e2ab0158c2e59372038fd1679fcf38f68a290e65a3d186bb38dc1002814dcdc2577e934efb5a38d96f190a6218175bc72418e930885fa6af2e4d5a30b230a364925216c1f89defb5c3bea5374e5eec6bbc0049ce0cd50caf5744cc9f07e39006d615b469c38641e43c801c65c131a762a992dcc635ff4d66d1b069f3ba7c41c661a20ce488f7ca75d67a3a3963c9c86d81d547b515461749e3167cf613ab0e43ca24863ad6376365b5579c612302531b96596649391adf7a10b5b6cda6278a09798541c55757ab84599b3318d04d0c131c9fe95eaa198aa65fb309ca369cc3baf9055371f7fd413d1d0d568eccdc25f74dd8de955d6c911774a0e2038f070e8e376334cdc90f14788ba5815bb0848f078d20f339471eaf73e721a662a98af16829aae11111ab9be01d86ca9c155a0dc86fbe9c562fb3c0994de4f3f8684012629f1d30cd027aa6bf65f898a4f793de8eaed2e17d89796d01f3e9650482ad9824019ba1c05668a7c8e7eb8b02b8b001a39f0bc2873e9786a012ddcbe655ca113a98d3cb58ac043633749205abe916381b1d9c571bf6ef670f6692ac8fc95ae3a43f55d95162e02f9299d93fb24d13a403793e6679462ebb2ac0890fd1c98a78fa37be4e10fcbdd9e2fa7b0bfae4fb9b776acc9fb3499a56791325ad58cc5d463f907c68c880318adffa0b4a8fef356f57b764156c6af80a498e8e2ef3f9c3af91e017587386ae4d5546e78ecef3f57d0d74ea5b0fb232c2c3ab596944431e499218eec9b2d73dd4330c98bb5580c350a77b98371a180ba2fd8e11e160699f6661fe9bb28f6f1cc6850cf65e43c01f8b84b2241a545ba9ffc9ea84067ee7757b8cc4b7a22010d10be666f4e358f0269ec43d36c87836d0d091c537fbdc822e4056eef420e458c9ba5621fa4e8cba0fe0d06804a6efe704617ef47180dcae4b6de4a628c52190035a1f071f5cd9cc8b3a69f11f89c997f9364906bc88614fe1c25735c84ddae4832e33b17815c312a31a5d8a90530466aee03e684051199d8ac10e1a98a7c4132c573852ca5c63b712d029caf97d676b007806163a2e3055e2734bb81d1aab63d6ac3f8f457bb9c060453e3057ccc79124a52c5d61e5dc6fabf73628dc23fae5924ceaab895448bc314b82170416bcbad61502fa0f1b7e0635a40a7a65dee2a7c70fa93ce4ee1ea6dfb4c4e44308b7ad56e8140a49517f7f302f89fedc999fd581403e3b623294e34478b308582de8e8b4e9eb7015257c0819e30340e6fcba404b987c1e12214a0c9422abef9db006a404714184d35e462dc733a71db873d29af7acfd45d7225a52e1e8154647601f57a066ac9fb2979fb72fe62c2b202b8b8e78c52605d95fc90d169b11e2b167ca970874d38c5f815329ed4428a8e24d0e0c681cb69cc284bf6062ced08c9b70b8949710d09001","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8a01c5d3519b99bb5af51a466587a22b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
