<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fd57c07d40f943828fb7d4c5a53f1ca7a3517f127eacc53832df6ea5083253c0c739f97dd09dcaba63c74bc884a440e1d42c2dbd05cee14747ec18f49547ad7a2403ac0003339430fb7f0dd2f1d5e5ab3c19b5e19e2be8a39eeb8f779916f7940bb490adf5374d068aa4a09547345a437789e053a4e13afcba1604f8e5ba60d772cab59b94e5ce911bc59b418d542e1175e426aaefacaffa18d3b12dba71285766b0a2426dd995692df55817d9abd520700c71d7811c02048c71f2960e610b524dfced8aea934415874f1687feed679f087e78805659db9dfd0d7197b111bc45876d3f4df70799305c3e8cd448fb14b8a290df5a482585e7722e51597be6d91496f6383d64f55cb8f08be8d3a728f23640784116e941f2b63528df36d0e05ef0cc3944ff95d773221d96cb0675f2236d2ca5451dc70b72e3d404cad8687c345bf31eb662b27697ac47101901f35b61514fe005e13c6573f03991800d13bf64e6a4f001ff14bfd8aab295b7f3bc8b4cf114805525a3ea3f6e929e57417ca892f8114b9e8aa36ca36947e3207344063ce1124a49319cf4203d66f330f1109507b84dba5a5d881c5d6c9b2b53a0b0eb9028e614ac39cd8bc46fb8efec2a7c45693ea21c5e8e065cdf833e47ea3fc24603be15d9b4a0369b937afc3693e63c11fb01f354f4e22ebac4ba1a2c56d409052f26ca6546569e8747b71157ea802e0a3d0583307769d641db50f7b706dff9a36ebc7f766be9138f40b28d893350de430785ab6de51fa250e12c9437bfe745b7dc41254ea4f5da89a29f9c52adee8331e7792117e341b99e8e946fe94110ec1352894f9cf4e58a850921ab350edf36f6164ae3e6e34947b5df9cdbca9c67767b250102da617042b7d60c491aecf511d9cf140b36dd8b5561791521ff67f707598769cc525c1301785ea4fcb1551bd0932397b9e7b5757d7ae90331e3d3d76b07c9a541119d20a7d6ebfef258559987cbebbc08a27e049c5072f67ba3d6fd02a9d5a6f6452ac054288e0012596385e1ea8a7cfaa76f906e5d2ab346f3d7bcce646eee8e6741103dee61a403a47bdf0ef8abb28970416cd9849c543304260848085adef5acf43b55895af6d30b8b67afdc9a7cd9565f894a97a96d62d26d8e0ed0f7cfc485f36ec69b26e4591c9bd062969a1e5508226c1b3fd42efc6c1543e19b1f0ae846569b2aad8f3064bb9e2a521e04e0eb6f9f6b412b4cc28f990513234f0f71cfe293298e1dcf2507eb127b8f01066d3800429042a4c6b8d0444a68ca4f66a80427cfebb820f68426f6e446347bb59ddeb2ec95872abcf23345dcd2e95f1a1b45ef90f311293c2fbe753f8c1a35ddda1ef939c407e8ca3e0ef708bc5f48085cfd2082e6c627eee64b96f65560061fe77691982b5e4c352e336a75e2c9e5f64505125b542b50190bb834bf787c92c62dc551eee1e9b14fa5628dbab2f772dbb38b890231016140339e6c96228f165524b7128e888bf479f11822e75a440b8b5b3262fbc26bc0a02a3413612fb21bdfce57a7b2118f916e2e6e162c009083c533dd29d744ae3cc58594b47d2f6e348c4041d910c756bb639c3af169b355e231237d91f8285f620f2f496f8bba058de6de988ab3632e8d3910995f706374dfb5ae7970553d1108b70eb7130e4dfad7d6930fc3cfc121a7481463fce970a2175b24e2d781b234bf46ffc06e64768a9cf29af1da80818d88adbba062697fc9eab1dbdedec56ba6fdb51d8e0d0898297df6a755f6739358261689ed9ceedfab353fc6525e7f47293a9056b9657b3a68e01d56ec2ce2a4f7947649e132d20cd2bdc2925786ab8abc3c5871a11a5a5667549e03bf9907a304dce24db2b2b83bf221f1328d83ca0fc5cd74c6207ce09cd1970d280b6c839f7a8ab3d6c8cfa5c486652f4bba971a62a54672b60b44ea2ffc8eae67a308419019e0dc283883f0881d5c753376438ab36abcc24cef09bf1469dfd6395c81e31b0d3f231c1b06d05b2ba50f344da670cdebc59811fda6555e2d39055402668cdd9487069f75f377241b029fa5a68da0f036ef6a35d8ddd0538df8798bde45c3e6168ce9c0e957c6bc4bb9a777274219c11414ef60df19b33c79861be29e3bb68ab48f3c382c448102cc4e719eebc0185074ae01206ad6d2af9d87886bcb990b4bad3a15006c55a69164e21dc85984f2598b2a5c445abd2e3f14d48d18a5a461e6ef57c7ac5991fff1c4316db98f570107dcc890dfdf611c6824ef52697e4ff82f6d6d46cf7dbc88a83f004b781dbf3a46a65c8332d78b2a169260791c55ca98895984e7b895d27f673b8124b62a1e316279b85e05d44e5b9ed1f0b7b9a9cc891d9fca2a7b90e178c11e39e7da151a335095d84e1b62b9966afcf4258d8187c0ede31c40fb032f870e875664d1817d5dafab4ff53541d552829ff710ae1ec0ba63f4a753f6d195755b4afe10ac3fbb523cc22bc4906052eddb83a51d18e6cb598b9a2ab757e5d98d35810024918e215453154a1b3652f6c30f0b4312d8c2cb0547be182b4bfed69ca6a13d128f28435f2af8feefcef619f003e7a7fdab381ce06fd0e4bf45f9f4146d62b6a20f1dada639f132a089f6b0d3619f40bfc57e605fe0d304d41ca587b3a13d9b9822a8b083db21fcb09e9501335e6fb68b06ffd1681bc1cd0d687f527e51189c275785dd80bd8e23406c726eb9234f727900fcda7231a97338ae49bac5924db99c3722e468e02dbd1823685275f0d6e43605df9d7bc7deabc2963d94ff588d031a1d18ff7abaeecd269fe480a4ce8699da1a5813d800ef641a6fd921589476da99ab1ec08bb12a898a0379fd69aff52ad6f717b8e46b6a522c96a1e5efc1ef9d5790d8ce240ce57ea56582a879938bac2b9bbf0df03d15ed5b64d1447fce72b54de8b65f17ebb4f778d0ecc2d284ed59e43e43b1809480066b3341b71cd34d030021ed6b0ee384e4a8a665e23921d281e71797969d88fb888d54ea7efff58af71f60c2ef21b34670232294e57a4c6a2548278293b5da0f32446d5b0393f56da4d7aa7426dc20c5ff0008bfb92204ad2c55bb1eddac176bd60c1c8b7e704807e4528066d17f8e618b54ff67040371d49003c4031e9d9484d6607132635a425ade0a2a8f6070bb247dd796c3ba1342cb8903a812ff7c803cf0b5d98b2c379429d1050cd4e7852c188fe87025a220f42501a94832ed2cd6439897d3f8d3485545c2f4749bcba461f0b994fcfa5f66cac3c84abe3cb4dc4301c56fafdccca5d889186ec90f432b8d31eceeb2257e060497bf5dc6984c85efaf2935a74d48b3b3f4d4e05ec481b66a9acb549217ae42f2a59d028d362cbde90505e79520a9abdd94ee9c60761bf658e323aa0e4441f5019630b058c7eba374d82cec35baf81c9657bd80597ebdb81d21cf95c7282f937dfdc43044e88b7bbbff3e6cde9346a94bda4eefd474ee1c7d6510ea69726e233e70bcdadeeb4657606abe01d0caea5cde2e035322c73d8286d07afdc433ab6be2e79f3ed7c3e29d0c637a3cbc027eba3aa769b733aaa6e899aef2c1c88ea9c15b53f9a9acd264a2e7eb4da3220241e231dec7dc1724a986793707702bd49d982006964686d5d75ffe0f3bd696ced052347289736976ffb6e122490519ca5db0a442dd70f6d6ed6815ea88aa7d23f84acae8a02eda2da0b7167b630d115c335201b26c9ca02a30de93a2dee2c785c27f1f794211f7c714ebbc61ac52e03fa0aa33b4320077f36a71806a8f60806f313180b40a9a273f7609578d71c14329832ebb453afb0038b4ff962ead1fdda64bee51f25f9a6ad779ca4607b997c965ac3b1fece530fb71988028faea747fcd416f3b7ad23d20b4c60fddf741365c59b2e897eb1b8d0070493275abe1fc70e9e4995ac19e35529086e3754e36c6422346b1944b46db5669b58dd56f8243ade11fe025ec53bfcf66608186471a713efcd3a98dfdfa187ec9100f6499483a83257a7350c720f1312ed11de81cb47553af0e4669eef7e560724910c02e46c48e7b69eae014bc0b0e85de3ff16e9d9e97bca2b70da9819d4d8fb30bc0936a31ef85aee57e5d1514a4acd06ab7f61b9cc51d96180655895654135c0358d8e967ff69f97c9bd41147ced010406d26ccff53aab4131dcd0c2b55784a8a109e536fb4be11f346760c9f903b4fa5cc4a7dc90942f8d6179fd0cd4385745e6758dde7933f3425f94c15c06cfc0324fd3ede3d6557a95349334b72ad88437a02164526d3b461c388fc768ebe705b210292d98ebd4121a93b207af3120710c2ec59d087110179eeb22b7a05a5690299afc2725dbc0bfa5e4659ab7f298099d14429363df106b659430f13a00191205af738fbd4f3ced7a523fc1f24672008cba0a4af3fc790a8689d832eeca92695543c40a6cebb0fea0f401df458cb12a2ecd7f01fadf2d84a9db6f78475d159c87c85d586552b423e725ed6410cc491fdebf9d09928935e30ce81f91091a7c682093ea57a98202be77db29b7bb24d5855ac75b5c3a614fdf5b959000f9199fa7f1a0f517c2e4b0330e7648b77aa93bcc1c4fb5ef8f17e6bbd012ea05a446cff6d4fdccdb4cb92d005b3b505bb0e5db2aed741222eff9d4f4276da24222cee665bb29f33850f9262dec7deb14d015cd5d44acc7a7461632e16eb77a5662ffefcc236fe87c53591de613d8835593abd012a4b3ba79cbf4fb0787dec738455278487961dd7bce5a31f6961eb5621e2b7b86b97064dc4d0264d97fd5816fdcfe2f0ef3de10575de157adce173d690af6a382fdc57db20796ac45f494377fde4e730c12a98f248ad966d399f9e1266764e6a6462890a05d7d6524fe7643cde96f34cdebaab2c3be5da2a16471830df39f7a868f40cbca5d4141e2e4967b46378504bf3dcf6bf55cdf5b323eb87aa2cace4bf79224117f1fd5214a9035827b845a13a3f49e58f27f777a1a138c4e2a62553cd705b935d73a7b68a07b866cd4826227027ada0a7034765b67c9a84a3ee11729ab3ab3f0d882ef14f52386a7ccdd91026d82e3df6dd15e8665490eaea1ffc22f5606a792cb1123caf7cd2d36708f4977e6d49b853f5bbea3ed99f5597607fe7c4941f83099f7e1744a776d9e666f3f19186f598537491720705131417b800cf8fa4456abf6b0edba6d27941d96495aca03bad4d5d9ec34503b1ad38d25f6b48082388d3244f6fbb5081e2aad3dd3e5106cd5ec08bb3f929f53141df38ca6ce678f0aa975a4e0a3c3a8fd9f47d34ce29cdd5bb664ffdfc02addfc4a73552931ec8b7b540af4d2e430b775b5cb04f16f5cc52ff84ba9b9f1521e8d936fb071bc8d37c751ea26eaedf635ced6c6321f54b637851defb943b4c95b11ea148f540502638cf0071f5008371124644ce2a6f1fdf78f09495f61de55ec050dd18a465458d984ab2188802b6211f121d02b65464c7b0d74dff41d52438fe70fed87a7cdcdfd8188ba8e0cc965e1f8712430fb2bc3157f2e2b15c189d3a807d971e5f3a2c7f56c549298c1c37020c673f8f602c856998a450ce23ee8f9a846c349bc63634edf96c4e5b8a7b48aee7a7eb35ef543ece4d5fe377a4027e397329c485a1ac06470afe407e06cc1788bf2c361111ca0960dc8a602e0e04e0703309729d8363ec992af8c0620885a3a4ebfcb747e1d45227e22da23307785ad1fb0e16592676f46b1223fb4da6c71fcbd5fb29dfbcb9eb7e124a6457d19461a29314cb47c9751e8c0a7135269183b23e2b6375be7ca9170fecb320f2eb8597a69cf52e1fd227250a58520180d1f037cf2a0f96ecbf212800ee343264ae7c232183aa5289eff5f1e05a9df9c13b3b48f922b1a0ce481d935c74a56d850e866235a63ff2e7689fdcf90e0614f7d800e2ce60d9efd0e20bf4b4c5b61d94bc43e738f0a197b19840480c7c2d115b8d4e4e98f6c9b1c50896a8762057e3744d4011fb13437a3d94b338f2aff5ed8c5025ea262affe16b956c4b87f82def9e89514b0cda426c6e60d4d81c12db99d2c2f6dc227692066fdf54a16e79bfe148a060b3fb05c9159e7847e7038d9b327e4cd2e00e77c5565c72abced7cc2e76992a5c34b744c2db332a916461d71eaf20fbbeeed4405a179a6c9db851e2246d0d6825053865b6f232545664673849b08a365bc65285a620dffdf1db5fdcb7de3edf4fcc13a4a8ba3ac08885747c521eb40f99f5cf54a79788c496221c92600ef308abbfdb342bed1236e23dadebda13faa65660c6e71d25aa443ddcfa60b46b1368b78d6539f33e52ae82c6a4051a56bef2a6a246aab335a4ef91d0b62b93a1d8c3976f4d2e35f1f931d5ef7360e50aa451a3d293455c94362eb5f7f5a25b22a2d859fc3d48ba7e9c329361d81d1eed8aac3dafbd7623a4768ff55338d33878435e90a3bef3b868c469e7adf1f496ef51f7d670513025deaec57c57377b360bb1e9b45644749d082b81ff1943faa1de0d31ae431b2223dd4fdb844d32a418ec19ff9b9555aca213948f34768895239bf2427ecd889c3489daabd089fab1113b9c3df7fe026197ed907f460c72dfc13f41d38b41d39aab66b94b7897ccd0355ffd8274a530b893285b88f1e7a137e325fbaee08a9f884fdf1c5e0896acf98d56fb1a6c4d167826e571a7228c8dfb6dda1a09830bcf03c4d11124e3ad5c2baa9e04bc7acc70dae525319c34593574f6c25d2ce6520b43d4403c3caeb97a433977a9dd5c1f657e2e805a604deacc25599819dc31bbde9cbed656f0ea0ec926f651d88e7e1ca817e59f95b6a8f6229d29724936e5db2a1bc90122936804ef0672e51288e6f4597d843d06c6a7e37fe1346d6ca2d338420bc26ac032d17589ffa4019f45b3472a02158a9f6e50d231bda6ce5fb7fea590d7ff5adc325413d7aa6985bb753b96dcf73704ef4810d05db1d87ec1ca998e852cf9ba39493dd15cc150edbfa17a3032b8db96bfc3e7266d375456ea82e5d9173b3ac9d558fbdb6c506937baf646e273b98cc312b684a6601b03d37fb39ed17c1668d73d2e0ca84875afa8544b6d102211083946c436373518bf3b54355c0804257ea4b4382659000ff943f52695a273828c485ef48c0e162e343ea68ecb63624db91b881f2089181a2b7dbbd67cffe29eed5979faeaf6a1c9416d0e0d69e7712940de4c844db30602044def1d97bc1e95f3ac3f5c7eefe6e2742fecbdc3a58d494b9e645fa0925a9f3e7ad130764010461041e2643fdcb9ab6c5d8a24d6c9eea92dd7fe61aa014b7e79e69959378aab6a2dffc8bb25b9f894e1e5fa6c77992c7d7bf526c3f6a9393ed3da68e9049beaed02a78ad72296b5ede35b3ee58280100b1eb86582da5dcf7562b0228b1ec83aa0b74bbbc6ea781a82aa2a911c118a60ea86346f2cd8ac8203f95adec03ece85b0073268cd2e9bbcff16fdd3b27e7e29488d08f5acd6f22cb63aed6af8b5a44d13a9fc9914b8929196df9a1e322068efc2b1fe7bb57f5172a7d8135bfdf986aef1118d430dd28f66da951e8d4c7c343b5a8492f01a8b045227aad4d9b88d258e19075d59a0f0f02b7308711af6a6d4cc1f1a78e9cf2489dfdff86a87aac2e63e092c292266ad31c4f8add669bd0be184c1ba5bcbb828da91b04253f480b4438983ae2e83886fcddf96b188a10cd58bef79d9d05e6de95cd70971719e1da4e3e451fae8b572c176beb0b3ae37f311782273a24827ad0fb71bb8ff7644347d586e46f0c2d9e2414f86b236e05923834b564aaaa05b299b47946ab078525df4bf1de49cc1cbc88d99a9cbcf9d7b6a5729ffbb836fe8c6c2b4ff251c0e6da70094cdf018585c7bc1ab05db341be31ee761d2a86839d58e71a553708980ce3d07442e74385fd447f3621557be5fbc485995861f3bbb274517206cfe4e51e527c1daaf2d0d8fc891ace898d6352e910b1db49984a9cd028f428c58bf7f129e58c10a8ac71fb9c6078421cc0605db0e05fb99de992102feee92157520c204f6e4abf0347a70e270b1941332585b086e104e1ce5e4a16794e7c3366e45aaadf21d75c15564af1bdcdab3193425ad4e0142ae71f04a2da0643edbbd2f5448847f382946e9308ea3099d3f7c332cb0ddafd8280f201460e1a6e11eb75aa84fe99fac1f658db9f97166bb4ebc24b4ba26ab82d6fc3a5dc993185943d10b105d459235f38cb0d8ad615568c310cb0d2a928ab25a87213406861bad5a46cb36c9dc6b247a1ebb2add73db645c0a9c83b12afc80b4a8a25d69745e3c0469917707dc533e1e3a046961b73415100f0b99413cd44508377def6b836b6d2e36fb00394ccedd55935ebbdd10778c680e77c4d4fb4093befea5c088c439a4ef78fcd1641b84f6e5510ee17e0a0e08067ec0d41c868a4f745302dece40a07abf8b1f3e8c402ef2375662fa6d5eb254b73fd23652d0a5f595ea9eb75ee944f99989d047281d864899bc95da05d27697e049f55252f0bc65c60c50c509b3aaad95519a7b165552b416e3a89dad90fc31bafba173fa0022a56094c22d9594a504951afe69abcc001142c682b7d8efe696e916066bd717a54d778b07c32504caf5c43edd4b89193b27d7ab8de27e0656752327e99ec54cba79fa269aefa567e5fc8af7642b5fffc00c1cde8e478b711306fd5e3f8176587a581dfaf7d0f3d756190e00d9915bc8c570c87505bfe33b69c18899894e0b906a5b46ef26c326fb9c417596caeb7f1defedb45af5a575a1766a265d881a468965c44d2ab703fb4aae89c20a37aaaa63da9fb5f2788dabb125d749e7537b31724a8eaff1e85f2fd6728514b7bdc0aaf869377c3b3aafa63d5da36a8b65b2639e1f14e6da14c4fcdc4153b55528bd6da93a0c9c59e86733eb43c7c3a3bba40e81ff7d1f8c0581f9d2b1f6760b6b82939de51d620c77d127a2f7d5c6641d2387e33ca1c71f4e30e70e942a69ceda03c777bbbe5e530b81db5397b44ac5e0da4a68f8b1f45987f20d1dcb244e6398092396495e8530d231683b365663aa2d08ec66cc8b94be54cb3c9258f9dbd51e2a320aa3917f3633b634305d625017beb313cee07ac0c4e5d2986814260a0c0980d76d9eb035d95cba15abac02d3c0d2803b732b2c429debb68895df909944ae1c9ed97e837dce9aa3d58a987a1b8a4f2697987cf594439f66d0f384ceaad88d7eef1a052eeb1f7031edc7b6b42305abf83d11ed23913e3094b7202567128780e1a00069ae1e8aa56038ec989c5d5d477660cd96f48b4aabbf47633f3248f95f96a4acf5c959ef21795195c0f8a4c600eb28cb0a4638470a4354f02a040291947d0aaf76e568ea8921ee5d4e5430b9e1ae682ded06399aee4e943d34512573aff1c1e99a7aae62a937d069ff58f71be202c659cb74d50ee9affec9fd4e280586d393c273da2164fc7974d78ba17d459bb6cbb80b4897d337e52064fac0b7622c071d047bab825768e2a6b9f721a8dd3f7cbb37611865471373fda7364d14dec8d7d0426e0a5e79a668631fd89b1adef80a557864f0c089b26f218eacc83e04f71d653c513f7469402652cb3e7eea8442f43d633418c7271ac963ed209962d0d90861a7986ed3cfbf32420b2ba1ca11f3d13db369bcb3796d178d9c7a528f0975bcf0d54c17ede7425400a1f03b64d491a386617691d13b0087228ad516fef686177436d56d3967e2ffdbbffd904db6d49e18fb88ea57cca92ee87b9b80c24464c22c54457eb04075da658a413cd324fe597009de1b05008d5688a5a2838806b290ca10f414db017c1863e240739ddcb721c8bdda8ec66a5b413f4ff154044916b5c519899d5c291514e23f06ea28a111fcf0d915c3a1568188095925957fdc245d671b6241923ca752642d483bd9f68a9f86906b2d182dbe60ba71cfb73a2166456c955fb102adbd152fc455a9b5209a2789a8862ee07e1e1997ea9289793afb5d1d8cf0c0e4c0f52f539a24782f604ac31edf89969af0a51b2fbc0c633f05d0960ab2bc26d018210f295f22a16713c32b785eb6f6f3788500b8a7a0a3cf89e97f37a063afc485947db90391b641aa87eb3a3e2d330bc122e88afa34f558ee62cf4666836fad97170b04b788ba61b417c64889c29c2d2cd7f29d272362b7f019a29c3a04424079cb9f462c347c42cbf87506614027fa4263878414ee605eb5f0ac17ff38a2bacf09ca21d334d5d52ef5775140aad14e75401c10a9634b16365db62ee16578df25c4486faf79a710d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"779b78f0b0e284ba3ac14be43b73028c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
