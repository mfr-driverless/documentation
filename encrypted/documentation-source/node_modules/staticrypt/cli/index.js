<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bbc3968b481022dfe2e4a43c6805a7621fb438fc4b610285cb87a5b25f42c00be8f05573909c562b546d57f5ec2d91b9cb87b67922a4f054e77c2a2b5071e6e287e88a610704397ead0fcd3f8631042bc2cec59cbdc93b3c6b96b8413f9e04ddaaedcf05394ad57e8e4530fbedc804c16622ed14843a3590b9406b2667ff9688c7a1b995272fde988a7304c6ca7decf9d45c5afeaff61fdedbf88f769f22ee6d4e5f5716058414b9e2b338178aad593f13f16d074508fbb2b8883e478c1971b9afa6f65977ee2b26fafa405b597de00581937a8e808e1ffb7c9b06aae3c8d87d5c3ee89ed32b207a57f89e4de09a126c8cf49fbb2120477e76097e1312cd24bbb8cd57634206acff07a87e9f8de347b7975f226b93e79a8363c638fe41027359c64205750d86f0baa3b2215d986b27a493542dde3aaa56144b1ac0a781a4f54e4ca234003e9a4a59574f9eccec9458a1126903a0c48e4f6bf4de160de3e0ca9e586eadd84e5b985deb5977b007ccbbf82248fc25b883db96192057c083b10c2cc5d7d1d8b022d345f7a1d49a2ab934a8d714650ddb93c280dcbc67e48b27003d5ec800bdc2e9b20f629ab81ffe5cbb74e53080816cf1729cd40b1b27cb35cfcdae4f5ea58af26b6ac42e9981d717afaefab8c2d1dedebd54e1f80da76e7d669418179aa34fc6767b9056158ee60dcaef078e427b6903f4848a7386774f3d5b47a1d6fa266fb330338a623e0b40243b4ba87875f8b01591a5b21d103162caee8cb8c4b3269dd2c065e3cdfca6ae64b925ef7ddb96d40ff80924c0c7e4a08f9d14bd59c2188601f8072db96ad57b243905d424ff5d7e7ab522b9907b974481e4d83bfe36cebfa395fc23c5c20abd4a5a8c402a05436f4bf59e51381df78e9e028a6040907c5909960086e3ea7c4257c35f3ecfc17dde4eb3b65bc91f7f18a72b6f97e17fe56c7f818f7a368cbb962cff5323d76d2142e80edadf3f4c16f0587b0096675c08d1c155b7bcceb54ea803e54f1d0b5e386214235499048f48dea2c265df21948cb9bec45efb050a9ee90f92c6e05795f15b8d0c6557619dd386c377217b65e76c6918f7286bf9c913cda653cd3aeb4261f391be390da7a797700989d4326e5087d25855d118ac18ec203a804dc9a94d24a357f319ca0a638326ecdea2c39968a68d61c7177ae090455057448d78e3788073efc92a5ebc984a1ee9558ea281f6d4bb4afe342dd599f04c36946902de5c299e2d80d47001a2af2abaacce6089b75c49a9cfefb9f548c28246090bc33ee1539e26e83388c3d9c7365715895ea5b91a8c7216627ea1f9c51b7ca928fa55c38d1edd978c89306de48071e24a602717d9aa9e3f3fbc23b34addefc2a1590dcfdbde15c98a926105b8bd16f04c1ab7d85ecea7927c8ab66adb5569924e20486748a621141a1b6f363c51d1e4d98770e77472dee5152eac9051c5e770c459d0e372bf50b0406c75687bd9059ad135a517510cbc82cfb4d87237e788ecd4e898df7a2e1fe38a8ac6f12510768ef4b969ce9bc4310ed2c44110b5f52c6b8755051761a3217c4ae4ef9a0b9356c884066ab9958b4b286aedc27af83d84ed8c08272c85d5ed85ffb00788583056efb5849655c23505cbea0c26fd5100dfefe67287df92915b1812b73d86c25edee76644c2c648bc9dca86734e61653dbd4d6386ac3b21d45f2e2d78c5e363ec91878d48fb7d9d74f1495d7fc617ec2de6520c4bdc19e9ef052c8cc9c9e6474b505309eb21a9d06de980c18ab690efc40d8581bac3357e8c9c4f9aecd44754555f1ea24e81650e84dbb062c6f4c54f950dbee58f8fd39f923284b321c6e6b990548b11961308f6ce5c36a017c368c10f0558790daa04d016cd12ff598db48dcead8a4c5035cb3bb20636dc6627e75cb9a0b72c68b3bbe5e49bf6a041eb52f27e9104bf9479d66182b482d4602e1ba86bfe563c5a50bd187850683eb7ca8458533aa721a011525a167168451354df86f2e9e417dee72f2300663d95fd4a3b6dc6f78af0ca341476b7eb5d8de8c7fa2b1b8d214309a348d0a17c0170186a878cbc2125f5871ccc2b8a2a2058f386d9bfe7b646fdf8081d82c31a454966e64d435e5b5ee4be8b9a5cb6cac6d178070f5d117d82f53229eccb79aece9e3c39506748de7f5704c36900981bbbd5a51f4865e8185f276865a824bb4f6ab7533b5e4a8b319f3919aa66da7b90b26832792d41e566c4689ddbae92f3ba0ba9846f07a8be534420832f0f80fa229f0cd1900459dde8dde798e6b682de12035fbf161a59a320addd6f475e894cb48dc25e037d73036128d9d0970c1d3fb4220ae2a687eda76360799165679c2616ab15d0c7ae520905e06870f327adb095e22ad9a2460b6ef1fc31f158158393b156e7c65778917882b68bb9a12d1a604fb1fb681f101d28833e267698c590bcfe913b826bf7dfb4c602b3cf385a787d79f2c870df49a18380045725f9cee2891a053cc0eced58c7ccac53aed353e9673ab75480ea4bfeeef7f2095dcdd131426d16005dd75c15e66f5226980af706abaf170f58d981129f6ca72a7b263d50a579bcb2541164771ed4bd24054382d85344c262cf297844712e510b96da93f29fc74457a5294989737d00196dd456cb3610a0b1a2b2b66187d022eed22fad21b1c03dad2145de33e90fa5ffa1d915bc02fe28af4a94ac0787964a7733dd99c6521d0ade65f9618beb5390144fd50972adb7772625bc9a4a05a59abfb472b9f406f294bc091ef012854c26fc401b07470a61b60ae0d31ba8270290bce1bbfa01e1085e4707e582c777c6d71ecc769d7fb9b2a28d6a428fc5b581489887b930710b4e2ddf39e83a574c36efb691d94143102cbd72a33c9952b8c03204d33687780d384a66580707a0a26aa3b0289356944a4b4571c19756eb6beaaf0d2b5f4335552678f98fdea7c71ab1f68f5c67bb8f153454e40f93d3a36dcb6617f3c8aef5351f45e2c66dd22d461e213c93f01b60da0e9d268563aa3f33b14f1170c215513064ccbf7f01cfeea58ea1900f4249f96091a5126f4584a33e177c4ab7c3fd7c72cc5881cf710c7cc811e155e893ee8975ca6ac7ebdd7bc0a7e48080240bb127a467ceb84e4c24daff7c5370dd8ecd9cb8466bc66021895afc4a341f06a9f592d44065093eb1b3b15fad4209171164007fa3a8e77f9d98faaa675fee106d28f36f5f02c55c3ea953c1819a34118c342de6c5c42c70929ec3992f85f22c4455d393540591f0c4cf7be45506d0786aba87fa9fdf8424aa8e6b085b486b212d9878fdec27d6112eefb873f7c2dc9bfac571e189c5cfdb94dee81706ee56f44456535f7259ab8de62a9cd7993a4ec1f64ddc533018f4dd035aa0ad52c8657c4604c85d498434a06fb9015700be22b2fa796be42d70d609e7a774e8a0bff7a5d68350d7bcab612497c693a845c9f7a5795867cfd5067b38c12508ca1e1a1c0602f46647442e82f45d77238aa1ff065d93825493c2bb6efbeaaeacaa166f09cba87de4b849aa18a7e0aebf1fdc164fb4c7c80b966d25dcbeb9cb12884f57a8bd4374a3380a3832f0771345ad6a4ad9ecb747e59ce90fd0141e8b4329bfee2cb91e5cb819be5726a547b320b27bf86feb61c591754354f5e241d6c9335278df2f250e922b632d1952a38734a7c3bc99fccf7f8aa953b7987290880971846275d241ea848011d879409b6a991619adedbed34c5277817353a86af70c24875f220703bbb161e14c2dcdabc465bee1d6cdc9c56b855c49f4fbe52dc22d14e473d4e15f747a03d8ff5325b6cae75122de2ecd6bb1cad491249cd04da0059dfef92bfad46d797e275d618b17c7f33de72015c5204cd75cf9ff37fd6f52b9c8190790ecc9ca4dbeb345447649ecfba0a9252be9e231173f876bb47c28099cd7bacb0024fbb42265274e82a223cf07ad59f036701894cb57c3e7cf9de0dc05593af95431213831d60728d47636f851dca0759c7690a4320e7dc858393f33e1c4103b3fc91b31ce387c5efa6843b563d08fae576ba3e93c6804c3bec96a1d9c8b78e6496a3385f1cc9894d57ff071c5e428f77f278b4be77efa55c9cde8aa77f7a168ef49f2b1746f0243e93fd14e9f0d13e50b685166b4ccd1978759581c757bb550a31dc1aab4b18ed7fe6a0ad61716d09b28bbc38d1e9aa433e58cef8d04f772cfd574b5f1861ae65692f7026a42f28686312d0b07ae7d270222cbf8bd0a3d817735d1ed10c9c8b33e2a1c5139a8a91c9542d3891861617fa1aa9552b9c55086888b40e8c49ecaa1b0df93e5c0aac7acefa8335c915bb2c0b4c39e5c32535036e593e85002bb49b64d853b3b9a9d72d21d588ad2843e7e4cf05125a3cb54cb1fee2be98dfcc6b54d669f80caad826c2c33482b32669c39889e22f71cc4a39fb8c91d9cf1da52dd7a48d275f236d32b24e2973dde001d296aa3edb622a0c93f64c7c99f85d437ea804e46f286b32897664558ff8a3f9ab8d547c344aeb9a4b6780f668b9bcf6e7c16693d8de1513d430d607df1f3f30feaabd362a7dc2410bbd9649d009afd4c267a5c887b186ed54467790002f8ccdd853c787bdc5bac1cee3b4dac8b79f5a7db6f03a0e7107be9cd4d953f1ec9763dd76b160bcb84bad8755df0076bd236c076ceb6c8cb227149471c958c67ddbe4667809eaaa5c5b058e302bf30a01acbdd8e3d9c6bf603bc77fd1c900197d3e43fc1a4dfcb011ea72246a76df327bcadf06720a656bb7b1f24b41537e27069e0b17bc3375bbf1f337c71097fe58c555ac5f94e0bd03505288514543f7dedd7b0c54e8214e52e5cea94fa4a7ab74f46117c1de9f8ac774402632bfd9e5416abcd8351e03491192d92f3efbe2adbdc5bac2952ace4101785ee3342eeb5c93196964b2995a64e0076be0769ea72d369017ce0d23aa6f3d6b98066ce52afa0e3841f7304492056c7d8e582acadf21a51814547a1c57a352e7129fe2035de334a0ca17f3ab593164efbba84a723eca33fe70c6ba2a47f41d87939b63264be032eefbda484f6f2f3f67cdc22759233d1421afaca342e75499a3f7d091afccb32bde6487de3482907514467305e9f46d527ee42194dd0e5a9c46e3fb05a490a3693de14c6a4cec00c1d909c86edb396ddba8132729c66a471fe742fb19e59f48f7b54af690fceaee6af16a0d5829fc73ebf8ac878366a7c37f1b9de7c6d8f16ddda56d70b732826a9d63df30aef6148fd1068537d2e954fe614df96ee00fd9d72f3eae3e1a155ffc4b3aabc62046987d1c72cf1a8aa79d876ba16afa98b8a749eb82dc134979c58a46a32872dc3cf55060f0657a9d25cc4d57a08cef6a34db3b8c1fb9183df02d1aa8142f0dd790fdbb6ef86b64e23f1d4fbed7140097c610af157ae54806cb9b9a25c791fa9fa38dee9ca9755c1bb07e7dc3e5e0cacaf4bfb0a007489c57ca64587a595223857c4de377333167ea56b21e21de40d0b58d1530db3d82f369615572e7677ef26c027ac7e91becae31bc0ae3d84a77c929042b2c6cecb687ac50629e789761f614f48f0a249fd850e888e104371850fdc8e17e6d09e5943b7d349f088801d02785efaa4d4e614a31355a23c737490a04928933d0872074e103e18d0449d8de130d57bda9e7d5482004ccf5c179b4096a12849fdb3519bd7270569c1753fe108ffbaccd893bdd65b9e07e6b7428275737dca32d8ef98f8a084d065ab059588122c8148502e60535a50e6a3a274dd5ddff62d63d0acaf3b2dcbde011d2955aa5598b8367f18cd319c18eeaf5aea99c4dfdc5ff8a33640a9f86a24cb542b3ae2975d9904af85df5189a1b63efaf6a74bc6f86650e557addf15654d47b6ceeb329dce5f05cc442da66dd6639c6cd869844830bab822b98e46158ea9c87a83ef86da63af09b2f865c7fdb4e6d203571f043e7217a6a881d05a9ce703d2ffbd448f8d750b551c29b842b878215130a4bec3e187da30046087ec87b86c734b52d9ba92866c20347ff3fee106169d801bf5324c58a76c0be8161b58ca177623f492898692985f964494dd3ac02aee0d3b96d4e3bdea4d13ba0f8f1c7400ac0e9359358a613d6f72b58204a3adce3e9fc180d510f469d1eaba009ae723557a1abc13537b9d769ee85bf091840413a7862ddfad5d63825ec563a4418c7ae079ee04f1d429d2f71e743af80e02f7a324e4a9165ee3a799a37a98d431438996b1e183659661d984eda68fe7b579bebef2ebaaa27d8b6f9a16a5b541518cd6996ee055fc9a64198aee5726afc473e667bbdf3cb5e188a46f2ab53793d00c89ff9ca54304909cda538f6fb4fef17853d0b018694ddf70be03bce04009d7485f535fe67d6fe5cc21a301a935c8d6737e0fdaae4131d45434484b07e63410c1cba22627f4fdb4a0b0bc40cdfd5dfa433501edcbec876dff120fef265aa8a5c0633a98f1267bbc415d88f922c210ce4bb5daf895dc298b5a164b005af720e8366dd59de4561b05fa5adea26dbfe87885f44d35373a13af16c0a6f4c1a09469dee1dab40f3a6384f965eeef717f225f41b9f506d870bd0f4200273ae8f3db5f88ecee4a75647e6859bf264440b6172673bbbc2f4ff06b4a5191da6baeb1d9b58733c514249b8889deb68205929b035570d1e3b014600c4703d2b9c7241565fa99c21c8929abec3e600e41ad3370fd9661a166bc8f87be7569c01e8bc26d7cc08686aa275affa8234734a11ac424e627c2c2921709a177a7b4328e4354069d42534b44f7746b82e41017c1c55d2dadac3354486736ac0768c38b98933f0f7349d34316fdaf73092daa780ed0e9fa1504e8f64e94d43097fac994a978094586ba360c5e50e3708ddaa2e3180ff3589fe5d9615021fa55ce8e6c68f60f33cf727c82e75903166aed03608751dfd820833a4775a8a709c29b705907c6784c61ba43e15237cd9a670a6e3d1219c7e5a745da1461056f2e835319ce759aca23ea538d6558335ee6307d05cc8546fadd764fbfe8262d5c87437a67f2e0015a36eb9e762adaa66c372226e582932dcea483b37c15910097fa6f8433a1819212f9665b1fa30420e74998704f24be82f51d89cdebb95b83f7f8708f5c5548954b12880e658eb1d901f5a16c172a185c5efddfc2750e0d1509ed25496edea7c3fb1056e98836c7c4731fb1987e0c7c3b2776ee26a6350e0b985378a0436eccb8fe9795a69f90c6d1e7caad39345e83d516bbb5ba521b893257172097d7fba96a89f826405fcc71b7e905e52d7715339efd74335a82b6e159c095148ccf72a4cc1064893c586bce1b6b9958fab39f97ad7bd54c4923f57f2f08653592625cf61d01531d614cc4e3c1ec56a3fefe2a5bf97dd85a19277ef77fac4779b31ec5ee6d238a3fd532188cdc35014596002e037c0edacc24d5fdbd492aee83bc9235cbddfd727ac900bfa20921d35a2c3d63d7ed2a0ba0d21f49dd39510368c4026073edbbfe33db25d588fb008fdbfcd9de4df4e6d4033b638c11e215679bc64fb5ca309dac43405d8b6e47a666aabf114e201bd9a2f7a060882984c51989bccbdf681438c2faf117366c614b07fb705613a2114b02df243930b953fb292c72d0de2ddbeecfd4066ce8b40f2cd9d7f76b2892dd8f9003daf6652b6f3e93796c44c4edd4977925d903c2436f19b07b8abaaff11a61be5810ee007667b998f409627dd8d6d8a42e4082c44ec188d3c74df7cbc7045c4d7f4ecaabea07b2f1666e6942ccc7f0553677e3ac74ed5c733573ee02db38f05dd62f2880405c005fed097f143bf5d5dcacbbfcd5600e7f2189484feb76af76388fa051617e69b996dcd34b4f2da9755a405a3fbceb76e7d94c08ae05ee65abd4723637629436c2ff5b1fbbe9ee3180f4d502da6477d958358404e3d1c5577c9678085daea0df9cf7bd6d82d88bb7e08ff03d9ea4b51ed248889294a444c093cde83e4f6e77944831753698e9c97ef1fa336b075b7cacecfc5218dd4073b1efababcc68c951937e627f60fca7604a5c1a77bc3fa1019dac9333820202789be7c5a733d123948b7097cf8e26b5e910bd3c9910787d9ecac6d7ebf6050ee6890db871591a7ef849caf24216b56f57d8a49b791846cdac1cf484ebcd960e0500cae3f8d6b3b5b9dd71b7185568f2cb43f919a11ba0ca0420b0bcdba4d9a842ccbd2c15ab9141d588c4585ae52b33454c85e2686fa99af1df1ccacde2a023cebde391c04b13461027e2817f3f240d9d175302d240f0e28e5de5f470b3a91868ee4655c3536bbf8b3717130442465612fad052c650770a6b120df0235f87945e73f50524193a628d1681757aaf86f61e234085a42394e21d49076d98d8c7c7aab413e7b5c4c9815b7153677cd72c9c7f389353b83b738af965bb381dd31f6cc0aee567e1e1dccacd8f510fe8b933435358baf9df36e0ab7b2fb0189753810d6c95ef8a7229d330bbbe02b6bcd70dc19f12c790dba23ceed77eacf7f5bda21a2e1e663e3ec41284099362ea6d6eac8d04a6861649b8e0b46c52907bfcff68934b55cc3fd33d2ab8ee0af45e391cbb4f6cb825ef356236624d223a4edc925766d860c06585c9f8bc57d8c07263dd27ddbd095c9c9e45a7ce2d0ff4181d010c994d33e35bc00a72e446b9dea8ee1aba3e030d85a0d80b30e4e2a51db924470d05b150568d5c795b5fd2d796dc3370af5d96a9d18761e0c853adc753e6299282c3bc79ce55d73adfba8d569112a36cf363932ca1d8e6e0ded57b11e2163525a86d77f7919c92417bc1cfd83e6a47eb2bea64058d971c2910458d1ec5ebdbb96f1c17f04d6dd74d35c7a305320440a3312bb1af56df42b5b361f8e00b4ebc5ace18dc8429855e1a3add0d86a5cf02ddca8ceb5934699f3011060d4b81659ebdfaf82111a888853aca01ba4837c8f48b4f4caa3d5f9c77467a9103d5a49667dd1ffc51ed6351c2913e9a64bc42331b86e0d2e1a42aba33f6535a675c1ea079823e8c374f836378fc13714a1454fbfe57eb3db18aa9a048b27f99fcf838630aaee6fa05946f2bb1cc1449d1751d0a03d7863b7ace0365c89b67835475adc38d75d0fdb58021c7dc498df793d972a11595c648b752956e1edf6c11dbe5bbfeb5cfc14594ebf7cde3b43c2bf1321ce01bded9bda663c4a9b3d59c54970fede672e6486f86f3ae81d7ffb92e7316d192538849cb011569c6fecf315f9e1accf8bc9e4bb7c0a3ab9d941d5901fe26ceba679314de4b4f3fa6282d105f86ee6d9099c34b32abcc3185cc49d362c6361e68099d684d074003f3097f6bf11ea09ff988fdec1abd35beec24d1ad6bc4462707785afe429c805851dad3151e0839741c40d68d8115f0c36c15ccdb372044ccc264a489b8a055a064b4bc4290146f4cc81067b6fd1f86c4c709702aa1ea7b3fa8bb8af3948c98735dd5034d884676467b6f1531322de1048a46cc83181891a620b62bc29169fd340cfc01b8f63b3bf0dae609920a8af2c9c01e4f33b113a4d6a26b7a74448717357013ca1ef84a79166bb47e5523f84144213e2b954aa78f380ff5caf02373359411d4114636579e83f4369d2ad3216dd63de2a1ec249336bf3b5f2599a4882a75c8002904c91d6977e0c381e818fb94c1f269d123f87b2148d20b1e9df47c2afa42273fef43288f2b442c3ccbaadb55592e44f19474ac488030e2a76674bf150e070cbb38eab3fcfb9e353cf2291b355cb034765f899afbea83208055d16cbd055be95f6b0844c72fc4c7ee6c33b4d289ca5c98a09c04afdb7dd08487d396800a8bb1bd6be69a3548e1be7e718abab513228b21ef5268fa25d2fc63db8171c4264336f0ae58097cc294735869f11a5cc12def0f86acd6f2cbd3f0b41fd6d1d27bf6477b38c2260aa2efc1f9de8ba0dddd184ab0c16b496cac39db458d270857060d1b3b071c09a2590b7ce4082954f3da7724d429275852f331c89031c0f78ac0422bb0df3772a3e3ba48b99e86082a52fd761f9b0832425e5e9d9adca3db75f4400b98c2579657b21641fc11521ff2b1e83c2a1eb11e53718f7c524387d9407545988df1b19dd20d4107fb1c0777124c1a86ed58f726a24811f5eaea7065247e98750afcf24be78631de55a9e8f84b96b9d4e2fd222998ec566d4bee2dca5512d6c28b9848c7f0597333b8edce171a991953223dfe1e2ba9e600644c8092d4223b60218cbef9c756116a37c88816df9d438","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5616fc32ad96bc6054a97b08493500e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
