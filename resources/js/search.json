[[{"l":"MFR Driverless Dokumentation","p":["Dies ist die Dokumentation des Driverless-Systems des Mainfranken Racing e.V.","Dieses enthält neben der erklärung sämtlicher verwendeter Komponenten und dessen Zusammenspiel, ebenfalls alle Informationen über die verwendete Hardware und Richtlinien, die bei der Programmierung beachtet werden sollten.","Die Dokumentation befindet sich noch in einem unvollständigen Zustand"]},{"l":"Informationen zur Dokumentation","p":["Die Dokumentation wird mit Hilfe von Retype in Markdown geschrieben. Alle verfügbaren Komponenten sind findbar unter","Retype.com"]},{"l":"Programmierrichtlinien","p":["TODO (Topic-Benennung usw.)"]}],[{"l":"Entwicklerrichtlinien","p":["Wie jeder andere Bereich hat auch Driverless seine Grundlegenden 10 Verhaltensweisen, die jederzeit befolgt werden müssen."]},{"l":"Die 10 Gebote des Driverless Bereichs","p":["Du sollst keine anderen Bereiche neben Driverless haben","Du sollst den Namen der GitHub Organization nicht verunehren","Du sollst den Tag der Bereichssitzung heiligen","Du sollst C++ und Python ehren","Du sollst keine Software töten","Du sollst die Entwicklerrichtlinien nicht brechen","Du sollst nicht jemand anderens Code stehlen","Du sollst nicht mit falschen Namen pushen","Du sollst nicht begehren deines Nächsten Laptop","Du sollst Dokumentation schreiben (ja Björn du auch!)"]},{"l":"Eventpfusch","p":["Auch Eventpfusch muss in der Versionsverwaltung berücksichtigt werden! Verschiedene Stände auf DV-PC, DV-Laptop, GitHub und privater PC/Laptop sollen vermieden werden!!!"]},{"l":"Clean Code","p":["Um anderen Leuten das Einarbeiten in deinen Code zu vereinfachen, sollten folgende Namens-Konventionen und Grundlegende Strukturen verwendet werden."]},{"l":"Benennungen","p":["TO DO: Packages im Snake Case! Klassen im CamelCase!"]},{"l":"Packages"},{"l":"Nodes"},{"l":"Topics","p":["ROS Topics müssen immer nach folgender naming-convention benannt werden:","Produktive Topics, die für das fahren des Autos essentiell sind, sollen so gepublisht werden:","/productive/Package-Name/Sub-Package-Name .../topicname","Topics die nur für das Debuggen relevant sind sollen so gepublisht werden:","/debug/Package-Name/Sub-Package-Name .../topicname","Die Debug Topics sollen während Event deaktiviert werden! (Vielleicht kann man so etwas Performance herausholen)","Informationen, die für FSG benötigt werden, werden in die Topic /diagnostics reingeschoben. Diese Topic kann mit ROS Diagnostics angeschaut werden. Die CAN-Node subscribed auf diese Topic, um alle Infos, die von FSG gewollt sind auf den CAN zu packen."]},{"l":"Klassen"},{"l":"Methoden"},{"l":"Variablen"},{"l":"Config File"},{"l":"Launch File"},{"l":"Repo Aufbau"},{"i":"readmemd","l":"README.md","p":["In die Readme gehören alle wichtigen Sachen, um das Package verwenden zu können.","Wie führe ich das einzelne Package aus?","Wie aktiviere/deaktiviere ich die debug-topics?"]}],[{"l":"Signalanbindung","p":["MF15 - Signalanbindung"]},{"l":"CAN Verbindungen","p":["Aktuell gemessener Lenkwinkel","Aktuelle Mission","Aktuelle Missionsauswahl","Bremsdurck Befehl","CAN Interface TX -> Brake","CAN Interface TX -> DVIB","CAN Interface TX -> Engine","Dashboard -> DVIB","Drehmoment Befehl","DVIB -> CAN Interface RX","DVIB Status","DVPC Status","Emergency ?","Kommunikationspartner","Nachricht","RES -> DVIB","Startsignal","Steering Sensor -> CAN Interface RX"]},{"l":"Anmerkungen","p":["Signale wie das Startsignal (RES GO) oder Emergency werden durch den Stautswechsel des DVIB Status erkannt. Das res go wird dann in dem Fall durch die CAN - Interface Node in einer spezifischen Topic mit dem Bool wert True an alle Nodes übermittelt.","Analog dazu das Mission Finished anhand der Transaktion des DVPC Status zu done.","Der DVPC sendet ebenfalls die ganze Zeit ein heartbeat - Signal um der DVIB zu versichern, das er noch an ist."]},{"l":"Notiz","p":["Es fehlen noch u.a. Bremsdrucksensoren in der Grafik usw."]}],[{"l":"Gaussian Process Regression","p":["Die GPR ist eine nicht parametrisierte Regressionsmethode, die oft im Bereich des maschinellen Lernens angewendet wird. Hierbei besteht die Möglichkeit, die Messungenauigkeit der Daten miteinzubeziehen. Im Gegensatz zu anderen Regressionsmöglichkeiten wird nicht nur eine Funktion angepasst, sondern eine Menge an allen möglichen Funktionen, welche die Daten repräsentieren betrachtet und über Gaußverteilungen mit einer Wahrscheinlichkeit dargestellt. Dies geschieht auf Basis einer Kovarianz-Kernel-Funktion. Diese gibt die Abhängigkeit des Vorhersagewerts an einer bestimmten Stelle von den umliegenden Trainingsdaten an. Eine häufig verwendete Kernel-Funktion ist der Squared Exponential Kernel.","Sie nimmt neben der Varianz der Trainingsdaten auch einen Lengthscale l entgegen, welcher die Kurvierung der resultierenden Regression beeinflusst. Da eine Gauß-Verteilung verwendet wird, kann die resultierende Vorhersagefunktion vollständig durch den Mittelwert und der entsprechenden Varianz beschrieben werden. Daraus folgend ist eine Vorhersage mit folgenden Formeln möglich:","Hierbei stellt K die oben beschriebene Kernel-Funktion da, X^\\star die x-Werte für die eine Vorhersage erstellt werden soll, Vektor X die x-Werte der Trainingsdaten mit den dazugehörigen y-Werten in y und der Varianz der Punkte \\sigma. I beschreibt die Einheitsmatrix.","Der größte Nachteil der GPR ist die mit der Anzahl der Trainingsdaten kubisch steigende Komplexität. Dies ist auf die Bildung der Matrixinversen zurückzuführen und macht das Verfahren nur bei einer kleineren Anzahl an Trainingsdaten nutzbar."]}],[{"l":"Kalman Filter","p":["Der Kalman-Filter ist ein Verfahren zur Ermittlung des Systemzustandes. Hierbei wird die Schätzung anhand von mehreren Messungen iterativ verbessert. Grundlegend sind Messdaten immer mit einem Rauschen behaftet und bieten keine exakten Ergebnisse. Es gilt die Annahme, dass die Messwerte normalverteilt sind.","Grundsätzlich gibt es zwei Möglichkeiten, um den Zustand eines Systems zu ermitteln. Diese umfassen die simple Vorhersage mithilfe eines physikalischen Modells oder die direkte Messung des Systemzustands. Beides bietet jedoch keine exakten Ergebnisse, da auch das physikalische Modell nie alle real agierenden Faktoren miteinbeziehen kann und somit Ungenauigkeiten aufweist.","Der Kalman-Filter macht sich die Kombination beider oben genannten Möglichkeiten zunutze. Dies erlaubt eine weitaus bessere Schätzung und ermöglicht die Berechnung nicht messbarer Parameter.","Ein Kalman-Filter besteht aus zwei Schritten, welche wie folgt definiert sind:","Kalman-Filter erklärung","Es ist zu beobachten, dass die Varianz der Schätzung im Korrekturschritt abnimmt und in der Vorhersage dazugewinnt. Hierbei sind die beiden Schritte, bezogen auf ihre Ausführungsreihenfolge, unabhängig voneinander. Dies ermöglicht ebenfalls die Fusion mehrerer Sensoren mit unterschiedlicher Aktualisierungsrate und die Interpolation von Systemzuständen.","Der Vorhersageschritt wendet auf den Filterzustand x das physikalische Modell an und kann dadurch den neuen Zustand vorhersagen. Die Kovarianzmatrix P wird bei den vorhergesagten Parametern, die durch die Matrix A angegeben werden, um eine initial festgelegte Konstante Q erhöht. Diese stellt das Prozessrauschen dar, welches durch die Abweichung des Modells entsteht.","Der Korrekturschritt ist wie eine Gewichtungsfunktion zu verstehen. Hierbei wird der gewichtete Durchschnitt aus dem Filterzustand und der Messung als neuer Systemzustand gesetzt. Der Anteil am Ergebnis bezieht sich dabei auf die Kovarianzmatrix bzw. einer zuvor bekannten Varianz der Messung. Die Gewichtung wird durch das sogenannte Kalman-Gain K dargestellt. Der Aktualisierung der Kovarianz liegt mathematisch eine simple Multiplikation der Varianzen zugrunde. H stellt eine Matrix dar, die das Messergebnis an die richtige Stelle in der korrekten Einheit auf die Kovarianzmatrix P zuordnet. R beschreibt die Messvarianz. I ist die Einheitsmatrix und z die Messung.","Der ursprüngliche Kalman-Filter ist lediglich für lineare Vorhersagemodelle ausgelegt. Eine Erweiterung ermöglicht ebenfalls die Nutzung nichtlinearer Funktionen. Diese wird als EKF bezeichnet. Dafür wird das nichtlineare Modell an der entsprechenden Stelle linearisiert, was der Steigung der Funktion entspricht. Im mehrdimensionalen Fall kann dies durch eine Jacobimatrix gelöst werden. Hierbei ist eine Anpassung durch Nutzung von Jacobimatrizen der Matrix A und H nötig."]}],[{"l":"KD Tree"}],[{"l":"Low Pass Filter"}],[{"l":"Particle Filter","p":["Partikelfilter im Kontext der Zustandsschätzung bieten eine Alternative zum eben vorgestellten Kalman-Filter. Hierbei wird die Wahrscheinlichkeitsverteilung mithilfe mehrerer Partikel dargestellt. Jedes Partikel kann dabei ebenfalls eine Gewichtung tragen. Durch die Position und die Gewichtung der einzelnen Partikel ergibt sich eine Repräsentation der Wahrscheinlichkeitsverteilung.","Ein Anwendungsfeld ist die Monte Carlo Localization. Diese erlaubt die Lokalisierung eines Roboters in einer exakt bekannten und vermessenen Umgebung.","Ein Beispiel ist ein Roboter, der die Distanzen zu den Wänden um sich herum messen kann und zudem Bewegungsdaten anhand der Raddrehzahl bekommt. Im Vorhersageschritt wird die gemessene Bewegung seit der letzten Iteration auf jedes Partikel unabhängig voneinander angewendet. Hierbei können zwei Partikel in komplett unterschiedliche Richtungen orientiert sein, was in unterschiedlichen Ergebnissen resultiert. Es wird ebenfalls ein Prozessrauschen angewendet, was die Partikel nicht exakt nach der Bewegung verschiebt, sondern kleine Abweichungen hinzufügt. Das Rauschen wird zufällig in der Regel nach einer Normalverteilung erzeugt. Dies soll den Ungenauigkeiten der Sensoren zur Bewegungsmessung entgegenwirken.","Im Korrekturschritt werden für jedes Partikel die Distanzen innerhalb der Referenzkarte ermittelt und mit den tatsächlich gemessenen Werten abgeglichen. Hierbei wird eine Gewichtung für jedes Partikel errechnet, die angibt, wie wahrscheinlich die Position des Partikels mit der tatsächlichen Position des Roboters übereinstimmt.","Die Gewichtung eines Partikels lässt sich als Differenz zwischen der Zielverteilung und einer Vorschlagsverteilung verstehen. Da man Partikel nicht nach jeder Verteilungsfunktion streuen kann, wird eine Vorschlagsverteilung oder auch Proposal-Distribution verwendet. Diese kann zum Beispiel eine Normalverteilung sein. Um den Unterschied zur benötigten Verteilung (Target-Distribution) auszugleichen, wird die Target-Distribution geteilt durch die Proposal-Distribution an der entsprechenden Stelle als Gewichtung gesetzt.","Anschließend wird ein Resampling durchgeführt, das die Gewichtungen in eine Verteilung der Partikel überführt. Hierbei werden Partikel mit geringer Wahrscheinlichkeit durch Partikel mit hoher Wahrscheinlichkeit ersetzt."]}],[{"l":"PIDController"}],[{"i":"ros---basics","l":"ROS - Basics"},{"l":"Subscriber"},{"l":"Publisher"},{"l":"Config"},{"i":"package---path","l":"Package - Path"},{"l":"Sonstiges","p":["Transform ( http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20listener%20%28Python%29)","Service ( http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29)","Anlegen eines Package ( http://wiki.ros.org/ROS/Tutorials/CreatingPackage)","Anlegen einer Node ( http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29)"]}],[{"l":"Spline Interpolation","p":["Die Spline-Interpolation ist eine Möglichkeit, eine Menge an Datenpunkten oder auch Stützstellen, zu einer kontinuierlichen Strecke zu verbinden bzw. zu interpolieren. Grundsätzlich gibt es verschiedene Arten von Splines. Da im Folgenden lediglich der kubische C^2-Spline Anwendung findet, beschränkt sich dieser Abschnitt ebenfalls auf diesen Typus.","Ziel der Spline-Interpolation ist eine Funktion zu finden, die durch die angegebenen Punkte verläuft und bestimmte Eigenschaften erfüllt. In diesem spezifischen Fall ist es die zweimalige Differenzierbarkeit der resultierenden Funktion.","Um dies zu bewerkstelligen, wird zwischen jedem Punktepaar eine Funktion mit einem Polynom dritten Grades gewählt.","Für den Erhalt einer möglichst glatten Strecke, müssen die Steigung und die Krümmung der an dem Punkt angrenzenden Funktionen übereinstimmen. Somit gilt:","Daraus ist ein Gleichungssystem bzw. ein Optimierungsproblem abzuleiten.","Um eine Spline-Interpolation im 2-dimensionalen Raum zu ermöglichen, müssen die Stützpunkte zuvor in einen Funktionsraum transferiert werden. Hierfür werden die X- und Y-Werte jeweils getrennt betrachtet und nach der Streckendistanz, sprich der kumulierten Distanz zwischen den Datenpunkten, aufgeführt."]}],[{"l":"Ubuntu Cheatsheet","p":["Dies ist ein Ubuntu Cheatsheet."]},{"l":"Ordner-Navigation","p":["command","description","mkdir Ordnername--> make directory, einen Ordner im aktuellen verzeichnis anlegen","cd Ordnername--> change directory, in einen Ordner wechseln","ls--> list, listet alle Inhalte eines Ordners","touch Dateiname--> Datei anlegen","rm Dateiname--> Datei löschen, Datei kommt nicht in den Papierkorb!","rmdir Ordnername--> löscht Ordner permanent","man Command--> zeigt Beschreibung zu Befehlen an (viel genauer als --h)","cp datei die kopiert werden soll datei in die kopiert werden soll--> copy in andere datei","mv quelle ziel--> verschiebt Inhalte und kann dabei Dateien umbenennen","find--> listet Ordner Inhalte","--> Ordnerstrukrur in der Konsole anzeigen und durchnavigieren","--> Ordnerstrukrur als tree anzeigen"]},{"l":"Shortcuts","p":["Tipps: Mit der Tabulator Taste kann man Verzeichnisse in der Konsole autovervollständigen, oder sich die verschiedenen Möglichkeiten anzeigen lassen. Mit der Pfeiltaste nach oben kann man letzten Befehl der eingegeben wurde wieder anzeigen."]},{"l":"TODO","p":["chmod und -f usw noch dokumentieren...."]}],[{"l":"Acceleration","p":["Aktion","Aufgabe","Controlling","Erkennung der zu befahrenen Strecke und Berechnung der nächsten zu fahrenden Meter","Errechnung der Steuerbefehle für Lenkung und Throttle auf basis des erkannten Fahrzeugzustands und Fahrlinie","FastSLAM","INFO","Kartierung und Lokalisierung des Fahrzeugs in der erstellten Karte","Komponente","Map Matching","MF15 Model Based - Vehicle Navigation Softwarestack","Mission Control","PathDetection","Schnittstelle zur erstellung der benötigten Nachricht zur Geschwindigkeitsmessung","Steuerung u.a. des Missionsendes und gegebenfalls Eingriff in die Steuerung","Velocity Estimation","Zuordnung der Fahrzeugposition zu einer Position in der Referenzkarte"]},{"l":"Cone Perception System","p":["TODO (Fehlen noch Sensor Nodes)"]},{"l":"Besonderheiten","p":["In Acceleration besteht nicht die Möglichkeit eine Karte vorzuladen, da die exakte Streckenbreite nicht bekannt ist. Deshalb muss die Karte zur laufzeit aufgebaut werden. Da durch den Streckenaufbau und der hohen Geschwindigkeit nahezu kein wiedererkennen von bereits eingetragenen Cones stattfindet entsteht oft eine Verzerrung in der erstellten Karte.","Dies führt ebenfalls dazu das die Partikelwolke sich auseinanderzieht und somit die erkannte Karte hin und her spring. Um dem entgegenzuwirken wird in der PathDetection eine hohe Prediction Noise eingestellt wärend die anderen Parameter sehr klein gewählt sind. Es ist auch darauf zu achten das eine zu hohe Prediction Noise ein instabieles Fahrverhalten erzeugt.","Der PurePursuit Controller ist auf eine Dynamische Pure Pursuit Distanz eingestellt."]}],[{"l":"Skidpad","p":["Aktion","Aufgabe","Controlling","Erkennung der zu befahrenen Strecke und Berechnung der nächsten zu fahrenden Meter","Errechnung der Steuerbefehle für Lenkung und Throttle auf basis des erkannten Fahrzeugzustands und Fahrlinie","FastSLAM","INFO","Kartierung und Lokalisierung des Fahrzeugs in der erstellten Karte","Komponente","Map Matching","MF15 Model Based - Vehicle Navigation Softwarestack","Mission Control","PathDetection","Schnittstelle zur erstellung der benötigten Nachricht zur Geschwindigkeitsmessung","Steuerung u.a. des Missionsendes und gegebenfalls Eingriff in die Steuerung","Velocity Estimation","Zuordnung der Fahrzeugposition zu einer Position in der Referenzkarte"]},{"l":"Cone Perception System","p":["TODO (Fehlen noch Sensor Nodes)"]},{"l":"Besonderheiten","p":["SkidPad hat die besonderheit das eine Karte vorgeladen wird. Dementsprechend werden durch den SLAM keine neuen Cones eingefügt, die Map Validierung wird nicht gemacht und die Partkiel werden an der Startposition gestreut.","Das MapMatching findet ganz normal statt. Ebenfalls wird die PathDetection normal gemacht. Es wird auch der Globale Offset ermittelt. Des weiteren werden lokale verschiebungen in diesem Modul korrigiert, da der SLAM ebenfalls die besthenden Cones leicht korrigieren kann. Hierbei werden in jedem Timestamp alle Buckets resettet und die Varianzparameter sehr klein eingestellt um eine sofortige Anpassung an die Verschiebung zu erreichen.","Das Controlling hat eine feste PurePursuit Distanz da hierdurch leichtere Kurvenfahrten möglich sind. Die Geschwindigkeit wird durch das MapMatching aus ein File geladen, wobei die erste Runde jewails langsamer gefahren wird, als die zweite um eine größere Zeit für das Resampling und die damit zusammenhängende Lokalisierung zu erreichen."]}],[{"i":"trackdrive--autocross","l":"Trackdrive / Autocross","p":["Aktion","Aufgabe","Controlling","Erkennung der zu befahrenen Strecke und Berechnung der nächsten zu fahrenden Meter","Errechnung der Steuerbefehle für Lenkung und Throttle auf basis des erkannten Fahrzeugzustands und Fahrlinie","FastSLAM","INFO","Kartierung und Lokalisierung des Fahrzeugs in der erstellten Karte","Komponente","MF15 Model Free - Vehicle Navigation Softwarestack","Mission Control","PathDetection","Planung der zu Fahrenden maximal möglichen Geschwindigkeit","Schnittstelle zur erstellung der benötigten Nachricht zur Geschwindigkeitsmessung","Steuerung u.a. des Missionsendes und gegebenfalls Eingriff in die Steuerung","Velocity Estimation","Velocity Planning"]},{"l":"Cone Perception System","p":["TODO (Fehlen noch Sensor Nodes)"]}],[{"l":"Camera Perception"}],[{"l":"Driverless Daemon"},{"l":"Kurzbeschreibung","p":["Das Driverless Daemon Modul unterscheidet sich zu allen anderen Modulen indem es primär ein ROS - Service ist. Dieser erlaubt zum einen das Starten der entsprechenden Nodes bei Auswahl der Mission durch einen Service und das beenden aller Nodes im falle eines Emergencys.","Repository: https://github.com/mfr-driverless/driverless_daemon"]},{"l":"Topics"},{"l":"Service Endpunkt","p":["Topic","Nachrichtentyp","Beschreibung","driverless_daemon","N/A","Service zur Auswahl der Mission"]},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/dvib/as_state","N/A","Momentaner interner Zustand in der Driverless Interface Box"]},{"l":"Ausführliche Beschreibung","p":["Grundsätzlich wird beim starten des Driverless PCs das driverless_daemon.launch File gestartet. Dieses startet neben der Service Node ebenfalls alle Nodes zur Perception / Sensorik und CAN Kommunikation zur Entgegennahme von Missionsbefehlen. Eine Ansprechung der Aktorik darf hier nocht nicht passieren.","Bei der Auswahl der Mission wird das entsprechende Launch - File gestartet. Wurde zuvor eine andere Mission ausgewählt werden die entsprechenden zuvor gestarteten Nodes wieder beendet.","Wird über die DVIB State Topic der Emergency State, der beim aktivieren des RES auftritt, übergeben, werden ebenfalls alle Nodes beendet um eine weitere Beeinflussung der Lenkung zu vermeiden."]}],[{"l":"FastSlam"},{"l":"Kurzbeschreibung","p":["Das FastSLAM Modul beschafft sich mit der Ertellung einer Karte auf Basis der zuvor erkannten Cones von Kamera und Lidar und Geschwindigkeitsmessungen des GPS/IMU Sensors. Hierbei wird das SLAM (Simultaneous localization and mapping) Problem gelößt, welches die starke Abhängigkeit der Erstellung einer Karte und der Lokalisierung in dieser beschreibt. In diesem Modul ist es ebenfalls möglich eine zuvor definierte Karte zu laden. Hierbei werden keine neuen Cones hinzugefügt, was das Modul zu einer Monte Carlo Localization abschwächt (mit einigen ausnahmen).","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/FastSlam"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/fusion/camera","N/A","Momentan erkannte Cones durch die Kamera","/fusion/lidar","Momentan erkannte Cones durch den Lidar","/estimation/velocity","Aktuell gemesenne Geschwindigkeitswerte","/novatel/oem7/odom","Odometriedaten des GPS (für absolute Orientierungsmessungen)"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/slam/car_state","N/A","Partikelwolke der möglichen Autopositionen","/slam/map","Aktuell erkannte Karte","/slam/landmark_info","Erkennungshäufigkeit jedes Cones (Debug für Map validierung)","/slam/state","Aktuelle Autopositionsschätzung"]},{"l":"Ausführliche Beschreibung","p":["SLAM ist ein gängiges Problem in der Robotik, welches sich mit der Kartierung und der Lokalisierung innerhalb einer Umgebung befasst. Hierbei werden mehrere Beobachtungen des Umfelds mit Bewegungsdaten kombiniert und dadurch die Umgebung erkundet. Da beide Problemstellungen stark voneinander abhängig sind, werden sie als ein Problem betrachtet und sind unabhängig voneinander nicht lösbar.","Zur Lösung des Problems gibt es viele verschiedene Ansätze, welche sich grundsätzlich in die drei Arten graphenbasiert, Lösung mit einem Kalman-Filter und Lösung mit einem Partikelfilter unterscheiden lassen. Zudem gibt es Mischformen, die nicht pauschal zugeordnet werden können.","Diese Arbeit stellt zur Lösung dieses Problems eine angepasste Version des FastSLAM2.0 vor. Dieser Ansatz kombiniert einen Kalman-Filter mit einem Partikelfilter. FastSLAM repräsentiert die Umgebung mit sogenannten Landmarks. Daher können im Folgenden die zuvor erkannten Cones als Landmark bezeichnet werden.","Jede Landmark besitzt einen eigenen 2x2 EKF und wird definiert durch den Vektor \\mu_n = (x_n, y_n). Die Position des Rennwagens wird als s = (x, y, \\theta) angegeben und enthält sowohl die Position innerhalb der Karte als auch die Orientierung des Fahrzeugs. Als Koordinatenursprung wird die Startposition des Rennwagens verwendet.","Graphisches SLAM-Modell","Die obenstehende Grafik beschreibt die zugrunde liegenden Abhängigkeiten und bietet somit die Basis für die Funktionsweise des FastSLAM. Die gemessene Position eines Cones im Koordinatensystem der Karte o hängt lediglich von der Messung z in diesem Fall von der Cone-Perception und von der aktuellen Position des Fahrzeugs ab. Die Fahrzeugposition s ist abhängig von den vorherigen Zuständen und der dazugehörigen Bewegungsmessung v. Die Pfeile sind dabei als 'beeinflusst' zu lesen. Daher besteht beim ursprünglichen SLAM-Problem eine Abhängigkeit der Positionsmessung o_{t+2} zum Beispiel zu s_{t-1}. Bei einem FastSLAM gilt für jeden Partikel die Annahme, dass die entsprechende Position korrekt ist. Hierdurch reduziert sich die Abhängigkeit von o zur aktuellen Fahrzeugposition und der aktuellen Messung."]},{"l":"Umsetzung des FastSLAM","p":["Zum besseren Verständnis wird zuerst lediglich der FastSLAM-Algorithmus beschrieben, welcher anschließend zu FastSLAM2.0 erweitert wird. Der FastSLAM besteht aus zwei Schritten und einem Resampling, die bei jeder neuen Beobachtung durchlaufen werden. Da nicht alle Aktionen auf denselben Sensordaten basieren, besteht keine Abhängigkeit zwischen bestimmten Schritten, was die Anpassung an die Veröffentlichungsrate des entsprechenden Sensors ermöglicht."]},{"l":"Partikelaktualisierung","p":["Wie bereits beschrieben, besteht der FastSLAM ebenfalls aus einem Partikelfilter. Die Aktualisierung der Partikel erfolgt daher analog zur Monte Carlo Localization. Bei der Positionsaktualisierung ist jedes Partikel getrennt voneinander zu betrachten und nutzt als Basis die intern gespeicherte letzte Position s_{t-1} und die Geschwindigkeit v. Die Verschiebung der Partikel ist somit abhängig von den zuvor ermittelten Geschwindigkeitswerten.","Um diese in die nächste Position zu transferieren, wird ein simples Bewegungsmodell verwendet, welches mit","definiert ist."]},{"l":"Landmarkaktualisierung","p":["Jedes Partikel hat seine eigene Menge an Landmarks. Eine Aktualisierung mit der momentanen Beobachtung wird somit für jedes Partikel ausgeführt. Eine Landmark besteht aus einem 2x2-EKF. Die relative Position eines Cones wird aufgrund der Verhaltensweise der Varianz zu Polarkoordinaten transferiert und hat somit, wie in folgender Abbildung dargestellt, einen Distanzanteil d und einen Winkel \\Phi.","Die Formeln beschreiben das Aktualisieren der Position einer Landmark. \\mu beschreibt die Position der Landmark und besteht daher aus einem zweiteiligen Vektor. m ist der Index des aktuellen Partikels, n der partikelinterne Index der Landmark und t beschreibt die zeitliche Reihenfolge.","Als Vorhersage wird die Distanz bzw. der Winkel zwischen der entsprechenden Landmark und der Position und Orientierung des Partikels verwendet, was in \\hat{z}_t gespeichert und mit der gemessenen Position z_t verglichen wird.","\\hat{z}_t berechnet sich mit der Funktion g","wobei das Resultat einer Vorhersage der erwarteten Messung entspricht. s_{t, \\theta} ist die Orientierung des Partikels. Es ist zu beachten, dass der Winkel normalisiert werden muss, um eine Eindeutigkeit zu erreichen. G_{\\mu_{n_t}} ist die dazugehörige Jacobi Matrix und ist definiert mit:","s_{t,x} bzw. s_{t,y} beschreibt den X- und Y-Anteil der Position des Fahrzeugs. Analog dazu die Position der Landmark."]},{"l":"Koordinatenaufbau"},{"l":"Zuordnungsproblem","p":["Hierbei besteht das Zuordnungsproblem oder in Englisch auch Data Association Problem. Dieses entsteht, da eine Zuordnung der aktuellen Beobachtung mit den bereits eingetragenen Landmarks nicht ohne Weiteres möglich ist. Zudem besteht die Frage, ob die Landmark bereits erkannt wurde. Da sowohl die Position der Landmark innerhalb der Beobachtung als auch die Fahrzeugposition variiert, ist eine perfekte Zuordnung nicht möglich.","Um trotzdem ein möglichst gutes Ergebnis zu erzielen, wird die beobachtete Cone-Position mit jedem \\ac jeder Landmark abgeglichen und diejenige mit der höchsten Wahrscheinlichkeit gewählt. Unterschreitet die höchste Wahrscheinlichkeit einen gewissen Schwellwert, wird eine neue Landmark erstellt.","Eine Berechnung dieser Wahrscheinlichkeit kann durch eine mehrdimensionale Normalverteilung erfolgen. Diese ist im zweidimensionalen regulären Fall definiert mit:","Die multiplizierte Wahrscheinlichkeit aller zugeordneten Landmarks eines Partikels kann als Gewichtung des Partikels verwendet werden."]},{"i":"erweiterung-auf-fastslam20","l":"Erweiterung auf FastSLAM2.0","p":["Der Unterschied zwischen FastSLAM1.0 und FastSLAM2.0 besteht darin, dass auch bei der Positionsschätzung des Fahrzeugs die Beobachtungswerte verwendet werden. Dies ermöglicht die gegenseitige Korrektur der Messungen und führt somit zu einem besseren Ergebnis. Die Aktualisierung erfolgt in diesem Schritt ebenfalls mit Hilfe eines EKF.","C_t beschreibt das Steuerungsrauschen, sprich die Genauigkeit des Bewegungsmodells. R_t ist, wie im Landmarkupdate, die Varianzmatrix der Beobachtungsmessung. G_{\\mu,n} ist ebenfalls identisch. G_{s,n} beschreibt die leicht veränderte Jacobimatrix und ist definiert als:","Dies wird für jede beobachtete Landmark, die zugeordnet werden konnte, durchgeführt, bevor die Landmark-Positionen aktualisiert werden. Ebenfalls wird eine Zufallsvariable addiert, um die Partikel zu streuen und somit das Abdecken unwahrscheinlicherer Fälle zu ermöglichen. Dies wirkt sich positiv auf das Zuordnungsproblem aus, da mehrere Partikel zu unterschiedlichen Zuordnungen finden können. Die Streuung erfolgt durch eine Normalverteilung, deren Varianz der Wert der Diagonale der Matrix P_{s_t,n} an der betreffenden Stelle entspricht."]},{"l":"Resampling","p":["Das Resampling beschreibt den Prozess, dass Partikel mit hoher Wahrscheinlichkeit dupliziert und dafür weniger wahrscheinliche Partikel entfernt werden. Eine Möglichkeit zur Implementierung ist das Stochastic universal sampling. Dies ermöglicht, nach vorheriger Normalisierung, N-Partikel nach Gewichtung mit einer Laufzeit von O(n) zu streuen. Die Berechnung der Partikel-Wahrscheinlichkeit erfolgt über mehrere Multinomialverteilungen. Die resultierende Wahrscheinlichkeit setzt sich dabei aus den kombinierten Probabilitäten der Landmarkzugehörigkeit und der Varianz der Positionsschätzung zusammen. Als Proposal-Distribution wird eine Normalverteilung um die aktuelle Position verwendet.","v ist in diesem Fall die Schätzung der Geschwindigkeit, z die Beobachtung und n die Landmarkassoziierung. Die Berechnung der Werte für p_n^{[m]} muss vor Anpassung der Position erfolgen.","Abschließend kann das Partikel mit der höchsten Wahrscheinlichkeit sowohl für die Karte als auch für die Position verwendet werden."]},{"i":"map-korrektur-validierung","l":"Map korrektur (Validierung)","p":["Um eine Möglichkeit zu schaffen falsch erkannte Objekte die trotzdem in die Karte eingefügt wurden wieder zu entfernen wurde eine zweite Instanz der Conevalidierung in den SLAM integriert. Hierbei wird sich zu nutze gemacht, das tatsächliche Cones deutlich öfter erkannt werden als Objekte die keine Cones darstellen.","Um dies zu erreichen wird der die Erkennungshäufigkeit jedes Cones der Karte mitgezählt. Anschließend wird die durchschnittliche Erkennungshäufigkeit der Cones in einem Bestimmten Umkreis berechnet (z.b. 5m). Objekte die deutlich weniger erkannt wurden als Landmarks im Umkreis werden gefiltert. Hierfür wird Berechnet wie viel Prozent der erwartbaren Erkennungne die Landmark tatsächlich besitzt. Fällt diese unter einen Threshold von z.b. 40% wird die Landmark nicht über die Topic an das nächste Modul weitergegeben. Eine Entfernung der Landmark aus der Karte erfolgt nicht."]},{"i":"performanceverbeserung-durch-logn-fastslam20","l":"Performanceverbeserung durch LogN-FastSLAM2.0","p":["Der Uhrsprüngliche FastSLAM2.0 hat eine Laufzeitkomplexität von O(N) was ihn deutlich schneller als z.B. einen EKF-SLAM macht. Um eine Echtzeitfähigkeit auf dem verwendeten System zu schaffen ist dies jedoch nicht ausreichend. Hierfür wurde zum ein KD-Tree zur spreicherung der Landmarks verwendet, was den Suchbereich einschränkt als auch Verlinkungen zwischen den Bäumen der Partikel verwendet um das Kopieren der Landmarks auf ein Minimum zu beschränken und somit unter anderem das Resampling zu verschnellern. Des weiteren wurde der Update-Prozess auf mehrere Threads aufgeteilt und das Resampling wird lediglich nach einer neuen Lidar-Observation oder jeder 10. Kameraobservation durchgeführt.","SLAM KD-Tree","In der oben aufgeführten Grafik sieht man wie in eine Kopie des Partikels eine neue Landmark (6) eingefügt wurde. Hierbei wird jede Node des Baums ebenfalls neu angelegt um eine Beeinflussung der Partikel zu vermeiden. In der Implementierung wurde dies umgesetzt in dem jede Node eine eindeutige ID hat und in einer HashMap abgespeichert wurde um die Speicherallocierung bewusst zu steuern. Zudem hat jede Node Informationen zu welchem Partikel sie gehört und welche Landmark sie repräsentiert. Um Speicher wieder freizugeben wird eine Garbage Collection durgeführt die angefangen von den Root-Nodes alle Nodes durchgeht und dadurch auf ihre Erreichbarkeit überprüft. Alle nicht erreichbaren Nodes werden anschließend aus der HashMap entfernt.","Durch die Aufteilung muss beim Resampling lediglich die ID der Root-Node mitkopiert werden und nicht die kompletten Landmarks. Als nachteil ergibt sich das die Partikel nicht mehr unabhängig voneinander sind und somit eine Parallele Aktuallisierung nicht möglich ist. Um dies dennoch zu schaffen hat jeder Thread eine lokale HashMap in die alle neuen Nodes zuerst eingefügt werden. Beim weiteren durchgehen des Baumes wird in dieser Liste bevorzugt gesucht. Nach Abschluss des Updatens und wieder zusammenführen der Threads werden ebenfalls die lokalen HashMaps in die globale HashMap zusammengeführt.","Der KD-Tree ermöglich ebenfalls die Landmark assoziierung auf eine logrithmische Laufzeit zu reduzieren. Zuvor musste die Wahrscheinlichkeit für alle Landmarks der Karte berechnet werden. Durch den KD-Tree ist es möglich den Suchbereich einzuschränken und die Cones in diesem Bereich in einer logarithmischen Zeit zu finden."]}],[{"i":"high---level-controlling","l":"High - Level Controlling"},{"l":"Kurzbeschreibung","p":["Das High-Level Controlling beschäftigt sich damit komplexe Informationen, wie die Fahrlinie, die Fahrzeugposition und die Zielgeschwindigkeit in konkrete Steuerbefehle wie Lenkwinkel, Bremskraft oder Beschleunigung zu übersetzten. Hierfür wird ein PID-Controller für die Geschwindigkeitsregelung und ein Pure-Pursuit-Controller für den Lenkwinkel verwendet.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/controlling"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/detection/center","N/A","Abzufahrende Fahrlinie","/estimation/velocity","Aktuelle Geschwindigkeitswerte","/slam/state","Momentane durch den SLAM geschätzte Fahrzeugposition","/res/go","Startsignal","/map_matching/target_speed","Zielgeschwindigkeit"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/mpc/control_command","N/A","Resultierender Steuerbefehl","/controlling/current_speed","Momentane Geschwindigkeit (Debug)"]},{"l":"Ausführliche Beschreibung"},{"l":"Geschwindigkeitsreglung","p":["Die Geschwindigkeitsregelung bekommt vom MapMatching bzw. vom VelocityPlanning eine gewisse Zielgeschwindigkeit und durch die Geschwindigkeitsmessungen die aktuelle Geschwindigkeit. Ziel ist die Reglung um möglichst den Zielwert zu erreichen. Als ausgabe wird ein Wert zwischen -1 und 1 erreicht. Hierbei werden negative Werte durch das CAN Modul an die Bremse weitergeleitet und Positive an den Motor. Dieses Kümmert sich ebenfalls darum, das wärend des Bremsvorgangs kein Beschleunigungsbefehl an den Motor gesendet wird und ebenfalls die Bremse nicht aktiv ist, wenn Beschleunigt werden soll.","Im grunde wird die Funktionalität durch einen PID - Regler sichergestellt, wobei die Zielgeschwindigkeit die Sollgröße, die Geschwindigkeitsmessung die Istgröße und der Steuerbefehl zwischen -1 und 1 die Regelgröße darstellt.","PID - Regler","Der Differentialanteil wird nicht verwendet. Bei P und I Anteil wird unterschieden ob der Zielwert kleiner als der Istwert ist oder nicht um unterschiedliche Einstellungen für Bremse und Motor zu ermöglichen. Grundsätlich reagiert die Bremse deutlich sensibler. Ist der Zielwert kleiner als der Istwert, werden die Einstellungen für die Bremse übernommen, ist dies nicht der Fall die des Motors."]},{"l":"Lenkwinkelsteuerung","p":["Die Lenkwinkelsteuerung wird mit einem Pure Pursuit Controller gemacht. Hierbei handelt es sich um einen Geometrischen Controller. Das heißt, das der Lenkwinkel lediglich auf Basis der aktuellen Situation berechnet wird mit Hilfe von Geometrie. Dies bringt die Annahme mit sich, das die geometrischen Zusammenhänge korrekt sind.","Der Lenkwinkel \\delta errechnet sich somit durch:","Pure Pursuit Controller Aufbau","Hierbei ist L die Länge des Fahrzeugs, l_d die Distanz zum Pure Purusit Punkt und \\alpha der Winkel zwischen Fahrzeugorientierung und Zielpunkt. Grundsätlich funktioniert der Controller indem er den Lenkwinkel berechnet um einen Punkt an der Strecke anzufahren. Dieser wird auf basis der Pure Pursuit Distanz gewählt. Sprich z.B. ein Punkt 10m vor dem Fahrzeug. Um eine bessere Verhaltensweise bei hohen Geschwindigkeiten zu erreichen wird diese Distnaz auf Grundlage der aktuellen Geschwindigkeit gewählt. Im falle der Implementierung sind dies das 0.8 Fache der Geschwindigkeit in Metern. Es ist ebenfalls möglich eine statische Pure Pursuit Distanz zu wählen, was bei SkidPad eine bessere Verhaltensweise verspricht."]}],[{"l":"Lidar Perception"}],[{"l":"Map Matching"},{"l":"Kurzbeschreibung","p":["Das Map Matching Modul übernimmt die Verantwortlichkeit der zuordnung der momentan geschätzten Position zu einer Position in einer Referenzstrecke in den Missionen SkidPad und Acceleration. Die Referenzstrecke ist die hierbei hinterlegte Fahrlinie, die sowohl hinweise zur zu befahrenden Strecke gibt als auch weitere Informationen über das Fahrverhalten wie die Geschwindigkeit angibt.","Dieses Modul macht dies durch Ausgabe einer Zielgeschwindigkeit und einem Boolean zur angabe ob die Halteregion bereits erreicht wurde und die Stopsequenz gestartet werden soll.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/map_matching"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/slam/state","N/A","Aktuelle durch den SLAM ermittelte Position des Fahrzeugs","/estimation/velocity","Momentane Geschwindigkeitsschätzung","/detection/global_offset","Globaler Versatz zwischen realer Karte und referenzkarte (wichtig für Acceleration)"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/map_matching/stopregion_reached","N/A","Boolscher Wert zur Angabe ob der Haltebereich bereits erreicht wurde","/map_matching/current_state","Momentane Position in Referenzstrecke (Angegeben als Distanz von Startpunkt)","/map_matching/target_speed","Aktuelle Zielgeschwindigkeit","/map_matching/reference_track","Alle Momentanen Partikelpositionen (Debug)","/map_matching/reference_connection","Assozierung zwischen aktueller Autoposition und geschätztem Referenzpunkt (Debug)"]},{"l":"Ausführliche Beschreibung"},{"l":"Aufbau der Referenzstrecke","p":["Grundsätlich besteht die hinterlegte Referenz aus einer Fahrstreckenreferenz, einer Geschwindigkeitsreferenz und einem Wert der den Anfang der Stopregion definiert.","Die Fahrstreckenreferenz ist eine Liste an Punkten die in einem File gespeichert wird. Die Punkte definieren die exakte abzufahrende Strecke. Dies heißt nachdem in SkidPad jede Seite zweimal befahren werden muss, sind auch die Punkte zweimal an dieser Stelle. Wichtig ist zudem, das die Reihenfolge der Punkte im File entsprechend der Fahrspur ist. Die angegebenen Punkte werden anschließend mit einem Spline interpoliert, wobei die X- und Y - Werte getrennt betrachtet werden und um eine Eindeutigkeit zu schaffen auf basis der Distanz betrachtet. Diese Distanz entspricht der Länge des Splines und ist somit identisch mit der gefahrenen Strecke bis zu diesem Punkt. Zur berechnung der Distanz wird jewais der Abstand der Punkte bis an die entsprechende Strecke kumuliert. Aufgrund der entsprechenden Form können anschließend alle Angaben auf basis der gefahrenen Strecke gemacht werden.","Die Geschwindigkeitsreferenz ist dementsprechend eine Liste an Distanzen und der entsprechenden Zielgeschwindigkeit in Meter pro Sekunde. Die Distanzen der Liste sind hierbei ebenfalls als Kumuliert zu betrachten, was bedeutet, das immer die Enddistanz der Sektion angegeben wird. Effektiv bedeutet dies in einer Geschwindigkeitsreferenz von:","das Sektion1 bis 11m geht und das in dieser 1m/s schnell gefahren werden soll. Analog hierzu Sektion2, welche den Bereich von 11m bis 20m beschreibt.","Abschließend wird der Anfang der Stoparea ebenfalls durch eine Distanzangabe festgelegt. Diese wird in der Config angegeben und die aktuelle Position in der Referenz wird kontinuierlich mit diesem Wert verglichen und der Boolen entsprechend gesetzt.","Um ein immer größer werdender Abstand zwischen tatsächlicher Karte und Referenzstrecke zu vermeiden, wird der durch die PathDetection ermittelte versatz eingerechnet. Dies geschieht indem die Position vom SLAM ensprechend des Versatzes zurück geschoben wird."]},{"l":"Partikelfilteraubau für MapMatching","p":["Im eine möglichst zuverlässige zuordnung zu erreichen wurde ein Partikelfilter genutzt. Hierbei beschreibt jedes Partikel eine mögliche Position auf der Referenzstrecke und hat lediglich den Zustand p_d der die Distanz auf dem Spline bzw. auf der Referenz beschreibt."]},{"l":"Update-Modell","p":["Das updaten eines Partikels kann somit durch","erfolgen. Hierbei beschreibt p_d den State bzw. die Distanzsschätzung des Partikels, v die aktuelle Geschwindigkeit, was der resultierenden Geschwindigkeit in x und y entspricht und \\Delta t die vergangene Zeit. Die zugrundeliegende Annahme beschreibt, dass das Auto ungefär der Referenzstrecke folgt und somit durch die Geschwindigkeit und der daraus resultierenden gefahrenen Strecke, die neue Position auf der Referenz ermittelt werden kann."]},{"l":"Observation-Modell","p":["Da diese Annahme nicht immer zutrifft und Sensorungenauigkeiten herschen folgt ein Korrekturschritt des Partikelfilters, welcher diesen Robuster gegenüber Störungen macht. Dieser erfolgt auf basis des Abstands von der Position des Partikels auf der Referenzsstrecke und der vom SLAM ermittelten Position. Mathematisch kann dies durch","beschrieben werden, wobei r_x und r_y die Position des Partikels beschreibt und p_x und p_y die geschätzte Position des SLAMs. Das Resultat p_w ist anschließend als Partikelgewichtung zu sehen und nach der Normalisierung ebenfalls als Wahrscheinlichkeit zu betrachten. \\lambda ist eine weitere Einstellungsmöglichkeit, die angiebt wie groß der einfluss durch die Positionsmessung auf das MapMatching sein soll."]}],[{"l":"Mission Control"},{"l":"Kurzbeschreibung","p":["Das Mission Control Modul übernimmt die Steuerung der Mission. Dies umfasst unter anderem das Blockieren der Steuersignale im Wartezustand, die Bremslogik beim erreichen des Haltebereichs und die Überwachung des Missionszustands.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/mission_control"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/mpc/control_command","N/A","Berechneter Steuerbefehl des Controlling Moduls","/map_matching/stopregion_reached","Boolscher Wert des MapMatching zur Angabe ob der Haltebereich erreicht wurde","/estimation/velocity","Momentane Geschwindigkeitswerte","/res/go","Startsignal","/slam/state","Durch den SLAM geschätzte Fahrzeugposition (zur Rundenzählung)"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/control/acceleration","N/A","Resultierender Steuerbefehl","/mission_control/mission_state","Status der aktuellen Mission","/control/acceleration_old","Resultierender Steuerbefehl [ungeglättet] (Debug)"]},{"l":"Ausführliche Beschreibung"},{"i":"missionsablauf-eingriff-in-die-steuerung","l":"Missionsablauf (Eingriff in die Steuerung)","p":["Wärend einer Mission werden die Steuerbefehle nahezu unverändert weitergeben (bis auf die Glättung). Wurde jedoch entweder das res go signal noch nicht gegeben, oder der Haltebereich bereits erreicht, wird entweder der Steuerbefehl geblockt und gar kein Befehl weitergegeben im Fall das die Mission noch nicht gestartet wurde oder am Missionsende eine Bremssequenz durchgeführt. Diese besteht daraus, das in einen Deceleration Zustand geschaltet wird, in dem der Throttle befehl mit einem konstanten Wert wie z.B. -1.0 überschrieben wird. Der Lenkwinkel wird nicht beeinflusst.","Wärend diesem Zustand wird durchgehend die Geschwindigkeit auf den Stillstand des Fahrzeugs überprüft. Hierfür wird die gemessene Geschwindigkeit mit einem Threshold Wert abgeglichen. Ist dies der Fall wird in den nächsten Zustand geschalten in dem das Missionsende angezeigt wird. In diesem Fall wird weiterhin der Throttle Befehl überschrieben. Zusätlich wird der Lenkwinkel überschrieben und auf 0.0 gesetzt um weitere Bewegungen des Lenkwinkelmotors zu vermeiden.","Somit ergibt sich folgender Missionsablauf:"]},{"l":"Glätten des Lenkwinkels","p":["Da der Lenkwinkelcontroller sensibel auf alle erkannten Änderungen in Position und Fahrlinie reagiert, müssen hochfrequente Steuerbefehle herausgefiltert werden um eine flüssige und zuverlässige Lenkung zu ermöglichen (Damit der Lenkwinkelmotor nicht alle kleinen Korrekturen mitmachen muss). Hierfür wurde ein Low-Pass-Filter genutzt, welcher die hochfrequenten Steuerbefehle herausfiltert. Dies hat nur minimale Auswirkungen auf die genauigkeit, vermeidet jedoch ruckartige Bewegungen in der Lenkung.","Low Pass Filter"]},{"i":"zählen-der-runden-trackdrive--autocross","l":"Zählen der Runden (Trackdrive / Autocross)","p":["Als letzte Funktionalität des Moduls ist das Zählen der Runden zu nennen, das durch die Config aktiviert werden kann. Die Rundenzahl wird anschließend mit einer in der Config angegebenen Rundenzahl abgeglichen und bei überschreitung wird, analog zur topic die angibt ob die Stopregion erreicht wurde, die Mission beendet.","Um die Runden zu zählen wird sich zu nutze gemacht, das der Startpunkt immer an der Position (0, 0) in der Karte ist. Hierfür wird konstant die Distanz von der aktuellen Fahrzeugposition zum Nullpunkt berechnet. Ist diese unter einem gewissen Schwellwert befindet sich das Auto in der Startregion. Es zählt als eine Runde, wenn das Fahrzeug den Startbereich betritt und anschließend wieder verlässt um zu vermeiden, das eine Runde doppelt gezählt wird. Erst beim verlassen des Bereichs wird die Rundenzahl verglichen und bei bedarf die Mission beendet um definitiv erst über der Zielline zum stehen zu kommen.","Als zusätliche Sicherheit das nicht durch eine Korrektur im SLAM der Fahrzeugposition das Auto zurück in den Startbereich zurückgesetzt wird Beträgt die Distanz zum eintreten in den Startbereich 6.0m wärend der Bereich zum verlassen 8.0m beträgt."]}],[{"l":"Model-Based Path Detection"},{"l":"Kurzbeschreibung","p":["Das Model - Based Path Detection Modul beschäftigt sich mit der Erkennung der Fahrlinie in einer bekannten Strecke. Dies bedeutet in den Missionen Skidpad und Acceleration. Grundsätlich wird durch Hilfe der durch das MapMatching erkannten Referenzposition die Fahrlinie berechnet und Verzerrungen gegenüber der Referenzkarte ausgeglichen. Zudem wird die Konstante verschiebung die durch nicht exakte Plazierung des Autos am Start entsteht ausgeglichen.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/mb_path_detection"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/slam/map","N/A","Aktuelle durch den SLAM erstellte Karte","/slam/state","Momentan durch den SLAM geschätzte Fahrzeugposition","/map_matching/current_state","Momentane Position innerhalb der Referenzkarte"]},{"l":"Output Topics","p":["/detection/center","/detection/center_cluster","/detection/global_offset","/detection/gpr/adjusted_track","/detection/gpr/points_x","/detection/gpr/points_y","/detection/matched_cones","/detection/reference_track","Beschreibung","Erkannte Mittelpunkte (Debug)","Globale erkannte Verschiebung in Rotation und X und Y - Richtung","Kompletter auf die Verschiebung angepasster Track (Debug)","N/A","Nachrichtentyp","Referkenzkarte entsprechend der Globalen Offset erkennung verschoben (Debug)","Resultierende Fahrlinie","Resultierende Fahrlinie als Marker (Debug)","Topic","X-Werte der Gaussian Process Offset Regression (Debug)","Y-Werte der Gaussian Process Offset Regression (Debug)"]},{"l":"Ausführliche Beschreibung"},{"l":"Globale offset Schätzung","p":["Da sich die SLAM Karte nach der Startposition des Fahrzeugs richtet und die Referenzkarte von einer perfekten Platzierung ausgeht muss der initiale Unterschied ermittelt werden. Dies wird am Anfang gemacht wärend das Fahrzeug noch im Stillstand ist. Hierfür wird eine Mischung aus einem Iterative - Closesd - Point Algorithmus und der direkten geometrischen Berechnung verwendet. Hierbei besteht das Ziel die Referenzkarte so zu verschieben, das sie möglichst der SLAM Karte entspricht. Diese Vorgehensweise besteht aus den folgenden 3 Schritten, welche bestehen da ein lokales Optimum gesucht wird und nicht das globale, das wäre dass die Karten Schräg übernanderliegen:","Ermittlung des Offsets in X und Y - Richtung:","Dieser Schritt geschieht mit den zuvor erwähnten ICP - Algorithmus. Dieser sucht in jeder Iteration den nähsten Cone in der Referenzkarte Karte zu jeden Cone in der SLAM Karte und versucht den Abstand zwischen diesem mit Hilfe eines Gradien Descent Verfahrens zu minimieren. Daraus entsteht folgender mathematischer Zusammenhang:","Hierbei entspricht s dem Cone i in der SLAM Karte und p dem dazugehörigen nähsten Punkt in der Referenz. Es ist zu beachten das die Punkte in der Referenz die verglichen werden bereits nach dem aktuellen Offset - Parametern verschoben wurden. x entspricht somit ebenfalls den Gradienten im update-Schritt. Die Rotations bleibt hierbei unverändert und lediglich eine Verschiebung nach X und Y wird vorgenommen.","Ermittlung des Rotationsoffsets:","In diesem Schritt wird der zuvor ermittelte Offset festgesetzt und lediglich die Rotation angepasst. Hierfür werden zunähst Mittelpunkte gesucht indem zu jedem roten ein anderer roter Cone bzw Blaue und Gelbe verbunden werden und der Mittelpunkt berechnet werden. Es werden lediglich Punkte betrachtet die einen Abstand unter einem Meter zur 0 - Achse haben um falsche Mittelpunkte zu vermeiden (Bei der Positionierung der 0 - Achse wird der zuvor ermittelte Positionsoffset mit einbezogen). Anschließend wird eine lineare Regression durch die Mittelpunkte vorgenommen und durch die Steigung der Winkel zwischen 0 - Achse und Regressionsgerade berechnet. Dieser Vorgang wird über mehrere Timestamps wiederholt und das durchschnittliche Ergebniss gebildet:","Dies erlaubt eine Iterative ermittlung des Rotationsoffsets r, wo in jeder Iteration t angepasst wird. c_t gibt an der wie vielte update Zyklus gerade ist und s_y gibt die Steigung der Linearen Regression der Y - Werte und analog dazu s_x der X - Werte an (Die Regression ist wieder getrennt und auf basis der Distanz zum Nullpunkt in den Funktionsraum transferiert).","Erneute Ermittlung des Offsets in X und Y - Richtung:","Im Grunde entspricht dieser Schritt dem 1. Schritt. Der einzige Unterschied besteht darin, das diesmal der ermittelte Rotationsoffset und nicht 0 festgesetzt ist, was zu einer genaueren Ermittlung des Positionsoffsets führt. Vor diesem Schritt wird ebenfalls der in Schritt 1. ermittelte Offset wieder resettet. Dieser wurde lediglich Berechnet damit man einen Rotationsoffset berechnen kann, da eine Verschiebung z.B. nach links oder Rechts den Winkel deutlich beeinträchtigen würde, da sonst die Annahme das die Mittelpunkte nah an der 0 - Achse liegen eventluell nicht zutrifft und somit alle Mittelpunkte herausgefilter werden."]},{"l":"Lokale offset Korrektur","p":["Neben der globalen Verschiebung die durch ungenaue Positionierung entstehen können ebenfalls kleine lokale Unterschiede in der SLAM Karte auftreten. Dies ist vorallem bei Acceleration der fall in dem keine zuvor gelade Karte vorhanden ist und somit aufgrund der Geschwindigkeit keine Gerade entsteht sondern eine leichte Krümmung. Auch in SkidPad in dem eine Karte geladen wurde entsteht durch Korrekturen der Cones in der Karte eine leichte lokale Verschiebung. Da sich die Fahrzeugspositionsschätzung anhand der SLAM Karte errechnet hat eine Anpassung der Referenzkarte auf die tatsächliche SLAM Karte große positive effekte und erlaubt eine deutlich genauere Fahrweise.","Die Vorgehensweise ist dabei sehr ähnlich zu der des Model - Free PathDetection Moduls. Der erste Schritt ist ebenfalls das die Mittelpunkte ermittelt werden indem Cones verbunden werden die auf Basis der Distanz zueinander und der Farben die Mittelpunkte darstellen könnten. Anschließend wird der nähste Punkt an der Referenzstrecke gesucht und der Versatz ermittelt. Dies wird ebenfalls mit einer Golden Section Search gemacht in dem zuvor der Suchbereich durch direkten Vergleich von Referenzpunkten eingegrenz wurde. Hierbei wird bei Skidpad in den übernanderliegenden Streckenabschnitten der Offset für beide Runden eingetragen.","Dies wird gemacht indem alle übernanderliegenden Distanzen ermittelt werden. Zuerst wird die Sektion der akutell ermittelte nähsten Distanz ermittelt. Danach wird der unterschied der Distanz zum Startpunkt der ermittelten Sektion ermittelt. Anschließend wird für jede Sektion die übernanderliegt der Distanzpunkt berechnet durch addieren des Startpunkts der Sektion mit dem Unterschied.","Hierdurch ergeben sich Funktionswerte indem der Offset in X und Y getrennt in Abhängigkeit der Fahrdistanz betrachtet wird. Aus Performancegründen wird jeder Meter Fahrdistanz in einem Bucket zusammengefasst welcher beim Updaten folgende Verhaltensweisen aufzeigt:","Hierbei hat jeder Bucket einen Mittelwert \\mu und eine Varianz \\sigma. Jeder Punkt der zum Bucket hinzugefügt werden soll hat ebenfalls einen Wert x und eine Varianz x_\\sigma. Des weiteren wird vor jedem Update eine Prediction Noise R aufaddiert. Diese ermöglicht die Regulierung wie schnell sich die Schätzung an Änderungen in der SLAM Karte anpassen soll. Diese ist in Acceleration so gewählt, das Sprünge in der Karte durch auswahl eines anderen Partikels schnell angepasst werden jedoch nicht so schnell, das gefährliche Fahrsituationen entstehen können. Es ist ebenfalls durch eine Einstellung in der Config möglich, das bei jeder neu eintreffenen Kartenanpassung die Buckets resettet werden um noch schneller auf Sprünge zu reagieren und die Timestamps unabhängig voneinander zu betrachten.","Abschließend wird eine Gaussian Process Regression durchgeführt um die Offset-Schätzung zu glätten. Diese wird über alle Bucketwerte durchgeführt und erlaubt somit zusätlich eine Interpolation des Offsets nach der Diskretisierung durch die Buckets (Als Referenzpunkt für den Offset eines Buckets wird die mitte des Bereichs verwendet)."]},{"l":"Informationen zur Resultierenden Fahrlinie","p":["Auch in der Modellbassierten PathDetection werden lediglich die nächsten zu befahrenden Meter übergeben und nicht die gesammte Strecke. Hierfür wird auf basis der durch das Map Matching ermittelten Referenzposition der kommende Fahrtverlauf ermittelt (dieser liegt als Spline vor welcher zuvor aus einer Datei geladen wurde) und zuerst nach der Globalen Verschiebung korrigiert. Anschließend wird die Strecke Meterweise in Punkte Diskretisiert und für jeden Punkt mit Hilfe der GPR ebenfalls der lokale Offset aufgerechnet."]}],[{"l":"Model-Free Path Detection"},{"l":"Kurzbeschreibung","p":["Das Model - Free Path Detection Modul beschäftigt sich mit der Erkennung der Fahrlinie in einer unbekannten Strecke. Dies bedeutet in den Missionen Trackdrive und Autocross. Hierfür wird eine zweidimensionale Regression durch die Mittelpunkte berechnet und somit die Mittellinie, die ebenfalls als Fahrlinie dient, ermittelt.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/mf_path_detection"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/slam/map","N/A","Aktuelle durch den SLAM erstellte Karte","/slam/state","Momentan durch den SLAM geschätzte Fahrzeugposition"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/detection/center","N/A","Tatsächlich übergebenen geglätteten Fahrlinie","/detection/midpoints","Die errechneten Mittelpunkte der Strecke (Debug)","/detection/detection","Komplette erkannte Mittellinie (Debug)","/detection/car_position","Marker topic der tatsächlich übergebenen geglätteten Fahrlinie (Debug)"]},{"l":"Ausführliche Beschreibung"},{"l":"Berechnung der Mittellpunkte","p":["Da die Modellfreie PathDetection letztendlich eine Regression der Streckenmittelpunkte ist, müssen zuerst die Mittelpunkte ermittelt werden. Dies wird gemacht indem jeder Blaue Cone mit jedem Gelben bzw. jeder Gelbe Cone mit jedem Blauen Cone verbunden wird. Liegt die Distanz zwischen den Cones in einem gewissen Bereich wird der Mittelpunkt berechnet und eingetragen. Um dies in einer vertretbaren Zeit zu machen wurde ein KD-Tree mit einem radius search verwendet."]},{"i":"2d---regression","l":"2D - Regression","p":["Nach Berechnung der Mittelpunkte liegt eine Form vor durch die eine Regression gemacht werden soll. Das Problem darin besteht, das diese Punkte in einem Funktionsraum gebracht werden müssen, da sonst mehrere Y - Werte für den selben X - Wert vorliegen. Hierfür wird wieder X und Y - Wert getrennt betrachtet und in Abhängigkeit der Fahrdistanz in einen Funktionsraum transferiert.","Hierbei besteht die herausforderung die Fahrdistanz für einen gewissen Punkt herauszufinden. Um dies zu tun wird für jeden Mittelpunkt der nähste Punkt auf der Bereits erkannten Strecke ermittelt und die Distanz von diesem Punkt, insofern die Distanz nicht zu groß ist, als Fahrdistanz verwendet.","Hierfür wird eine Vorhersage getroffen, welche einer Gerade entspricht, welche die Strecke mit der Steigung der letzten Meter weiterführt und somit einen Punkt gibt an dem die weiterführenden Punkte ihre Fahrdistanz finden können. Anschließend werden die nähsten Punkte auf der Fahrstrecke gesucht und bei einer Distanz zur Strecke unter einem bestimmten Threshold zu einer Liste hinzugefügt zusammen mit der ermittelten Fahrdistanz. Die Ermittlung des nähsten Punkts auf der Strecke Erfolgt hierbei in dem die bereits bekannte Strecke alle 10m einen Punkt entnommen bekommt und der Punkt mit der geringsten Distanz zum entsprechenden Mittelpunkt ermittelt wird. Anschließend wird in dem entsprechenden Bereich mit einer Golden Section Search näher gesucht (Bei alleiniger suche mit Golden Section Search würde teilweise lediglich ein lokales optimum gefunden werden).","Die ermittelten Punkte die als Fahrstrecke dienen werden zunächst in Buckets gruppiert in dem aus allen Punkten die auf den selben Meter der Strecke fallen der Durchschnitt gebildet wird um die Performance zu verbessern. Anschließend wird durch alle Buckets ein Univariate Cubic Smoothing Spline gelegt, welcher die Eigenschaft hat nicht durch alle Punkte gehen zu müssen sondern die Strecke zusätlich glättet und somit harte Kanten in der Fahrstrecke vermeidet.","In der Implementierung wird anschließend durch das Resultat des Univariate Cubic Smoothing Spline eine weitere Spline Regression gemacht um es in eine Form zu bringen in der leichter nach den nähsten Punkten gesucht werden kann.","Abschließend wird wieder durch die Steigung der letzten Meter der Regression eine vorhersagegerade Berechnet und von neu begonnen. Dies wird mit 10Hz wiederholt, was dem Modul erlaubt die Strecke auch bei noch ein paar fehlenden Cones oder z.B. durch zuvor an anderer Stelle erkannte Streckenabschnitte (Wenn z.B. ein Streckenabschnitt vom Ende der Strecke schon am Anfang sichtbar war, da sie relativ nah aneinander vorbeiführen) die Runde sofort abzuschließen."]},{"i":"schließen-der-strecke-loop-closure","l":"Schließen der Strecke (Loop Closure)","p":["Nach jeden update - Schritt wird ebenfalls geprüft ob die Runde bereits geschlossen werden kann. Hierfür wird der Letzte durch die Spline - Regression erzeugte Punkt (nicht die Vorhersage) mit dem Startpunkt der Strecke verglichen und dessen Distanz berechnet. Liegt dieser Wert unter einem gewissen Schwellwert wird ein Loop Closure angenommen. Hierbei wird die entgültige Streckenlänge gesetzt. Zudem werden die ersten erkannten Mittelpunkte von Streckenstart ebenfalls an das Streckenende hinzugefügt um einen möglichst glatten Übergang zwischen den Runden zu erreichen."]},{"l":"Zusätliche korrektur der Fahrlinie","p":["Es wird an das nächste Modul nicht die komplette erkannte Strecke übergeben sondern lediglich die nächsten zu befahrenden Meter. Dies schließt ebenfalls die Vorhersagegerade aus die nicht mit dazu Zählt. Somit ist sichergestellt, dass das Velocity Planning Modul niemals eine zu hohe Geschwindigkeit berechnet auf basis von Vorhersagewerten. Da die Geschwindigkeit ebenfalls von der Kurvierung der Strecke abhängt ist zusätlich Wichtig, das die Fahrstrecke möglichst glatt ist. Dies ist vorallem ein Problem beim Rundenübergang an dem ein Knick entstehen könnte, auch tortz übername der Werte vom Rundenstart. Um dies zu vermeiden wird der zu übergebende Streckenabschnitt ein letztes mal durch einen Univariate Cubic Smoothing Spline geglättet was entgültig knicke in der Fahrstrecke ausschließt. Dieser Spline wird Meterweise in Punkte diskretisiert, welche abschließend an die Folgemodule weitergegeben werden."]}],[{"l":"Sensor Fusion"},{"l":"Kurzbeschreibung","p":["Das SensorFusion Modul übernimmt die Verantwortlichkeit der ersten Cone-Validierungsschicht, interplation der Conebewegung zum ausgleich der Bearbeitungszeit und der Korrektur des Sensorversatzes.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/SensorFusion"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/stereo_cone_perception/cones","N/A","Momentan erkannte Cones durch die Kamera (aus der Kamera-Node)","/cone_cloud","Momentan erkannte Cones durch den Lidar (aus der Lidar-Node)","/estimation/velocity","Aktuell gemesenne Geschwindigkeitswerte (aus der Velocity-Estimation-Node)"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/fusion/cones","N/A","Debug Topic zum anzeigen der Cumulierten Erkennungen der letzten Sekunde","/fusion/info","Info-Topic zum anzeigen der möglichen Erkennungen des Cones","/fusion/validated","Debug Topic zum anzeigen aller validen Cones","/fusion/camera","Korrigierte Kamera Cone-Erkennungen","/fusion/lidar","Korrigierte Lidar Cone-Erkennungen"]},{"l":"Ausführliche Beschreibung"},{"l":"Koordinatenumrechnung","p":["Da sich die Kamera (main hoop) und der Lidar (auf der Nase) an unterschiedlichen positionen im Auto befinden muss eine Umrechnung der Koordinaten erfolgen, damit die resultierenden Erkennungen übereinander liegen. Des weiteren ist die Kamera leicht nach unten geneigt, weshalb ebenfalls diese Rotation entfernt werden muss. Zur umsetzung wurden die ROS-internen transforms verwendet.","Transform Struktur","Die obenstehende Grafik zeigt die Anordnung der entsprechenden Frames, wobei os_sensor den Lidar beschreibt. Die Kamera hat eine verschiebung von -0.26m nach hinten und 1.1m nach oben, wobei von base_link ausgegangen wird, der ungefähr den Masseschwerpunkt des Autos beschreibt bzw. sich von der Höhe auf dem Straßenboden befindet. Des weiteren ist eine Neigung von 0.310rad eingestellt. Der Lidar hat eine Verschiebung von 1.25m nach vorne und 0.58 nach oben. Die Umsetzung wurde mit dem vorgefertigten ROS-Packet static_transform_publisher gemacht. Zudem wurde durch die 1000ms angegeben wie lange der Transform gültig sein soll."]},{"i":"cone---validierung","l":"Cone - Validierung","p":["Die Conevalidierung stellt einen weiteren Filter gegen Falscherkennungen da. Hierbei wird sich ebenfalls zu nutze gemacht, das Objekte die fehlerhaft als Cone klassifiziert wurden deutlich weniger häufig als solches eingeordnet werden. Hierfür werden die Erkennungen pro Sekunde ermittelt und anschließend mit einem Threshold gefiltert. Bei der Berechnung der Erkennungen pro Sekunde wird effektiv nicht zwischen den Sensoren unterschieden. Dies ermöglicht eine möglichst schnelle einordnung.","Da Kameraerkennungen nur unter 15m weitergegeben werden, wird ein Cone in der Regel bereits vorher mal erkannt (Distanz > 15m). Diese erkennungen werden ebenfalls in die Erkennungen pro Sekunde mit eingerechnet, was ermöglicht das im Regelfall die erste Lidarerkennung bereits durchgelassen werden kann, da zuvor einige Kameraerkennungen des selben Cones stattfanden.","Grundsätzlich wird jede Observation in eine Queue zusammen mit dem entsprechenden Timestamp eingetragen. Diese Queue wird nach jedem update schritt soweit geleert, das lediglich die Observations der letzten Sekunde vorhanden sind. Jede Observation enthält zusätlich einen confidence Wert, der Abhängig von der Sensorart gesetzt wird (Lidar: 0.7, Kamera: abhängig der Confidence des neuronalen Netzes).","Um die Bewegung des Fahrzeugs zu kompensieren und somit eine zuordnung der Observations zu einem Cone zu ermöglichen, werden alle Observations dieser Liste entsprechend der Geschwindigkeit verschoben, so dass sich alle Observations eines Cones an der Stelle befinden, wo die nächste Observation des Cones auftauchen sollte. Dies erfolgt mit hilfe von:","wobei, v_x, v_y und v_r, die momentane Geschwindigkeit in x und y bzw. die Rotationsgeschwindigkeit angibt. \\Delta t beschreibt die Vergangene Zeit seit der letzten Observation und x, y die vorherige Position der eingetragenen Observation.","Um letztendlich eine Klassifizierung zu erreichen, ob es tatsächlich ein Cone ist oder nicht, müssen alle Observations einen Cone zugeordnet werden, aus denen dann ein Score berechnet werden kann. Diese zuordnung erfolgt bei jeder Observation neu, was eine soft association ermöglicht.","Die Berechnung des entgültigen Scores / der Confidence zur Einordnung erfolgt mit:","Es handelt sich hierbei um eine iterative Formel, welche zur Einordnung einer neuen Observation für jede umliegende Observation ausgeführt wird. Hierbei beschreibt C_t die akutelle Confidence, und o_i die Confidence der Observation i. Momentan werden alle Observations mit einer Confidence von 0.95 weitergegeben."]},{"l":"Interpolation der Bearbeitungszeit","p":["Da sich die Bearbeitungszeit / Durchlaufzeit (Zeit von tatsächlicher Aufnahme bis Eintragung in Karte) teilweise im signifikanten bereich befindet muss diese Kompensiert werden um nicht die Sensorgenauigkeit durch den Versatz beim schnellen Fahren zu verlieren. Diese Korrektur wird analag des updates der Observations der Liste durchgeführt, jedoch auf der aktuellen Observation, wobei \\Delta t die Bearbeitungszeit beschreibt. Das Resultat wird dementsprechend an den SLAM weitergegeben."]}],[{"l":"Velocity Estimation","p":["TODO"]}],[{"l":"Velocity Planning"},{"l":"Kurzbeschreibung","p":["Das Velocity Planning Modul übernimmt die Geschwindigkeitsplanung durch Berechnung der maximal möglichigen Geschwindigkeit für die zu fahrende Strecke. Dieses findet lediglich in den Missionen Trackdrive und Autocross anwendung. Die funktionalität ist durch einen forward-backward solver gewährleistet.","Wissenschaftliche Grundlage: -","Repository: https://github.com/mfr-driverless/velocity_planning"]},{"l":"Topics"},{"l":"Input Topics","p":["Topic","Nachrichtentyp","Beschreibung","/detection/center","N/A","Die zu befahrende Linie / Strecke","/estimation/velocity","Die aktuellen Geschwindigkeitswerte des Fahrzeugs"]},{"l":"Output Topics","p":["Topic","Nachrichtentyp","Beschreibung","/map_matching/target_speed","N/A","Die resultierende Zielgeschwindigkeit für das Fahrzeug"]},{"l":"Ausführliche Beschreibung"},{"l":"Physikalische Grundlage","p":["Grundsätlich geht es darum an jeder Stelle der Strecke so schnell wie möglich zu fahren. Hierbei ist der limitierende Faktor die seitliche Beschleunigung bzw. damit resultierende Bremswege. Um möglichst an den limits zu fahren, kann die Annahme getroffen werden, das zu jedem Zeitpunkt immer die maximale Beschleunigung möglich ist und damit gerechnet werden kann.","Daraus ergibt sich mit den simplen pyhsikalischen Formeln eine einfache Berechnung z.b. mit","wobei v_{i+1} die Geschwindigkeit am nächsten Punkt angibt der l_i Meter entfernt liegt. v_i beschreibt die aktuelle Geschwindigkeit und a_{x,i} die maximale Beschleunigung in X-Richtung. Letzteres kann durch ein GGV - Profil gemessen werden, wobei ein Fahrer eine Strecke fährt und man dabei die Beschleunigungen nach vorne und zur Seite aufzeichnet. Hieraus ergibt sich ebenfalls die maximale Beschleunigung die möglich ist ohne die Strecke zu verlassen."]},{"l":"Forward-Backward Solver","p":["Um an jeder Position den Bremsweg zu berücksichtigen wird ein Forward-Backward Solver verwendet. Dieser hat seinen Namen da er die zu befahrene Strecke erst vorwärts und anschließend rückwärts durchlauft was zu einer linearen Laufzeit führt. Grundsätzlich wird die Fahrlinie in gewissen abständen zu Punkten unterteilt. Die maximale Geschwindigkeit an einem Punkt ist berechenbar über die maximale Beschleunigung und die Kurvierung der Strecke. Hierfür wird zuvor für jeden Punkt unabhängig voneinander eine initiale Geschwindigkeit berechnet, die in den folgenden Schritten lediglich nach unten korrigiert werden kann.","Dies kann mit folgender Formel berechnet werden:","wo \\kappa die Kurvierung der Strecke an der Stelle i darstellt und a_{y,max} die konstant gesetzte maximale seitliche Beschleunigung. Die Berechnung wird kontinuierlich für die nächsten vom Path Planning übergebenen zu befahrenden Meter (Vorhersagehorizont) gemacht. Aus Sicherheitsgründen ist die Zielgeschwindigkeit am ende des Vorhersagehorizonts immer gleich 0 um auf jede mögliche Situation reagieren zu können und auch bei scharfen Kurven die Möglichkeit zu Bremensen zu haben. Somit ergibt sich zum Beispiel folgendes Geschwindigkeitsprofil:","Geschwindigkeitsprofil","Der Startzustand wird hierbei gleich der aktuellen Geschwindigkeit gesetzt und die Planung wird auf eine maximal mögliche Geschwindigkeit begrenzt. Die durchgezogene Linie beschreibt das Profil nach der zuvor beschriebenen unabhängigen Berechnung der Punkte. Die gestrichelte linie ist das Ergebniss nach dem Forward - Backward Solver. Dieser geht zuerst Punkt für Punkt in fahrrichtung durch und berechnet die Geschwindigkeit des darauf folgenden Punktes. Hierbei wird die Geschwindigkeit des Punktes nur korrigiert, wenn diese langsamer ist als die zuvor eingetragene Geschwindigkeit. Dies wird durch die Formeln:","berechnet. Hierbei ist a_{x,max} die maximale Beschleunigung nach vorne welche vorallem durch Motor und Bremse festgelegt wird. a_{x,i} beschreibt die letztendlich noch mögliche longitudinale Beschleunigung welche durch die oben beschriebene formel der konstanten Beschleunigung in die entsprechende Geschwindigkeit übersetzt werden kann.","Anschließend erflolgt der Backward teil, welcher Punkt für Punkt entgegen der Fahrtrichtung analog zum forward Teil durchgeht und somit Bremswege einbezieht. Auch hier wird die geschwindigkeit lediglich nach unten korrigiert."]},{"l":"Ermittlung des Zielwertes","p":["Letztendlich wird ein einzelner Wert als Zielgeschwindigkeit erwartet. Dieser muss aus dem Geschwindigkeitsprofil extrahiert werden. Da es sich dabei um einzelene Werte z.B. jeden Meter handelt muss zuvor eine Interpolation zu einem kontinuierlichen Wert geschehen. Dies wird durch eine Spline - Interpolation gewährleistet. Anschließend wird der Wert an der Stelle genommen der im nächsten Timestamp erreicht werden soll. Hierfür wird die aktuelle Geschwindigkeit mal der Sampling Rate genommen. Somit wird der bis zum nächsten update zurückgelegte Weg berechnet. Der Wert an der entsprechenden Stelle wird als resultat an das Controlling weitergegeben."]}]]